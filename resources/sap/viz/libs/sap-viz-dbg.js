/* BuildVersion: 4.0.2.144 */(function(){var a;if(window){sap=window.sap||{}}else{sap=sap||{}}if(sap){sap.common=sap.common||{}}if(sap.common){sap.common.globalization=sap.common.globalization||{}}sap.common.globalization.VERSION=function(){return"6.2.0"};sap.common.globalization.BUILD=function(){return 1};sap.common.globalization.declare=function(c){if(!c){throw new Error("name required")}if(typeof(c)!="string"){throw new Error("name has to be a string")}if(c.charAt(0)=="."||c.charAt(c.length-1)=="."||c.indexOf("..")!=-1){throw new Error("illegal name: "+c)}c=c.split(".");var d=window;for(var b=0;b<c.length;b++){d[c[b]]=d[c[b]]||{};d=d[c[b]]}return d};sap.common.globalization.require=function(b){};sap.common.globalization.extend=function(f,b){var c=f.prototype;f.superclass=b.prototype;var d=function(){};d.prototype=b.prototype;f.prototype=new d();for(var e in c){if(c.hasOwnProperty(e)){f.prototype[e]=c[e]}}f.prototype.constructor=f;if(b.prototype.constructor==Object.prototype.constructor){b.prototype.constructor=b}return f}})();(function(){sap.common.globalization.declare("sap.common.globalization.NumericFormatManager");sap.common.globalization.require("sap.common.globalization.utils.NumberUtil");sap.common.globalization.require("sap.common.globalization.utils.BooleanUtil");sap.common.globalization.require("sap.common.globalization.utils.DataFormatUtils");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");sap.common.globalization.require("sap.common.globalization.numericFormat.FTUtil");sap.common.globalization.require("sap.common.globalization.numericFormat.FT");sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");var a=sap.common.globalization.NumericFormatManager;a.DEFAULT_FORMAT_DATE_TIME="SAP_FORMAT_DEFAULT_DATE_TIME";a.DEFAULT_FORMAT_TIME="SAP_FORMAT_DEFAULT_TIME";a.DEFAULT_FORMAT_SHORT_DATE="SAP_FORMAT_DEFAULT_SHORT_DATE";a.DEFAULT_FORMAT_LONG_DATE="SAP_FORMAT_DEFAULT_LONG_DATE";a.DEFAULT_FORMAT_NUMBER="SAP_DEFAULT_NUMBER_FORMAT";a.DEFAULT_FORMAT_BOOLEAN="SAP_DEFAULT_BOOLEAN_FORMAT";a._formatsCache={};a.resetFormatsCache=function(){a._formatsCache={}};a.setPVL=function(e,d){var b=sap.common.globalization.GlobalizationPreference.getInstance().pvl();sap.common.globalization.GlobalizationPreference.getInstance().setPvl(e);var c=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(!b||c!=b){a._formatsCache={};if(!d){a.setCustomizedLocaleInfo(null)}}};a.getPVL=function(){return sap.common.globalization.GlobalizationPreference.getInstance().pvl()};a.setCustomizedLocaleInfo=function(c,b){if(b){delete c.dayStrings;delete c.shortDayStrings;delete c.monthStrings;delete c.shortMonthStrings;delete c.amPms}sap.common.globalization.numericFormat.FLocalization.getInstance().setCustomizedLocaleInfo(c)};a.getThousandSeparator=function(){return sap.common.globalization.GlobalizationNumericConstant.getDisplayThousandSeparator()};a.getDecimalSeparator=function(){return sap.common.globalization.GlobalizationNumericConstant.getDisplayDecimalSeparator()};a.formatToText=function(d,b,c){return this._format(d,b,false,c)};a.formatToTextWithColor=function(d,b,c){return this._format(d,b,true,c)};a.getFormattedColor=function(c){var b=undefined;if(c&&c.hasOwnProperty("color")){b=c.color}return b};a.getFormattedText=function(b){var c=b;if(b&&b.hasOwnProperty("text")){c=b.text}return c};a.getFormat=function(f){if((f==null)||(f=="")){return null}if(!a._formatsCache){a._formatsCache=new Object()}var k=a._formatsCache[f];var b=sap.common.globalization.defaultFormat;if(k==null){if(f==a.DEFAULT_FORMAT_SHORT_DATE||f==a.DEFAULT_FORMAT_LONG_DATE||f==a.DEFAULT_FORMAT_DATE_TIME||f==a.DEFAULT_FORMAT_TIME){var f;var m=b.CustomNumericFormatLocaleFactory.getInstance();switch(f){case a.DEFAULT_FORMAT_SHORT_DATE:var j=new b.DefaultShortDateFormatLocaleFactory();k=new sap.common.globalization.numericFormat.FT(j,m);f=j.getDefaultDateFormat();break;case a.DEFAULT_FORMAT_LONG_DATE:var c=new b.DefaultDateFormatLocaleFactory();k=new sap.common.globalization.numericFormat.FT(c,m);f=c.getDefaultDateFormat();break;case a.DEFAULT_FORMAT_DATE_TIME:var e=new b.DefaultDateTimeFormatLocaleFactory();k=new sap.common.globalization.numericFormat.FT(e,m);f=e.getDefaultDateFormat();break;case a.DEFAULT_FORMAT_TIME:default:var i=new b.DefaultTimeFormatLocaleFactory();k=new sap.common.globalization.numericFormat.FT(i,m);f=i.getDefaultDateFormat()}k.parse(f)}else{if(f==a.DEFAULT_FORMAT_NUMBER){var g=new b.DefaultNumericFormatLocaleFactory();var g;var l=g.getDefaultNumericFormat();k=new sap.common.globalization.numericFormat.FT(b.CustomDateFormatLocaleFactory.getInstance(),g);k.parse(l)}else{if(b.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat(f)){var h=new b.DefaultCurrencyFormatLocaleFactory(f);var d=h.getDefaultCurrencyFormat();k=new sap.common.globalization.numericFormat.FT(b.CustomDateFormatLocaleFactory.getInstance(),h);k.parse(d)}else{if(f==a.DEFAULT_FORMAT_BOOLEAN){k=new sap.common.globalization.numericFormat.FTBoolean();k.parse(f)}else{k=new sap.common.globalization.numericFormat.FT();k.parse(f)}}}}a._formatsCache[f]=k}return k};a._format=function(i,f,h,j){var k=i==null?"":i;var g=a.getFormat(f);var d=false;var e=NaN;var j=j==undefined?true:j;var l;var b=String(k);if(g){g.color=undefined;var c=false;if(j){if(sap.common.globalization.utils.NumberUtil.isNumericValue(k)){c=true}}else{if(sap.common.globalization.utils.BaseUtils.isNumber(k)){c=true}}if(c){b=g.display(Number(k));e=Number(g.color)}else{if(sap.common.globalization.utils.BooleanUtil.isBooleanValue(k)&&sap.common.globalization.numericFormat.FTUtil.isBooleanFT(g)){b=g.display(k)}else{if(k instanceof Date){b=g.display(k)}}}}if(h&&!isNaN(e)){if(!l){l={}}l.color=e;l.text=b}else{l=b}return l};a.format=function(c,b){var d=a.getFormat(b);if(d==null){return c}return d.display(c)};a.SAP_PARAMETERS={};a.resetParameters=function(){a.SAP_PARAMETERS={}};a.setBooleanDisplayString=function(b,c){sap.common.globalization.GlobalizationBooleanConstant.BOOLEAN_STRING_TRUE=b;sap.common.globalization.GlobalizationBooleanConstant.BOOLEAN_STRING_FALSE=c}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationPreference");sap.common.globalization.require("sap.common.globalization.NumericFormatManager");sap.common.globalization.GlobalizationPreference=function(){this.__className="sap.common.globalization.GlobalizationPreference";this._preferredViewingLocale=null};var a=sap.common.globalization.GlobalizationPreference;a._instance=null;a.DOCUMENT_LOCALE="en";a.getInstance=function(){if(!a._instance){a._instance=new sap.common.globalization.GlobalizationPreference()}return a._instance};a.resetInstance=function(){a._instance=new sap.common.globalization.GlobalizationPreference()};a.prototype.pvl=function(){return this._preferredViewingLocale};a.prototype.setPvl=function(b){if(b!=this._preferredViewingLocale){this._preferredViewingLocale=b}};a.prototype.pvlIsoLanguageCode=function(){return this._getIsoLanguageCode(this.pvl())};a.prototype.documentLocale=function(){return a.DOCUMENT_LOCALE};a.prototype.documentIsoLanguageCode=function(){return this._getIsoLanguageCode(a.DOCUMENT_LOCALE)};a.prototype._getIsoLanguageCode=function(b){if(b){return String(b).split("_")[0]}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationBooleanConstant");var a=sap.common.globalization.GlobalizationBooleanConstant;a.BOOLEAN_STRING_TRUE="TRUE";a.BOOLEAN_STRING_FALSE="FALSE";a.getBooleanStrings=function(){return[a.BOOLEAN_STRING_TRUE,a.BOOLEAN_STRING_FALSE]}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.GlobalizationNumericConstant=function(){this.__className="sap.common.globalization.GlobalizationNumericConstant"};var a=sap.common.globalization.GlobalizationNumericConstant;a._FORMAT_TYPE_NUMBER="number";a._FORMAT_TYPE_CURRENCY="currency";a._KEY_TYPE_NUMERIC="numeric";a._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR="displayThousandsSeparator";a._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR="displayDecimalSeparator";a._DEFAULT_FORMAT_STRING={af:{number:"#,##0.###",currency:"¤#,##0.00"},af_ZA:{},ar:{number:"#,##0.###;#,##0.###-",currency:"¤ #,##0.00;¤ #,##0.00-"},ar_AE:{},ar_BH:{},ar_DZ:{},ar_EG:{},ar_IQ:{},ar_JO:{},ar_KW:{},ar_LB:{},ar_LY:{},ar_MA:{},ar_OM:{},ar_QA:{number:"#0.###;#0.###-",currency:"¤#0.00"},ar_SA:{number:"#0.###;#0.###-",currency:"¤#0.00"},ar_SY:{number:"#0.###;#0.###-",currency:"¤#0.00"},ar_TN:{number:"#0.###;#0.###-",currency:"¤#0.00"},ar_YE:{number:"#0.###;#0.###-",currency:"¤#0.00"},az:{number:"#,##0.###",currency:"¤ #,##0.00"},az_AZ:{},be:{number:"#,##0.###",currency:"¤#,##0.00"},be_BY:{},bg:{number:"#,##0.###",currency:"#,##0.00 ¤"},bg_BG:{},bn:{number:"#,##,##0.###",currency:"#,##,##0.00¤;(#,##,##0.00¤)"},bn_IN:{},bs:{number:"#,##0.###",currency:"¤ #,##0.00"},bs_BA:{},ca:{number:"#,##0.###",currency:"#,##0.00 ¤"},ca_ES:{},cs:{number:"#,##0.###",currency:"#,##0.00 ¤"},cs_CZ:{},cy:{number:"#,##0.###",currency:"¤#,##0.00"},cy_GB:{},da:{number:"#,##0.###",currency:"#,##0.00 ¤"},da_DK:{},de:{number:"#,##0.###",currency:"#,##0.00 ¤"},de_AT:{currency:"¤ #,##0.00"},de_CH:{currency:"¤ #,##0.00;¤-#,##0.00"},de_DE:{},de_LI:{currency:"¤ #,##0.00"},de_LU:{},el:{number:"#,##0.###",currency:"#,##0.00 ¤"},el_GR:{},en:{number:"#,##0.###",currency:"¤#,##0.00;(¤#,##0.00)"},en_AU:{currency:"¤#,##0.00"},en_BZ:{currency:"¤#,##0.00"},en_CA:{},en_GB:{currency:"¤#,##0.00"},en_IE:{currency:"¤#,##0.00"},en_JM:{currency:"¤#,##0.00"},en_NZ:{currency:"¤#,##0.00"},en_PH:{},en_TT:{currency:"¤#,##0.00"},en_US:{},en_VI:{},en_ZA:{currency:"¤#,##0.00"},en_ZW:{currency:"¤#,##0.00"},es:{number:"#,##0.###",currency:"¤ #,##0.00"},es_AR:{},es_BO:{},es_CL:{currency:"¤#,##0.00;¤-#,##0.00"},es_CO:{},es_CR:{},es_DO:{},es_EC:{currency:"¤#,##0.00;¤-#,##0.00"},es_ES:{},es_GT:{},es_HN:{},es_MX:{},es_NI:{},es_PA:{},es_PE:{},es_PR:{},es_PY:{currency:"¤ #,##0.00;¤ -#,##0.00"},es_SV:{},es_UY:{currency:"¤ #,##0.00;(¤ #,##0.00)"},es_VE:{currency:"¤#,##0.00;¤-#,##0.00"},et:{number:"#,##0.###",currency:"#,##0.00 ¤"},et_EE:{},eu:{number:"#,##0.###",currency:"#,##0.00 ¤"},eu_ES:{},fa:{number:"#,##0.###;'-#,##0.###'",currency:"#,##0.00 ¤;'-#,##0.00' ¤"},fa_IR:{},fi:{number:"#,##0.###",currency:"#,##0.00 ¤"},fi_FI:{},fo:{number:"#,##0.###",currency:"¤#,##0.00;¤-#,##0.00"},fo_FO:{},fr:{number:"#,##0.###",currency:"#,##0.00 ¤"},fr_BE:{},fr_CA:{currency:"#,##0.00 ¤;(#,##0.00 ¤)"},fr_CH:{currency:"¤ #,##0.00;¤-#,##0.00"},fr_FR:{},fr_LU:{},fr_MC:{},gl:{number:"#,##0.###",currency:"#,##0.00 ¤"},gl_ES:{},gu:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},gu_IN:{},he:{number:"#,##0.###",currency:"#,##0.00 ¤"},he_IL:{},hi:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},hi_IN:{},hr:{number:"#,##0.###",currency:"#,##0.00 ¤"},hr_HR:{},hu:{number:"#,##0.###",currency:"#,##0.00 ¤"},hu_HU:{},hy:{number:"#0.###",currency:"#0.00 ¤"},hy_AM:{},id:{number:"#,##0.###",currency:"¤#,##0.00"},id_ID:{},is:{number:"#,##0.###",currency:"#,##0.00 ¤"},is_IS:{},it:{number:"#,##0.###",currency:"¤ #,##0.00"},it_CH:{currency:"¤ #,##0.00;¤-#,##0.00"},it_IT:{},ja:{number:"#,##0.###",currency:"¤#,##0.00"},ja_JP:{},ka:{number:"#,##0.###",currency:"¤ #,##0.00"},ka_GE:{},kk:{number:"#,##0.###",currency:"#,##0.00 ¤"},kk_KZ:{},kn:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},kn_IN:{},ko:{number:"#,##0.###",currency:"¤#,##0.00"},ko_KR:{},kok:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},kok_IN:{},lt:{number:"#,##0.###",currency:"#,##0.00 ¤"},lt_LT:{},lv:{number:"#,##0.###",currency:"#,##0.00 ¤"},lv_LV:{},mk:{number:"#,##0.###;(#,##0.###)",currency:"¤ #,##0.00"},mk_MK:{},ml:{number:"#,##,##0.###",currency:"#,##,##0.00¤"},ml_IN:{},mn:{number:"#,##0.###",currency:"¤ #,##0.00"},mn_MN:{},mr:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},mr_IN:{},ms:{number:"#,##0.###",currency:"¤#,##0.00;(¤#,##0.00)"},ms_BN:{currency:"¤ #,##0.00"},ms_MY:{},mt:{number:"#,##0.###",currency:"¤#,##0.00"},mt_MT:{},nb:{number:"#,##0.###",currency:"¤ #,##0.00"},nb_NO:{},nl:{number:"#,##0.###",currency:"¤ #,##0.00;¤ #,##0.00-"},nl_BE:{currency:"#,##0.00 ¤"},nl_NL:{},nn:{number:"#,##0.###",currency:"#,##0.00 ¤"},nn_NO:{},pa:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},pa_IN:{},pl:{number:"#,##0.###",currency:"#,##0.00 ¤"},pl_PL:{},pt:{number:"#,##0.###",currency:"¤#,##0.00;(¤#,##0.00)"},pt_BR:{},pt_PT:{currency:"#,##0.00 ¤"},ro:{number:"#,##0.###",currency:"#,##0.00 ¤"},ro_RO:{},ru:{number:"#,##0.###",currency:"#,##0.00 ¤"},ru_RU:{},se:{number:"#,##0.###",currency:"¤ #,##0.00"},se_NO:{},sk:{number:"#,##0.###",currency:"#,##0.00 ¤"},sk_SK:{},sl:{number:"#,##0.###",currency:"#,##0.00 ¤"},sl_SI:{},sq:{number:"#,##0.###",currency:"¤#,##0.00"},sq_AL:{},sr:{number:"#,##0.###",currency:"#,##0.00 ¤"},sr_BA:{},sr_CS:{},sv:{number:"#,##0.###",currency:"#,##0.00 ¤"},sv_FI:{},sv_SE:{},sw:{number:"#,##0.###",currency:"#,##0.00 ¤"},sw_KE:{currency:"¤#,##0.00"},syr:{number:"#,##0.###",currency:"¤ #,##0.00"},syr_SY:{},ta:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},ta_IN:{},te:{number:"#,##,##0.###",currency:"¤ #,##,##0.00"},te_IN:{},th:{number:"#,##0.###",currency:"¤#,##0.00;¤-#,##0.00"},th_TH:{},tn:{number:"#,##0.###",currency:"¤#,##0.00"},tn_ZA:{},tr:{number:"#,##0.###",currency:"#,##0.00 ¤"},tr_TR:{},uk:{number:"#,##0.###",currency:"#,##0.00 ¤"},uk_UA:{},uz:{number:"#,##0.###",currency:"¤ #,##0.00"},uz_UZ:{},vi:{number:"#,##0.###",currency:"#,##0.00 ¤"},vi_VN:{},xh:{number:"#,##0.###",currency:"¤#,##0.00"},xh_ZA:{},zh:{number:"#,##0.###",currency:"¤#,##0.00"},zh_CN:{},zh_HK:{},zh_MO:{},zh_SG:{},zh_TW:{},zu:{number:"#,##0.###",currency:"¤#,##0.00"},zu_ZA:{}};a._RESOURCE_MAP={af:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},af_ZA:{numeric:{}},ar:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ar_AE:{numeric:{}},ar_BH:{numeric:{}},ar_DZ:{numeric:{}},ar_EG:{numeric:{}},ar_IQ:{numeric:{}},ar_JO:{numeric:{}},ar_KW:{numeric:{}},ar_LB:{numeric:{}},ar_LY:{numeric:{}},ar_MA:{numeric:{}},ar_OM:{numeric:{}},ar_QA:{numeric:{}},ar_SA:{numeric:{}},ar_SY:{numeric:{}},ar_TN:{numeric:{}},ar_YE:{numeric:{}},az:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},az_AZ:{numeric:{}},be:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},be_BY:{numeric:{}},bg:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},bg_BG:{numeric:{}},bn:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},bn_IN:{numeric:{}},bs:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},bs_BA:{numeric:{}},ca:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ca_ES:{numeric:{}},cs:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},cs_CZ:{numeric:{}},cy:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},cy_GB:{numeric:{}},da:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},da_DK:{numeric:{}},de:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},de_AT:{numeric:{}},de_CH:{numeric:{displayThousandsSeparator:"'",displayDecimalSeparator:"."}},de_DE:{numeric:{}},de_LI:{numeric:{displayThousandsSeparator:"'",displayDecimalSeparator:"."}},de_LU:{numeric:{}},el:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},el_GR:{numeric:{}},en:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},en_AU:{numeric:{}},en_BZ:{numeric:{}},en_CA:{numeric:{}},en_GB:{numeric:{}},en_IE:{numeric:{}},en_JM:{numeric:{}},en_NZ:{numeric:{}},en_PH:{numeric:{}},en_TT:{numeric:{}},en_US:{numeric:{}},en_VI:{numeric:{}},en_ZA:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},en_ZW:{numeric:{}},es:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},es_AR:{numeric:{}},es_BO:{numeric:{}},es_CL:{numeric:{}},es_CO:{numeric:{}},es_CR:{numeric:{}},es_DO:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_EC:{numeric:{}},es_ES:{numeric:{}},es_GT:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_HN:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_MX:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_NI:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_PA:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_PE:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_PR:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_PY:{numeric:{}},es_SV:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},es_UY:{numeric:{}},es_VE:{numeric:{}},et:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},et_EE:{numeric:{}},eu:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},eu_ES:{numeric:{}},fa:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},fa_IR:{numeric:{}},fi:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},fi_FI:{numeric:{}},fo:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},fo_FO:{numeric:{}},fr:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},fr_BE:{numeric:{displayThousandsSeparator:"."}},fr_CA:{numeric:{}},fr_CH:{numeric:{displayThousandsSeparator:"'",displayDecimalSeparator:"."}},fr_FR:{numeric:{}},fr_LU:{numeric:{displayThousandsSeparator:"."}},fr_MC:{numeric:{}},gl:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},gl_ES:{numeric:{}},gu:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},gu_IN:{numeric:{}},he:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},he_IL:{numeric:{}},hi:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},hi_IN:{numeric:{}},hr:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},hr_HR:{numeric:{}},hu:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},hu_HU:{numeric:{}},hy:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},hy_AM:{numeric:{}},id:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},id_ID:{numeric:{}},is:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},is_IS:{numeric:{}},it:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},it_CH:{numeric:{displayThousandsSeparator:"'",displayDecimalSeparator:"."}},it_IT:{numeric:{}},ja:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ja_JP:{numeric:{}},ka:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ka_GE:{numeric:{}},kk:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},kk_KZ:{numeric:{}},kn:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},kn_IN:{numeric:{}},ko:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ko_KR:{numeric:{}},kok:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},kok_IN:{numeric:{}},lt:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},lt_LT:{numeric:{}},lv:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},lv_LV:{numeric:{}},mk:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},mk_MK:{numeric:{}},ml:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ml_IN:{numeric:{}},mn:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},mn_MN:{numeric:{}},mr:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},mr_IN:{numeric:{}},ms:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ms_BN:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ms_MY:{numeric:{}},mt:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},mt_MT:{numeric:{}},nb:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},nb_NO:{numeric:{}},nl:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},nl_BE:{numeric:{}},nl_NL:{numeric:{}},nn:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},nn_NO:{numeric:{}},pa:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},pa_IN:{numeric:{}},pl:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},pl_PL:{numeric:{}},pt:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},pt_BR:{numeric:{}},pt_PT:{numeric:{displayThousandsSeparator:" "}},ro:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},ro_RO:{numeric:{}},ru:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},ru_RU:{numeric:{}},se:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},se_NO:{numeric:{}},sk:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},sk_SK:{numeric:{}},sl:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},sl_SI:{numeric:{}},sq:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},sq_AL:{numeric:{}},sr:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},sr_BA:{numeric:{}},sr_CS:{numeric:{}},sv:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},sv_FI:{numeric:{}},sv_SE:{numeric:{}},sw:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},sw_KE:{numeric:{}},syr:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},syr_SY:{numeric:{}},ta:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},ta_IN:{numeric:{}},te:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},te_IN:{numeric:{}},th:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},th_TH:{numeric:{}},tn:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},tn_ZA:{numeric:{}},tr:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},tr_TR:{numeric:{}},uk:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},uk_UA:{numeric:{}},uz:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},uz_UZ:{numeric:{}},vi:{numeric:{displayThousandsSeparator:".",displayDecimalSeparator:","}},vi_VN:{numeric:{}},xh:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},xh_ZA:{numeric:{}},zh:{numeric:{displayThousandsSeparator:",",displayDecimalSeparator:"."}},zh_CN:{numeric:{}},zh_HK:{numeric:{}},zh_MO:{numeric:{}},zh_SG:{numeric:{}},zh_TW:{numeric:{}},zu:{numeric:{displayThousandsSeparator:" ",displayDecimalSeparator:","}},zu_ZA:{numeric:{}}};a.getParseThousandSeparator=function(b){return","};a.getDisplayThousandSeparator=function(b){var b=b||null;if(b){if(a._resourceExist(b,a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR)){return a.getNumericResource(b,a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR)}else{return null}}return a._getAppropriateNumericResource(a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_THOUSANDS_SEPARATOR)};a.getParseDecimalSeparator=function(b){return"."};a.getDisplayDecimalSeparator=function(b){var b=b||null;if(b){if(a._resourceExist(b,a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR)){return a.getNumericResource(b,a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR)}else{return null}}return a._getAppropriateNumericResource(a._KEY_TYPE_NUMERIC,a._KEY_TOKEN_DISPLAY_DECIMAL_SEPARATOR)};a.getParseCurrencySymbol=function(){return"¤"};a.getDefaultNumberFormat=function(b){var b=b||null;if(b){if(a._formatExist(b,a._FORMAT_TYPE_NUMBER)){return a._getNumericFormat(b,a._FORMAT_TYPE_NUMBER)}else{return null}}return a._getAppropriateNumericFormat(a._FORMAT_TYPE_NUMBER)};a.getDefaultCurrencyFormat=function(b){var b=b||null;if(b){if(a._formatExist(b,a._FORMAT_TYPE_CURRENCY)){return a._getNumericFormat(b,a._FORMAT_TYPE_CURRENCY)}else{return null}}return a._getAppropriateNumericFormat(a._FORMAT_TYPE_CURRENCY)};a.getActualLocaleForDefaultCurrencyFormat=function(){return a.getActualLocaleForNumerFormat(a._FORMAT_TYPE_CURRENCY)};a.getActualLocaleForDefaultNumberFormat=function(){return a.getActualLocaleForNumerFormat(a._FORMAT_TYPE_NUMBER)};a.getActualLocaleForNumerFormat=function(d){var e=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(a._formatExist(e,d)){return e}var c=sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();if(a._formatExist(c,d)){return c}var f=sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();if(a._formatExist(f,d)){return f}var b=sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();if(a._formatExist(b,d)){return b}return"en"};a._getAppropriateNumericFormat=function(b){return a._getNumericFormat(a.getActualLocaleForNumerFormat(b),b)};a._formatExist=function(b,c){return(b&&c&&a._DEFAULT_FORMAT_STRING[b]&&a._DEFAULT_FORMAT_STRING[b][c])};a._getNumericFormat=function(b,c){return a._DEFAULT_FORMAT_STRING[b][c]};a._getAppropriateNumericResource=function(e,b){var f=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(a._resourceExist(f,e,b)){return a.getNumericResource(f,e,b)}var d=sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();if(a._resourceExist(d,e,b)){return a.getNumericResource(d,e,b)}var g=sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();if(a._resourceExist(g,e,b)){return a.getNumericResource(g,e,b)}var c=sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();if(a._resourceExist(c,e,b)){return a.getNumericResource(c,e,b)}return a.getNumericResource("en",e,b)};a._resourceExist=function(b,d,c){return(b&&d&&c&&a._RESOURCE_MAP[b]&&a._RESOURCE_MAP[b][d]&&a._RESOURCE_MAP[b][d][c])};a.getNumericResource=function(b,d,c){return a._RESOURCE_MAP[b][d][c]}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.GlobalizationDateConstant=function(){this.__className="sap.common.globalization.defaultFormat.GlobalizationDateConstant"};var a=sap.common.globalization.GlobalizationDateConstant;a.FORMAT_TYPE_SHORTDATE="shortDate",a.FORMAT_TYPE_LONGDATE="longDate",a.FORMAT_TYPE_DATE_TIME="dateTime",a.FORMAT_TYPE_TIME="timeFormat",a.KEY_TYPE_DATE="date",a.KEY_TYPE_TIME="time",a.KEY_TOKEN_SHORT_DAY="shortDay",a.KEY_TOKEN_LONG_DAY="longDay",a.KEY_TOKEN_SHORT_MONTH="shortMonth",a.KEY_TOKEN_LONG_MONTH="longMonth",a.KEY_TOKEN_AM_PM="amPm",a.KEY_DATE_SEPARATOR="dateSeparator",a.KEY_TIME_SEPARATOR="timeSeparator",a.KEY_TOKEN_ABBREV_ERA="eraAbbr",a.DEFAULT_FORMAT_STRING={af:{longDate:"dddd dd MMMM yyyy;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},af_ZA:{},ar:{longDate:"dddd، d MMMM، yyyy;@",shortDate:"d/M/yyyy;@",dateTime:"dd/MM/yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},ar_AE:{},ar_BH:{},ar_DZ:{},ar_EG:{},ar_IQ:{},ar_JO:{},ar_KW:{},ar_LB:{},ar_LY:{},ar_MA:{},ar_OM:{},ar_QA:{},ar_SA:{},ar_SY:{},ar_TN:{},ar_YE:{},az:{longDate:"dddd, d, MMMM, yyyy;@",shortDate:"yyyy-MM-dd;@",dateTime:"d MMM, yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},az_AZ:{},be:{longDate:"dddd, d MMMM yyyy;@",shortDate:"d.M.yy;@",dateTime:"d.M.yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},be_BY:{},bg:{longDate:"dd MMMM yyyy, dddd;@",shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},bg_BG:{},bn:{longDate:"dddd, d MMMM, yyyy;@",shortDate:"d/M/yy;@",dateTime:"d MMM, yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},bn_IN:{},bs:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},bs_BA:{},ca:{longDate:'dddd d "de" MMMM "de" yyyy;@',shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},ca_ES:{},cs:{longDate:"dddd, d. MMMM yyyy;@",shortDate:"d.M.yy;@",dateTime:"d.M.yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},cs_CZ:{},cy:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},cy_GB:{},da:{longDate:'dddd "den" d. MMMM yyyy;@',shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},da_DK:{},de:{longDate:"dddd, d. MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},de_AT:{longDate:"dddd, dd. MMMM yyyy;@"},de_CH:{},de_DE:{},de_LI:{},de_LU:{},el:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"dd/MM/yyyy;@",dateTime:"dd MMM yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},el_GR:{},en:{longDate:"dddd, MMMM d, yyyy;@",shortDate:"M/d/yy;@",dateTime:"MMM d, yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},en_AU:{longDate:"dddd, d MMMM yyyy;@",shortDate:"d/MM/yy;@",dateTime:"dd/MM/yyyy h:mm:ss AM/PM;@"},en_BZ:{dateTime:"dd-MMM-yyyy h:mm:ss AM/PM;@"},en_CA:{shortDate:"yy-MM-dd;@",dateTime:"yyyy-MM-dd h:mm:ss AM/PM;@"},en_GB:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd/MM/yyyy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},en_IE:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd/MM/yyyy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},en_JM:{},en_NZ:{longDate:"dddd, d MMMM yyyy;@",shortDate:"d/MM/yy;@",dateTime:"d/MM/yyyy h:mm:ss AM/PM;@"},en_PH:{},en_TT:{},en_US:{},en_VI:{},en_ZA:{longDate:"dddd dd MMMM yyyy;@",shortDate:"yyyy/MM/dd;@",dateTime:"dd MMM yyyy h:mm:ss AM/PM;@"},en_ZW:{longDate:"dddd dd MMMM yyyy;@",shortDate:"d/M/yyyy;@",dateTime:"dd MMM, yyyy h:mm:ss AM/PM;@"},es:{longDate:'dddd d "de" MMMM "de" yyyy;@',shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},es_AR:{},es_BO:{},es_CL:{shortDate:"dd-MM-yy;@",dateTime:"dd-MM-yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},es_CO:{shortDate:"d/MM/yy;@",dateTime:"d/MM/yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},es_CR:{},es_DO:{},es_EC:{dateTime:"dd/MM/yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},es_ES:{},es_GT:{shortDate:"d/MM/yy;@",dateTime:"d/MM/yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},es_HN:{longDate:'dddd dd "de" MMMM "de" yyyy;@'},es_MX:{},es_NI:{},es_PA:{shortDate:"MM/dd/yy;@",dateTime:"MM/dd/yyyy HH:mm:ss;@"},es_PE:{shortDate:"d/MM/yy;@"},es_PR:{shortDate:"MM/dd/yy;@",dateTime:"MM/dd/yyyy HH:mm:ss;@"},es_PY:{},es_SV:{},es_UY:{},es_VE:{},et:{longDate:"dddd, d, MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},et_EE:{},eu:{longDate:'dddd, yyyy"eko" MMMM"ren" dd"a";@',shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},eu_ES:{},fa:{longDate:"dddd d MMMM yyyy;@",shortDate:"yy/M/d;@",dateTime:"yyyy/M/d، H:mm:ss;@",timeFormat:"H:mm:ss;@"},fa_IR:{},fi:{longDate:"dddd d. MMMM yyyy;@",shortDate:"d.M.yyyy;@",dateTime:"d.M.yyyy H.mm.ss;@",timeFormat:"H.mm.ss;@"},fi_FI:{},fo:{longDate:"dddd dd MMMM yyyy;@",shortDate:"dd-MM-yy;@",dateTime:"dd-MM-yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},fo_FO:{},fr:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},fr_BE:{shortDate:"d/MM/yy;@"},fr_CA:{shortDate:"yy-MM-dd;@",dateTime:"yyyy-MM-dd HH:mm:ss;@"},fr_CH:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd.MM.yy;@"},fr_FR:{},fr_LU:{},fr_MC:{},gl:{longDate:"dddd dd MMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"d MMM, yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},gl_ES:{},gu:{longDate:"dddd, d MMMM, yyyy;@",shortDate:"d-MM-yy;@",dateTime:"d MMM, yyyy hh:mm:ss AM/PM;@",timeFormat:"hh:mm:ss AM/PM;@"},gu_IN:{},he:{longDate:"dddd, d בMMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},he_IL:{},hi:{longDate:"dddd, d MMMM yyyy;@",shortDate:"d-M-yy;@",dateTime:"dd-MM-yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},hi_IN:{},hr:{longDate:"dddd, d. MMMM yyyy.;@",shortDate:"dd.MM.yyyy.;@",dateTime:"d.M.yyyy. HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},hr_HR:{},hu:{longDate:"yyyy. MMMM d., dddd;@",shortDate:"yyyy.MM.dd.;@",dateTime:"yyyy.MM.dd. H:mm:ss;@",timeFormat:"H:mm:ss;@"},hu_HU:{},hy:{longDate:"dddd, MMMM d, yyyy;@",shortDate:"MM/dd/yy;@",dateTime:"MMM d, yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},hy_AM:{},id:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},id_ID:{},is:{longDate:"dddd, d. MMMM yyyy;@",shortDate:"d.M.yyyy;@",dateTime:"d.M.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},is_IS:{},it:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd/MM/yy;@",dateTime:"dd/MMM/yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},it_CH:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"d-MMM-yyyy HH.mm.ss;@"},it_IT:{},ja:{longDate:"yyyy年M月d日dddd;@",shortDate:"yy/MM/dd;@",dateTime:"yyyy/MM/dd H:mm:ss;@",timeFormat:"H:mm:ss;@"},ja_JP:{},ka:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},ka_GE:{},kk:{longDate:'dddd, d MMMM yyyy "ж".;@',shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},kk_KZ:{},kn:{longDate:"dddd d MMMM yyyy;@",shortDate:"d-M-yy;@",dateTime:"d MMM yyyy hh:mm:ss AM/PM;@",timeFormat:"hh:mm:ss AM/PM;@"},kn_IN:{},ko:{longDate:"yyyy년 M월 d�?� dddd;@",shortDate:"yy. M. d.;@",dateTime:"yyyy. M. d. AM/PM h:mm:ss;@",timeFormat:"AM/PM h:mm:ss;@"},ko_KR:{},kok:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},kok_IN:{},lt:{longDate:'yyyy "m". MMMM d "d".,dddd;@',shortDate:"yyyy-MM-dd;@",dateTime:"yyyy.MM.dd HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},lt_LT:{},lv:{longDate:'dddd, yyyy. "gada" d. MMMM;@',shortDate:"dd.MM.yy;@",dateTime:'yyyy. "gada" d. MMM HH:mm:ss;@',timeFormat:"HH:mm:ss;@"},lv_LV:{},mk:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"dd.M.yy;@",dateTime:"dd.M.yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},mk_MK:{},ml:{longDate:"yyyy, MMMM d, dddd;@",shortDate:"dd/MM/yy;@",dateTime:"yyyy, MMM d h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},ml_IN:{},mn:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},mn_MN:{},mr:{longDate:"dddd d MMMM yyyy;@",shortDate:"d-M-yy;@",dateTime:"d MMM yyyy h-mm-ss AM/PM;@",timeFormat:"h-mm-ss AM/PM;@"},mr_IN:{},ms:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},ms_BN:{longDate:"dd MMMM yyyy;@",dateTime:"dd/MM/yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},ms_MY:{},mt:{longDate:'dddd, d "ta"’ MMMM yyyy;@',shortDate:"dd/MM/yyyy;@",dateTime:"dd MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},mt_MT:{},nb:{longDate:"dddd d. MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"d. MMM yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},nb_NO:{},nl:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd-MM-yy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},nl_BE:{shortDate:"d/MM/yy;@",dateTime:"d-MMM-yyyy HH:mm:ss;@"},nl_NL:{},nn:{longDate:"dddd d. MMMM yyyy;@",shortDate:"dd.MM.yy;@",dateTime:"d. MMM. yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},nn_NO:{},pa:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"dd/MM/yyyy;@",dateTime:"d MMM yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},pa_IN:{},pl:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd-MM-yy;@",dateTime:"dd-MM-yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},pl_PL:{},pt:{longDate:'dddd, d "de" MMMM "de" yyyy;@',shortDate:"dd/MM/yy;@",dateTime:"dd/MM/yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},pt_BR:{},pt_PT:{dateTime:'d "de" MMM "de" yyyy HH:mm:ss;@'},ro:{longDate:"dddd, d MMMM yyyy;@",shortDate:"dd.MM.yyyy;@",dateTime:"dd.MM.yyyy, HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},ro_RO:{},ru:{longDate:'dddd, d MMMM yyyy "г".;@',shortDate:"dd.MM.yy;@",dateTime:"dd.MM.yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},ru_RU:{},se:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},se_NO:{},sk:{longDate:"dddd, d. MMMM yyyy;@",shortDate:"d.M.yyyy;@",dateTime:"d.M.yyyy H:mm:ss;@",timeFormat:"H:mm:ss;@"},sk_SK:{},sl:{longDate:"dddd, dd. MMMM yyyy;@",shortDate:"d. MM. yy;@",dateTime:"d. MMM. yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},sl_SI:{},sq:{longDate:"dddd, dd MMMM yyyy;@",shortDate:"yy-MM-dd;@",dateTime:"yyyy-MM-dd h.mm.ss.AM/PM;@",timeFormat:"h.mm.ss.AM/PM;@"},sq_AL:{},sr:{longDate:"dddd, dd. MMMM yyyy.;@",shortDate:"d.M.yy.;@",dateTime:"dd.MM.yyyy. HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},sr_BA:{},sr_CS:{},sv:{longDate:"dddd d MMMM yyyy;@",shortDate:"yyyy-MM-dd;@",dateTime:"d MMM yyyy HH.mm.ss;@",timeFormat:"HH.mm.ss;@"},sv_FI:{},sv_SE:{},sw:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},sw_KE:{},syr:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"y MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},syr_SY:{},ta:{longDate:"dddd, d MMMM, yyyy;@",shortDate:"d-M-yy;@",dateTime:"d MMM, yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},ta_IN:{},te:{longDate:"dddd d MMMM yyyy;@",shortDate:"dd-MM-yy;@",dateTime:"d MMM yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},te_IN:{},th:{longDate:"ddddที่ d MMMM G yyyy;@",shortDate:"d/M/yyyy;@",dateTime:"d MMM yyyy, H:mm:ss;@",timeFormat:"H:mm:ss;@"},th_TH:{},tn:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},tn_ZA:{},tr:{longDate:"dd MMMM yyyy dddd;@",shortDate:"dd.MM.yyyy;@",dateTime:"dd MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},tr_TR:{},uk:{longDate:'dddd, d MMMM yyyy "р".;@',shortDate:"dd.MM.yy;@",dateTime:"d MMM yyyy HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},uk_UA:{},uz:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},uz_UZ:{},vi:{longDate:'dddd, "ngày" dd MMMM "năm" yyyy;@',shortDate:"dd/MM/yyyy;@",dateTime:"HH:mm:ss dd-MM-yyyy;@",timeFormat:"HH:mm:ss;@"},vi_VN:{},xh:{longDate:"dddd, yyyy MMMM dd;@",shortDate:"yyyy-MM-dd;@",dateTime:"yyyy MMM d HH:mm:ss;@",timeFormat:"HH:mm:ss;@"},xh_ZA:{},zh:{longDate:"yyyy年M月d日dddd;@",shortDate:"yy-M-d;@",dateTime:"yyyy-M-d AM/PMhh:mm:ss;@",timeFormat:"AM/PMhh:mm:ss;@"},zh_CN:{},zh_HK:{},zh_MO:{},zh_SG:{},zh_TW:{},zu:{longDate:"dddd dd MMMM yyyy;@",shortDate:"yyyy-MM-dd;@",dateTime:"d MMM yyyy h:mm:ss AM/PM;@",timeFormat:"h:mm:ss AM/PM;@"},zu_ZA:{}},a.RESOURCE_MAP={af:{date:{dateSeparator:"-",era:["voor Christus","na Christus"],eraAbbr:["v.C.","n.C."],shortDay:["So","Ma","Di","Wo","Do","Vr","Sa"],shortMonth:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Aug","Sep","Okt","Nov","Des"],longDay:["Sondag","Maandag","Dinsdag","Woensdag","Donderdag","Vrydag","Saterdag"],longMonth:["Januarie","Februarie","Maart","April","Mei","Junie","Julie","Augustus","September","Oktober","November","Desember"]},time:{timeSeparator:":",amPm:["vm.","nm."]}},af_ZA:{date:{},time:{}},ar:{date:{dateSeparator:"/",era:["قبل الميلاد","ميلادي"],eraAbbr:["ق.م","م"],shortDay:["أحد","إثنين","ثلاثاء","أربعاء","خميس","جمعة","سبت"],shortMonth:["يناير","�?براير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نو�?مبر","ديسمبر"],longDay:["الأحد","الإثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],longMonth:["يناير","�?براير","مارس","أبريل","مايو","يونيو","يوليو","أغسطس","سبتمبر","أكتوبر","نو�?مبر","ديسمبر"]},time:{timeSeparator:":",amPm:["ص","م"]}},ar_AE:{date:{},time:{}},ar_BH:{date:{},time:{}},ar_DZ:{date:{},time:{}},ar_EG:{date:{},time:{}},ar_IQ:{date:{},time:{}},ar_JO:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],shortMonth:["كانون الثاني","شباط","آذار","نيسان","أيار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"],longMonth:["كانون الثاني","شباط","آذار","نيسان","أيار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"]},time:{}},ar_KW:{date:{},time:{}},ar_LB:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],shortMonth:["كانون الثاني","شباط","آذار","نيسان","نوار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"],longMonth:["كانون الثاني","شباط","آذار","نيسان","نوار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"]},time:{}},ar_LY:{date:{},time:{}},ar_MA:{date:{},time:{}},ar_OM:{date:{},time:{}},ar_QA:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},time:{}},ar_SA:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},time:{}},ar_SY:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"],shortMonth:["كانون الثاني","شباط","آذار","نيسان","نوار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"],longMonth:["كانون الثاني","شباط","آذار","نيسان","نوار","حزيران","تموز","آب","أيلول","تشرين الأول","تشرين الثاني","كانون الأول"]},time:{}},ar_TN:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},time:{}},ar_YE:{date:{shortDay:["الأحد","الاثنين","الثلاثاء","الأربعاء","الخميس","الجمعة","السبت"]},time:{}},az:{date:{dateSeparator:"-",era:["eramızdan əvvəl","bizim eramızın"],eraAbbr:["e.ə.","b.e."],shortDay:["B.","B.E.","Ç.A.","Ç.","C.A.","C","Ş."],shortMonth:["yan","fev","mar","apr","may","iyn","iyl","avq","sen","okt","noy","dek"],longDay:["bazar","bazar ertəsi","çərşənbə axşamı","çərşənbə","cümə axşamı","cümə","şənbə"],longMonth:["Yanvar","Fevral","Mart","Aprel","May","İyun","İyul","Avqust","Sentyabr","Oktyabr","Noyabr","Dekabr"]},time:{timeSeparator:":",amPm:["AM","PM"]}},az_AZ:{date:{},time:{}},be:{date:{dateSeparator:".",era:["да н.�?.","н.�?."],eraAbbr:["да н.е.","н.е."],eraNarrow:["да н.�?.","н.�?."],shortDay:["нд","пн","аў","�?р","чц","пт","�?б"],shortMonth:["�?ту","лют","�?ак","кра","май","ч�?р","ліп","жні","вер","ка�?","лі�?","�?не"],longDay:["н�?дзел�?","пан�?дзелак","аўторак","�?ерада","чацвер","п�?тніца","�?убота"],longMonth:["�?тудзень","люты","�?акавік","кра�?авік","май","ч�?рвень","ліпень","жнівень","вера�?ень","ка�?трычнік","лі�?тапад","�?нежань"]},time:{timeSeparator:".",amPm:["да палудн�?","па�?л�? палудн�?"]}},be_BY:{date:{},time:{}},bg:{date:{dateSeparator:".",era:["пр.Хр.","�?л.Хр."],eraAbbr:["пр. н. е.","от н. е."],eraNarrow:["�?л.н.е."],shortDay:["нд","пн","вт","�?р","чт","пт","�?б"],shortMonth:["�?н.","февр.","март","апр.","май","юни","юли","авг.","�?епт.","окт.","ноем.","дек."],longDay:["недел�?","понеделник","вторник","�?р�?да","четвъртък","петък","�?ъбота"],longMonth:["�?нуари","февруари","март","април","май","юни","юли","авгу�?т","�?ептември","октомври","ноември","декември"]},time:{timeSeparator:":",amPm:["пр. об.","�?л. об."]}},bg_BG:{date:{},time:{}},bn:{date:{dateSeparator:"/",eraAbbr:["খৃষ�?টপূর�?ব","খৃষ�?টাব�?দ"],shortDay:["রবি","সোম","মঙ�?গল","ব�?ধ","বৃহস�?পতি","শ�?ক�?র","শনি"],shortMonth:["জান�?য়ারী","ফেব�?র�?য়ারী","মার�?চ","�?প�?রিল","মে","জ�?ন","জ�?লাই","আগস�?ট","সেপ�?টেম�?বর","অক�?টোবর","নভেম�?বর","ডিসেম�?বর"],longDay:["রবিবার","সোমবার","মঙ�?গলবার","ব�?ধবার","বৃহষ�?পতিবার","শ�?ক�?রবার","শনিবার"],longMonth:["জান�?য়ারী","ফেব�?র�?য়ারী","মার�?চ","�?প�?রিল","মে","জ�?ন","জ�?লাই","আগস�?ট","সেপ�?টেম�?বর","অক�?টোবর","নভেম�?বর","ডিসেম�?বর"]},time:{timeSeparator:":",amPm:["পূর�?বাহ�?ণ","অপরাহ�?ণ"]}},bn_IN:{date:{},time:{}},bs:{date:{dateSeparator:"-",eraAbbr:["BCE","CE"],shortDay:["7","1","2","3","4","5","6"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["7","1","2","3","4","5","6"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},bs_BA:{date:{},time:{}},ca:{date:{dateSeparator:"/",eraAbbr:["aC","dC"],shortDay:["dg.","dl.","dt.","dc.","dj.","dv.","ds."],shortMonth:["gen.","febr.","març","abr.","maig","juny","jul.","ag.","set.","oct.","nov.","des."],longDay:["diumenge","dilluns","dimarts","dimecres","dijous","divendres","dissabte"],longMonth:["gener","febrer","març","abril","maig","juny","juliol","agost","setembre","octubre","novembre","desembre"]},time:{timeSeparator:":",amPm:["a.m.","p.m."]}},ca_ES:{date:{},time:{}},cs:{date:{dateSeparator:".",eraAbbr:["př.Kr.","po Kr."],shortDay:["ne","po","út","st","�?t","pá","so"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12",],longDay:["neděle","pondělí","úterý","středa","�?tvrtek","pátek","sobota"],longMonth:["ledna","února","března","dubna","května","�?ervna","�?ervence","srpna","září","října","listopadu","prosince"]},time:{timeSeparator:":",amPm:["dop.","odp."]}},cs_CZ:{date:{},time:{}},cy:{date:{dateSeparator:"-",era:["Cyn Crist","Oed Crist"],eraAbbr:["CC","OC"],eraNarrow:["C","O"],shortDay:["Sul","Llun","Maw","Mer","Iau","Gwen","Sad"],shortMonth:["Ion","Chwef","Mawrth","Ebrill","Mai","Meh","Gorff","Awst","Medi","Hyd","Tach","Rhag"],longDay:["Dydd Sul","Dydd Llun","Dydd Mawrth","Dydd Mercher","Dydd Iau","Dydd Gwener","Dydd Sadwrn"],longMonth:["Ionawr","Chwefror","Mawrth","Ebrill","Mai","Mehefin","Gorffenaf","Awst","Medi","Hydref","Tachwedd","Rhagfyr"]},time:{timeSeparator:":",amPm:["AM","PM"]}},cy_GB:{date:{},time:{}},da:{date:{dateSeparator:"/",era:["f.Kr.","e.Kr."],eraAbbr:["f.Kr.","e.Kr."],shortDay:["søn","man","tir","ons","tor","fre","lør"],shortMonth:["jan.","feb.","mar.","apr.","maj","jun.","jul.","aug.","sep.","okt.","nov.","dec."],longDay:["søndag","mandag","tirsdag","onsdag","torsdag","fredag","lørdag"],longMonth:["januar","februar","marts","april","maj","juni","juli","august","september","oktober","november","december"]},time:{timeSeparator:".",amPm:["f.m.","e.m."]}},da_DK:{date:{},time:{}},de:{date:{dateSeparator:".",era:["v. Chr.","n. Chr."],eraAbbr:["v. Chr.","n. Chr."],shortDay:["So.","Mo.","Di.","Mi.","Do.","Fr.","Sa."],shortMonth:["Jan","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],longDay:["Sonntag","Montag","Dienstag","Mittwoch","Donnerstag","Freitag","Samstag"],longMonth:["Januar","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"]},time:{timeSeparator:":",amPm:["vorm.","nachm."]}},de_AT:{date:{shortMonth:["Jän","Feb","Mär","Apr","Mai","Jun","Jul","Aug","Sep","Okt","Nov","Dez"],longMonth:["Jänner","Februar","März","April","Mai","Juni","Juli","August","September","Oktober","November","Dezember"]},time:{}},de_CH:{date:{},time:{}},de_DE:{date:{},time:{}},de_LI:{date:{},time:{}},de_LU:{date:{},time:{}},el:{date:{dateSeparator:"/",era:["π.Χ.","μ.Χ."],eraAbbr:["π.Χ.","μ.Χ."],shortDay:["Κυ�?","Δευ","Τ�?ι","Τετ","Πεμ","Πα�?","Σαβ"],shortMonth:["Ιαν","Φεβ","Μα�?","Απ�?","Μαϊ","Ιουν","Ιουλ","Αυγ","Σεπ","Οκτ","�?οε","Δεκ"],longDay:["Κυ�?ιακή","Δευτέ�?α","Τ�?ίτη","Τετά�?τη","Πέμπτη","Πα�?ασκευή","Σάββατο"],longMonth:["Ιανουα�?ίου","Φεβ�?ουα�?ίου","Μα�?τίου","Απ�?ιλίου","Μα�?ου","Ιουνίου","Ιουλίου","Αυγο�?στου","Σεπτεμβ�?ίου","Οκτωβ�?ίου","�?οεμβ�?ίου","Δεκεμβ�?ίου"]},time:{timeSeparator:":",amPm:["π.μ.","μ.μ."]}},el_GR:{date:{},time:{}},en:{date:{dateSeparator:"/",era:["Before Christ","Anno Domini"],eraAbbr:["BC","AD"],eraNarrow:["B","A"],shortDay:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortMonth:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],longDay:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],longMonth:["January","February","March","April","May","June","July","August","September","October","November","December"]},time:{timeSeparator:":",amPm:["AM","PM"]}},en_AU:{date:{dateSeparator:"/"},time:{}},en_BZ:{date:{dateSeparator:"/"},time:{timeSeparator:":"}},en_CA:{date:{dateSeparator:"-"},time:{}},en_GB:{date:{dateSeparator:"/"},time:{timeSeparator:":"}},en_IE:{date:{dateSeparator:"/"},time:{timeSeparator:":",amPm:["a.m.","p.m."]}},en_JM:{date:{},time:{}},en_NZ:{date:{dateSeparator:"/"},time:{}},en_PH:{date:{},time:{}},en_TT:{date:{},time:{}},en_US:{date:{},time:{}},en_VI:{date:{},time:{}},en_ZA:{date:{dateSeparator:"/"},time:{}},en_ZW:{date:{dateSeparator:"/"},time:{}},es:{date:{dateSeparator:"/",era:["antes de Cristo","anno Dómini"],eraAbbr:["a.C.","d.C."],shortDay:["dom","lun","mar","mié","jue","vie","sáb"],shortMonth:["ene","feb","mar","abr","may","jun","jul","ago","sep","oct","nov","dic"],longDay:["domingo","lunes","martes","miércoles","jueves","viernes","sábado"],longMonth:["enero","febrero","marzo","abril","mayo","junio","julio","agosto","septiembre","octubre","noviembre","diciembre"]},time:{timeSeparator:":",amPm:["a.m.","p.m."]}},es_AR:{date:{},time:{amPm:["a.m.","p.m."]}},es_BO:{date:{},time:{}},es_CL:{date:{dateSeparator:"-"},time:{timeSeparator:":"}},es_CO:{date:{dateSeparator:"/"},time:{timeSeparator:":"}},es_CR:{date:{},time:{}},es_DO:{date:{},time:{}},es_EC:{date:{},time:{timeSeparator:":"}},es_ES:{date:{},time:{}},es_GT:{date:{dateSeparator:"/"},time:{}},es_HN:{date:{},time:{}},es_MX:{date:{},time:{}},es_NI:{date:{},time:{}},es_PA:{date:{dateSeparator:"/"},time:{}},es_PE:{date:{dateSeparator:"/"},time:{}},es_PR:{date:{dateSeparator:"/"},time:{}},es_PY:{date:{},time:{}},es_SV:{date:{},time:{}},es_UY:{date:{},time:{}},es_VE:{date:{},time:{}},et:{date:{dateSeparator:".",era:["enne meie aega","meie aja järgi"],eraAbbr:["e.m.a.","m.a.j."],shortDay:["P","E","T","K","N","R","L"],shortMonth:["jaan","veebr","märts","apr","mai","juuni","juuli","aug","sept","okt","nov","dets"],longDay:["pühapäev","esmaspäev","teisipäev","kolmapäev","neljapäev","reede","laupäev"],longMonth:["jaanuar","veebruar","märts","aprill","mai","juuni","juuli","august","september","oktoober","november","detsember"]},time:{timeSeparator:":",amPm:["AM","PM"]}},et_EE:{date:{},time:{}},eu:{date:{dateSeparator:"-",eraAbbr:["BCE","CE"],shortDay:["ig","al","as","az","og","or","lr"],shortMonth:["urt","ots","mar","api","mai","eka","uzt","abu","ira","urr","aza","abe"],longDay:["igandea","astelehena","asteartea","asteazkena","osteguna","ostirala","larunbata"],longMonth:["urtarrila","otsaila","martxoa","apirila","maiatza","ekaina","uztaila","abuztua","iraila","urria","azaroa","abendua"]},time:{timeSeparator:":",amPm:["AM","PM"]}},eu_ES:{date:{},time:{}},fa:{date:{dateSeparator:"/",era:["قبل از میلاد","میلادی"],eraAbbr:["ق.م.","م."],eraNarrow:["ق","م"],shortDay:["یکشنبه","دوشنبه","سهشنبه","چهارشنبه","پنجشنبه","جمعه","شنبه"],shortMonth:["ژانویهٔ","�?وریهٔ","مارس","آوریل","مهٔ","ژوئن","ژوئیهٔ","اوت","سپتامبر","اکتبر","نوامبر","دسامبر"],longDay:["یکشنبه","دوشنبه","سهشنبه","چهارشنبه","پنجشنبه","جمعه","شنبه"],longMonth:["ژانویهٔ","�?وریهٔ","مارس","آوریل","مهٔ","ژوئن","ژوئیهٔ","اوت","سپتامبر","اکتبر","نوامبر","دسامبر"]},time:{timeSeparator:":",amPm:["قبل از ظهر","بعد از ظهر"]}},fa_IR:{date:{},time:{}},fi:{date:{dateSeparator:".",era:["ennen Kristuksen syntymää","jälkeen Kristuksen syntymän"],eraAbbr:["eKr.","jKr."],shortDay:["su","ma","ti","ke","to","pe","la"],shortMonth:["tammikuuta","helmikuuta","maaliskuuta","huhtikuuta","toukokuuta","kesäkuuta","heinäkuuta","elokuuta","syyskuuta","lokakuuta","marraskuuta","joulukuuta"],longDay:["sunnuntaina","maanantaina","tiistaina","keskiviikkona","torstaina","perjantaina","lauantaina"],longMonth:["tammikuuta","helmikuuta","maaliskuuta","huhtikuuta","toukokuuta","kesäkuuta","heinäkuuta","elokuuta","syyskuuta","lokakuuta","marraskuuta","joulukuuta"]},time:{timeSeparator:".",amPm:["ap.","ip."]}},fi_FI:{date:{},time:{}},fo:{date:{dateSeparator:"-",era:["fyrir Krist","eftir Krist"],eraAbbr:["BCE","CE"],eraNarrow:["f.Kr.","e.Kr."],shortDay:["sun","mán","týs","mik","hós","frí","ley"],shortMonth:["jan","feb","mar","apr","mai","jun","jul","aug","sep","okt","nov","des"],longDay:["sunnudagur","mánadagur","týsdagur","mikudagur","hósdagur","fríggjadagur","leygardagur"],longMonth:["januar","februar","mars","apríl","mai","juni","juli","august","september","oktober","november","desember"]},time:{timeSeparator:":",amPm:["AM","PM"]}},fo_FO:{date:{},time:{}},fr:{date:{dateSeparator:"/",era:["avant Jésus-Christ","après Jésus-Christ"],eraAbbr:["av. J.-C.","ap. J.-C."],shortDay:["dim.","lun.","mar.","mer.","jeu.","ven.","sam."],shortMonth:["janv.","févr.","mars","avr.","mai","juin","juil.","août","sept.","oct.","nov.","déc."],longDay:["dimanche","lundi","mardi","mercredi","jeudi","vendredi","samedi"],longMonth:["janvier","février","mars","avril","mai","juin","juillet","août","septembre","octobre","novembre","décembre"]},time:{timeSeparator:":",amPm:["AM","PM"]}},fr_BE:{date:{dateSeparator:"/"},time:{}},fr_CA:{date:{dateSeparator:"-"},time:{}},fr_CH:{date:{dateSeparator:"."},time:{}},fr_FR:{date:{},time:{}},fr_LU:{date:{},time:{}},fr_MC:{date:{},time:{}},gl:{date:{dateSeparator:"/",era:["antes de Cristo","despois de Cristo"],eraAbbr:["a.C.","d.C."],shortDay:["Dom","Lun","Mar","Mér","Xov","Ven","Sáb"],shortMonth:["Xan","Feb","Mar","Abr","Mai","Xuñ","Xul","Ago","Set","Out","Nov","Dec"],longDay:["Domingo","Luns","Martes","Mércores","Xoves","Venres","Sábado"],longMonth:["Xaneiro","Febreiro","Marzo","Abril","Maio","Xuño","Xullo","Agosto","Setembro","Outubro","Novembro","Decembro"]},time:{timeSeparator:":",amPm:["AM","PM"]}},gl_ES:{date:{},time:{}},gu:{date:{dateSeparator:"-",era:["ઈસવીસન પૂર�?વે","ઇસવીસન"],eraAbbr:["BCE","CE"],eraNarrow:["ઇ સ પ�?","ઇસ"],shortDay:["રવિ","સોમ","મંગળ","બ�?ધ","ગ�?ર�?","શ�?ક�?ર","શનિ"],shortMonth:["જાન�?ય�?","ફેબ�?ર�?","માર�?ચ","�?પ�?રિલ","મે","જૂન","જ�?લાઈ","ઑગસ�?ટ","સપ�?ટે","ઑક�?ટો","નવે","ડિસે"],longDay:["રવિવાર","સોમવાર","મંગળવાર","બ�?ધવાર","ગ�?ર�?વાર","શ�?ક�?રવાર","શનિવાર"],longMonth:["જાન�?ય�?આરી","ફેબ�?ર�?આરી","માર�?ચ","�?પ�?રિલ","મે","જૂન","જ�?લાઈ","ઑગસ�?ટ","સપ�?ટેમ�?બર","ઑક�?ટ�?બર","નવેમ�?બર","ડિસેમ�?બર"]},time:{timeSeparator:":",amPm:["am","pm"]}},gu_IN:{date:{},time:{}},he:{date:{dateSeparator:"/",era:["לפני הספירה","לספירה"],eraAbbr:["לפנה״ס","לסה״נ"],shortDay:["יו�? �?'","יו�? ב'","יו�? ג'","יו�? ד'","יו�? ה'","יו�? ו'","שבת"],shortMonth:["ינו","פבר","מרס","�?פר","מ�?י","יונ","יול","�?וג","ספט","�?וק","נוב","דצמ"],longDay:["יו�? ר�?שון","יו�? שני","יו�? שלישי","יו�? רביעי","יו�? חמישי","יו�? שישי","יו�? שבת"],longMonth:["ינו�?ר","פברו�?ר","מרס","�?פריל","מ�?י","יוני","יולי","�?וגוסט","ספטמבר","�?וקטובר","נובמבר","דצמבר"]},time:{timeSeparator:":",amPm:['לפנה"צ','�?חה"צ']}},he_IL:{date:{},time:{}},hi:{date:{dateSeparator:"-",eraAbbr:["ईसापूर�?व","सन"],shortDay:["रवि","सोम","मंगल","ब�?ध","ग�?र�?","श�?क�?र","शनि"],shortMonth:["जनवरी","फरवरी","मार�?च","अप�?रैल","मई","जून","ज�?लाई","अगस�?त","सितम�?बर","अक�?तूबर","नवम�?बर","दिसम�?बर"],longDay:["रविवार","सोमवार","मंगलवार","ब�?धवार","ग�?र�?वार","श�?क�?रवार","शनिवार"],longMonth:["जनवरी","फरवरी","मार�?च","अप�?रैल","मई","जून","ज�?लाई","अगस�?त","सितम�?बर","अक�?तूबर","नवम�?बर","दिसम�?बर"]},time:{timeSeparator:":",amPm:["AM","PM"]}},hi_IN:{date:{},time:{}},hr:{date:{dateSeparator:".",era:["Prije Krista","Poslije Krista"],eraAbbr:["pr.n.e.","AD"],shortDay:["ned","pon","uto","sri","�?et","pet","sub"],shortMonth:["01.","02.","03.","04.","05.","06.","07.","08.","09.","10.","11.","12."],longDay:["nedjelja","ponedjeljak","utorak","srijeda","�?etvrtak","petak","subota"],longMonth:["sije�?nja","velja�?e","ožujka","travnja","svibnja","lipnja","srpnja","kolovoza","rujna","listopada","studenoga","prosinca"]},time:{timeSeparator:":",amPm:["AM","PM"]}},hr_HR:{date:{},time:{}},hu:{date:{dateSeparator:".",era:["időszámításunk előtt","időszámításunk szerint"],eraAbbr:["i. e.","i. sz."],shortDay:["V","H","K","Sze","Cs","P","Szo"],shortMonth:["jan.","febr.","márc.","ápr.","máj.","jún.","júl.","aug.","szept.","okt.","nov.","dec."],longDay:["vasárnap","hétfő","kedd","szerda","csütörtök","péntek","szombat"],longMonth:["január","február","március","április","május","június","július","augusztus","szeptember","október","november","december"]},time:{timeSeparator:":",amPm:["de.","du."]}},hu_HU:{date:{},time:{}},hy:{date:{dateSeparator:"/",eraAbbr:["Ք․Ա․","Ք․Ե․"],shortDay:["Կիր","Երկ","Երք","Չոր","Հնգ","Ուր","Շաբ"],shortMonth:["Յնր","Փտր","Մրտ","Ապր","Մյս","Յնս","Յլս","Օգս","�?եպ","Հոկ","Նոյ","Դեկ"],longDay:["Կիրակի","Երկուշաբթի","Երեքշաբթի","Չորեքշաբթի","Հինգշաբթի","Ուրբաթ","Շաբաթ"],longMonth:["Յունուար","Փետրուար","Մարտ","Ապրիլ","Մայիս","Յունիս","Յուլիս","Օգոստոս","�?եպտեմբեր","Հոկտեմբեր","Նոյեմբեր","Դեկտեմբեր"]},time:{timeSeparator:":",amPm:["Առ․","Եր․"]}},hy_AM:{date:{},time:{}},id:{date:{dateSeparator:"/",eraAbbr:["BCE","CE"],shortDay:["Min","Sen","Sel","Rab","Kam","Jum","Sab"],shortMonth:["Jan","Feb","Mar","Apr","Mei","Jun","Jul","Agu","Sep","Okt","Nov","Des"],longDay:["Minggu","Senin","Selasa","Rabu","Kamis","Jumat","Sabtu"],longMonth:["Januari","Februari","Maret","April","Mei","Juni","Juli","Agustus","September","Oktober","November","Desember"]},time:{timeSeparator:":",amPm:["AM","PM"]}},id_ID:{date:{},time:{}},is:{date:{dateSeparator:".",eraAbbr:["fyrir Krist","eftir Krist",],eraNarrow:["f.k.","e.k."],shortDay:["sun","mán","þri","mið","fim","fös","lau"],shortMonth:["jan","feb","mar","apr","maí","jún","júl","ágú","sep","okt","nóv","des"],longDay:["sunnudagur","mánudagur","þriðjudagur","miðvikudagur","fimmtudagur","föstudagur","laugardagur"],longMonth:["janúar","febrúar","mars","apríl","maí","júní","júlí","ágúst","september","október","nóvember","desember"]},time:{timeSeparator:":",amPm:["f.h.","e.h."]}},is_IS:{date:{},time:{}},it:{date:{dateSeparator:"/",era:["a.C.","d.C"],eraAbbr:["aC","dC"],shortDay:["dom","lun","mar","mer","gio","ven","sab"],shortMonth:["gen","feb","mar","apr","mag","giu","lug","ago","set","ott","nov","dic"],longDay:["domenica","lunedì","martedì","mercoledì","giovedì","venerdì","sabato"],longMonth:["gennaio","febbraio","marzo","aprile","maggio","giugno","luglio","agosto","settembre","ottobre","novembre","dicembre"]},time:{timeSeparator:".",amPm:["m.","p."]}},it_CH:{date:{dateSeparator:"."},time:{}},it_IT:{date:{},time:{}},ja:{date:{dateSeparator:"/",era:["紀元�?","西暦"],eraAbbr:["紀元�?","西暦"],shortDay:["日","月","�?�","水","木","金","土"],shortMonth:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],longDay:["日曜日","月曜日","�?�曜日","水曜日","木曜日","金曜日","土曜日"],longMonth:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"]},time:{timeSeparator:":",amPm:["�?��?","�?�後"]}},ja_JP:{date:{},time:{}},ka:{date:{dateSeparator:"-",era:["ჩვენს წელთ�?ღრიცხვ�?მდე","ჩვენი წელთ�?ღრიცხვით"],eraAbbr:["ჩვენს წელთ�?ღრიცხვ�?მდე","ჩვენი წელთ�?ღრიცხვით"],eraNarrow:["ჩვენს წელთ�?ღრიცხვ�?მდე","ჩვენი წელთ�?ღრიცხვით"],shortDay:["კვი","�?რშ","ს�?მ","�?თხ","ხუთ","პ�?რ","შ�?ბ"],shortMonth:["ი�?ნ","თებ","მ�?რ","�?პრ","მ�?ი","ივნ","ივლ","�?გვ","სექ","�?ქტ","ნ�?ე","დეკ"],longDay:["კვირ�?","�?რშ�?ბ�?თი","ს�?მშ�?ბ�?თი","�?თხშ�?ბ�?თი","ხუთშ�?ბ�?თი","პ�?რ�?სკევი","შ�?ბ�?თი"],longMonth:["ი�?ნვ�?რი","თებერვ�?ლი","მ�?რტი","�?პრილი","მ�?ისი","ივნისი","ივლისი","�?გვისტ�?","სექტემბერი","�?ქტ�?მბერი","ნ�?ემბერი","დეკემბერი"]},time:{timeSeparator:":",amPm:["დილის","ს�?ღ�?მ�?ს"]}},ka_GE:{date:{},time:{}},kk:{date:{dateSeparator:".",eraAbbr:["BCE","CE"],shortDay:["ж�?.","д�?.","�?�?.","�?р.","б�?.","жм.","�?һ."],shortMonth:["қаң.","ақп.","нау.","�?әу.","мам.","мау.","шіл.","там.","қыр.","қаз.","қар.","желт."],longDay:["жек�?ені","дуй�?енбі","�?ей�?енбі","�?әренбі","бей�?енбі","жұма","�?енбі"],longMonth:["қаңтар","ақпан","наурыз","�?әуір","мамыр","мау�?ым","шілде","тамыз","қыркүйек","қазан","қараша","желтоқ�?ан"]},time:{timeSeparator:":",amPm:["AM","PM"]}},kk_KZ:{date:{},time:{}},kn:{date:{dateSeparator:"-",era:["ಈಸಪೂವ೯.","ಕ�?ರಿಸ�?ತ ಶಕ"],eraAbbr:["BCE","CE"],shortDay:["ರ.","ಸೋ.","ಮಂ.","ಬ�?.","ಗ�?.","ಶ�?.","ಶನಿ."],shortMonth:["ಜನವರೀ","ಫೆಬ�?ರವರೀ","ಮಾರ�?ಚ�?","ಎಪ�?ರಿಲ�?","ಮೆ","ಜೂನ�?","ಜ�?ಲೈ","ಆಗಸ�?ಟ�?","ಸಪ�?ಟೆಂಬರ�?","ಅಕ�?ಟೋಬರ�?","ನವೆಂಬರ�?","ಡಿಸೆಂಬರ�?"],longDay:["ರವಿವಾರ","ಸೋಮವಾರ","ಮಂಗಳವಾರ","ಬ�?ಧವಾರ","ಗ�?ರ�?ವಾರ","ಶ�?ಕ�?ರವಾರ","ಶನಿವಾರ"],longMonth:["ಜನವರೀ","ಫೆಬ�?ರವರೀ","ಮಾರ�?ಚ�?","ಎಪ�?ರಿಲ�?","ಮೆ","ಜೂನ�?","ಜ�?ಲೈ","ಆಗಸ�?ಟ�?","ಸಪ�?ಟೆಂಬರ�?","ಅಕ�?ಟೋಬರ�?","ನವೆಂಬರ�?","ಡಿಸೆಂಬರ�?"]},time:{timeSeparator:":",amPm:["am","pm"]}},kn_IN:{date:{},time:{}},ko:{date:{dateSeparator:". ",era:["서력기�?전","서력기�?"],eraAbbr:["기�?전","서기"],shortDay:["�?�","월","화","수","목","금","토"],shortMonth:["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"],longDay:["�?�요�?�","월요�?�","화요�?�","수요�?�","목요�?�","금요�?�","토요�?�"],longMonth:["1월","2월","3월","4월","5월","6월","7월","8월","9월","10월","11월","12월"]},time:{timeSeparator:":",amPm:["오전","오후"]}},ko_KR:{date:{},time:{}},kok:{date:{dateSeparator:"-",eraAbbr:["क�?रिस�?तपूर�?व","क�?रिस�?तशखा"],shortDay:["रवि","सोम","मंगळ","ब�?ध","ग�?र�?","श�?क�?र","शनि"],shortMonth:["जानेवारी","फेबृवारी","मार�?च","�?प�?रिल","मे","जून","ज�?लै","ओगस�?ट","सेप�?टेंबर","ओक�?टोबर","नोव�?हेंबर","डिसेंबर"],longDay:["आदित�?यवार","सोमवार","मंगळार","ब�?धवार","ग�?र�?वार","श�?क�?रवार","शनिवार"],longMonth:["जानेवारी","फेब�?र�?वारी","मार�?च","�?प�?रिल","मे","जून","ज�?लै","ओगस�?ट","सेप�?टेंबर","ओक�?टोबर","नोव�?हेंबर","डिसेंबर"]},time:{timeSeparator:":",amPm:["म.पू.","म.नं."]}},kok_IN:{date:{},time:{}},lt:{date:{dateSeparator:"-",era:["prieš Kristų","po Kristaus"],eraAbbr:["pr. Kr.","po Kr."],shortDay:["Sk","Pr","An","Tr","Kt","Pn","Št"],shortMonth:["Sau","Vas","Kov","Bal","Geg","Bir","Lie","Rgp","Rgs","Spl","Lap","Grd"],longDay:["sekmadienis","pirmadienis","antradienis","tre�?iadienis","ketvirtadienis","penktadienis","šeštadienis"],longMonth:["sausio","vasario","kovo","balandžio","gegužės","birželio","liepos","rugpjū�?io","rugsėjo","spalio","lapkri�?io","gruodžio"]},time:{timeSeparator:":",amPm:["priešpiet","popiet"]}},lt_LT:{date:{},time:{}},lv:{date:{dateSeparator:".",era:["pirms mūsu ēras","mūsu ēr�?"],eraAbbr:["p.m.ē.","m.ē."],eraNarrow:["p.m.ē.","m.ē."],shortDay:["Sv","Pr","Ot","Tr","Ce","Pk","Se"],shortMonth:["janv.","febr.","marts","apr.","maijs","jūn.","jūl.","aug.","sept.","okt.","nov.","dec."],longDay:["svētdiena","pirmdiena","otrdiena","trešdiena","ceturtdiena","piektdiena","sestdiena"],longMonth:["janv�?ris","febru�?ris","marts","aprīlis","maijs","jūnijs","jūlijs","augusts","septembris","oktobris","novembris","decembris"]},time:{timeSeparator:":",amPm:["AM","PM"]}},lv_LV:{date:{},time:{}},mk:{date:{dateSeparator:".",eraAbbr:["пр.н.е.","ае."],shortDay:["нед.","пон.","вт.","�?ре.","чет.","пет.","�?аб."],shortMonth:["јан.","фев.","мар.","апр.","мај","јун.","јул.","авг.","�?епт.","окт.","ноем.","декем."],longDay:["недела","понеделник","вторник","�?реда","четврток","петок","�?абота"],longMonth:["јануари","февруари","март","април","мај","јуни","јули","авгу�?т","�?ептември","октомври","ноември","декември"]},time:{timeSeparator:":",amPm:["претпладне","попладне"]}},mk_MK:{date:{},time:{}},ml:{date:{dateSeparator:"/",era:["ക�?രിസ�?ത�?വിന�?�? മ�?മ�?പ�?","ക�?രിസ�?ത�?വിന�? പിന�?പ�?"],eraAbbr:["ക�?രി.മ�?.","ക�?രി.പി."],eraNarrow:["ക�?രി.മ�?.","ക�?രി.പി."],shortDay:["ഞായര�?","തിങ�?കള�?","ചൊവ�?വ","ബ�?ധന�?","വ�?യാഴം","വെള�?ളി","ശനി"],shortMonth:["ജന�?","ഫെബ�?ര�?","മാര�?","�?പ�?രി","മേയ�?","ജൂണ�?","ജൂലൈ","ഓഗ","സെപ�?റ�?റം","ഒക�?ടോ","നവം","ഡിസം"],longDay:["ഞായറാഴ�?ച","തിങ�?കളാഴ�?ച","ചൊവ�?വാഴ�?ച","ബ�?ധനാഴ�?ച","വ�?യാഴാഴ�?ച","വെള�?ളിയാഴ�?ച","ശനിയാഴ�?ച"],longMonth:["ജന�?വരി","ഫെബ�?ര�?വരി","മാര�?ച�?ച�?","�?പ�?രില�?","മേയ�?","ജൂണ�?","ജൂലൈ","ഓഗസ�?റ�?റ�?","സെപ�?റ�?റംബര�?","ഒക�?ടോബര�?","നവംബര�?","ഡിസംബര�?"]},time:{timeSeparator:":",amPm:["am","pm"]}},ml_IN:{date:{},time:{}},mn:{date:{dateSeparator:"-",era:["манай �?риний өмнөх","манай �?риний"],eraAbbr:["BCE","CE"],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},mn_MN:{date:{},time:{}},mr:{date:{dateSeparator:"-",era:["ईसवीसनपूर�?व","ईसवीसन"],eraAbbr:["ई.स.पू.","ई.स."],shortDay:["रवि","सोम","मंगळ","ब�?ध","ग�?र�?","श�?क�?र","शनि"],shortMonth:["जानेवारी","फेब�?र�?वारी","मार�?च","�?प�?रिल","मे","जून","ज�?लै","ऑगस�?ट","सप�?टेंबर","ऑक�?टोबर","नोव�?हेंबर","डिसेंबर"],longDay:["रविवार","सोमवार","मंगळवार","ब�?धवार","ग�?र�?वार","श�?क�?रवार","शनिवार"],longMonth:["जानेवारी","फेब�?र�?वारी","मार�?च","�?प�?रिल","मे","जून","ज�?लै","ऑगस�?ट","सप�?टेंबर","ऑक�?टोबर","नोव�?हेंबर","डिसेंबर"]},time:{timeSeparator:"-",amPm:["am","pm"]}},mr_IN:{date:{},time:{}},ms:{date:{dateSeparator:"-",eraAbbr:["BCE","CE"],shortDay:["Ahd","Isn","Sel","Rab","Kha","Jum","Sab"],shortMonth:["Jan","Feb","Mac","Apr","Mei","Jun","Jul","Ogos","Sep","Okt","Nov","Dis"],longDay:["Ahad","Isnin","Selasa","Rabu","Khamis","Jumaat","Sabtu"],longMonth:["Januari","Februari","Mac","April","Mei","Jun","Julai","Ogos","September","Oktober","November","Disember"]},time:{timeSeparator:":",amPm:["AM","PM"]}},ms_BN:{date:{},time:{timeSeparator:":"}},ms_MY:{date:{},time:{}},mt:{date:{dateSeparator:"/",era:["Qabel Kristu","Wara Kristu"],eraAbbr:["QK","WK"],shortDay:["Ħad","Tne","Tli","Erb","Ħam","Ġim","Sib"],shortMonth:["Jan","Fra","Mar","Apr","Mej","Ġun","Lul","Aww","Set","Ott","Nov","Diċ"],longDay:["Il-Ħadd","It-Tnejn","It-Tlieta","L-Erbgħa","Il-Ħamis","Il-Ġimgħa","Is-Sibt"],longMonth:["Jannar","Frar","Marzu","April","Mejju","Ġunju","Lulju","Awwissu","Settembru","Ottubru","Novembru","Diċembru"]},time:{timeSeparator:":",amPm:["QN","WN"]}},mt_MT:{date:{},time:{}},nb:{date:{dateSeparator:".",era:["f.Kr.","e.Kr."],eraAbbr:["f.Kr.","e.Kr."],shortDay:["søn.","man.","tir.","ons.","tor.","fre.","lør."],shortMonth:["jan.","feb.","mars","apr.","mai","juni","juli","aug.","sep.","okt.","nov.","des."],longDay:["søndag","mandag","tirsdag","onsdag","torsdag","fredag","lørdag"],longMonth:["januar","februar","mars","april","mai","juni","juli","august","september","oktober","november","desember"]},time:{timeSeparator:".",amPm:["AM","PM"]}},nb_NO:{date:{},time:{}},nl:{date:{dateSeparator:"-",era:["Voor Christus","Anno Domini"],eraAbbr:["v. Chr.","n. Chr."],shortDay:["zo","ma","di","wo","do","vr","za"],shortMonth:["jan.","feb.","mrt.","apr.","mei","jun.","jul.","aug.","sep.","okt.","nov.","dec."],longDay:["zondag","maandag","dinsdag","woensdag","donderdag","vrijdag","zaterdag"],longMonth:["januari","februari","maart","april","mei","juni","juli","augustus","september","oktober","november","december"]},time:{timeSeparator:":",amPm:["AM","PM"]}},nl_BE:{date:{dateSeparator:"/"},time:{}},nl_NL:{date:{},time:{}},nn:{date:{dateSeparator:".",era:["f.Kr.","e.Kr."],eraAbbr:["f.Kr.","e.Kr."],shortDay:["sø.","må.","ty.","on.","to.","fr.","la."],shortMonth:["jan","feb","mar","apr","mai","jun","jul","aug","sep","okt","nov","des"],longDay:["søndag","måndag","tysdag","onsdag","torsdag","fredag","laurdag"],longMonth:["januar","februar","mars","april","mai","juni","juli","august","september","oktober","november","desember"]},time:{timeSeparator:".",amPm:["formiddag","ettermiddag"]}},nn_NO:{date:{},time:{}},pa:{date:{dateSeparator:"/",era:["ਈਸਾਪੂਰਵ","ਸੰਨ"],eraAbbr:["BCE","CE"],shortDay:["�?ਤ.","ਸੋਮ.","ਮੰਗਲ.","ਬ�?ਧ.","ਵੀਰ.","ਸ਼�?ਕਰ.","ਸ਼ਨੀ."],shortMonth:["ਜਨਵਰੀ","ਫ਼ਰਵਰੀ","ਮਾਰਚ","ਅਪ�?ਰੈਲ","ਮਈ","ਜੂਨ","ਜ�?ਲਾਈ","ਅਗਸਤ","ਸਤੰਬਰ","ਅਕਤੂਬਰ","ਨਵੰਬਰ","ਦਸੰਬਰ"],longDay:["�?ਤਵਾਰ","ਸੋਮਵਾਰ","ਮੰਗਲਵਾਰ","ਬ�?ਧਵਾਰ","ਵੀਰਵਾਰ","ਸ਼�?ੱਕਰਵਾਰ","ਸ਼ਨੀਚਰਵਾਰ"],longMonth:["ਜਨਵਰੀ","ਫ਼ਰਵਰੀ","ਮਾਰਚ","ਅਪ�?ਰੈਲ","ਮਈ","ਜੂਨ","ਜ�?ਲਾਈ","ਅਗਸਤ","ਸਤੰਬਰ","ਅਕਤੂਬਰ","ਨਵੰਬਰ","ਦਸੰਬਰ"]},time:{timeSeparator:":",amPm:["ਸਵੇਰੇ","ਸ਼ਾਮ"]}},pa_IN:{date:{},time:{}},pl:{date:{dateSeparator:"-",era:["p.n.e.","n.e."],eraAbbr:["p.n.e.","n.e."],shortDay:["niedz.","pon.","wt.","śr.","czw.","pt.","sob."],shortMonth:["sty","lut","mar","kwi","maj","cze","lip","sie","wrz","paź","lis","gru"],longDay:["niedziela","poniedziałek","wtorek","środa","czwartek","piątek","sobota"],longMonth:["stycznia","lutego","marca","kwietnia","maja","czerwca","lipca","sierpnia","września","października","listopada","grudnia"]},time:{timeSeparator:":",amPm:["AM","PM"]}},pl_PL:{date:{},time:{}},pt:{date:{dateSeparator:"/",era:["Antes de Cristo","Ano do Senhor"],eraAbbr:["a.C.","d.C."],shortDay:["dom","seg","ter","qua","qui","sex","sáb"],shortMonth:["jan","fev","mar","abr","mai","jun","jul","ago","set","out","nov","dez"],longDay:["domingo","segunda-feira","terça-feira","quarta-feira","quinta-feira","sexta-feira","sábado"],longMonth:["janeiro","fevereiro","março","abril","maio","junho","julho","agosto","setembro","outubro","novembro","dezembro"]},time:{timeSeparator:":",amPm:["AM","PM"]}},pt_BR:{date:{},time:{}},pt_PT:{date:{shortMonth:["Jan","Fev","Mar","Abr","Mai","Jun","Jul","Ago","Set","Out","Nov","Dez"],longMonth:["Janeiro","Fevereiro","Março","Abril","Maio","Junho","Julho","Agosto","Setembro","Outubro","Novembro","Dezembro"]},time:{amPm:["Antes do meio-dia","Depois do meio-dia"]}},ro:{date:{dateSeparator:".",era:["înainte de Hristos","după Hristos"],eraAbbr:["î.Hr.","d.Hr."],shortDay:["Du","Lu","Ma","Mi","Jo","Vi","Sâ"],shortMonth:["ian.","feb.","mar.","apr.","mai","iun.","iul.","aug.","sept.","oct.","nov.","dec."],longDay:["duminică","luni","marți","miercuri","joi","vineri","sâmbătă"],longMonth:["ianuarie","februarie","martie","aprilie","mai","iunie","iulie","august","septembrie","octombrie","noiembrie","decembrie"]},time:{timeSeparator:":",amPm:["AM","PM"]}},ro_RO:{date:{},time:{}},ru:{date:{dateSeparator:".",era:["до н.�?.","н.�?."],eraAbbr:["до н.�?.","н.�?."],shortDay:["В�?","Пн","Вт","Ср","Чт","Пт","Сб"],shortMonth:["�?нв.","февр.","марта","апр.","ма�?","июн�?","июл�?","авг.","�?ент.","окт.","но�?б.","дек."],longDay:["во�?кре�?енье","понедельник","вторник","�?реда","четверг","п�?тница","�?уббота"],longMonth:["�?нвар�?","феврал�?","марта","апрел�?","ма�?","июн�?","июл�?","авгу�?та","�?ент�?бр�?","окт�?бр�?","но�?бр�?","декабр�?"]},time:{timeSeparator:":",amPm:["AM","PM"]}},ru_RU:{date:{},time:{}},se:{date:{dateSeparator:"-",era:["ovdal Kristtusa","maŋŋel Kristtusa"],eraAbbr:["BCE","CE"],eraNarrow:["o.Kr.","m.Kr."],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},se_NO:{date:{},time:{}},sk:{date:{dateSeparator:".",eraAbbr:["pred n.l.","n.l."],shortDay:["ne","po","ut","st","št","pi","so"],shortMonth:["jan","feb","mar","apr","máj","jún","júl","aug","sep","okt","nov","dec"],longDay:["nedeľa","pondelok","utorok","streda","štvrtok","piatok","sobota"],longMonth:["januára","februára","marca","apríla","mája","júna","júla","augusta","septembra","októbra","novembra","decembra"]},time:{timeSeparator:":",amPm:["dopoludnia","popoludní"]}},sk_SK:{date:{},time:{}},sl:{date:{dateSeparator:". ",era:["pred našim štetjem","naše štetje"],eraAbbr:["pr. n. št.","po Kr."],shortDay:["ned","pon","tor","sre","�?et","pet","sob"],shortMonth:["jan","feb","mar","apr","maj","jun","jul","avg","sep","okt","nov","dec"],longDay:["nedelja","ponedeljek","torek","sreda","�?etrtek","petek","sobota"],longMonth:["januar","februar","marec","april","maj","junij","julij","avgust","september","oktober","november","december"]},time:{timeSeparator:":",amPm:["dop.","pop."]}},sl_SI:{date:{},time:{}},sq:{date:{dateSeparator:"-",eraAbbr:["p.e.r.","n.e.r."],shortDay:["Die","Hën","Mar","Mër","Enj","Pre","Sht"],shortMonth:["Jan","Shk","Mar","Pri","Maj","Qer","Kor","Gsh","Sht","Tet","Nën","Dhj"],longDay:["e diel","e hënë","e martë","e mërkurë","e enjte","e premte","e shtunë"],longMonth:["janar","shkurt","mars","prill","maj","qershor","korrik","gusht","shtator","tetor","nëntor","dhjetor"]},time:{timeSeparator:".",amPm:["PD","MD"]}},sq_AL:{date:{},time:{}},sr:{date:{dateSeparator:".",era:["Пре нове ере","�?ове ере"],eraAbbr:["п. н. е.","н. е"],eraNarrow:["п.н.е.","н.е."],shortDay:["нед","пон","уто","�?ре","чет","пет","�?уб"],shortMonth:["јан","феб","мар","апр","мај","јун","јул","авг","�?еп","окт","нов","дец"],longDay:["недеља","понедељак","уторак","�?реда","четвртак","петак","�?убота"],longMonth:["јануар","фебруар","март","април","мај","јун","јул","авгу�?т","�?ептембар","октобар","новембар","децембар"]},time:{timeSeparator:".",amPm:["пре подне","поподне"]}},sr_BA:{date:{},time:{}},sr_CS:{date:{},time:{}},sv:{date:{dateSeparator:"-",era:["före Kristus","efter Kristus"],eraAbbr:["f.Kr.","e.Kr."],shortDay:["sön","mån","tis","ons","tors","fre","lör"],shortMonth:["jan","feb","mar","apr","maj","jun","jul","aug","sep","okt","nov","dec"],longDay:["söndag","måndag","tisdag","onsdag","torsdag","fredag","lördag"],longMonth:["januari","februari","mars","april","maj","juni","juli","augusti","september","oktober","november","december"]},time:{timeSeparator:".",amPm:["fm","em"]}},sv_FI:{date:{},time:{}},sv_SE:{date:{},time:{}},sw:{date:{dateSeparator:"-",era:["Kabla ya Kristo","Baada ya Kristo"],eraAbbr:["KK","BK"],shortDay:["Jpi","Jtt","Jnn","Jtn","Alh","Iju","Jmo"],shortMonth:["Jan","Feb","Mac","Apr","Mei","Jun","Jul","Ago","Sep","Okt","Nov","Des"],longDay:["Jumapili","Jumatatu","Jumanne","Jumatano","Alhamisi","Ijumaa","Jumamosi"],longMonth:["Januari","Februari","Machi","Aprili","Mei","Juni","Julai","Agosti","Septemba","Oktoba","Novemba","Desemba"]},time:{timeSeparator:":",amPm:["AM","PM"]}},sw_KE:{date:{},time:{}},syr:{date:{dateSeparator:"-",shortDay:["1","2","3","4","5","6","7"],shortMonth:["ܟܢ ܒ","ܫܒܛ","�?ܕܪ","ܢ�?ܣܢ","�?�?ܪ","ܚܙ�?ܪܢ","ܬܡܘܙ","�?ܒ","�?�?ܠܘܠ","ܬܫ �?","ܬܫ ܒ","ܟܢ �?"],longDay:["1","2","3","4","5","6","7"],longMonth:["ܟܢ ܒ","ܫܒܛ","�?ܕܪ","ܢ�?ܣܢ","�?�?ܪ","ܚܙ�?ܪܢ","ܬܡܘܙ","�?ܒ","�?�?ܠܘܠ","ܬܫ �?","ܬܫ ܒ","ܟܢ �?"]},time:{timeSeparator:":",amPm:["AM","PM"]}},syr_SY:{date:{},time:{}},ta:{date:{dateSeparator:"-",era:["கிறிஸ�?த�?வ�?க�?க�? ம�?ன�?","அனோ டோமினி"],eraAbbr:["கிம�?","கிபி"],shortDay:["ஞா","தி","செ","ப�?","வி","வெ","ச"],shortMonth:["ஜன.","பிப�?.","மார�?.","�?ப�?.","மே","ஜூன�?","ஜூலை","ஆக.","செப�?.","அக�?.","நவ.","டிச."],longDay:["ஞாயிற�?","திங�?கள�?","செவ�?வாய�?","ப�?தன�?","வியாழன�?","வெள�?ளி","சனி"],longMonth:["ஜனவரி","பிப�?ரவரி","மார�?ச�?","�?ப�?ரல�?","மே","ஜூன�?","ஜூலை","ஆகஸ�?ட�?","செப�?டம�?பர�?","அக�?டோபர�?","நவம�?பர�?","டிசம�?பர�?"]},time:{timeSeparator:":",amPm:["am","pm"]}},ta_IN:{date:{},time:{}},te:{date:{dateSeparator:"-",era:["ఈసాపూర�?వ.","సన�?."],eraAbbr:["BCE","CE"],shortDay:["ఆది","సోమ","మంగళ","బ�?ధ","గ�?ర�?","శ�?క�?ర","శని"],shortMonth:["జనవరి","ఫిబ�?రవరి","మార�?చి","�?ప�?రిల�?","మే","జూన�?","జూలై","ఆగస�?ట�?","సెప�?టెంబర�?","అక�?టోబర�?","నవంబర�?","డిసెంబర�?"],longDay:["ఆదివారం","సోమవారం","మంగళవారం","బ�?ధవారం","గ�?ర�?వారం","శ�?క�?రవారం","శనివారం"],longMonth:["జనవరి","ఫిబ�?రవరి","మార�?చి","�?ప�?రిల�?","మే","జూన�?","జూలై","ఆగస�?ట�?","సెప�?టెంబర�?","అక�?టోబర�?","నవంబర�?","డిసెంబర�?"]},time:{timeSeparator:":",amPm:["am","pm"]}},te_IN:{date:{},time:{}},th:{date:{dateSeparator:"/",era:["ปี�?่อนคริสต์ศั�?ราช","คริสต์ศั�?ราช"],eraAbbr:["ปี�?่อน ค.ศ.","ค.ศ."],eraNarrow:["�?่อน ค.ศ."],shortDay:["อา.","จ.","อ.","พ.","พฤ.","ศ.","ส."],shortMonth:["ม.ค.","�?.พ.","มี.ค.","เม.ย.","พ.ค.","มิ.ย.","�?.ค.","ส.ค.","�?.ย.","ต.ค.","พ.ย.","ธ.ค."],longDay:["วันอาทิตย์","วันจันทร์","วันอังคาร","วันพุธ","วันพฤหัสบดี","วันศุ�?ร์","วันเสาร์"],longMonth:["ม�?ราคม","�?ุมภาพันธ์","มีนาคม","เมษายน","พฤษภาคม","มิถุนายน","�?ร�?ฎาคม","สิงหาคม","�?ันยายน","ตุลาคม","พฤศจิ�?ายน","ธันวาคม"]},time:{timeSeparator:":",amPm:["�?่อนเที่ยง","หลังเที่ยง"]}},th_TH:{date:{},time:{}},tn:{date:{dateSeparator:"-",era:["BC","AD"],eraAbbr:["BCE","CE"],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},tn_ZA:{date:{},time:{}},tr:{date:{dateSeparator:".",era:["Milattan Önce","Milattan Sonra"],eraAbbr:["MÖ","MS"],shortDay:["Paz","Pzt","Sal","Çar","Per","Cum","Cmt"],shortMonth:["Oca","Şub","Mar","Nis","May","Haz","Tem","Ağu","Eyl","Eki","Kas","Ara"],longDay:["Pazar","Pazartesi","Salı","Çarşamba","Perşembe","Cuma","Cumartesi"],longMonth:["Ocak","Şubat","Mart","Nisan","Mayıs","Haziran","Temmuz","Ağustos","Eylül","Ekim","Kasım","Aralık"]},time:{timeSeparator:":",amPm:["AM","PM"]}},tr_TR:{date:{},time:{}},uk:{date:{dateSeparator:".",era:["до нашої ери","нашої ери"],eraAbbr:["до н.е.","н.е."],shortDay:["�?д","Пн","Вт","Ср","Чт","Пт","Сб"],shortMonth:["�?іч.","лют.","бер.","квіт.","трав.","черв.","лип.","�?ерп.","вер.","жовт.","ли�?т.","груд."],longDay:["�?еділ�?","Понеділок","Вівторок","Середа","Четвер","Пʼ�?тниц�?","Субота"],longMonth:["�?ічн�?","лютого","березн�?","квітн�?","травн�?","червн�?","липн�?","�?ерпн�?","вере�?н�?","жовтн�?","ли�?топада","грудн�?"]},time:{timeSeparator:":",amPm:["дп","пп"]}},uk_UA:{date:{},time:{}},uz:{date:{dateSeparator:"-",eraAbbr:["BCE","CE"],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},uz_UZ:{date:{},time:{}},vi:{date:{dateSeparator:"/",eraAbbr:["tr. CN","sau CN"],shortDay:["CN","Th 2","Th 3","Th 4","Th 5","Th 6","Th 7"],shortMonth:["thg 1","thg 2","thg 3","thg 4","thg 5","thg 6","thg 7","thg 8","thg 9","thg 10","thg 11","thg 12"],longDay:["Chủ nhật","Thứ hai","Thứ ba","Thứ tư","Thứ năm","Thứ sáu","Thứ bảy"],longMonth:["tháng một","tháng hai","tháng ba","tháng tư","tháng năm","tháng sáu","tháng bảy","tháng tám","tháng chín","tháng mư�?i","tháng mư�?i một","tháng mư�?i hai"]},time:{timeSeparator:":",amPm:["SA","CH"]}},vi_VN:{date:{},time:{}},xh:{date:{dateSeparator:"-",era:["BC","umnyaka wokuzalwa kukaYesu"],eraAbbr:["BCE","CE"],shortDay:["1","2","3","4","5","6","7"],shortMonth:["1","2","3","4","5","6","7","8","9","10","11","12"],longDay:["1","2","3","4","5","6","7"],longMonth:["1","2","3","4","5","6","7","8","9","10","11","12"]},time:{timeSeparator:":",amPm:["AM","PM"]}},xh_ZA:{date:{},time:{}},zh:{date:{dateSeparator:"-",era:["公元�?","公元"],eraAbbr:["公元�?","公元"],shortDay:["周日","周一","周二","周三","周四","周五","周六"],shortMonth:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"],longDay:["星期日","星期一","星期二","星期三","星期四","星期五","星期六"],longMonth:["1月","2月","3月","4月","5月","6月","7月","8月","9月","10月","11月","12月"]},time:{timeSeparator:":",amPm:["上�?�","下�?�"]}},zh_CN:{date:{},time:{}},zh_HK:{date:{},time:{}},zh_MO:{date:{},time:{}},zh_SG:{date:{},time:{}},zh_TW:{date:{},time:{}},zu:{date:{dateSeparator:"-",eraAbbr:["BC","AD"],shortDay:["Son","Mso","Bil","Tha","Sin","Hla","Mgq"],shortMonth:["Jan","Feb","Mas","Apr","Mey","Jun","Jul","Aga","Sep","Okt","Nov","Dis"],longDay:["Sonto","Msombuluko","Lwesibili","Lwesithathu","uLwesine","Lwesihlanu","Mgqibelo"],longMonth:["Januwari","Februwari","Mashi","Apreli","Meyi","Juni","Julayi","Agasti","Septhemba","Okthoba","Novemba","Disemba"]},time:{timeSeparator:":",amPm:["AM","PM"]}},zu_ZA:{date:{},time:{}}};a.formatExist=function(b,c){return(b&&c&&a.DEFAULT_FORMAT_STRING[b]&&a.DEFAULT_FORMAT_STRING[b][c])};a.getDefaultDateFormat=function(b,c){return a.DEFAULT_FORMAT_STRING[b][c]};a.getShortDay=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_DAY)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_DAY)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_DAY)};a.getLongDay=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_DAY)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_DAY)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_DAY)};a.getShortMonth=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_MONTH)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_MONTH)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_SHORT_MONTH)};a.getLongMonth=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_MONTH)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_MONTH)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_LONG_MONTH)};a.getDateSeparator=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_DATE_SEPARATOR)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_DATE_SEPARATOR).toString()}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_DATE_SEPARATOR).toString()};a.getTimeSeparator=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_TIME,a.KEY_TIME_SEPARATOR)){return a.getDateResource(b,a.KEY_TYPE_TIME,a.KEY_TIME_SEPARATOR).toString()}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_TIME,a.KEY_TIME_SEPARATOR).toString()};a.getAmPmToken=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_TIME,a.KEY_TOKEN_AM_PM)){return a.getDateResource(b,a.KEY_TYPE_TIME,a.KEY_TOKEN_AM_PM)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_TIME,a.KEY_TOKEN_AM_PM)};a.getAbbrevEraString=function(b){if(b){if(a.resourceExist(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_ABBREV_ERA)){return a.getDateResource(b,a.KEY_TYPE_DATE,a.KEY_TOKEN_ABBREV_ERA)}else{return null}}return a.getAppropriateDateResource(a.KEY_TYPE_DATE,a.KEY_TOKEN_ABBREV_ERA)};a.getDefaultShorDateFormat=function(b){if(b){if(a.formatExist(b,a.FORMAT_TYPE_SHORTDATE)){return a.getDefaultDateFormat(b,a.FORMAT_TYPE_SHORTDATE).toString()}else{return""}}return a.getAppropriateDateFormat(a.FORMAT_TYPE_SHORTDATE).toString()};a.getDefaultLongDateFormat=function(b){if(b){if(a.formatExist(b,a.FORMAT_TYPE_LONGDATE)){return a.getDefaultDateFormat(b,a.FORMAT_TYPE_LONGDATE).toString()}else{return null}}return a.getAppropriateDateFormat(a.FORMAT_TYPE_LONGDATE)};a.getDefaultDateTimeFormat=function(b){if(b){if(a.formatExist(b,a.FORMAT_TYPE_DATE_TIME)){return a.getDefaultDateFormat(b,a.FORMAT_TYPE_DATE_TIME).toString()}else{return null}}return a.getAppropriateDateFormat(a.FORMAT_TYPE_DATE_TIME).toString()};a.getDefaultTimeFormat=function(b){if(b){if(a.formatExist(b,a.FORMAT_TYPE_TIME)){return a.getDefaultDateFormat(b,a.FORMAT_TYPE_TIME).toString()}else{return null}}return a.getAppropriateDateFormat(a.FORMAT_TYPE_TIME).toString()};a.getAppropriateDateFormat=function(d){var e=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(a.formatExist(e,d)){return a.getDefaultDateFormat(e,d).toString()}var c=sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();if(a.formatExist(c,d)){return a.getDefaultDateFormat(c,d).toString()}var f=sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();if(a.formatExist(f,d)){return a.getDefaultDateFormat(f,d).toString()}var b=sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();if(a.formatExist(b,d)){return a.getDefaultDateFormat(b,d).toString()}return a.getDefaultDateFormat("en",d).toString()};a.getAppropriateDateResource=function(e,b){var f=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(a.resourceExist(f,e,b)){return a.getDateResource(f,e,b)}var d=sap.common.globalization.GlobalizationPreference.getInstance().pvlIsoLanguageCode();if(a.resourceExist(d,e,b)){return a.getDateResource(d,e,b)}var g=sap.common.globalization.GlobalizationPreference.getInstance().documentLocale();if(a.resourceExist(g,e,b)){return a.getDateResource(g,e,b)}var c=sap.common.globalization.GlobalizationPreference.getInstance().documentIsoLanguageCode();if(a.resourceExist(c,e,b)){return a.getDateResource(c,e,b)}return a.getDateResource("en",e,b)};a.resourceExist=function(b,d,c){return(b&&d&&c&&a.RESOURCE_MAP[b]&&a.RESOURCE_MAP[b][d]&&a.RESOURCE_MAP[b][d][c])};a.getDateResource=function(b,d,c){return a.RESOURCE_MAP[b][d][c]}})();(function(){sap.common.globalization.declare("sap.common.globalization.GlobalizationNumericUtil");sap.common.globalization.GlobalizationNumericUtil=function(){this.__className="sap.common.globalization.GlobalizationNumericUtil"};sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry=function(a){switch(a){case"bn":case"bn_IN":case"gu":case"gu_IN":case"hi":case"hi_IN":case"kn":case"kn_IN":case"kok":case"kok_IN":case"ml":case"ml_IN":case"mr":case"mr_IN":case"pa":case"pa_IN":case"ta":case"ta_IN":case"te":case"te_IN":return true;default:return false}}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.NumericFormatManager");sap.common.globalization.numericFormat.FLocalization=function(){this.__className="sap.common.globalization.numericFormat.FLocalization";this._setDisplayLocaleInfo();this._numericParseLocaleInfo=null;this._numericDisplayLocaleInfo=null;this._dateParseLocaleInfo=null;this._dateDisplayLocaleInfo=null};var a=sap.common.globalization.numericFormat.FLocalization;a._defaultLocale="en";a._DayStrings=null;a._shortDayStrings=null;a._MonthStrings=null;a._shortMonthStrings=null;a._DateTimeCodes=null;a._NumericStrings=null;a._DateTimeStrings=null;a._CurrencySymbol=null;a._SAPCurrencySymbol=null;a._SAPDateString=null;a._SAPTimeString=null;a._SAPThousandsSeparator=null;a._SAPDecimalSeparator=null;a._SAPLongDay=null;a._SAPShortDay=null;a._SAPLongMonth=null;a._SAPShortMonth=null;a._AmPms=null;a._singleton=null;sap.common.globalization.numericFormat.FLocalization.prototype.replaceNBSP=function(e){if(e){var f="";var c=160;for(var d=0;d<e.length;++d){if(e.charCodeAt(d)==c){f+=" "}else{f+=e.charAt(d)}}e=f}return e};a.getInstance=function(){if(!a._singleton){a._initStrings();a._initializePvlDateStrings();a._initSAPGlobilizationStrings();a._singleton=new sap.common.globalization.numericFormat.FLocalization();a._singleton.IMSABBREVDAYNAME1=a._shortDayStrings.en[1]}return a._singleton};a.resetInstance=function(){a._resetAllStaticVars();a._initStrings();a._initializePvlDateStrings();a._initSAPGlobilizationStrings();a._singleton=new sap.common.globalization.numericFormat.FLocalization();a._singleton.IMSABBREVDAYNAME1=a._shortDayStrings.en[1]};var b={monthStrings:"_MonthStrings",shortMonthStrings:"_shortMonthStrings",dayStrings:"_DayStrings",shortDayStrings:"_shortDayStrings",dateTimeCodes:"_DateTimeCodes",numericStrings:"_NumericStrings",dateTimeStrings:"_DateTimeStrings",currencySymbol:"_CurrencySymbol",amPms:"_AmPms"};a.prototype._setDisplayLocaleInfo=function(){this.IMDateSeparator=a._DateTimeStrings.en[1];this.IMDayCode=a._DateTimeCodes.en[5];this.IMDecimalSeparator=a._NumericStrings.en[1];this.IMGeneralFormatName="General";this.IMHourCode=a._DateTimeCodes.en[3];this.IMMinuteCode=a._DateTimeCodes.en[1];this.IMMonthCode=a._DateTimeCodes.en[4];this.IMSABBREVDAYNAME1=a._shortDayStrings.en[1];this.IMSABBREVDAYNAME2=a._shortDayStrings.en[2];this.IMSABBREVDAYNAME3=a._shortDayStrings.en[3];this.IMSABBREVDAYNAME4=a._shortDayStrings.en[4];this.IMSABBREVDAYNAME5=a._shortDayStrings.en[5];this.IMSABBREVDAYNAME6=a._shortDayStrings.en[6];this.IMSABBREVDAYNAME7=a._shortDayStrings.en[7];this.IMSABBREVMONTHNAME1=a._shortMonthStrings.en[1];this.IMSABBREVMONTHNAME10=a._shortMonthStrings.en[10];this.IMSABBREVMONTHNAME11=a._shortMonthStrings.en[11];this.IMSABBREVMONTHNAME12=a._shortMonthStrings.en[12];this.IMSABBREVMONTHNAME2=a._shortMonthStrings.en[2];this.IMSABBREVMONTHNAME3=a._shortMonthStrings.en[3];this.IMSABBREVMONTHNAME4=a._shortMonthStrings.en[4];this.IMSABBREVMONTHNAME5=a._shortMonthStrings.en[5];this.IMSABBREVMONTHNAME6=a._shortMonthStrings.en[6];this.IMSABBREVMONTHNAME7=a._shortMonthStrings.en[7];this.IMSABBREVMONTHNAME8=a._shortMonthStrings.en[8];this.IMSABBREVMONTHNAME9=a._shortMonthStrings.en[9];this.IMSDAYNAME1=a._DayStrings.en[1];this.IMSDAYNAME2=a._DayStrings.en[2];this.IMSDAYNAME3=a._DayStrings.en[3];this.IMSDAYNAME4=a._DayStrings.en[4];this.IMSDAYNAME5=a._DayStrings.en[5];this.IMSDAYNAME6=a._DayStrings.en[6];this.IMSDAYNAME7=a._DayStrings.en[7];this.IMSMONTHNAME1=a._MonthStrings.en[1];this.IMSMONTHNAME10=a._MonthStrings.en[10];this.IMSMONTHNAME11=a._MonthStrings.en[11];this.IMSMONTHNAME12=a._MonthStrings.en[12];this.IMSMONTHNAME2=a._MonthStrings.en[2];this.IMSMONTHNAME3=a._MonthStrings.en[3];this.IMSMONTHNAME4=a._MonthStrings.en[4];this.IMSMONTHNAME5=a._MonthStrings.en[5];this.IMSMONTHNAME6=a._MonthStrings.en[6];this.IMSMONTHNAME7=a._MonthStrings.en[7];this.IMSMONTHNAME8=a._MonthStrings.en[8];this.IMSMONTHNAME9=a._MonthStrings.en[9];this.IMSecondCode=a._DateTimeCodes.en[2];this.IMTimeSeparator=a._DateTimeStrings.en[2];this.IMYearCode=a._DateTimeCodes.en[6];this.IMCurrencySymbol=a._CurrencySymbol.en[1];this.SAPDateSeparator=a._SAPDateString;this.SAPTimeSeparator=a._SAPTimeString;this.SAPCurrencySymbol=a._SAPCurrencySymbol;this.SAPDecimalSeparator=a._SAPDecimalSeparator;this.SAPThousandsSeparator=a._SAPThousandsSeparator;this.SAPLongDay=a._SAPLongDay;this.SAPShortDay=a._SAPShortDay;this.SAPLongMonth=a._SAPLongMonth;this.SAPShortMonth=a._SAPShortMonth;this.IMAMTOKEN=a._AmPms.en[1];this.IMPMTOKEN=a._AmPms.en[2];this._IMThousandsSeparator=this.replaceNBSP(a._NumericStrings.en[2])};a.prototype.setCustomizedLocaleInfo=function(e){if(e){var d;for(d in b){if(e.hasOwnProperty(d)){var g=b[d];this._setCustomizedLocaleInfoByType(g,e[d])}}}else{var c=sap.common.globalization.GlobalizationDateConstant;var f=sap.common.globalization.GlobalizationNumericConstant;this._setCustomizedLocaleInfoByType(b.dayStrings,c.getLongDay());this._setCustomizedLocaleInfoByType(b.shortDayStrings,c.getShortDay());this._setCustomizedLocaleInfoByType(b.monthStrings,c.getLongMonth());this._setCustomizedLocaleInfoByType(b.shortMonthStrings,c.getShortMonth());this._setCustomizedLocaleInfoByType(b.amPms,c.getAmPmToken());this._setCustomizedLocaleInfoByType(b.dateTimeStrings,[c.getDateSeparator(),c.getTimeSeparator()]);this._setCustomizedLocaleInfoByType(b.numericStrings,[f.getDisplayDecimalSeparator(),f.getDisplayThousandSeparator()]);this._dateParseLocaleInfo=null;this._dateDisplayLocaleInfo=null;this._numericParseLocaleInfo=null;this._numericDisplayLocaleInfo=null}this._setDisplayLocaleInfo()};a.prototype._setCustomizedLocaleInfoByType=function(e,f){if(f&&f.length>0){var c;for(var d=0;d<f.length;d++){c=d+1;a[e]["en"][c]=f[d]}}};a._initStrings=function(){a._DayStrings={en:{1:"Monday",2:"Tuesday",3:"Wednesday",4:"Thursday",5:"Friday",6:"Saturday",7:"Sunday"}};a._shortDayStrings={en:{1:"Mon",2:"Tue",3:"Wed",4:"Thu",5:"Fri",6:"Sat",7:"Sun"}};a._MonthStrings={en:{1:"January",2:"February",3:"March",4:"April",5:"May",6:"June",7:"July",8:"August",9:"September",10:"October",11:"November",12:"December"}};a._shortMonthStrings={en:{1:"Jan",2:"Feb",3:"Mar",4:"Apr",5:"May",6:"Jun",7:"Jul",8:"Aug",9:"Sep",10:"Oct",11:"Nov",12:"Dec"}};a._DateTimeCodes={en:{1:"m",2:"s",3:"h",4:"M",5:"D",6:"Y"}};a._NumericStrings={en:{1:".",2:","}};a._DateTimeStrings={en:{1:"/",2:":"}};a._CurrencySymbol={en:{1:"$",2:"$"}};a._AmPms={en:{1:"AM",2:"PM"}}};a._initSAPGlobilizationStrings=function(){var d=sap.common.globalization.NumericFormatManager;var e=d.SAP_PARAMETERS["BICSWS_DECIMAL"];e=e?e:d.SAP_PARAMETERS["SAP_decimal"];var l=d.SAP_PARAMETERS["BICSWS_THOUSANDSEPARATOR"];l=l?l:d.SAP_PARAMETERS["SAP_thousandSeparator"];var f=d.SAP_PARAMETERS["BICSWS_MONTHSLONG"];f=f?f:d.SAP_PARAMETERS["SAP_monthsLong"];var g=d.SAP_PARAMETERS["BICSWS_MONTHSSHORT"];g=g?g:d.SAP_PARAMETERS["SAP_monthsShort"];var c=d.SAP_PARAMETERS["BICSWS_DAYSLONG"];c=c?c:d.SAP_PARAMETERS["SAP_daysLong"];var m=d.SAP_PARAMETERS["BICSWS_DAYSSHORT"];m=m?m:d.SAP_PARAMETERS["SAP_daysShort"];var k=d.SAP_PARAMETERS["BICSWS_DATESEPARATOR"];k=k?k:d.SAP_PARAMETERS["SAP_dateSeparator"];var j=d.SAP_PARAMETERS["BICSWS_TIMESEPARATOR"];j=j?j:d.SAP_PARAMETERS["SAP_timeSeparator"];var h=d.SAP_PARAMETERS["SAP_s_g_n_FLocalization._CurrencySymbol"];var i;if(c){i=c.split(",");a._SAPLongDay=i;a._DayStrings.en[1]=i[0];a._DayStrings.en[2]=i[1];a._DayStrings.en[3]=i[2];a._DayStrings.en[4]=i[3];a._DayStrings.en[5]=i[4];a._DayStrings.en[6]=i[5];a._DayStrings.en[7]=i[6]}if(m){i=m.split(",");a._SAPShortDay=i;a._shortDayStrings.en[1]=i[0];a._shortDayStrings.en[2]=i[1];a._shortDayStrings.en[3]=i[2];a._shortDayStrings.en[4]=i[3];a._shortDayStrings.en[5]=i[4];a._shortDayStrings.en[6]=i[5];a._shortDayStrings.en[7]=i[6]}if(f){i=f.split(",");a._SAPLongMonth=i;a._MonthStrings.en[1]=i[0];a._MonthStrings.en[2]=i[1];a._MonthStrings.en[3]=i[2];a._MonthStrings.en[4]=i[3];a._MonthStrings.en[5]=i[4];a._MonthStrings.en[6]=i[5];a._MonthStrings.en[7]=i[6];a._MonthStrings.en[8]=i[7];a._MonthStrings.en[9]=i[8];a._MonthStrings.en[10]=i[9];a._MonthStrings.en[11]=i[10];a._MonthStrings.en[12]=i[11]}if(g){i=g.split(",");a._SAPShortMonth=i;a._shortMonthStrings.en[1]=i[0];a._shortMonthStrings.en[2]=i[1];a._shortMonthStrings.en[3]=i[2];a._shortMonthStrings.en[4]=i[3];a._shortMonthStrings.en[5]=i[4];a._shortMonthStrings.en[6]=i[5];a._shortMonthStrings.en[7]=i[6];a._shortMonthStrings.en[8]=i[7];a._shortMonthStrings.en[9]=i[8];a._shortMonthStrings.en[10]=i[9];a._shortMonthStrings.en[11]=i[10];a._shortMonthStrings.en[12]=i[11]}if(e){a._SAPDecimalSeparator=e}if(l){a._SAPThousandsSeparator=l}if(k){a._SAPDateString=k}if(j){a._SAPTimeString=j}if(h){a._SAPCurrencySymbol=h}};a.prototype.IMThousandsSeparator=function(c){if(arguments.length>=1){this._IMThousandsSeparator=this.replaceNBSP(c);return this}else{return this._IMThousandsSeparator}};a.prototype.getDateParseLocaleInfo=function(){if(!this._dateParseLocaleInfo){this._dateParseLocaleInfo=new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl();this._dateParseLocaleInfo.IMDateSeparator(this.IMDateSeparator);this._dateParseLocaleInfo.IMTimeSeparator(this.IMTimeSeparator)}return this._dateParseLocaleInfo};a.prototype.getDateDisplayLocaleInfo=function(){if(!this._dateDisplayLocaleInfo){this._dateDisplayLocaleInfo=new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();this._dateDisplayLocaleInfo.IMDateSeparator(this.SAPDateSeparator);this._dateDisplayLocaleInfo.IMSDAYNAME1(this.IMSDAYNAME1);this._dateDisplayLocaleInfo.IMSDAYNAME2(this.IMSDAYNAME2);this._dateDisplayLocaleInfo.IMSDAYNAME3(this.IMSDAYNAME3);this._dateDisplayLocaleInfo.IMSDAYNAME4(this.IMSDAYNAME4);this._dateDisplayLocaleInfo.IMSDAYNAME5(this.IMSDAYNAME5);this._dateDisplayLocaleInfo.IMSDAYNAME6(this.IMSDAYNAME6);this._dateDisplayLocaleInfo.IMSDAYNAME7(this.IMSDAYNAME7);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME1(this.IMSABBREVDAYNAME1);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME2(this.IMSABBREVDAYNAME2);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME3(this.IMSABBREVDAYNAME3);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME4(this.IMSABBREVDAYNAME4);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME5(this.IMSABBREVDAYNAME5);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME6(this.IMSABBREVDAYNAME6);this._dateDisplayLocaleInfo.IMSABBREVDAYNAME7(this.IMSABBREVDAYNAME7);this._dateDisplayLocaleInfo.IMSMONTHNAME1(this.IMSMONTHNAME1);this._dateDisplayLocaleInfo.IMSMONTHNAME2(this.IMSMONTHNAME2);this._dateDisplayLocaleInfo.IMSMONTHNAME3(this.IMSMONTHNAME3);this._dateDisplayLocaleInfo.IMSMONTHNAME4(this.IMSMONTHNAME4);this._dateDisplayLocaleInfo.IMSMONTHNAME5(this.IMSMONTHNAME5);this._dateDisplayLocaleInfo.IMSMONTHNAME6(this.IMSMONTHNAME6);this._dateDisplayLocaleInfo.IMSMONTHNAME7(this.IMSMONTHNAME7);this._dateDisplayLocaleInfo.IMSMONTHNAME8(this.IMSMONTHNAME8);this._dateDisplayLocaleInfo.IMSMONTHNAME9(this.IMSMONTHNAME9);this._dateDisplayLocaleInfo.IMSMONTHNAME10(this.IMSMONTHNAME10);this._dateDisplayLocaleInfo.IMSMONTHNAME11(this.IMSMONTHNAME11);this._dateDisplayLocaleInfo.IMSMONTHNAME12(this.IMSMONTHNAME12);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME1(this.IMSABBREVMONTHNAME1);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME2(this.IMSABBREVMONTHNAME2);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME3(this.IMSABBREVMONTHNAME3);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME4(this.IMSABBREVMONTHNAME4);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME5(this.IMSABBREVMONTHNAME5);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME6(this.IMSABBREVMONTHNAME6);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME7(this.IMSABBREVMONTHNAME7);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME8(this.IMSABBREVMONTHNAME8);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME9(this.IMSABBREVMONTHNAME9);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME10(this.IMSABBREVMONTHNAME10);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME11(this.IMSABBREVMONTHNAME11);this._dateDisplayLocaleInfo.IMSABBREVMONTHNAME12(this.IMSABBREVMONTHNAME12);this._dateDisplayLocaleInfo.IMTimeSeparator(this.SAPTimeSeparator);this._dateDisplayLocaleInfo.IMAMTOKEN(this.IMAMTOKEN);this._dateDisplayLocaleInfo.IMPMTOKEN(this.IMPMTOKEN)}return this._dateDisplayLocaleInfo};a.prototype.numericParseLocaleInfo=function(){if(!this._numericParseLocaleInfo){this._numericParseLocaleInfo=new sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl(this._IMThousandsSeparator,this.IMDecimalSeparator,this.IMCurrencySymbol)}return this._numericParseLocaleInfo};a.prototype.numericDisplayLocaleInfo=function(){if(!this._numericDisplayLocaleInfo){var c=(this.SAPThousandsSeparator?this.SAPThousandsSeparator:this._IMThousandsSeparator);var e=(this.SAPDecimalSeparator?this.SAPDecimalSeparator:this.IMDecimalSeparator);var d=(this.SAPCurrencySymbol?this.SAPCurrencySymbol:this.IMCurrencySymbol);this._numericDisplayLocaleInfo=new sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl(c,e,d)}return this._numericDisplayLocaleInfo};a._initializePvlDateStrings=function(){var g=sap.common.globalization.GlobalizationPreference.getInstance().pvl();if(g&&!sap.common.globalization.utils.StringUtil.isBlankString(g)){var f=sap.common.globalization.GlobalizationDateConstant.getLongDay();if(f){a._DayStrings.en[1]=f[1];a._DayStrings.en[2]=f[2];a._DayStrings.en[3]=f[3];a._DayStrings.en[4]=f[4];a._DayStrings.en[5]=f[5];a._DayStrings.en[6]=f[6];a._DayStrings.en[7]=f[0]}var c=sap.common.globalization.GlobalizationDateConstant.getShortDay();if(c){a._shortDayStrings.en[1]=c[1];a._shortDayStrings.en[2]=c[2];a._shortDayStrings.en[3]=c[3];a._shortDayStrings.en[4]=c[4];a._shortDayStrings.en[5]=c[5];a._shortDayStrings.en[6]=c[6];a._shortDayStrings.en[7]=c[0]}var h=sap.common.globalization.GlobalizationDateConstant.getLongMonth();if(h){a._MonthStrings.en[1]=h[0];a._MonthStrings.en[2]=h[1];a._MonthStrings.en[3]=h[2];a._MonthStrings.en[4]=h[3];a._MonthStrings.en[5]=h[4];a._MonthStrings.en[6]=h[5];a._MonthStrings.en[7]=h[6];a._MonthStrings.en[8]=h[7];a._MonthStrings.en[9]=h[8];a._MonthStrings.en[10]=h[9];a._MonthStrings.en[11]=h[10];a._MonthStrings.en[12]=h[11]}var e=sap.common.globalization.GlobalizationDateConstant.getShortMonth();if(e){a._shortMonthStrings.en[1]=e[0];a._shortMonthStrings.en[2]=e[1];a._shortMonthStrings.en[3]=e[2];a._shortMonthStrings.en[4]=e[3];a._shortMonthStrings.en[5]=e[4];a._shortMonthStrings.en[6]=e[5];a._shortMonthStrings.en[7]=e[6];a._shortMonthStrings.en[8]=e[7];a._shortMonthStrings.en[9]=e[8];a._shortMonthStrings.en[10]=e[9];a._shortMonthStrings.en[11]=e[10];a._shortMonthStrings.en[12]=e[11]}var d=sap.common.globalization.GlobalizationDateConstant.getAmPmToken();if(d){a._AmPms.en[1]=d[0];a._AmPms.en[2]=d[1]}}};a._resetAllStaticVars=function(){a._DayStrings=null;a._shortDayStrings=null;a._MonthStrings=null;a._shortMonthStrings=null;a._DateTimeCodes=null;a._NumericStrings=null;a._DateTimeStrings=null;a._CurrencySymbol=null;a._SAPCurrencySymbol=null;a._SAPDateString=null;a._SAPTimeString=null;a._SAPThousandsSeparator=null;a._SAPDecimalSeparator=null;a._SAPLongDay=null;a._SAPShortDay=null;a._SAPLongMonth=null;a._SAPShortMonth=null;a._AmPms=null}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.BaseUtils");var b=sap.common.globalization.utils.BaseUtils;var a=0;sap.common.globalization.utils.BaseUtils.genUID=function(){if(!a){a=0}return"xgen_"+(a++)};var c={"[object Boolean]":"boolean","[object Number]":"number","[object String]":"string","[object Function]":"function","[object Array]":"array","[object Date]":"date","[object RegExp]":"regexp","[object Object]":"object"};sap.common.globalization.utils.BaseUtils.applyProperties=function(g,f){if(f!=null){var d=f.length;for(var e=0;e<d;e++){var h=f[e];if(h&&h!=null){this.applyObjectProperty(g,h.name,h.value)}}}};sap.common.globalization.utils.BaseUtils.applyObjectProperty=function(g,f,d){try{if(b.isFunction(g[f])){g[f](d)}else{if(g.hasOwnProperty(f)){g[f]=d}}}catch(h){if(console){console.log(h)}}};sap.common.globalization.utils.BaseUtils.getObjectProperty=function(f,d){try{if(b.isFunction(f[d])){return f[d]()}else{if(f.hasOwnProperty(d)){return f[d]}}}catch(g){if(console){console.log(g)}}};sap.common.globalization.utils.BaseUtils.type=function(d){return d==null?String(d):c[Object.prototype.toString.call(d)]||"object"};sap.common.globalization.utils.BaseUtils.isFunction=function(d){return b.type(d)==="function"};sap.common.globalization.utils.BaseUtils.isBoolean=function(d){return b.type(d)==="boolean"};sap.common.globalization.utils.BaseUtils.isString=function(d){return b.type(d)==="string"};sap.common.globalization.utils.BaseUtils.isArray=function(d){return b.type(d)==="array"};sap.common.globalization.utils.BaseUtils.isNumber=function(d){return b.type(d)==="number"};sap.common.globalization.utils.BaseUtils.isRegExp=function(d){return b.type(d)==="regexp"};sap.common.globalization.utils.BaseUtils.sortArrayOn=function(d,f,e){if(b.isArray(d)&&b.isString(f)){d.sort(function(h,g){return e?(h[f]<g[f])-(h[f]>g[f]):(h[f]>g[f])-(h[f]<g[f])})}}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.UnitAbbreviations");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.utils.UnitAbbreviations=function(){this.__className="sap.common.globalization.utils.UnitAbbreviations";this.thousands="K";this.millions="M";this.billions="B";this.trillions="T"};sap.common.globalization.utils.UnitAbbreviations.prototype.toObject=function(){return{thousands:this.thousands,millions:this.millions,billions:this.billions,trillions:this.trillions}};sap.common.globalization.utils.UnitAbbreviations.prototype.copyFromObject=function(a){if(!a){a={thousands:"K",millions:"M",billions:"B",trillions:"T"}}var b=false;for(attr in ["thousands","millions","billions","trillions"]){if(sap.common.globalization.utils.BaseUtils.isString(a[attr])&&a[attr]!=this[attr]){this[attr]=a[attr];b=true}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.BooleanUtil");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.utils.BooleanUtil.isBooleanValue=function(a){if(sap.common.globalization.utils.BaseUtils.isBoolean(a)){return true}else{if(sap.common.globalization.utils.BaseUtils.isString(a)){return String(a).toLowerCase()=="true"||String(a).toLowerCase()=="false"}else{return false}}}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.ColorUtil");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.utils.ColorUtil.convertToHexString=function(c){if(c==null||!sap.common.globalization.utils.BaseUtils.isNumber(c)||isNaN(c)){return null}var h="#",b=["r","g","b"],d=sap.common.globalization.utils.ColorUtil.convertToRGBObject(c);for(var f=0,a=b.length;f<a;f++){var g=b[f],e=d[g].toString(16);if(e.length==1){h+="0"}h+=e}return h};sap.common.globalization.utils.ColorUtil.convertToRGBObject=function(a){if(a==null||!sap.common.globalization.utils.BaseUtils.isNumber(a)||isNaN(a)){return null}return{r:(a&16711680)>>16,g:(a&65280)>>8,b:a&255}}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.DataFormatUtils");sap.common.globalization.require("sap.common.globalization.utils.ColorUtil");sap.common.globalization.utils.DataFormatUtils.decorateColorHTML=function(b,a){if(!isNaN(a)){return'<FONT COLOR="'+sap.common.globalization.utils.ColorUtil.convertToHexString(a)+'"/>'+b+"</FONT>"}return b};sap.common.globalization.utils.DataFormatUtils.DataFormatUtils=function(){throw new Error("Should not initialize DataFormatUtils.")}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.NumberUtil");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.require("sap.common.globalization.utils.UnitAbbreviations");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");sap.common.globalization.utils.NumberUtil.checkEquality=function(d,c,a){a=a||-5;if(d==c){return true}var b=Math.pow(10,a-1);var e=d-c;return e<b&&e>-b};sap.common.globalization.utils.NumberUtil.lessThanEqual=function(b,c,a){a=a||-5;return((b<c)||sap.common.globalization.utils.NumberUtil.checkEquality(b,c,a))};sap.common.globalization.utils.NumberUtil.greaterThanEqual=function(b,c,a){a=a||-5;return((b>c)||sap.common.globalization.utils.NumberUtil.checkEquality(b,c,a))};sap.common.globalization.utils.NumberUtil.getPrecision=function(d){var c=String(d);var e=c.length;var b=c.indexOf(".");var a=e-(b+1);return a};sap.common.globalization.utils.NumberUtil.roundToPrecision=function(e,c){var f=e.toString(10);var d=f.split(".");var a=(d&&d.length>1?d[1].length:0);if(a<=c){return e}var b=Math.pow(10,c);return Math.round(e*b)/b};sap.common.globalization.utils.NumberUtil.roundToNearest=function(b,a,c){a=a||1;c=c||0;return Math.round((b+c)/a)*a-c};sap.common.globalization.utils.NumberUtil.abbreviate=function(f,g,c){var h=1000;var d=1000000;var b=1000000000;var a=1000000000000;g=g||null;c=c||1;if(!g){g=new sap.common.globalization.utils.UnitAbbreviations()}var i="";var e=Math.abs(f);if(e>=a){f/=a;i=g.trillions}else{if(e>=b){f/=b;i=g.billions}else{if(e>=d){f/=d;i=g.millions}else{if(e>=h){f/=h;i=g.thousands}}}}f=sap.common.globalization.utils.NumberUtil.roundToPrecision(f,c);return String(f)+i};sap.common.globalization.utils.NumberUtil.parseNumber=function(c,b){var a=b;if(c!=null){var d=Number(c);if(isNaN(d)==false){a=d}}return a};sap.common.globalization.utils.NumberUtil.isNumericValue=function(a){if(sap.common.globalization.utils.BaseUtils.isNumber(a)&&!isNaN(a)){return true}else{if(sap.common.globalization.utils.BaseUtils.isString(a)){return sap.common.globalization.utils.StringUtil.isNumber(String(a))}else{return false}}}})();(function(){sap.common.globalization.declare("sap.common.globalization.utils.StringUtil");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.utils.StringUtil.escapeEntities=function(a){if(a){a=a.split("&").join("&amp;");a=a.split("<").join("&lt;");a=a.split(">").join("&gt;");a=a.split('"').join("&quot;");a=a.split("'").join("&apos;")}return a};sap.common.globalization.utils.StringUtil.trim=function(a){return a.replace(/^\s*/,"").replace(/\s*$/,"")};sap.common.globalization.utils.StringUtil.isBlankString=function(a){if(a==null||!(sap.common.globalization.utils.BaseUtils.isString(a))){return false}return sap.common.globalization.utils.StringUtil.trim(a)===""};sap.common.globalization.utils.StringUtil.isNumber=function(a){if(isNaN(Number(a))){return false}else{if(sap.common.globalization.utils.StringUtil.isBlankString(a)){return false}else{return true}}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.numericFormat.");sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory=function(){this.__className="sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory";this._parseLocaleInfo=null;this._displayLocaleInfo=null};var a=sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory;a.prototype.getDateParseLocaleInfo=function(){if(!this._parseLocaleInfo){this._parseLocaleInfo=this.getPredefinedDateParseLocaleString()}return this._parseLocaleInfo};a.prototype.getDateDisplayLocaleInfo=function(){if(!this._displayLocaleInfo){this._displayLocaleInfo=this.getPredefinedDateDisplayLocaleString();this.applySAPDateTokensAndSeparators(this._displayLocaleInfo)}return this._displayLocaleInfo};a.prototype.getDefaultDateFormat=function(){return sap.common.globalization.GlobalizationDateConstant.getDefaultLongDateFormat()};a.prototype.createFDate=function(){return new sap.common.globalization.numericFormat.FDefaultDate(this.getDateParseLocaleInfo(),this.getDateDisplayLocaleInfo())};a.prototype.getPredefinedDateParseLocaleString=function(){return new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl()};a.prototype.getPredefinedDateDisplayLocaleString=function(){var e=new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();var f=sap.common.globalization.GlobalizationDateConstant.getLongDay();if(f){e.IMSDAYNAME1(f[1]);e.IMSDAYNAME2(f[2]);e.IMSDAYNAME3(f[3]);e.IMSDAYNAME4(f[4]);e.IMSDAYNAME5(f[5]);e.IMSDAYNAME6(f[6]);e.IMSDAYNAME7(f[0])}var c=sap.common.globalization.GlobalizationDateConstant.getShortDay();if(c){e.IMSABBREVDAYNAME1(c[1]);e.IMSABBREVDAYNAME2(c[2]);e.IMSABBREVDAYNAME3(c[3]);e.IMSABBREVDAYNAME4(c[4]);e.IMSABBREVDAYNAME5(c[5]);e.IMSABBREVDAYNAME6(c[6]);e.IMSABBREVDAYNAME7(c[0])}var g=sap.common.globalization.GlobalizationDateConstant.getLongMonth();if(g){e.IMSMONTHNAME1(g[0]);e.IMSMONTHNAME2(g[1]);e.IMSMONTHNAME3(g[2]);e.IMSMONTHNAME4(g[3]);e.IMSMONTHNAME5(g[4]);e.IMSMONTHNAME6(g[5]);e.IMSMONTHNAME7(g[6]);e.IMSMONTHNAME8(g[7]);e.IMSMONTHNAME9(g[8]);e.IMSMONTHNAME10(g[9]);e.IMSMONTHNAME11(g[10]);e.IMSMONTHNAME12(g[11])}var d=sap.common.globalization.GlobalizationDateConstant.getShortMonth();if(d){e.IMSABBREVMONTHNAME1(d[0]);e.IMSABBREVMONTHNAME2(d[1]);e.IMSABBREVMONTHNAME3(d[2]);e.IMSABBREVMONTHNAME4(d[3]);e.IMSABBREVMONTHNAME5(d[4]);e.IMSABBREVMONTHNAME6(d[5]);e.IMSABBREVMONTHNAME7(d[6]);e.IMSABBREVMONTHNAME8(d[7]);e.IMSABBREVMONTHNAME9(d[8]);e.IMSABBREVMONTHNAME10(d[9]);e.IMSABBREVMONTHNAME11(d[10]);e.IMSABBREVMONTHNAME12(d[11])}var b=sap.common.globalization.GlobalizationDateConstant.getAbbrevEraString();if(b&&b[1]){e.IMEraToken(b[1])}return e};a.prototype.applySAPDateTokensAndSeparators=function(c){var b=sap.common.globalization.numericFormat.FLocalization.getInstance();if(b.SAPShortDay){c.IMSABBREVDAYNAME1(b.SAPShortDay[0]);c.IMSABBREVDAYNAME2(b.SAPShortDay[1]);c.IMSABBREVDAYNAME3(b.SAPShortDay[2]);c.IMSABBREVDAYNAME4(b.SAPShortDay[3]);c.IMSABBREVDAYNAME5(b.SAPShortDay[4]);c.IMSABBREVDAYNAME6(b.SAPShortDay[5]);c.IMSABBREVDAYNAME7(b.SAPShortDay[6])}if(b.SAPLongDay){c.IMSDAYNAME1(b.SAPLongDay[0]);c.IMSDAYNAME2(b.SAPLongDay[1]);c.IMSDAYNAME3(b.SAPLongDay[2]);c.IMSDAYNAME4(b.SAPLongDay[3]);c.IMSDAYNAME5(b.SAPLongDay[4]);c.IMSDAYNAME6(b.SAPLongDay[5]);c.IMSDAYNAME7(b.SAPLongDay[6])}if(b.SAPShortMonth){c.IMSABBREVMONTHNAME1(b.SAPShortMonth[0]);c.IMSABBREVMONTHNAME2(b.SAPShortMonth[1]);c.IMSABBREVMONTHNAME3(b.SAPShortMonth[2]);c.IMSABBREVMONTHNAME4(b.SAPShortMonth[3]);c.IMSABBREVMONTHNAME5(b.SAPShortMonth[4]);c.IMSABBREVMONTHNAME6(b.SAPShortMonth[5]);c.IMSABBREVMONTHNAME7(b.SAPShortMonth[6]);c.IMSABBREVMONTHNAME8(b.SAPShortMonth[7]);c.IMSABBREVMONTHNAME9(b.SAPShortMonth[8]);c.IMSABBREVMONTHNAME10(b.SAPShortMonth[9]);c.IMSABBREVMONTHNAME11(b.SAPShortMonth[10]);c.IMSABBREVMONTHNAME12(b.SAPShortMonth[11])}if(b.SAPLongMonth){c.IMSMONTHNAME1(b.SAPLongMonth[0]);c.IMSMONTHNAME2(b.SAPLongMonth[1]);c.IMSMONTHNAME3(b.SAPLongMonth[2]);c.IMSMONTHNAME4(b.SAPLongMonth[3]);c.IMSMONTHNAME5(b.SAPLongMonth[4]);c.IMSMONTHNAME6(b.SAPLongMonth[5]);c.IMSMONTHNAME7(b.SAPLongMonth[6]);c.IMSMONTHNAME8(b.SAPLongMonth[7]);c.IMSMONTHNAME9(b.SAPLongMonth[8]);c.IMSMONTHNAME10(b.SAPLongMonth[9]);c.IMSMONTHNAME11(b.SAPLongMonth[10]);c.IMSMONTHNAME12(b.SAPLongMonth[11])}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");var a=sap.common.globalization.defaultFormat;a.DefaultDateTimeFormatLocaleFactory=function(){a.DefaultDateTimeFormatLocaleFactory.superclass.constructor.apply(this);this.__className="sap.common.globalization.defaultFormat.DefaultDateTimeFormatLocaleFactory"};a.DefaultDateTimeFormatLocaleFactory=sap.common.globalization.extend(a.DefaultDateTimeFormatLocaleFactory,a.DefaultDateFormatLocaleFactory);a.DefaultDateTimeFormatLocaleFactory.prototype.getDefaultDateFormat=function(){return sap.common.globalization.GlobalizationDateConstant.getDefaultDateTimeFormat()};a.DefaultDateTimeFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators=function(c){a.DefaultDateTimeFormatLocaleFactory.superclass.applySAPDateTokensAndSeparators(c);var b=sap.common.globalization.numericFormat.FLocalization.getInstance();if(c&&b&&b.SAPTimeSeparator){c.IMTimeSeparator(b.SAPTimeSeparator)}};a.DefaultDateTimeFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString=function(){var c=a.DefaultDateTimeFormatLocaleFactory.superclass.getPredefinedDateParseLocaleString();var b=sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();if(b&&c){c.IMTimeSeparator(b)}return c};a.DefaultDateTimeFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString=function(){var d=a.DefaultDateTimeFormatLocaleFactory.superclass.getPredefinedDateDisplayLocaleString();var b=sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();if(b&&d){d.IMTimeSeparator(b)}var c=sap.common.globalization.GlobalizationDateConstant.getAmPmToken();if(c&&d){d.IMAMTOKEN(c[0]);d.IMPMTOKEN(c[1])}return d}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");var a=sap.common.globalization.defaultFormat;a.DefaultShortDateFormatLocaleFactory=function(){a.DefaultShortDateFormatLocaleFactory.superclass.constructor.apply(this);this.__className="sap.common.globalization.defaultFormat.DefaultShortDateFormatLocaleFactory"};a.DefaultShortDateFormatLocaleFactory=sap.common.globalization.extend(a.DefaultShortDateFormatLocaleFactory,a.DefaultDateFormatLocaleFactory);a.DefaultShortDateFormatLocaleFactory.prototype.getDefaultDateFormat=function(){return sap.common.globalization.GlobalizationDateConstant.getDefaultShorDateFormat()};a.DefaultShortDateFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators=function(c){a.DefaultShortDateFormatLocaleFactory.superclass.applySAPDateTokensAndSeparators(c);var b=sap.common.globalization.numericFormat.FLocalization.getInstance();if(c&&b&&b.SAPDateSeparator){c.IMDateSeparator(b.SAPDateSeparator)}};a.DefaultShortDateFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString=function(){var b=a.DefaultShortDateFormatLocaleFactory.superclass.getPredefinedDateParseLocaleString();var c=sap.common.globalization.GlobalizationDateConstant.getDateSeparator();if(c&&b){b.IMDateSeparator(c)}return b};a.DefaultShortDateFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString=function(){var b=a.DefaultShortDateFormatLocaleFactory.superclass.getPredefinedDateDisplayLocaleString();var c=sap.common.globalization.GlobalizationDateConstant.getDateSeparator();if(c&&b){b.IMDateSeparator(c)}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo=function(){this.__className="sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo";this._trueString="";this._falseString=""};sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo.prototype.trueString=function(a){if(arguments.length>=1){this._trueString=a;return this}else{return this._trueString}};sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo.prototype.falseString=function(a){if(arguments.length>=1){this._falseString=a;return this}else{return this._falseString}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationPreference");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateForPVL");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");var a=sap.common.globalization.defaultFormat;a.CustomDateFormatLocaleFactory=function(){this.__className="sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory";this._dateParseLocaleInfo=null;this._dateDisplayLocaleInfo=null};a.CustomDateFormatLocaleFactory._instance=null;a.CustomDateFormatLocaleFactory.getInstance=function(){if(!a.CustomDateFormatLocaleFactory._instance){a.CustomDateFormatLocaleFactory._instance=new a.CustomDateFormatLocaleFactory()}return a.CustomDateFormatLocaleFactory._instance};a.CustomDateFormatLocaleFactory.prototype.getDateParseLocaleInfo=function(){return sap.common.globalization.numericFormat.FLocalization.getInstance().getDateParseLocaleInfo()};a.CustomDateFormatLocaleFactory.prototype.getDateDisplayLocaleInfo=function(){return sap.common.globalization.numericFormat.FLocalization.getInstance().getDateDisplayLocaleInfo()};a.CustomDateFormatLocaleFactory.prototype.createFDate=function(){var b=sap.common.globalization.GlobalizationPreference.getInstance().pvl()&&!sap.common.globalization.utils.StringUtil.isBlankString(sap.common.globalization.GlobalizationPreference.getInstance().pvl());if(b){return new sap.common.globalization.numericFormat.FDateForPVL(this.getDateParseLocaleInfo(),this.getDateDisplayLocaleInfo())}else{return new sap.common.globalization.numericFormat.FDate(null,this.getDateDisplayLocaleInfo())}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory=function(){this.__className="sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory"};var a=sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory;a._instance=null;a.getInstance=function(){if(!a._instance){a._instance=new sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory()}return a._instance};a.prototype.getNumericParseLocaleInfo=function(){return sap.common.globalization.numericFormat.FLocalization.getInstance().numericParseLocaleInfo()};a.prototype.getNumericDisplayLocaleInfo=function(){return sap.common.globalization.numericFormat.FLocalization.getInstance().numericDisplayLocaleInfo()};a.prototype.createFNumber=function(){return new sap.common.globalization.numericFormat.FNumber(this.getNumericParseLocaleInfo(),this.getNumericDisplayLocaleInfo())}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl=function(){this.__className="sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl";this._IMDateSeparator=null;this._IMSMONTHNAME1=null;this._IMSMONTHNAME2=null;this._IMSMONTHNAME3=null;this._IMSMONTHNAME4=null;this._IMSMONTHNAME5=null;this._IMSMONTHNAME6=null;this._IMSMONTHNAME7=null;this._IMSMONTHNAME8=null;this._IMSMONTHNAME9=null;this._IMSMONTHNAME10=null;this._IMSMONTHNAME11=null;this._IMSMONTHNAME12=null;this._IMSABBREVMONTHNAME1=null;this._IMSABBREVMONTHNAME2=null;this._IMSABBREVMONTHNAME3=null;this._IMSABBREVMONTHNAME4=null;this._IMSABBREVMONTHNAME5=null;this._IMSABBREVMONTHNAME6=null;this._IMSABBREVMONTHNAME7=null;this._IMSABBREVMONTHNAME8=null;this._IMSABBREVMONTHNAME9=null;this._IMSABBREVMONTHNAME10=null;this._IMSABBREVMONTHNAME11=null;this._IMSABBREVMONTHNAME12=null;this._IMSDAYNAME1=null;this._IMSDAYNAME2=null;this._IMSDAYNAME3=null;this._IMSDAYNAME4=null;this._IMSDAYNAME5=null;this._IMSDAYNAME6=null;this._IMSDAYNAME7=null;this._IMSABBREVDAYNAME1=null;this._IMSABBREVDAYNAME2=null;this._IMSABBREVDAYNAME3=null;this._IMSABBREVDAYNAME4=null;this._IMSABBREVDAYNAME5=null;this._IMSABBREVDAYNAME6=null;this._IMSABBREVDAYNAME7=null;this._IMTimeSeparator=null;this._IMAMToken=null;this._IMPMToken=null;this._IMEraToken=null};var a=sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl;a.prototype.IMDateSeparator=function(b){if(arguments.length>=1){this._IMDateSeparator=b}else{return this._IMDateSeparator}};a.prototype.IMSMONTHNAME1=function(b){if(arguments.length>=1){this._IMSMONTHNAME1=b}else{return this._IMSMONTHNAME1}};a.prototype.IMSMONTHNAME2=function(b){if(arguments.length>=1){this._IMSMONTHNAME2=b}else{return this._IMSMONTHNAME2}};a.prototype.IMSMONTHNAME3=function(b){if(arguments.length>=1){this._IMSMONTHNAME3=b}else{return this._IMSMONTHNAME3}};a.prototype.IMSMONTHNAME4=function(b){if(arguments.length>=1){this._IMSMONTHNAME4=b}else{return this._IMSMONTHNAME4}};a.prototype.IMSMONTHNAME5=function(b){if(arguments.length>=1){this._IMSMONTHNAME5=b}else{return this._IMSMONTHNAME5}};a.prototype.IMSMONTHNAME6=function(b){if(arguments.length>=1){this._IMSMONTHNAME6=b}else{return this._IMSMONTHNAME6}};a.prototype.IMSMONTHNAME7=function(b){if(arguments.length>=1){this._IMSMONTHNAME7=b}else{return this._IMSMONTHNAME7}};a.prototype.IMSMONTHNAME8=function(b){if(arguments.length>=1){this._IMSMONTHNAME8=b}else{return this._IMSMONTHNAME8}};a.prototype.IMSMONTHNAME9=function(b){if(arguments.length>=1){this._IMSMONTHNAME9=b}else{return this._IMSMONTHNAME9}};a.prototype.IMSMONTHNAME10=function(b){if(arguments.length>=1){this._IMSMONTHNAME10=b}else{return this._IMSMONTHNAME10}};a.prototype.IMSMONTHNAME11=function(b){if(arguments.length>=1){this._IMSMONTHNAME11=b}else{return this._IMSMONTHNAME11}};a.prototype.IMSMONTHNAME12=function(b){if(arguments.length>=1){this._IMSMONTHNAME12=b}else{return this._IMSMONTHNAME12}};a.prototype.IMSABBREVMONTHNAME1=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME1=b}else{return this._IMSABBREVMONTHNAME1}};a.prototype.IMSABBREVMONTHNAME2=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME2=b}else{return this._IMSABBREVMONTHNAME2}};a.prototype.IMSABBREVMONTHNAME3=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME3=b}else{return this._IMSABBREVMONTHNAME3}};a.prototype.IMSABBREVMONTHNAME4=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME4=b}else{return this._IMSABBREVMONTHNAME4}};a.prototype.IMSABBREVMONTHNAME5=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME5=b}else{return this._IMSABBREVMONTHNAME5}};a.prototype.IMSABBREVMONTHNAME6=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME6=b}else{return this._IMSABBREVMONTHNAME6}};a.prototype.IMSABBREVMONTHNAME7=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME7=b}else{return this._IMSABBREVMONTHNAME7}};a.prototype.IMSABBREVMONTHNAME8=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME8=b}else{return this._IMSABBREVMONTHNAME8}};a.prototype.IMSABBREVMONTHNAME9=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME9=b}else{return this._IMSABBREVMONTHNAME9}};a.prototype.IMSABBREVMONTHNAME10=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME10=b}else{return this._IMSABBREVMONTHNAME10}};a.prototype.IMSABBREVMONTHNAME11=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME11=b}else{return this._IMSABBREVMONTHNAME11}};a.prototype.IMSABBREVMONTHNAME12=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME12=b}else{return this._IMSABBREVMONTHNAME12}};a.prototype.IMSDAYNAME1=function(b){if(arguments.length>=1){this._IMSDAYNAME1=b}else{return this._IMSDAYNAME1}};a.prototype.IMSDAYNAME2=function(b){if(arguments.length>=1){this._IMSDAYNAME2=b}else{return this._IMSDAYNAME2}};a.prototype.IMSDAYNAME3=function(b){if(arguments.length>=1){this._IMSDAYNAME3=b}else{return this._IMSDAYNAME3}};a.prototype.IMSDAYNAME4=function(b){if(arguments.length>=1){this._IMSDAYNAME4=b}else{return this._IMSDAYNAME4}};a.prototype.IMSDAYNAME5=function(b){if(arguments.length>=1){this._IMSDAYNAME5=b}else{return this._IMSDAYNAME5}};a.prototype.IMSDAYNAME6=function(b){if(arguments.length>=1){this._IMSDAYNAME6=b}else{return this._IMSDAYNAME6}};a.prototype.IMSDAYNAME7=function(b){if(arguments.length>=1){this._IMSDAYNAME7=b}else{return this._IMSDAYNAME7}};a.prototype.IMSABBREVDAYNAME1=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME1=b}else{return this._IMSABBREVDAYNAME1}};a.prototype.IMSABBREVDAYNAME2=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME2=b}else{return this._IMSABBREVDAYNAME2}};a.prototype.IMSABBREVDAYNAME3=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME3=b}else{return this._IMSABBREVDAYNAME3}};a.prototype.IMSABBREVDAYNAME4=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME4=b}else{return this._IMSABBREVDAYNAME4}};a.prototype.IMSABBREVDAYNAME5=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME5=b}else{return this._IMSABBREVDAYNAME5}};a.prototype.IMSABBREVDAYNAME6=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME6=b}else{return this._IMSABBREVDAYNAME6}};a.prototype.IMSABBREVDAYNAME7=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME7=b}else{return this._IMSABBREVDAYNAME7}};a.prototype.IMTimeSeparator=function(b){if(arguments.length>=1){this._IMTimeSeparator=b}else{return this._IMTimeSeparator}};a.prototype.IMAMTOKEN=function(b){if(arguments.length>=1){this._IMAMToken=b}else{return this._IMAMToken}};a.prototype.IMPMTOKEN=function(b){if(arguments.length>=1){this._IMPMToken=b}else{return this._IMPMToken}};a.prototype.IMEraToken=function(b){if(arguments.length>=1){this._IMEraToken=b}else{return this._IMEraToken}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl=function(){this.__className="sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl";this._IMDateSeparator=null;this._IMTimeSeparator=null};sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl.prototype.IMDateSeparator=function(a){if(arguments.length>=1){this._IMDateSeparator=a}else{return this._IMDateSeparator}};sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl.prototype.IMTimeSeparator=function(a){if(arguments.length>=1){this._IMTimeSeparator=a}else{return this._IMTimeSeparator}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");sap.common.globalization.require("sap.common.globalization.GlobalizationBooleanConstant");sap.common.globalization.require("sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo");sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory=function(){this.className="sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory";this._displayLocale=null};var a=sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory;a._instance=null;a.getInstance=function(){if(!a._instance){a._instance=new sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory()}return a._instance};a.prototype.getBooleanDisplayLocaleInfo=function(){if(!this._displayLocale){this._displayLocale=new sap.common.globalization.defaultFormat.BooleanDisplayLocaleInfo();var b=sap.common.globalization.GlobalizationBooleanConstant.getBooleanStrings();if(b){this._displayLocale.trueString(b[0]);this._displayLocale.falseString(b[1])}}return this._displayLocale}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.require("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultNumber");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericUtil");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory=function(){this.__className="sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory.DefaultNumericFormatLocaleFactory";this._numericParseLocaleInfo=null;this._numericDisplayLocaleInfo=null};var a=sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory;a.prototype.getNumericParseLocaleInfo=function(){var b=sap.common.globalization;if(!this._numericParseLocaleInfo){this._numericParseLocaleInfo=new b.defaultFormat.NumericParseLocaleInfoImpl(b.GlobalizationNumericConstant.getParseThousandSeparator(),b.GlobalizationNumericConstant.getParseDecimalSeparator(),b.GlobalizationNumericConstant.getParseCurrencySymbol())}return this._numericParseLocaleInfo};a.prototype.getNumericDisplayLocaleInfo=function(){if(!this._numericDisplayLocaleInfo){var e=",";var d=".";var b=sap.common.globalization;if(b.numericFormat.FLocalization.getInstance().SAPThousandsSeparator){e=b.numericFormat.FLocalization.getInstance().SAPThousandsSeparator}else{if(b.GlobalizationNumericConstant.getDisplayThousandSeparator()){e=b.GlobalizationNumericConstant.getDisplayThousandSeparator()}}if(b.numericFormat.FLocalization.getInstance().SAPDecimalSeparator){d=b.numericFormat.FLocalization.getInstance().SAPDecimalSeparator}else{if(b.GlobalizationNumericConstant.getDisplayDecimalSeparator()){d=b.GlobalizationNumericConstant.getDisplayDecimalSeparator()}}var c=(b.numericFormat.FLocalization.getInstance().SAPCurrencySymbol?b.numericFormat.FLocalization.getInstance().SAPCurrencySymbol:this.displayCurrencySymbol());this._numericDisplayLocaleInfo=new b.defaultFormat.NumericDisplayLocaleInfoImpl(e,d,c)}return this._numericDisplayLocaleInfo};a.prototype.createFNumber=function(){var b=new sap.common.globalization.numericFormat.FDefaultNumber(this.getNumericParseLocaleInfo(),this.getNumericDisplayLocaleInfo());if(sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry(sap.common.globalization.GlobalizationNumericConstant.getActualLocaleForDefaultNumberFormat())){b.groupingStrategy=sap.common.globalization.numericFormat.TwoDigitGroupingStrategy.instance()}return b};a.prototype.getDefaultNumericFormat=function(){if(sap.common.globalization.GlobalizationNumericConstant.getDefaultNumberFormat()){return sap.common.globalization.GlobalizationNumericConstant.getDefaultNumberFormat()}return"#,##0.###"};a.prototype.displayCurrencySymbol=function(){return""}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationDateConstant");sap.common.globalization.require("sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");var a=sap.common.globalization.defaultFormat;a.DefaultTimeFormatLocaleFactory=function(){a.DefaultTimeFormatLocaleFactory.superclass.constructor.apply(this);this.__className="sap.common.globalization.defaultFormat.DefaultTimeFormatLocaleFactory"};a.DefaultTimeFormatLocaleFactory=sap.common.globalization.extend(a.DefaultTimeFormatLocaleFactory,a.DefaultDateFormatLocaleFactory);a.DefaultTimeFormatLocaleFactory.prototype.getDefaultDateFormat=function(){return sap.common.globalization.GlobalizationDateConstant.getDefaultTimeFormat()};a.DefaultTimeFormatLocaleFactory.prototype.applySAPDateTokensAndSeparators=function(c){var b=sap.common.globalization.numericFormat.FLocalization.getInstance();if(c&&b&&b.SAPTimeSeparator){c.IMTimeSeparator(b.SAPTimeSeparator)}};a.DefaultTimeFormatLocaleFactory.prototype.getPredefinedDateParseLocaleString=function(){var c=new sap.common.globalization.defaultFormat.DateParseLocaleInfoImpl();var b=sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();if(b&&c){c.IMTimeSeparator(b)}return c};a.DefaultTimeFormatLocaleFactory.prototype.getPredefinedDateDisplayLocaleString=function(){var d=new sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl();var b=sap.common.globalization.GlobalizationDateConstant.getTimeSeparator();if(b&&d){d.IMTimeSeparator(b)}var c=sap.common.globalization.GlobalizationDateConstant.getAmPmToken();if(c&&d){d.IMAMTOKEN(c[0]);d.IMPMTOKEN(c[1])}return d}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl");sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl=function(a,b,c){if(a){this._thousandsSeparator=a}else{this._thousandsSeparator=","}if(b){this._decimalSeparator=b}else{this._decimalSeparator="."}if(c){this._currencySymbol=c}else{this._currencySymbol=""}};sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.thousandsSeparator=function(){return this._thousandsSeparator};sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.decimalSeparator=function(){return this._decimalSeparator};sap.common.globalization.defaultFormat.NumericDisplayLocaleInfoImpl.prototype.currencySymbol=function(){return this._currencySymbol}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl");sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl=function(a,b,c){if(a){this._thousandsSeparator=a}else{this._thousandsSeparator=","}if(b){this._decimalSeparator=b}else{this._decimalSeparator="."}if(c){this._currencySymbol=c}else{this._currencySymbol=""}};sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.thousandsSeparator=function(){return this._thousandsSeparator};sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.decimalSeparator=function(){return this._decimalSeparator};sap.common.globalization.defaultFormat.NumericParseLocaleInfoImpl.prototype.currencySymbol=function(){return this._currencySymbol}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateA");var a=sap.common.globalization.numericFormat;a.FDateA=function(b){this.__className="sap.common.globalization.numericFormat.FDateA";this._full=true;this._displayLocale=b};a.FDateA.prototype.parse=function(e,d){var c=0;var b=d.toLowerCase();if(b.substr(0,5)=="am/pm"){e.miltime=false;c=5}if(b.substr(0,3)=="a/p"){e.miltime=false;this._full=false;c=3}return c};a.FDateA.prototype.display=function(c){var b="";if(c.getHrs()>=12){if(this._full){b=this._displayLocale.IMPMTOKEN()?this._displayLocale.IMPMTOKEN():"PM"}else{b=this._displayLocale.IMPMTOKEN()?this._displayLocale.IMPMTOKEN():"P"}}else{if(this._full){b=this._displayLocale.IMAMTOKEN()?this._displayLocale.IMAMTOKEN():"AM"}else{b=this._displayLocale.IMAMTOKEN()?this._displayLocale.IMAMTOKEN():"A"}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateB");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");var a=sap.common.globalization.numericFormat;a.FDateB=function(b){this.__className="sap.common.globalization.numericFormat.FDateB";this._displayLocaleInfo=b;this.mask=undefined;this.c="";this._tok={};this.initializeTokenMap()};a.FDateB.prototype.parse=function(f,e){var c=2;this.c=e.charAt(1);var d=this.createTokenFormatter(this._tok[this.c]);if(this.c=="M"||this.c=="m"){d.bminute=true}var b=d.parse(f,e.substring(1));if(b>0){this.mask=d;c+=b}return c};a.FDateB.prototype.display=function(c){var b;if(this.c=="S"||this.c=="s"){b=86400*c.serial}else{if(this.c=="M"||this.c=="m"){b=1440*c.serial}else{if(this.c=="H"||this.c=="h"){b=24*c.serial}}}this.mask.value=Math.floor(b);return this.mask.display(c)};a.FDateB.prototype.createTokenFormatter=function(b){var c=null;switch(b){case a.FDateM:c=new a.FDateM(this._displayLocaleInfo);break;case a.FDateH:c=new a.FDateH();break;case a.FDateS:c=new a.FDateS();break;default:}return c};a.FDateB.prototype.initializeTokenMap=function(){this._tok.M=a.FDateM;this._tok.H=a.FDateH;this._tok.S=a.FDateS;this._tok.m=a.FDateM;this._tok.h=a.FDateH;this._tok.s=a.FDateS}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateD");var a=sap.common.globalization.numericFormat;a.FDateD=function(b){this.__className="sap.common.globalization.numericFormat.FDateD";this._placeholders=0;this._displayLocaleInfo=b};a.FDateD.prototype.getPlaceholders=function(){return this._placeholders};a.FDateD.prototype.parse=function(d,c){var b=0;while(c.charAt(b)=="D"||c.charAt(b)=="d"){b++}if(b<=2){this._placeholders=b}else{if(b==3){this._placeholders=-1}else{if(b>=4){this._placeholders=-2}}}return b};a.FDateD.prototype.display=function(d){var c="";if(this._placeholders>=0){c+=d.getDate();while(c.length<this._placeholders){c="0"+c}}else{var b=d.getDay();if(this._placeholders==-1){c+=this.getShortDay(b)}else{c+=this.getDay(b)}}return c};a.FDateD.prototype.getDay=function(b){if(b==0){return this._displayLocaleInfo.IMSDAYNAME7()}if(b==1){return this._displayLocaleInfo.IMSDAYNAME1()}if(b==2){return this._displayLocaleInfo.IMSDAYNAME2()}if(b==3){return this._displayLocaleInfo.IMSDAYNAME3()}if(b==4){return this._displayLocaleInfo.IMSDAYNAME4()}if(b==5){return this._displayLocaleInfo.IMSDAYNAME5()}if(b==6||b==-1){return this._displayLocaleInfo.IMSDAYNAME6()}return this._displayLocaleInfo.IMSDAYNAME6()};a.FDateD.prototype.getShortDay=function(b){if(b==0){return this._displayLocaleInfo.IMSABBREVDAYNAME7().split(".")[0]}if(b==1){return this._displayLocaleInfo.IMSABBREVDAYNAME1().split(".")[0]}if(b==2){return this._displayLocaleInfo.IMSABBREVDAYNAME2().split(".")[0]}if(b==3){return this._displayLocaleInfo.IMSABBREVDAYNAME3().split(".")[0]}if(b==4){return this._displayLocaleInfo.IMSABBREVDAYNAME4().split(".")[0]}if(b==5){return this._displayLocaleInfo.IMSABBREVDAYNAME5().split(".")[0]}if(b==6||b==-1){return this._displayLocaleInfo.IMSABBREVDAYNAME6().split(".")[0]}return this._displayLocaleInfo.IMSABBREVDAYNAME6().split(".")[0]}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateH");var a=sap.common.globalization.numericFormat;a.FDateH=function(){this.__className="sap.common.globalization.numericFormat.FDateH";this.placeholders=1;this.number=0;this.value=NaN};sap.common.globalization.numericFormat.FDateH.prototype.parse=function(d,c){var b=0;this.number=d.HNum+1;d.HBool=true;d.HNum=this.number;while(c.charAt(b)=="H"||c.charAt(b)=="h"){b++}if(b>1){this.placeholders=2}return b};a.FDateH.prototype.display=function(d){var b;if(isNaN(this.value)){b=d.getHrs()}else{b=this.value}if(!d.miltime){if(this.number==d.HNum){if(b>11){b=b-12}if(b==0){b=12}}}var c=""+b;while(this.placeholders>c.length){c="0"+c}return c}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateM");var a=sap.common.globalization.numericFormat;a.FDateM=function(b){this.__className="sap.common.globalization.numericFormat.FDateM";this.bminute=false;this.placeholders=0;this.value=undefined;this._displayLocaleInfo=b};a.FDateM.prototype.parse=function(d,c){var b=0;while(c.charAt(b)=="M"||c.charAt(b)=="m"){b++}if(b<=2){if(d.HBool){this.bminute=true}d.HBool=false;this.placeholders=b}else{if(b==3){this.placeholders=-1}else{if(b==4){this.placeholders=-2}else{if(b==5){this.placeholders=-3}}}}return b};a.FDateM.prototype.display=function(g){var f="";if(this.placeholders>=0&&this.bminute){if(this.value==undefined){f+=g.getMin()}else{f+=this.value}while(f.length<this.placeholders){f="0"+f}}else{var d=g.getMonth();if(this.placeholders>=0){d++;f+=d;while(f.length<this.placeholders){f="0"+f}}else{var e=new Array(this._displayLocaleInfo.IMSMONTHNAME1(),this._displayLocaleInfo.IMSMONTHNAME2(),this._displayLocaleInfo.IMSMONTHNAME3(),this._displayLocaleInfo.IMSMONTHNAME4(),this._displayLocaleInfo.IMSMONTHNAME5(),this._displayLocaleInfo.IMSMONTHNAME6(),this._displayLocaleInfo.IMSMONTHNAME7(),this._displayLocaleInfo.IMSMONTHNAME8(),this._displayLocaleInfo.IMSMONTHNAME9(),this._displayLocaleInfo.IMSMONTHNAME10(),this._displayLocaleInfo.IMSMONTHNAME11(),this._displayLocaleInfo.IMSMONTHNAME12());var c=new Array(this._displayLocaleInfo.IMSABBREVMONTHNAME1(),this._displayLocaleInfo.IMSABBREVMONTHNAME2(),this._displayLocaleInfo.IMSABBREVMONTHNAME3(),this._displayLocaleInfo.IMSABBREVMONTHNAME4(),this._displayLocaleInfo.IMSABBREVMONTHNAME5(),this._displayLocaleInfo.IMSABBREVMONTHNAME6(),this._displayLocaleInfo.IMSABBREVMONTHNAME7(),this._displayLocaleInfo.IMSABBREVMONTHNAME8(),this._displayLocaleInfo.IMSABBREVMONTHNAME9(),this._displayLocaleInfo.IMSABBREVMONTHNAME10(),this._displayLocaleInfo.IMSABBREVMONTHNAME11(),this._displayLocaleInfo.IMSABBREVMONTHNAME12());if(this.placeholders==-1){f+=c[d]}else{if(this.placeholders==-3){f+=e[d].substring(0,1)}else{f+=e[d]}}}}return f}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateS");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.numericFormat.FDateS=function(){this.__className="sap.common.globalization.numericFormat.FDateS";this.splaceholders=1;this.msplaceholders=0;this.value=undefined;this.IMDecimalSeparator=sap.common.globalization.numericFormat.FLocalization.getInstance().IMDecimalSeparator;this.ms=NaN};sap.common.globalization.numericFormat.FDateS.prototype.parse=function(g,f){var e=0;var c=g.mask;var b=c.length;for(var d=b-1;d>=0;d--){if(c[d].__className=="sap.common.globalization.numericFormat.FDateM"){c[d].bminute=true;break}}while(f.charAt(e)=="S"||f.charAt(e)=="s"){e++}if(e>1){this.splaceholders=2}if(f.charAt(e)==this.IMDecimalSeparator.charAt(0)&&f.charAt(e+1)=="0"){e++;while(f.charAt(e)=="0"){e++;this.msplaceholders++}if(this.msplaceholders>g.ms){g.ms=this.msplaceholders}}return e};sap.common.globalization.numericFormat.FDateS.prototype.display=function(d){var c;if(this.value==undefined){c=""+d.getSec()}else{c=""+this.value}while(this.splaceholders>c.length){c="0"+c}if(this.msplaceholders>0){var a=d.getMS()/Math.pow(10,(3-this.msplaceholders));if(this.msplaceholders<this.ms){a=Math.floor(a)}else{a=Math.round(a)}var b=""+a;while(b.length<this.msplaceholders){b="0"+b}c+=this.IMDecimalSeparator+b}return c}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateSep");sap.common.globalization.numericFormat.FDateSep=function(a,b){this.__className="sap.common.globalization.numericFormat.FDateSep";this._parseLocalInfo=a;this._displayLocaleInfo=b};sap.common.globalization.numericFormat.FDateSep.prototype.parse=function(c,b){var a=b.charAt(0);if(this._displayLocaleInfo.IMDateSeparator()!=null&&(a=="."||a=="/"||a=="-")){return 1}else{return 0}};sap.common.globalization.numericFormat.FDateSep.prototype.display=function(b){var a=this._displayLocaleInfo.IMDateSeparator();return a}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateY");sap.common.globalization.numericFormat.FDateY=function(){this.__className="sap.common.globalization.numericFormat.FDateY";this.placeholders=2};sap.common.globalization.numericFormat.FDateY.prototype.parse=function(c,b){var a=0;while(b.charAt(a)=="Y"||b.charAt(a)=="y"){a++}if(a>2){this.placeholders=4}return a};sap.common.globalization.numericFormat.FDateY.prototype.display=function(b){var a=""+b.getYear();if(this.placeholders<4){a=a.substring(2)}return a}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FText");sap.common.globalization.numericFormat.FText=function(){this.__className="sap.common.globalization.numericFormat.FText";this.color=NaN;this.format="";this.condnum=0;this.cond={};this.numAts=0;this.mask=new Array()};sap.common.globalization.numericFormat.FText.tokens="@";sap.common.globalization.numericFormat.FText.prototype.parse=function(b){var a=0;while(b.charAt(a)=="@"){a++}this.numAts=a;return a};sap.common.globalization.numericFormat.FText.prototype.display=function(a){var c="";for(var b=0;b<this.numAts;b++){c+=a.toString()}return c}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl");sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl=function(){this.__className="sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl";this._IMDateSeparator=null;this._IMSMONTHNAME1=null;this._IMSMONTHNAME2=null;this._IMSMONTHNAME3=null;this._IMSMONTHNAME4=null;this._IMSMONTHNAME5=null;this._IMSMONTHNAME6=null;this._IMSMONTHNAME7=null;this._IMSMONTHNAME8=null;this._IMSMONTHNAME9=null;this._IMSMONTHNAME10=null;this._IMSMONTHNAME11=null;this._IMSMONTHNAME12=null;this._IMSABBREVMONTHNAME1=null;this._IMSABBREVMONTHNAME2=null;this._IMSABBREVMONTHNAME3=null;this._IMSABBREVMONTHNAME4=null;this._IMSABBREVMONTHNAME5=null;this._IMSABBREVMONTHNAME6=null;this._IMSABBREVMONTHNAME7=null;this._IMSABBREVMONTHNAME8=null;this._IMSABBREVMONTHNAME9=null;this._IMSABBREVMONTHNAME10=null;this._IMSABBREVMONTHNAME11=null;this._IMSABBREVMONTHNAME12=null;this._IMSDAYNAME1=null;this._IMSDAYNAME2=null;this._IMSDAYNAME3=null;this._IMSDAYNAME4=null;this._IMSDAYNAME5=null;this._IMSDAYNAME6=null;this._IMSDAYNAME7=null;this._IMSABBREVDAYNAME1=null;this._IMSABBREVDAYNAME2=null;this._IMSABBREVDAYNAME3=null;this._IMSABBREVDAYNAME4=null;this._IMSABBREVDAYNAME5=null;this._IMSABBREVDAYNAME6=null;this._IMSABBREVDAYNAME7=null;this._IMTimeSeparator=null;this._IMAMToken=null;this._IMPMToken=null;this._IMEraToken=null};var a=sap.common.globalization.defaultFormat.DateDisplayLocaleInfoImpl;a.prototype.IMDateSeparator=function(b){if(arguments.length>=1){this._IMDateSeparator=b}else{return this._IMDateSeparator}};a.prototype.IMSMONTHNAME1=function(b){if(arguments.length>=1){this._IMSMONTHNAME1=b}else{return this._IMSMONTHNAME1}};a.prototype.IMSMONTHNAME2=function(b){if(arguments.length>=1){this._IMSMONTHNAME2=b}else{return this._IMSMONTHNAME2}};a.prototype.IMSMONTHNAME3=function(b){if(arguments.length>=1){this._IMSMONTHNAME3=b}else{return this._IMSMONTHNAME3}};a.prototype.IMSMONTHNAME4=function(b){if(arguments.length>=1){this._IMSMONTHNAME4=b}else{return this._IMSMONTHNAME4}};a.prototype.IMSMONTHNAME5=function(b){if(arguments.length>=1){this._IMSMONTHNAME5=b}else{return this._IMSMONTHNAME5}};a.prototype.IMSMONTHNAME6=function(b){if(arguments.length>=1){this._IMSMONTHNAME6=b}else{return this._IMSMONTHNAME6}};a.prototype.IMSMONTHNAME7=function(b){if(arguments.length>=1){this._IMSMONTHNAME7=b}else{return this._IMSMONTHNAME7}};a.prototype.IMSMONTHNAME8=function(b){if(arguments.length>=1){this._IMSMONTHNAME8=b}else{return this._IMSMONTHNAME8}};a.prototype.IMSMONTHNAME9=function(b){if(arguments.length>=1){this._IMSMONTHNAME9=b}else{return this._IMSMONTHNAME9}};a.prototype.IMSMONTHNAME10=function(b){if(arguments.length>=1){this._IMSMONTHNAME10=b}else{return this._IMSMONTHNAME10}};a.prototype.IMSMONTHNAME11=function(b){if(arguments.length>=1){this._IMSMONTHNAME11=b}else{return this._IMSMONTHNAME11}};a.prototype.IMSMONTHNAME12=function(b){if(arguments.length>=1){this._IMSMONTHNAME12=b}else{return this._IMSMONTHNAME12}};a.prototype.IMSABBREVMONTHNAME1=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME1=b}else{return this._IMSABBREVMONTHNAME1}};a.prototype.IMSABBREVMONTHNAME2=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME2=b}else{return this._IMSABBREVMONTHNAME2}};a.prototype.IMSABBREVMONTHNAME3=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME3=b}else{return this._IMSABBREVMONTHNAME3}};a.prototype.IMSABBREVMONTHNAME4=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME4=b}else{return this._IMSABBREVMONTHNAME4}};a.prototype.IMSABBREVMONTHNAME5=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME5=b}else{return this._IMSABBREVMONTHNAME5}};a.prototype.IMSABBREVMONTHNAME6=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME6=b}else{return this._IMSABBREVMONTHNAME6}};a.prototype.IMSABBREVMONTHNAME7=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME7=b}else{return this._IMSABBREVMONTHNAME7}};a.prototype.IMSABBREVMONTHNAME8=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME8=b}else{return this._IMSABBREVMONTHNAME8}};a.prototype.IMSABBREVMONTHNAME9=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME9=b}else{return this._IMSABBREVMONTHNAME9}};a.prototype.IMSABBREVMONTHNAME10=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME10=b}else{return this._IMSABBREVMONTHNAME10}};a.prototype.IMSABBREVMONTHNAME11=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME11=b}else{return this._IMSABBREVMONTHNAME11}};a.prototype.IMSABBREVMONTHNAME12=function(b){if(arguments.length>=1){this._IMSABBREVMONTHNAME12=b}else{return this._IMSABBREVMONTHNAME12}};a.prototype.IMSDAYNAME1=function(b){if(arguments.length>=1){this._IMSDAYNAME1=b}else{return this._IMSDAYNAME1}};a.prototype.IMSDAYNAME2=function(b){if(arguments.length>=1){this._IMSDAYNAME2=b}else{return this._IMSDAYNAME2}};a.prototype.IMSDAYNAME3=function(b){if(arguments.length>=1){this._IMSDAYNAME3=b}else{return this._IMSDAYNAME3}};a.prototype.IMSDAYNAME4=function(b){if(arguments.length>=1){this._IMSDAYNAME4=b}else{return this._IMSDAYNAME4}};a.prototype.IMSDAYNAME5=function(b){if(arguments.length>=1){this._IMSDAYNAME5=b}else{return this._IMSDAYNAME5}};a.prototype.IMSDAYNAME6=function(b){if(arguments.length>=1){this._IMSDAYNAME6=b}else{return this._IMSDAYNAME6}};a.prototype.IMSDAYNAME7=function(b){if(arguments.length>=1){this._IMSDAYNAME7=b}else{return this._IMSDAYNAME7}};a.prototype.IMSABBREVDAYNAME1=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME1=b}else{return this._IMSABBREVDAYNAME1}};a.prototype.IMSABBREVDAYNAME2=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME2=b}else{return this._IMSABBREVDAYNAME2}};a.prototype.IMSABBREVDAYNAME3=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME3=b}else{return this._IMSABBREVDAYNAME3}};a.prototype.IMSABBREVDAYNAME4=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME4=b}else{return this._IMSABBREVDAYNAME4}};a.prototype.IMSABBREVDAYNAME5=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME5=b}else{return this._IMSABBREVDAYNAME5}};a.prototype.IMSABBREVDAYNAME6=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME6=b}else{return this._IMSABBREVDAYNAME6}};a.prototype.IMSABBREVDAYNAME7=function(b){if(arguments.length>=1){this._IMSABBREVDAYNAME7=b}else{return this._IMSABBREVDAYNAME7}};a.prototype.IMTimeSeparator=function(b){if(arguments.length>=1){this._IMTimeSeparator=b}else{return this._IMTimeSeparator}};a.prototype.IMAMTOKEN=function(b){if(arguments.length>=1){this._IMAMToken=b}else{return this._IMAMToken}};a.prototype.IMPMTOKEN=function(b){if(arguments.length>=1){this._IMPMToken=b}else{return this._IMPMToken}};a.prototype.IMEraToken=function(b){if(arguments.length>=1){this._IMEraToken=b}else{return this._IMEraToken}}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateY");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");sap.common.globalization.require("sap.common.globalization.numericFormat.FTimeSep");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateA");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateB");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateSep");var a=sap.common.globalization.numericFormat;a.FDate=function(c,b){this.__className="sap.common.globalization.numericFormat.FDate";this.date;this.color;this.condnum;this.cond;this.tok={};this.HBool=false;this.serial=37500;this.format="";this.HNum=0;this.miltime=true;this.ms=0;this.mask=new Array();this._parseLocaleInfo=c;this._displayLocaleInfo=b;this._inputIsDateType=false;this.initializeTokenMap()};a.FDate.tokens="MDYHSAmdyhsa";a.FDate.prototype.parse=function(f){var g=f.charAt(0);if(g=="."){g=f.substring(0,2)}var e=this.tok[g];if(e==undefined){return 0}var d=this.createTokenFormatter(e);var b=d.parse(this,f);if(b>0){this.mask.push(d)}else{b=0}return b};a.FDate.prototype.display=function(d){if(d<0){return"###########################################"}this.setNumber(d);var c=this.mask;var b=c.length;var f="";for(var e=0;e<b;e++){if((typeof c[e])=="object"){f+=c[e].display(this)}else{f+=c[e]}}return f};a.FDate.prototype.getMaskClone=function(){if(this.mask){return this.mask.slice()}return[]};a.FDate.prototype.getYear=function(){if(this._inputIsDateType){return this.date.getFullYear()}if(this.serial>=0&&this.serial<1){return 1900}return this.date.getUTCFullYear()};a.FDate.prototype.getMonth=function(){if(this._inputIsDateType){return this.date.getMonth()}if(this.serial>=0&&this.serial<1){return 0}return this.date.getUTCMonth()};a.FDate.prototype.getDate=function(){if(this._inputIsDateType){return this.date.getDate()}if(this.serial>=0&&this.serial<1){return 0}if(this.serial==60){return 29}return this.date.getUTCDate()};a.FDate.prototype.getDay=function(){var b=this.date.getUTCDay();if(this.serial<60){b--}if(this._inputIsDateType){b=this.date.getDay()}return b};a.FDate.prototype.getHrs=function(){if(this._inputIsDateType){return this.date.getHours()}return this.date.getUTCHours()};a.FDate.prototype.getMin=function(){if(this._inputIsDateType){return this.date.getMinutes()}return this.date.getUTCMinutes()};a.FDate.prototype.getSec=function(){if(this._inputIsDateType){return this.date.getSeconds()}return this.date.getUTCSeconds()};a.FDate.prototype.getMS=function(){if(this._inputIsDateType){return this.date.getMilliseconds()}return this.date.getUTCMilliseconds()};a.FDate.prototype.setNumber=function(b){if(b instanceof Date){var e=new Date();e.setTime(b.getTime());this.date=e;this._inputIsDateType=true;this.serial=37500;return}this._inputIsDateType=false;this.serial=b;if(b<60){b++}var d=b*86400*1000;var c=d-(2209161600*1000);this.date=new Date(c);if(this.date.getUTCMilliseconds()>=500){this.date.setUTCMilliseconds(this.date.getUTCMilliseconds()+500)}};a.FDate.prototype.createTokenFormatter=function(b){var c=null;switch(b){case a.FDateM:c=new a.FDateM(this._displayLocaleInfo);break;case a.FDateD:c=new a.FDateD(this._displayLocaleInfo);break;case a.FDateY:c=new a.FDateY();break;case a.FDateH:c=new a.FDateH();break;case a.FDateS:c=new a.FDateS();break;case a.FDateSep:c=new a.FDateSep(this._parseLocaleInfo,this._displayLocaleInfo);break;case a.FTimeSep:c=new a.FTimeSep(this._parseLocaleInfo,this._displayLocaleInfo);break;case a.FDateA:c=new a.FDateA(this._displayLocaleInfo);break;case a.FDateB:c=new a.FDateB(this._displayLocaleInfo);break;default:}return c};a.FDate.prototype.initializeTokenMap=function(){this.tok.M=a.FDateM;this.tok.D=a.FDateD;this.tok.Y=a.FDateY;this.tok.H=a.FDateH;this.tok.S=a.FDateS;this.tok.A=a.FDateA;this.tok.m=a.FDateM;this.tok.d=a.FDateD;this.tok.y=a.FDateY;this.tok.h=a.FDateH;this.tok.s=a.FDateS;this.tok.a=a.FDateA;this.tok["["]=a.FDateB;this.tok["/"]=a.FDateSep;this.tok[".M"]=a.FDateSep;this.tok[".D"]=a.FDateSep;this.tok[".Y"]=a.FDateSep;this.tok["-"]=a.FDateSep;this.tok[".m"]=a.FTimeSep;this.tok[".h"]=a.FTimeSep;this.tok[".s"]=a.FTimeSep;this.tok[":"]=a.FTimeSep};a.FDate.prototype.toString=function(){var b="[FDate]\n";for(var c in this){b=b+c+" = "+this[c]+"\n"}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDateForPVL");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.numericFormat.FDateForPVL=function(c,b){sap.common.globalization.numericFormat.FDateForPVL.superclass.constructor.apply(this,[c,b]);this.__className="sap.common.globalization.numericFormat.FDateForPVL"};sap.common.globalization.numericFormat.FDateForPVL=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDateForPVL,sap.common.globalization.numericFormat.FDate);var a=sap.common.globalization.numericFormat.FDateForPVL;a.prototype.createTokenFormatter=function(b){var c=null;if(b==sap.common.globalization.numericFormat.FDefaultDateD){c=new sap.common.globalization.numericFormat.FDefaultDateD(this._displayLocaleInfo)}else{c=a.superclass.createTokenFormatter.call(this,b)}return c};a.prototype.initializeTokenMap=function(){a.superclass.initializeTokenMap.apply(this);this.tok.d=sap.common.globalization.numericFormat.FDefaultDateD;this.tok.D=sap.common.globalization.numericFormat.FDefaultDateD}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateSep");sap.common.globalization.numericFormat.FDefaultDateSep=function(b,a){sap.common.globalization.numericFormat.FDefaultDateSep.superclass.constructor.call(this,b,a);this.__className="sap.common.globalization.numericFormat.FDefaultDateSep"};sap.common.globalization.numericFormat.FDefaultDateSep=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateSep,sap.common.globalization.numericFormat.FDateSep);sap.common.globalization.numericFormat.FDefaultDateSep.prototype.parse=function(e,d){var a=this._parseLocalInfo.IMDateSeparator();if(a){var c=a.length;var b=d.substr(0,c);if(b==a){return c}else{return 0}}return 0}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");sap.common.globalization.numericFormat.FDefaultDateH=function(){sap.common.globalization.numericFormat.FDefaultDateH.superclass.constructor.apply(this);this.__className="sap.common.globalization.numericFormat.FDefaultDateH";this._is12HourStyle=false};sap.common.globalization.numericFormat.FDefaultDateH=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateH,sap.common.globalization.numericFormat.FDateH);sap.common.globalization.numericFormat.FDefaultDateH.prototype.parse=function(c,b){var a=0;this.number=c.HNum+1;c.HBool=true;c.HNum=this.number;this._is12HourStyle=true;while(b.charAt(a)=="H"||b.charAt(a)=="h"){if(b.charAt(a)=="H"){this._is12HourStyle=false}a++}if(a>1){this.placeholders=2}return a};sap.common.globalization.numericFormat.FDefaultDateH.prototype.display=function(c){var a;if(isNaN(this.value)){a=c.getHrs()}else{a=this.value}if(this._is12HourStyle){if(this.number==c.HNum){if(a>11){a=a-12}if(a==0){a=12}}}var b=""+a;while(this.placeholders>b.length){b="0"+b}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateG");sap.common.globalization.require("sap.common.globalization.utils.StringUtil");sap.common.globalization.numericFormat.FDefaultDateG=function(a){this.__className="sap.common.globalization.numericFormat.FDefaultDateG";this._displayLocInfo=a;this._count=0};sap.common.globalization.numericFormat.FDefaultDateG.prototype.parse=function(c,b){if(b&&!sap.common.globalization.utils.StringUtil.isBlankString(b)){if(this._displayLocInfo&&this._displayLocInfo.IMEraToken()){this._count=0;var a=b.charAt(this._count);while(a=="G"){this._count++;a=b.charAt(this._count)}return this._count}}return 0};sap.common.globalization.numericFormat.FDefaultDateG.prototype.display=function(b){var a="";if(this._displayLocInfo&&this._displayLocInfo.IMEraToken()){switch(this._count){case 4:case 5:case 1:case 2:case 3:default:a=this._displayLocInfo.IMEraToken()}}return a}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");var a=sap.common.globalization.numericFormat;sap.common.globalization.numericFormat.FDefaultDateD=function(b){sap.common.globalization.numericFormat.FDefaultDateD.superclass.constructor.call(this,b);this.__className="sap.common.globalization.numericFormat.FDefaultDateD"};sap.common.globalization.numericFormat.FDefaultDateD=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDateD,sap.common.globalization.numericFormat.FDateD);a.FDefaultDateD.prototype.getShortDay=function(b){if(b==0){return this._displayLocaleInfo.IMSABBREVDAYNAME7()}if(b==1){return this._displayLocaleInfo.IMSABBREVDAYNAME1()}if(b==2){return this._displayLocaleInfo.IMSABBREVDAYNAME2()}if(b==3){return this._displayLocaleInfo.IMSABBREVDAYNAME3()}if(b==4){return this._displayLocaleInfo.IMSABBREVDAYNAME4()}if(b==5){return this._displayLocaleInfo.IMSABBREVDAYNAME5()}if(b==6||b==-1){return this._displayLocaleInfo.IMSABBREVDAYNAME6()}return this._displayLocaleInfo.IMSABBREVDAYNAME6()}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateG");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FTimeSep");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateSep");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateM");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateD");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateY");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateH");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateS");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateA");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateB");sap.common.globalization.require("sap.common.globalization.numericFormat.FDateSep");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultDateSep");sap.common.globalization.numericFormat.FDefaultDate=function(b,a){sap.common.globalization.numericFormat.FDefaultDate.superclass.constructor.apply(this,[b,a]);this.__className="sap.common.globalization.numericFormat.FDefaultDate"};sap.common.globalization.numericFormat.FDefaultDate=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultDate,sap.common.globalization.numericFormat.FDate);sap.common.globalization.numericFormat.FDefaultDate.prototype.createTokenFormatter=function(a){var c=sap.common.globalization.numericFormat;var b=null;switch(a){case c.FDateM:b=new c.FDateM(this._displayLocaleInfo);break;case c.FDefaultDateD:b=new c.FDefaultDateD(this._displayLocaleInfo);break;case c.FDateY:b=new c.FDateY();break;case c.FDefaultDateH:b=new c.FDefaultDateH();break;case c.FDateS:b=new c.FDateS();break;case c.FDefaultDateSep:b=new c.FDefaultDateSep(this._parseLocaleInfo,this._displayLocaleInfo);break;case c.FTimeSep:b=new c.FTimeSep(this._parseLocaleInfo,this._displayLocaleInfo);break;case c.FDateA:b=new c.FDateA(this._displayLocaleInfo);break;case c.FDateB:b=new c.FDateB(this._displayLocaleInfo);break;case c.FDefaultDateG:b=new c.FDefaultDateG(this._displayLocaleInfo);break;default:}return b};sap.common.globalization.numericFormat.FDefaultDate.prototype.initializeTokenMap=function(){var a=sap.common.globalization.numericFormat;this.tok.M=a.FDateM;this.tok.Y=a.FDateY;this.tok.S=a.FDateS;this.tok.A=a.FDateA;this.tok.m=a.FDateM;this.tok.y=a.FDateY;this.tok.s=a.FDateS;this.tok.a=a.FDateA;this.tok["["]=a.FDateB;this.tok.D=a.FDefaultDateD;this.tok.d=a.FDefaultDateD;this.tok.H=a.FDefaultDateH;this.tok.h=a.FDefaultDateH;if(this._parseLocaleInfo&&this._parseLocaleInfo.IMDateSeparator){if(this._parseLocaleInfo.IMDateSeparator()=="."){this.tok[".M"]=a.FDefaultDateSep;this.tok[".D"]=a.FDefaultDateSep;this.tok[".d"]=a.FDefaultDateSep;this.tok[".Y"]=a.FDefaultDateSep;this.tok[".y"]=a.FDefaultDateSep}else{this.tok[this._parseLocaleInfo.IMDateSeparator()]=a.FDefaultDateSep}}if(this._parseLocaleInfo&&this._parseLocaleInfo.IMTimeSeparator()){if(this._parseLocaleInfo.IMDateSeparator=="."){this.tok[".m"]=a.FTimeSep;this.tok[".h"]=a.FTimeSep;this.tok[".H"]=a.FTimeSep;this.tok[".s"]=a.FTimeSep;this.tok[".S"]=a.FTimeSep}else{this.tok[this._parseLocaleInfo.IMTimeSeparator()]=a.FTimeSep}}this.tok.G=a.FDefaultDateG}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.DefaultGroupingStrategy");sap.common.globalization.numericFormat.DefaultGroupingStrategy=function(){this.__className="sap.common.globalization.numericFormat.DefaultGroupingStrategy"};var a=sap.common.globalization.numericFormat.DefaultGroupingStrategy;a._instance=new sap.common.globalization.numericFormat.DefaultGroupingStrategy();a.prototype.nextGroupDigits=function(){return 2};a.instance=function(){return a._instance}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.Helper");sap.common.globalization.require("sap.common.globalization.numericFormat.FLocalization");sap.common.globalization.numericFormat.Helper.isThousandsSeparator=function(d,b,e){var e=e||null;var a=(e?e:sap.common.globalization.numericFormat.FLocalization.getInstance().IMThousandsSeparator());if(a.charAt(0)==" "){for(var c=b;c<d.length;++c){if(d.charAt(c)!=" "){break}}if(d.charAt(c)=="€"||d.charAt(c)=="г"||d.charAt(c)=="k"||d.charAt(c)=="S"||d.charAt(c)=="L"||d.charAt(c)=="m"||d.charAt(c)=="K"){return false}}return(d.charAt(b)==a.charAt(0))}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FCurr");sap.common.globalization.numericFormat.FCurr=function(b,a){this.__className="sap.common.globalization.numericFormat.FCurr";this.display="";this._parseLocaleInfo=b;this._displayLocaleInfo=a};sap.common.globalization.numericFormat.FCurr.prototype.parse=function(c,b){var a=this._parseLocaleInfo.currencySymbol();var d=this._displayLocaleInfo.currencySymbol();if(d!=null&&a!=null&&a!=d){c.currencyIndex=c.mask.length;this.display=d;return a.length}else{return 0}}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNum0");sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");sap.common.globalization.numericFormat.FNum0=function(a){this.__className="sap.common.globalization.numericFormat.FNum0";this._parseLocaleInfo=a;this.display="0"};sap.common.globalization.numericFormat.FNum0.prototype.parse=function(e,d){var b=1;if(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,1,this._parseLocaleInfo.thousandsSeparator())){var f=d.charAt(2);if(f!="#"&&f!="?"&&f!="0"){if(!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,2,this._parseLocaleInfo.thousandsSeparator())){e.scale=e.scale/1000}else{e.scale=e.scale/1000000}}else{e.bcomma=true}var a=1;while(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,a++,this._parseLocaleInfo.thousandsSeparator())){b++}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumP");sap.common.globalization.numericFormat.FNumP=function(){this.__className="sap.common.globalization.numericFormat.FNumP";this.display="%"};sap.common.globalization.numericFormat.FNumP.prototype.parse=function(b,a){b.scale=b.scale*100;return -1}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumQ");sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");sap.common.globalization.numericFormat.FNumQ=function(a){this.__className="sap.common.globalization.numericFormat.FNumQ";this._parseLocaleInfo=a;this.display=" "};sap.common.globalization.numericFormat.FNumQ.prototype.parse=function(e,d){var b=1;if(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,1,this._parseLocaleInfo.thousandsSeparator())){var f=d.charAt(2);if(f!="#"&&f!="?"&&f!="0"&&!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,2,this._parseLocaleInfo.thousandsSeparator())){e.scale=e.scale/1000}else{e.bcomma=true}var a=1;while(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,a++,this._parseLocaleInfo.thousandsSeparator())){b++}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumS");sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");sap.common.globalization.numericFormat.FNumS=function(a){this.__className="sap.common.globalization.numericFormat.FNumS";this._parseLocaleInfo=a;this.display=""};sap.common.globalization.numericFormat.FNumS.prototype.parse=function(e,d){var b=1;if(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,1,this._parseLocaleInfo.thousandsSeparator())){var f=d.charAt(2);if(f!="#"&&f!="?"&&f!="0"){if(!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,2,this._parseLocaleInfo.thousandsSeparator())){e.scale=e.scale/1000}else{e.scale=e.scale/1000000}}else{e.bcomma=true}var a=1;while(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,a++,this._parseLocaleInfo.thousandsSeparator())){b++}}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FPeriod");sap.common.globalization.require("sap.common.globalization.numericFormat.Helper");sap.common.globalization.numericFormat.FPeriod=function(b,a){this.__className="sap.common.globalization.numericFormat.FPeriod";this._parseLocaleInfo=b;this.display=a.decimalSeparator()};sap.common.globalization.numericFormat.FPeriod.prototype.parse=function(e,d){var b=-1;if(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,1,this._parseLocaleInfo.thousandsSeparator())){var f=d.charAt(2);if(f!="#"&&f!="?"&&f!="0"&&!sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,2,this._parseLocaleInfo.thousandsSeparator())){e.scale=e.scale/1000}var a=1;while(sap.common.globalization.numericFormat.Helper.isThousandsSeparator(d,a++,this._parseLocaleInfo.thousandsSeparator())){b++}}if(e.period==-1){e.period=e.mask.length}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.numericFormat.FNumber=function(d,c){this.__className="sap.common.globalization.numericFormat.FNumber";this.scale=1;this.bcomma=false;this.bsign=true;this.period=-1;this.numfore=undefined;this.numaft=undefined;this.sign="";this.mask=new Array();this.mfore=new Array();this.maft=new Array();this.format=undefined;this.currencyIndex=-1;this._tok={};this._tok["#"]=sap.common.globalization.numericFormat.FNumS;this._tok["?"]=sap.common.globalization.numericFormat.FNumQ;this._tok["%"]=sap.common.globalization.numericFormat.FNumP;this._tok["0"]=sap.common.globalization.numericFormat.FNum0;this.condnum=0;this.cond={};var a=d.decimalSeparator();this._tok[a]=sap.common.globalization.numericFormat.FPeriod;this.IMDecimalSeparator=a;this.parseLocaleInfo=d;this.displayLocaleInfo=c;this.IMThousandsSeparator=c.thousandsSeparator();var b=this.parseLocaleInfo.currencySymbol();if(b){this._tok[b]=sap.common.globalization.numericFormat.FCurr}};sap.common.globalization.numericFormat.FNumber.tokens="#?%0";sap.common.globalization.numericFormat.FNumber.prototype.parse=function(f){if(this.format==null){this.format=f}var g=f.charAt(0);if(this._tok[g]==undefined||(g==this.IMDecimalSeparator&&(f.length>1&&f.charAt(1)!="#"&&f.charAt(1)!="0"))){return 0}var e=this.createTokenFormatter(this._tok[g]);var d=e.parse(this,f);if(this.period>1){var a=true}if(d>0){var b=this.mask.length;this.mask.push(e);if(this.currencyIndex!=b){if(this.period==-1){this.mfore.push(b)}else{this.maft.push(b)}}}else{if(d<0){this.mask.push(e);d=Math.abs(d)}else{d=0}}return d};sap.common.globalization.numericFormat.FNumber.prototype.display=function(k){if(typeof(k)!="number"){return k}if(isNaN(k)||!isFinite(k)){return k}if(this.mfore.length==0&&this.maft.length==0){return this.format}this.setNumber(k);var q=new Array();var e=this.mfore.length;var c=3;var m=this.period;var f=(m==-1)?(this.mask.length):m;var g;var o;var p;for(var h=e-1;h>=0;h--){m=this.mfore[h];for(var g=f-1;g>m;g--){p=this.mask[g];if((typeof p)=="object"){q.unshift(p.display)}else{q.unshift(p)}}if(this.numfore.length>0){if(this.bcomma){if(c--==0){q.unshift(this.IMThousandsSeparator);c=2}}o=this.numfore.length-1;q.unshift(this.numfore.charAt(o));this.numfore=this.numfore.substring(0,o)}else{var n=this.mask[m].display;if(n.length!=0){if(this.bcomma&&c--==0){q.unshift(this.IMThousandsSeparator);c=2}q.unshift(this.mask[m].display)}}f=m}if(this.numfore.length>0){if(this.bcomma){while(this.numfore.length>0){if(c--==0){q.unshift(this.IMThousandsSeparator);c=2}o=this.numfore.length-1;q.unshift(this.numfore.charAt(o));this.numfore=this.numfore.substring(0,o)}}else{q.unshift(this.numfore)}}p=this.mask;if(this.currencyIndex!=-1){h=0}for(g=f-1;g>=0;g--){if((typeof p[h])=="object"){q.unshift(this.mask[g].display)}else{q.unshift(this.mask[g])}}e=this.mask.length;h=(this.period==-1)?(e):(this.period);m=0;for(;h<e;h++){if((typeof p[h])=="object"){if(this.maft[m]==h){m++;if(this.numaft.length>0){q.push(this.numaft.charAt(0));this.numaft=this.numaft.substring(1)}else{q.push(p[h].display)}}else{q.push(p[h].display)}}else{q.push(p[h])}}var b;if(this.bsign){b=this.sign+q.join("")}else{b=q.join("")}return b};sap.common.globalization.numericFormat.FNumber.prototype.setNumber=function(c){c=c*this.scale;var a=this.maft.length;var e=Math.pow;var d=e(10,a);if(c<0){d*=-1}var f=c*d;f=Math.round(f);c=f/d;var b=c.toString().split(".");this.numfore=b[0];if(this.numfore.charAt(0)=="-"){this.sign="-";this.numfore=this.numfore.substring(1)}else{this.sign=""}if(this.numfore.charAt(0)=="0"){this.numfore=this.numfore.substring(1)}this.numaft=undefined;if(b.length<2){this.numaft=""}else{this.numaft=b[1]}};sap.common.globalization.numericFormat.FNumber.prototype.createTokenFormatter=function(a){var b=null;var c=sap.common.globalization.numericFormat;switch(a){case c.FNumS:b=new sap.common.globalization.numericFormat.FNumS(this.parseLocaleInfo);break;case c.FNumQ:b=new sap.common.globalization.numericFormat.FNumQ(this.parseLocaleInfo);break;case c.FNumP:b=new sap.common.globalization.numericFormat.FNumP();break;case c.FNum0:b=new sap.common.globalization.numericFormat.FNum0(this.parseLocaleInfo);break;case c.FPeriod:b=new sap.common.globalization.numericFormat.FPeriod(this.parseLocaleInfo,this.displayLocaleInfo);break;case c.FCurr:b=new sap.common.globalization.numericFormat.FCurr(this.parseLocaleInfo,this.displayLocaleInfo);break;default:}return b}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.DefaultGroupingStrategy");sap.common.globalization.require("sap.common.globalization.numericFormat.FPeriod");sap.common.globalization.numericFormat.FDefaultNumber=function(b,a){sap.common.globalization.numericFormat.FDefaultNumber.superclass.constructor.apply(this,[b,a]);this.__className="sap.common.globalization.numericFormat.FDefaultDateNumber";this._groupingStrategy=sap.common.globalization.numericFormat.DefaultGroupingStrategy.instance()};sap.common.globalization.numericFormat.FDefaultNumber=sap.common.globalization.extend(sap.common.globalization.numericFormat.FDefaultNumber,sap.common.globalization.numericFormat.FNumber);sap.common.globalization.numericFormat.FDefaultNumber.prototype.display=function(m){if(typeof(m)!="number"){return m}if(isNaN(m)||!isFinite(m)){return m}if(this.mfore.length==0&&this.maft.length==0){return this.format}this.setNumber(m);var r=new Array();var e=this.mfore.length;var c=3;var n=this.period;var g=(n==-1)?(this.mask.length):n;var h;var p;var q;for(var k=e-1;k>=0;k--){n=this.mfore[k];for(h=g-1;h>n;h--){q=this.mask[h];if((typeof q)=="object"){r.unshift(q.display)}else{r.unshift(q)}}if(this.numfore.length>0){if(this.bcomma){if(c--==0){r.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}}p=this.numfore.length-1;r.unshift(this.numfore.charAt(p));this.numfore=this.numfore.substring(0,p)}else{var o=this.mask[n].display;if(o.length!=0){if(this.bcomma&&c--==0){r.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}r.unshift(this.mask[n].display)}}g=n}if(this.numfore.length>0){if(this.bcomma){while(this.numfore.length>0){if(c--==0){r.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}p=this.numfore.length-1;r.unshift(this.numfore.charAt(p));this.numfore=this.numfore.substring(0,p)}}else{r.unshift(this.numfore)}}q=this.mask;if(this.currencyIndex!=-1){k=0}for(h=g-1;h>=0;h--){if((typeof q[k])=="object"){r.unshift(this.mask[h].display)}else{r.unshift(this.mask[h])}}e=this.mask.length;k=(this.period==-1)?(e):(this.period);n=0;var f=false;for(;k<e;k++){if((typeof q[k])=="object"){if(q[k].__className=="sap.common.globalization.numericFormat.FPeriod"&&!this.numaft){f=true;continue}if(this.maft[n]==k){n++;if(this.numaft.length>0){if(!f){r.push(this.numaft.charAt(0))}this.numaft=this.numaft.substring(1)}else{r.push(q[k].display)}}else{r.push(q[k].display)}}else{r.push(q[k])}}var b;if(this.bsign){b=this.sign+r.join("")}else{b=r.join("")}return b};sap.common.globalization.numericFormat.FDefaultNumber.prototype.groupingStrategy=function(a){if(this._groupingStrategy!=a){this._groupingStrategy=a}}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FT");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");sap.common.globalization.require("sap.common.globalization.numericFormat.FDate");sap.common.globalization.require("sap.common.globalization.numericFormat.FText");sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory");sap.common.globalization.numericFormat.FT=function(c,b){this.__className="sap.common.globalization.numericFormat.FT";this._hasCustomCondition=false;this.color=undefined;this.o=new Array();this._dateLocaleFactory=c?c:sap.common.globalization.defaultFormat.CustomDateFormatLocaleFactory.getInstance();this._numericLocaleFactory=b?b:sap.common.globalization.defaultFormat.CustomNumericFormatLocaleFactory.getInstance()};var a=sap.common.globalization.numericFormat.FT;a.ftarr=new Array();a._CONDITION_TOKENS="=<>";a._equals=function(d,c){return(d==c)};a._neq=function(d,c){return(d!=c)};a._gthan=function(d,c){return(d>c)};a._gte=function(d,c){return(d>=c)};a._lthan=function(d,c){return(d<c)};a._lte=function(d,c){return(d<=c)};a._CONDITIONS={"=":sap.common.globalization.numericFormat.FT._equals,"<>":sap.common.globalization.numericFormat.FT._neq,"<":sap.common.globalization.numericFormat.FT._lthan,"<=":sap.common.globalization.numericFormat.FT._lte,">":sap.common.globalization.numericFormat.FT._gthan,">=":sap.common.globalization.numericFormat.FT._gte};a._COLORS={black:0,blue:255,cyan:65535,green:65280,magenta:16711935,red:16711680,white:16777215,yellow:16776960};a.prototype._isNumeric=function(e){var d="#?%";var b=d.length;for(var c=0;c<b;c++){if(e.indexOf(d.charAt(c))!=-1){return true}}return false};a.prototype.parse=function(x){this._hasCustomCondition=false;var z=x;var t=x.length;var B;var d=0;for(var w=0;w<t;w++){B=z.charAt(w);if(B=='"'){while(w<t){if(z.charAt(++w)=='"'&&z.charAt(w-1)!="\\"){break}}continue}if(B=="\\"||B=="_"||B=="*"){w++;continue}if(B==";"){if(this.o[d]==undefined){this.o[d]=new sap.common.globalization.numericFormat.FText()}this.o[d].format=z.substring(0,w);d++;z=z.substring(w+1);t=z.length;w=-1;continue}if(B=="["){var r="";while(z.charAt(++w)!="]"&&(w<t)){r+=z.charAt(w)}var A=r.length;var n=r.charAt(0);if(n=="s"||n=="m"||n=="h"){for(var v=1;v<A;v++){var k=r.charAt(v);if(n!=k){break}}if(v==A){if(this.o[d]==undefined){this.o[d]=this._dateLocaleFactory.createFDate()}}}}var D=sap.common.globalization.numericFormat.FDate.tokens.indexOf(B);if(sap.common.globalization.numericFormat.FDate.tokens.indexOf(B)!=-1&&!this._isNumeric(x)){if(this.o[d]==undefined){this.o[d]=this._dateLocaleFactory.createFDate()}this.o[d]=this._dateLocaleFactory.createFDate()}else{if(sap.common.globalization.numericFormat.FNumber.tokens.indexOf(B)!=-1){if(this.o[d]==undefined){this.o[d]=this._numericLocaleFactory.createFNumber();if(d==1){this.o[d].bsign=false}}}else{if(sap.common.globalization.numericFormat.FText.tokens.indexOf(B)!=-1){if(this.o[d]==undefined){this.o[d]=new sap.common.globalization.numericFormat.FText()}}}}}if(this.o[d]==undefined){this.o[d]=this._numericLocaleFactory.createFNumber()}this.o[d].format=z;var g=this.o.length;for(var s=0;s<g;s++){var m=this.o[s];m.condnum=0;if(s==0){m.cond=sap.common.globalization.numericFormat.FT._gthan}else{if(s==1){m.cond=sap.common.globalization.numericFormat.FT._lthan}else{if(s==2){m.cond=sap.common.globalization.numericFormat.FT._equals}}}var C=m.mask;var h=false;z=m.format;t=z.length;for(var v=0;v<t;v++){B=z.charAt(v);if(B=='"'){h=!h;continue}if(B=="\\"){v++;B=z.charAt(v);C.push(B);continue}if(h){C.push(B);continue}if(B=="*"){v++;continue}if(B=="_"){v++;C.push(" ");continue}if(B=="["){n=z.charAt(v+1);k=z.charAt(v+2);if(n=="$"&&k!="-"){var y=z.indexOf("]",v+1);if(y!=-1){var u=z.substring(v+1,y);if(r.indexOf("-")!=-1){u=r.substring(1,r.indexOf("-"))}else{u=r.substring(1)}for(var b=0;b<u.length;++b){C.push(u.charAt(b))}v=y;continue}}else{r=z.substring(v+1);r=r.substring(0,r.indexOf("]")).toLowerCase();if(sap.common.globalization.numericFormat.FT._COLORS[r]!=undefined){m.color=sap.common.globalization.numericFormat.FT._COLORS[r];v+=r.length+1;continue}else{if(r=="h"||r=="m"||r=="s"){}else{var e=1;while(sap.common.globalization.numericFormat.FT._CONDITION_TOKENS.indexOf(r.charAt(e))!=-1){e++}var p=r.substring(0,e);if(sap.common.globalization.numericFormat.FT._CONDITIONS[p]!=undefined){m.cond=sap.common.globalization.numericFormat.FT._CONDITIONS[p];m.condnum=r.substring(e);v+=r.length+1;this._hasCustomCondition=true;continue}else{v+=r.length+1;continue}}}}}var E=m.parse(z.substring(v));if(E>0){v+=E-1}else{C.push(B)}}}};a.prototype.display=function(d){var f=this.o[0];var b=this.o.length;if(b>3&&sap.common.globalization.utils.BaseUtils.isString(d)){f=this.o[3]}else{if(this._hasCustomCondition&&b>0){if(b<=3){f=this.o[b-1]}else{f=this.o[2]}}for(var e=0;e<3&&e<b;e++){var c=this.o[e];if(c&&c.cond(d,c.condnum)){f=c;break}}}if(!isNaN(f.color)){this.color=f.color}else{this.color=undefined}return(f.display(d))};a.prototype.getNumericDisplayLoacleInfo=function(){return this._numericLocaleFactory.getNumericDisplayLocaleInfo()}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FTBoolean");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.NumericFormatManager;");sap.common.globalization.require("sap.common.globalization.numericFormat.FT");sap.common.globalization.require("sap.common.globalization.utils.BaseUtils");var a=sap.common.globalization.numericFormat;sap.common.globalization.numericFormat.FTBoolean=function(c,b){a.FTBoolean.superclass.constructor.apply(this,[c,b]);this.__className="sap.common.globalization.numericFormat.FTBoolean";c=c||null;b=b||null;this._booleanLocaleFactory=sap.common.globalization.defaultFormat.DefaultBooleanFormatLocaleFactory.getInstance()};a.FTBoolean.BOOLEAN_TOKEN="SAP_DEFAULT_BOOLEAN_FORMAT";a.FTBoolean=sap.common.globalization.extend(a.FTBoolean,a.FT);sap.common.globalization.numericFormat.FTBoolean.prototype.parse=function(b){if(b==a.FTBoolean.BOOLEAN_TOKEN){this.o[0]=this}else{this.o[0]=null}};sap.common.globalization.numericFormat.FTBoolean.prototype.display=function(b){var d=String(b);var c=this._booleanLocaleFactory.getBooleanDisplayLocaleInfo();if(c&&this.o[0].__className=="sap.common.globalization.numericFormat.FTBoolean"){if(sap.common.globalization.utils.BaseUtils.isBoolean(b)){d=b?c.trueString():c.falseString()}else{if(sap.common.globalization.utils.BaseUtils.isString(b)&&(String(b).toLowerCase()=="true"||String(b).toLowerCase()=="false")){d=String(b).toLowerCase()=="true"?c.trueString():c.falseString()}}}return d}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FTimeSep");sap.common.globalization.numericFormat.FTimeSep=function(b,a){this._parseLocale=b;this._displayLocale=a};sap.common.globalization.numericFormat.FTimeSep.prototype.parse=function(c,b){var a=b.charAt(0);if(this._displayLocale.IMTimeSeparator()!=null&&(a==":"||a==".")){return 1}else{return 0}};sap.common.globalization.numericFormat.FTimeSep.prototype.display=function(a){return this._displayLocale.IMTimeSeparator()}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FTUtil");sap.common.globalization.numericFormat.FTUtil.isBooleanFT=function(a){return a&&(a.__className=="sap.common.globalization.numericFormat.FTBoolean")};sap.common.globalization.numericFormat.FTUtil.isDate=function(a){return a&&a.o&&a.o.length>0&&(a.o[0].__className=="sap.common.globalization.numericFormat.FDate")}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");sap.common.globalization.numericFormat.TwoDigitGroupingStrategy=function(){this.__className="sap.common.globalization.numericFormat.TwoDigitGroupingStrategy"};var a=sap.common.globalization.numericFormat.TwoDigitGroupingStrategy;a._instance=new sap.common.globalization.numericFormat.TwoDigitGroupingStrategy();a.prototype.nextGroupDigits=function(){return 1};a.instance=function(){return a._instance}})();(function(){sap.common.globalization.declare("sap.common.globalization.numericFormat.FDefaultCurrencyNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.FNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.DefaultGroupingStrategy");var a=sap.common.globalization.numericFormat;sap.common.globalization.numericFormat.FDefaultCurrencyNumber=function(c,b){sap.common.globalization.numericFormat.FDefaultCurrencyNumber.superclass.constructor.apply(this,[c,b]);this.__className="sap.common.globalization.numericFormat.FDefaultCurrencyNumber";this._groupingStrategy=a.DefaultGroupingStrategy.instance()};a.FDefaultCurrencyNumber=sap.common.globalization.extend(a.FDefaultCurrencyNumber,a.FNumber);a.FDefaultCurrencyNumber.prototype.display=function(k){if(typeof(k)!="number"){return k}if(isNaN(k)||!isFinite(k)){return k}if(this.mfore.length==0&&this.maft.length==0){return this.format}this.setNumber(k);var q=new Array();var e=this.mfore.length;var c=3;var m=this.period;var f=(m==-1)?(this.mask.length):m;var g;var o;var p;for(var h=e-1;h>=0;h--){m=this.mfore[h];for(g=f-1;g>m;g--){p=this.mask[g];if((typeof p)=="object"){q.unshift(p.display)}else{q.unshift(p)}}if(this.numfore.length>0){if(this.bcomma){if(c--==0){q.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}}o=this.numfore.length-1;q.unshift(this.numfore.charAt(o));this.numfore=this.numfore.substring(0,o)}else{var n=this.mask[m].display;if(n.length!=0){if(this.bcomma&&c--==0){q.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}q.unshift(this.mask[m].display)}}f=m}if(this.numfore.length>0){if(this.bcomma){while(this.numfore.length>0){if(c--==0){q.unshift(this.IMThousandsSeparator);c=this._groupingStrategy.nextGroupDigits()}o=this.numfore.length-1;q.unshift(this.numfore.charAt(o));this.numfore=this.numfore.substring(0,o)}}else{q.unshift(this.numfore)}}p=this.mask;if(this.currencyIndex!=-1){h=0}for(g=f-1;g>=0;g--){if((typeof this.mask[g])=="object"){q.unshift(this.mask[g].display)}else{q.unshift(this.mask[g])}}e=this.mask.length;h=(this.period==-1)?(e):(this.period);m=0;for(;h<e;h++){if((typeof p[h])=="object"){if(this.maft[m]==h){m++;if(this.numaft.length>0){q.push(this.numaft.charAt(0));this.numaft=this.numaft.substring(1)}else{q.push(p[h].display)}}else{q.push(p[h].display)}}else{q.push(p[h])}}var b;if(this.bsign){b=this.sign+q.join("")}else{b=q.join("")}return b};a.FDefaultCurrencyNumber.prototype.groupingStrategy=function(b){if(this._groupingStrategy!=b){this._groupingStrategy=b}}})();(function(){sap.common.globalization.declare("sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.defaultFormat.DefaultNumericFormatLocaleFactory");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericConstant");sap.common.globalization.require("sap.common.globalization.numericFormat.FDefaultCurrencyNumber");sap.common.globalization.require("sap.common.globalization.numericFormat.TwoDigitGroupingStrategy");sap.common.globalization.require("sap.common.globalization.GlobalizationNumericUtil");sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory=function(b){sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory.superclass.constructor.apply(this,[b]);this.__className="sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory";this._displayCurrencySymbol=null;if(sap.common.globalization.defaultFormat.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat(b)){this._parseCurrencySymbol(b)}};var a=sap.common.globalization.defaultFormat;a.DefaultCurrencyFormatLocaleFactory=sap.common.globalization.extend(a.DefaultCurrencyFormatLocaleFactory,a.DefaultNumericFormatLocaleFactory);a.DefaultCurrencyFormatLocaleFactory.REG_DEFAULT_CURRENCY_FORMAT=new RegExp('^SAP_DEFAULT_CURRENCY_FORMAT(;".*")?$',"i");a.DefaultCurrencyFormatLocaleFactory.isDefaultCurrencyFormat=function(b){return a.DefaultCurrencyFormatLocaleFactory.REG_DEFAULT_CURRENCY_FORMAT.test(b)};a.DefaultCurrencyFormatLocaleFactory.prototype.getDefaultCurrencyFormat=function(){return sap.common.globalization.GlobalizationNumericConstant.getDefaultCurrencyFormat()};a.DefaultCurrencyFormatLocaleFactory.prototype._parseCurrencySymbol=function(b){if("SAP_DEFAULT_CURRENCY_FORMAT"==b){this._displayCurrencySymbol=""}else{this._displayCurrencySymbol=b.slice(29,b.length-1)}};a.DefaultCurrencyFormatLocaleFactory.prototype.createFNumber=function(){var b=new sap.common.globalization.numericFormat.FDefaultCurrencyNumber(this.getNumericParseLocaleInfo(),this.getNumericDisplayLocaleInfo());if(sap.common.globalization.GlobalizationNumericUtil.isTwoDigitGroupingCountry(sap.common.globalization.GlobalizationNumericConstant.getActualLocaleForDefaultCurrencyFormat())){b._groupingStrategy=sap.common.globalization.numericFormat.TwoDigitGroupingStrategy.instance()}return b};a.DefaultCurrencyFormatLocaleFactory.prototype.displayCurrencySymbol=function(){return this._displayCurrencySymbol}})();(function() {
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function(searchElement /* , fromIndex */) {
			"use strict";
			if (this == null) {
				throw new TypeError();
			}
			var t = Object(this);
			var len = t.length >>> 0;
			if (len === 0) {
				return -1;
			}
			var n = 0;
			if (arguments.length > 0) {
				n = Number(arguments[1]);
				if (n != n) { // shortcut for verifying if it's NaN
					n = 0;
				} else if (n != 0 && n != Infinity && n != -Infinity) {
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
				}
			}
			if (n >= len) {
				return -1;
			}
			var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
			for (; k < len; k++) {
				if (k in t && t[k] === searchElement) {
					return k;
				}
			}
			return -1;
		}
	}

	if (!Array.prototype.lastIndexOf) {
		Array.prototype.lastIndexOf = function(searchElement /* , fromIndex */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (len === 0)
				return -1;

			var n = len;
			if (arguments.length > 1) {
				n = Number(arguments[1]);
				if (n != n)
					n = 0;
				else if (n != 0 && n != (1 / 0) && n != -(1 / 0))
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}

			var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);

			for (; k >= 0; k--) {
				if (k in t && t[k] === searchElement)
					return k;
			}
			return -1;
		};
	}

	if (!Array.prototype.filter) {
		Array.prototype.filter = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var res = [];
			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t) {
					var val = t[i]; // in case fun mutates this
					if (fun.call(thisp, val, i, t))
						res.push(val);
				}
			}

			return res;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.18
	// Reference: http://es5.github.com/#x15.4.4.18
	if (!Array.prototype.forEach) {

		Array.prototype.forEach = function(callback, thisArg) {

			var T, k;

			if (this == null) {
				throw new TypeError("this is null or not defined");
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			// value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal method
			// of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0; // Hack to convert O.length to a UInt32

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be
			// undefined.
			if (thisArg) {
				T = thisArg;
			}

			// 6. Let k be 0
			k = 0;

			// 7. Repeat, while k < len
			while (k < len) {

				var kValue;

				// a. Let Pk be ToString(k).
				// This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty
				// internal method of O with argument Pk.
				// This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					// method of O with argument Pk.
					kValue = O[k];

					// ii. Call the Call internal method of callback with T as
					// the this value and
					// argument list containing kValue, k, and O.
					callback.call(T, kValue, k, O);
				}
				// d. Increase k by 1.
				k++;
			}
			// 8. return undefined
		};
	}

	if (!Array.prototype.every) {
		Array.prototype.every = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t && !fun.call(thisp, t[i], i, t))
					return false;
			}

			return true;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.19
	// Reference: http://es5.github.com/#x15.4.4.19
	if (!Array.prototype.map) {
		Array.prototype.map = function(callback, thisArg) {

			var T, A, k;

			if (this == null) {
				throw new TypeError(" this is null or not defined");
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			// value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal method
			// of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0;

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be
			// undefined.
			if (thisArg) {
				T = thisArg;
			}

			// 6. Let A be a new array created as if by the expression new
			// Array(len) where Array is
			// the standard built-in constructor with that name and len is the
			// value of len.
			A = new Array(len);

			// 7. Let k be 0
			k = 0;

			// 8. Repeat, while k < len
			while (k < len) {

				var kValue, mappedValue;

				// a. Let Pk be ToString(k).
				// This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty
				// internal method of O with argument Pk.
				// This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					// method of O with argument Pk.
					kValue = O[k];

					// ii. Let mappedValue be the result of calling the Call
					// internal method of callback
					// with T as the this value and argument list containing
					// kValue, k, and O.
					mappedValue = callback.call(T, kValue, k, O);

					// iii. Call the DefineOwnProperty internal method of A with
					// arguments
					// Pk, Property Descriptor {Value: mappedValue, Writable:
					// true, Enumerable: true, Configurable: true},
					// and false.

					// In browsers that support Object.defineProperty, use the
					// following:
					// Object.defineProperty(A, Pk, { value: mappedValue,
					// writable: true, enumerable: true, configurable: true });

					// For best browser support, use the following:
					A[k] = mappedValue;
				}
				// d. Increase k by 1.
				k++;
			}

			// 9. return A
			return A;
		};
	}

	if (!Array.prototype.some) {
		Array.prototype.some = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t && fun.call(thisp, t[i], i, t))
					return true;
			}

			return false;
		};
	}

	if (!Array.prototype.reduce) {
		Array.prototype.reduce = function reduce(accumulator) {
			if (this === null || this === undefined)
				throw new TypeError("Object is null or undefined");
			var i = 0, l = this.length >> 0, curr;

			if (typeof accumulator !== "function") // ES5 : "If
				// IsCallable(callbackfn) is
				// false, throw a TypeError
				// exception."
				throw new TypeError("First argument is not callable");

			if (arguments.length < 2) {
				if (l === 0)
					throw new TypeError("Array length is 0 and no second argument");
				curr = this[0];
				i = 1; // start accumulating at the second element
			} else
				curr = arguments[1];

			while (i < l) {
				if (i in this)
					curr = accumulator.call(undefined, curr, this[i], i, this);
				++i;
			}

			return curr;
		};
	}

	if (!Array.prototype.reduceRight) {
		Array.prototype.reduceRight = function(callbackfn /* , initialValue */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof callbackfn != "function")
				throw new TypeError();

			// no value to return if no initial value, empty array
			if (len === 0 && arguments.length === 1)
				throw new TypeError();

			var k = len - 1;
			var accumulator;
			if (arguments.length >= 2) {
				accumulator = arguments[1];
			} else {
				do {
					if (k in this) {
						accumulator = this[k--];
						break;
					}

					// if array contains no values, no initial value to return
					if (--k < 0)
						throw new TypeError();
				} while (true);
			}

			while (k >= 0) {
				if (k in t)
					accumulator = callbackfn.call(undefined, accumulator, t[k], k, t);
				k--;
			}

			return accumulator;
		};
	}

	if (!Function.prototype.bind) {
		Function.prototype.bind = function(oThis) {
			if (typeof this !== "function") {
				// closest thing possible to the ECMAScript 5 internal
				// IsCallable function
				throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
			}

			var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {
			}, fBound = function() {
				return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice
						.call(arguments)));
			};

			fNOP.prototype = this.prototype;
			fBound.prototype = new fNOP();

			return fBound;
		};
	}

	if (!Object.create) {
		// this is the polyfill implementation covers the main use case
		Object.create = function(o) {
			if (arguments.length > 1) {
				throw new Error('Object.create implementation only accepts the first parameter.');
			}
			function F() {
			}
			F.prototype = o;
			return new F();
		};
	}

	function defineProperties(obj, properties) {
		// this is the polyfill implementation covers the main use case
		function convertToDescriptor(desc) {
			function hasProperty(obj, prop) {
				return Object.prototype.hasOwnProperty.call(obj, prop);
			}

			function isCallable(v) {
				// NB: modify as necessary if other values than functions are
				// callable.
				return typeof v === "function";
			}

			if (typeof desc !== "object" || desc === null)
				throw new TypeError("bad desc");

			var d = {};
			if (hasProperty(desc, "enumerable"))
				d.enumerable = !!obj.enumerable;
			if (hasProperty(desc, "configurable"))
				d.configurable = !!obj.configurable;
			if (hasProperty(desc, "value"))
				d.value = obj.value;
			if (hasProperty(desc, "writable"))
				d.writable = !!desc.writable;
			if (hasProperty(desc, "get")) {
				var g = desc.get;
				if (!isCallable(g) && g !== "undefined")
					throw new TypeError("bad get");
				d.get = g;
			}
			if (hasProperty(desc, "set")) {
				var s = desc.set;
				if (!isCallable(s) && s !== "undefined")
					throw new TypeError("bad set");
				d.set = s;
			}

			if (("get" in d || "set" in d) && ("value" in d || "writable" in d))
				throw new TypeError("identity-confused descriptor");

			return d;
		}

		if (typeof obj !== "object" || obj === null)
			throw new TypeError("bad obj");

		properties = Object(properties);
		var keys = Object.keys(properties);
		var descs = [];
		for ( var i = 0; i < keys.length; i++)
			descs.push([ keys[i], convertToDescriptor(properties[keys[i]]) ]);
		for ( var i = 0; i < descs.length; i++)
			Object.defineProperty(obj, descs[i][0], descs[i][1]);

		return obj;
	}

	if (!Object.keys) {
		Object.keys = (function() {
			var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !({
				toString : null
			}).propertyIsEnumerable('toString'), dontEnums = [ 'toString', 'toLocaleString', 'valueOf',
					'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor' ], dontEnumsLength = dontEnums.length

			return function(obj) {
				if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null)
					throw new TypeError('Object.keys called on non-object')

				var result = []

				for ( var prop in obj) {
					if (hasOwnProperty.call(obj, prop))
						result.push(prop)
				}

				if (hasDontEnumBug) {
					for ( var i = 0; i < dontEnumsLength; i++) {
						if (hasOwnProperty.call(obj, dontEnums[i]))
							result.push(dontEnums[i])
					}
				}
				return result
			}
		})()
	}

	if (typeof Object.getPrototypeOf !== "function") {
		if (typeof "test".__proto__ === "object") {
			Object.getPrototypeOf = function(object) {
				return object.__proto__;
			};
		} else {
			Object.getPrototypeOf = function(object) {
				// May break if the constructor has been tampered with
				return object.constructor.prototype;
			};
		}
	}

	if (!String.prototype.trim) {
		String.prototype.trim = function() {
			return this.replace(/^\s+|\s+$/g, '');
		};
	}

	var undefined = void (0);
	if (window.sap !== undefined && window.sap.riv !== undefined && window.sap.riv.module !== undefined) {
		// In case of already defined
		return;
	}

	var isJQueryUsed = typeof jQuery !== 'undefined' ? true : false

	var jQueryHoldReady = function(shouldHold) {
		if (isJQueryUsed) {
			if (jQuery.holdReady) {
				jQuery.holdReady(shouldHold);
			} else if (shouldHold) {
				jQuery.readyWait += 1;
			} else {
				jQuery.ready(true);
			}
		}
	}
	var curScript = undefined;
	var context_path = '/';
	var scripts = document.getElementsByTagName("script");
	var trace = function() {
	};
	// Look for a base-url script attribute, which could adjust the baseUrl.
	if (scripts.length && scripts[scripts.length - 1].getAttribute('src')
			&& scripts[scripts.length - 1].getAttribute('base-url')) {
		curScript = scripts[scripts.length - 1];
		if (((curScript.getAttribute('trace') || '').toLowerCase() === 'true') && (typeof console !== undefined)) {
			trace = function(traceLog) {
				console.log(traceLog);
			};
		}

		var context_path = curScript.getAttribute('base-url');
		if (context_path.charAt(context_path.length - 1) !== '/')
			context_path = context_path + '/';
	} else {
		context_path = "./";
	}

	window.sap = window.sap || {};
	window.sap.riv = window.sap.riv || {};

	var ENTRY_CREATED = 0, IN_LOADING = 1, DEFINED = 2, ERROR = 3;

	var hasOwn = Object.prototype.hasOwnProperty;

	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	var isFunction = function(obj) {
		return type(obj) === "function";
	};

	var isArray = Array.isArray || function(obj) {
		return type(obj) === "array";
	};

	var isString = function(obj) {
		return type(obj) === "string";
	};

	// A crude way of determining if an object is a window
	var isWindow = function(obj) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	};

	var isNaN = function(obj) {
//		return obj == null || !/\d/.test(obj) || isNaN(obj);
		return obj === null || obj === undefined || obj != +obj;
	};

	var isNumber = function(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};

	var isDefined = function(v) {
		return typeof (v) !== 'undefined';
	};

	var isUndefined = function(v) {
		return typeof (v) === 'undefined';
	};

	var isPlainObject = function(obj) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the
		// constructor property.
		// Make sure that DOM nodes and window objects don't pass through,
		// as well
		if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
			return false;
		}

		// Not own constructor property must be Object
		if (obj.constructor && !hasOwn.call(obj, "constructor")
				&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for (key in obj) {
		}

		return key === undefined || hasOwn.call(obj, key);
	};

	var isEmptyObject = function(obj) {
		for ( var name in obj) {
			return false;
		}
		return true;
	};

	var ModuleEntry = function(qname, version) {
		this._qname = qname;
		this._version = version;
		this._moduleSetupFunc = undefined;
		this._status = ENTRY_CREATED;
		this._moduleObject = undefined;
		this._exportToGlobal = false;
		this._depList = [];
		this._pendingDefTaskList = [];
		jQueryHoldReady(true);
	};
	ModuleEntry.prototype.moduleObject = function(moduleObj) {
		return this._moduleObject;
	};
	ModuleEntry.prototype.setupFunction = function(setupFunction) {
		if (isDefined(setupFunction)) {
			this._moduleSetupFunc = setupFunction;
			return this;
		} else {
			return this._moduleSetupFunc;
		}
	};
	ModuleEntry.prototype.setModuleObject = function(moduleObj) {
		this._moduleObject = moduleObj;
	};
	ModuleEntry.prototype.qname = function() {
		return this._qname;
	};
	ModuleEntry.prototype.version = function() {
		return this._version;
	};
	ModuleEntry.prototype.status = function(status) {
		if (status !== undefined) {
			this._status = status;
			return this;
		} else {
			return this._status;
		}
	};
	ModuleEntry.prototype.dependentModules = function(depList) {
		if (isDefined(depList)) {
			this._depList = depList;
			return this;
		} else {
			return this._depList;
		}
	};
	ModuleEntry.prototype.exportToGlobal = function(exportToGlobal) {
		if (isDefined(exportToGlobal)) {
			this._exportToGlobal = exportToGlobal;
			return this;
		} else {
			return this._exportToGlobal;
		}

	};

	ModuleEntry.prototype.waitUntilDefined = function(pendingDefTask) {
		this._pendingDefTaskList.push(pendingDefTask);
	};
	ModuleEntry.prototype.getPendingDefTasks = function() {
		return this._pendingDefTaskList;
	};

	// A global pool for containing all of the managed modules
	var modulesPool = {};
	// Register loaded url
	var loadedURLs = {};

	var loader = function(url, callback) { //modularizing jQuery: add callback
		if (!loadedURLs.hasOwnProperty(url)) {
			loadedURLs[url] = false;
			var head = document.getElementsByTagName("head")[0] || document.documentElement;
			var script = document.createElement("script");
			script.type = 'text/javascript';
			script.src = url;
			// Handle Script loading
			var done = false;
			// Attach handlers for all browsers
			script.onload = script.onreadystatechange = function() {
				if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
					done = true;
					// Handle memory leak in IE
					script.onload = script.onreadystatechange = null;
					if (head && script.parentNode) {
						head.removeChild(script);
					}
					loadedURLs[url] = true;
					if (callback) {
						callback();
					}
				}
			};
			if (script.addEventListener) {
				script.addEventListener('error', function() {
					throw new Error('Loading ' + url + ' failed.')
				}, true);
			}
			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709 and #4378).
			head.insertBefore(script, head.firstChild);
			// We handle everything using the script element injection
		}

		return undefined;
	};

	var isValidSemanticVersion = function(semver) {
		if (semver === undefined || typeof semver !== 'string') {
			return false;
		}
		var components = semver.split('.');
		if (components.length > 3) {
			return false;
		}
		for ( var i = 0, len = components.length; i < len; i++) {
			if (parseInt(components[i]) === NaN) {
				return false;
			}
		}
		return true;
	};

	var buildModuleURL = function(qname, version) {
		var paths = qname.split('.');
		var fileName = paths.splice(paths.length - 1, 1);
		return context_path + paths.join('/') + '/' + fileName + '.' + version + '.js';
	};

	var setupModule = function(moduleEntry) {
		var moduleObject;
		if (isFunction(moduleEntry.setupFunction())) {
			var args = [];
			for ( var i = 0, depModule, depModuleList = moduleEntry.dependentModules(), len = depModuleList.length; i < len; i++) {
				depModule = depModuleList[i];
				args.push(modulesPool[depModule.qname][depModule.version].moduleObject());
			}
			moduleObject = moduleEntry.setupFunction().apply(window, args);
		} else {
			moduleObject = moduleEntry.moduleObject();
		}
		if (moduleEntry.exportToGlobal()) {
			var qnameComps = moduleEntry.qname().split('.');
			var attachTo = window;
			for ( var i = 0, part, len = qnameComps.length; i < len; i++) {
				part = qnameComps[i];
				if (i === len - 1) {
					attachTo[part] = moduleObject;
				} else {
					attachTo[part] = attachTo[part] || {};
					attachTo = attachTo[part];
				}
			}
		}
		moduleEntry.setModuleObject(moduleObject);
		moduleEntry.status(DEFINED);
		trace(moduleEntry.qname() + ' ' + moduleEntry.version() + ' loaded')
		// Resume the definition tasks that are blocked on this module
		var pendingTasks = moduleEntry.getPendingDefTasks();
		while (pendingTasks.length) {
			var pendingTask = pendingTasks.pop();
			pendingTask(moduleEntry);
		}
		jQueryHoldReady(false)
	};

	var createPendingDefTask = function(waitedModules, moduleEntry) {
		return (function(availableModuleEntry) {
			// remove the available module from the waited modules
			delete waitedModules[availableModuleEntry.qname()][availableModuleEntry.version()];
			if (isEmptyObject(waitedModules[availableModuleEntry.qname()])) {
				delete waitedModules[availableModuleEntry.qname()];
			}
			if (isEmptyObject(waitedModules)) {
				setupModule(moduleEntry);
			}
		});
	};

	sap.riv.module = function(moduleCfg, dependencies, moduleSetupFunc) {
		if (isUndefined(moduleCfg) || isUndefined(moduleCfg.qname) || isUndefined(moduleCfg.version)) {
			throw new Error('Bad Arguments: you have to specify the qname and version for the module.');
		}
		if (!isString(moduleCfg.qname) || !isValidSemanticVersion(moduleCfg.version)) {
			throw new Error('Invalid qname or version string');
		}
		if (arguments.length === 2) {
			if (!isPlainObject(dependencies) && !isFunction(dependencies)) {
				throw new Error('You must specify a plain object or a module setup function');
			}
			moduleSetupFunc = dependencies;
			dependencies = [];
		}
		if (arguments.length === 3) {
			if (!isArray(dependencies) || (!isPlainObject(moduleSetupFunc) && !isFunction(moduleSetupFunc))) {
				throw new Error(
						'Dependencies must be array, and you must specify an plain object or a module setup function');
			}
		}
		var qname = moduleCfg.qname, version = moduleCfg.version, exportToGlobal = isUndefined(moduleCfg.exported) ? false
				: moduleCfg.exported, moduleEntry;

		if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool, version)) {
			modulesPool[qname] = modulesPool[qname] || {};
			modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
		}
		moduleEntry = modulesPool[qname][version];

		if (moduleEntry.status() === ENTRY_CREATED) {
			// The depending module is just created for the loading
			if (typeof moduleSetupFunc === 'object') {
				// Module is just a plain object
				moduleEntry.exportToGlobal(exportToGlobal).setModuleObject(moduleSetupFunc);
			} else {
				var depList = [];
				for ( var i = 0, depModule, len = dependencies.length; i < len; i++) {
					depModule = dependencies[i];
					if (!isString(depModule.qname) || !isValidSemanticVersion(depModule.version)) {
						throw new Error('You must specify qname and version for the depending module');
					}
					depList.push({
						qname : depModule.qname,
						version : depModule.version
					});
				}
				moduleEntry.exportToGlobal(exportToGlobal).dependentModules(depList).setupFunction(moduleSetupFunc);
			}
		}

		if (moduleEntry.status() === DEFINED || moduleEntry.status() === IN_LOADING) {
			return;
		}
		moduleEntry.status(IN_LOADING);

		if (moduleEntry.dependentModules().length === 0) {
			setupModule(moduleEntry);
			return;
		} else {
			var waitedModules = {};
			for ( var i = 0, dep, depList = moduleEntry.dependentModules(), len = depList.length; i < len; i++) {
				dep = depList[i];
				if (!(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))
						|| (modulesPool[dep.qname][dep.version].status() !== DEFINED)) {
					//modularizing jQuery: if the specific version doesn't exist, match a minimal higher version
					if (dep.qname === JQUERY && !(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))) {
						dep.version = findMinHigherJQueryVersion(dep.version);
						if (modulesPool[dep.qname][dep.version].status() === DEFINED) {
							continue;
						}
					}
					// The depending module is not ready, either because of not
					// loaded yet or because of pending on defining
					waitedModules[dep.qname] = waitedModules[dep.qname] || {};
					waitedModules[dep.qname][dep.version] = waitedModules[dep.qname][dep.version] || {
						qname : dep.qname,
						version : dep.version,
						url : dep.url || buildModuleURL(dep.qname, dep.version)
					};
				}
			}
			if (isEmptyObject(waitedModules)) {
				// All the depending modules are ready
				setupModule(moduleEntry);
				return;
			} else {
				// Some of the depending modules are not ready, either because
				// of not loaded yet or because of pending on defining
				for ( var qname in waitedModules) {
					for ( var version in waitedModules[qname]) {
						if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool[qname], version)) {
							// if it's a brand new module, then create a entry
							// for it
							modulesPool[qname] = modulesPool[qname] || {};
							modulesPool[qname][version] = modulesPool[qname][version]
									|| new ModuleEntry(qname, version);
							// TODO check circular dependencies
							modulesPool[qname][version].waitUntilDefined(createPendingDefTask(waitedModules,
									moduleEntry));
							// TODO handle loading error
							loader(waitedModules[qname][version].url);
						} else {
							// if it's not ready(either is loading or not), wait
							// until it's done
							modulesPool[qname][version].waitUntilDefined(createPendingDefTask(waitedModules,
									moduleEntry));
						}
					}
				}
			}
		}
	};

	/*modularizing jQuery Start*/
	var JQUERY = 'jquery';
	var findMinHigherJQueryVersion = function(expVerStr) {
		var expVer = +expVerStr,
			minVer;
		if (isNaN(expVer)) {
			throw TypeError(expVerStr + ' is not an one-decimal number.');
		}
		for (var ver in modulesPool[JQUERY]) {
			if (+ver > expVer && (minVer === undefined || +ver < minVer)) {
				minVer = ver;
			}
		}
		if (minVer === undefined) {
			throw Error("Can't find a jQuery module with version " + expVerStr + " or higher.");
		}
		return '' + minVer;		
	};
	sap.riv.config = (function(){
		var JQUERY_PREFIX = JQUERY + '-';
		var registerJQueryAsModule = function(version, loaded, url) {
			var qname = JQUERY, moduleEntry;
			version = '' + version;
			if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool, version)) {
				modulesPool[qname] = modulesPool[qname] || {};
				modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
			}
			moduleEntry = modulesPool[qname][version];
			if (moduleEntry.status() === ENTRY_CREATED) {
				moduleEntry.setupFunction(function() {
					var _jQuery = $;
					if (!loaded) {
						$.noConflict();
					}
					return _jQuery;
				});
			}		
			if (moduleEntry.status() === DEFINED || moduleEntry.status() === IN_LOADING) {
				return;
			}		
			moduleEntry.status(IN_LOADING);		
			if (loaded === true) {
				setupModule(moduleEntry);
			} else {
				loader(url, function() {
					setupModule(moduleEntry);
				});			
			}
		};
		var trimJQueryVersion = function(versionStr) {
			var comps = versionStr.split('.');
			var version = +(comps[0] + '.' + comps[1]);
			if (isNaN(version)) {
				console.warn("Can't parse version number from " + version);
				return undefined;
			}
			return version;
		};
		if (typeof $ !== 'undefined') {
			if ($ && $.fn && $.fn.jquery) {
				var version = trimJQueryVersion($.fn.jquery);
				registerJQueryAsModule(version, true);
			}
		}
		return function(config) {
			if (!config.paths) return;
			for (var name in config.paths) {
				if (name <= JQUERY_PREFIX.length || name.indexOf(JQUERY_PREFIX) !== 0) {
					console.warn('Unknown config option "' + name + '", must start with jquery-');
					continue;
				}
				var comps = name.substring(JQUERY_PREFIX.length).split('.');
				var version = +(comps[0] + '.' + comps[1]);
				if (isNaN(version)) {
					console.warn("Can't parse version number from " + name);
					continue;
				}
				var url = config.paths[name];
				if (url.indexOf(':') < 0 && url.charAt(0) !== '/') { //relative path
					url = context_path + url;
				}
				//load js from url
				registerJQueryAsModule(version, false, url);
			}
		};		
	})();
	/*modularizing jQuery End*/
	
	var executeRequiredFunction = function(requiredFunction, requiredModules) {
		var args = [];
		for ( var i = 0, requiredModule, len = requiredModules.length; i < len; i++) {
			requiredModule = requiredModules[i];
			args.push(modulesPool[requiredModule.qname][requiredModule.version].moduleObject());
		}
		requiredFunction.apply(window, args);
	};

	var createPendingRequireTask = function(waitedModules, requiredFunc, requiredModules) {
		return (function(availableModuleEntry) {
			// remove the available module from the waited modules
			delete waitedModules[availableModuleEntry.qname()][availableModuleEntry.version()];
			if (isEmptyObject(waitedModules[availableModuleEntry.qname()])) {
				delete waitedModules[availableModuleEntry.qname()];
			}
			if (isEmptyObject(waitedModules)) {
				executeRequiredFunction(requiredFunc, requiredModules);
			}
		});
	};

	sap.riv.require = function(dependencies, requireFunc) {
		if (arguments.length === 1) {
			if (!isFunction(dependencies)) {
				throw new Error('You have to specify a function to run');
			}
			requireFunc = dependencies;
			dependencies = [];
		}
		if (arguments.length === 2) {
			if (!isArray(dependencies) || !isFunction(requireFunc)) {
				throw new Error(
						'the first argument has to be array of depending modules, the second argument should be function type');
			}
		}

		if (!dependencies.length) {
			// No dependencies specified, execute it right away.
			executeRequiredFunction(requireFunc, dependencies);
			return;
		}

		var waitedModules = {};
		for ( var i = 0, dep, len = dependencies.length; i < len; i++) {
			dep = dependencies[i];
			if (!(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))
					|| (modulesPool[dep.qname][dep.version].status() !== DEFINED)) {
				//modularizing jQuery: if the specific version doesn't exist, match a minimal higher version
				if (dep.qname === JQUERY && !(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))) {
					dep.version = findMinHigherJQueryVersion(dep.version);
					if (modulesPool[dep.qname][dep.version].status() === DEFINED) {
						continue;
					}
				}
				// The depending module is not ready, either because of not
				// loaded yet or because of pending on defining
				waitedModules[dep.qname] = waitedModules[dep.qname] || {};
				waitedModules[dep.qname][dep.version] = waitedModules[dep.qname][dep.version] || {
					qname : dep.qname,
					version : dep.version,
					url : dep.url || buildModuleURL(dep.qname, dep.version)
				};
			}
		}
		if (isEmptyObject(waitedModules)) {
			// All the depending modules are ready
			executeRequiredFunction(requireFunc, dependencies);
			return;
		} else {
			// Some of the depending modules are not ready, either because
			// of not loaded yet or because of pending on defining
			for ( var qname in waitedModules) {
				for ( var version in waitedModules[qname]) {
					if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool[qname], version)) {
						// if it's a brand new module, then create a entry
						// for it
						modulesPool[qname] = modulesPool[qname] || {};
						modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
						// TODO check circular dependencies
						modulesPool[qname][version].waitUntilDefined(createPendingRequireTask(waitedModules,
								requireFunc, dependencies));
						// TODO handle loading error
						loader(waitedModules[qname][version].url);
					} else {
						// if it's not ready(either is loading or not), wait
						// until it's done
						modulesPool[qname][version].waitUntilDefined(createPendingRequireTask(waitedModules,
								requireFunc, dependencies));
					}
				}
			}
		}
	};

	// Evalulates a script in a global context
	var globalEval = function(data) {
		if (data && /\S/.test(data)) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.getElementsByTagName("head")[0] || document.documentElement, script = document
					.createElement("script");

			script.type = "text/javascript";

			try {
				script.appendChild(document.createTextNode(data));
			} catch (e) {
				script.text = data;
			}

			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709).
			head.insertBefore(script, head.firstChild);
			head.removeChild(script);
		}
	};

	sap.riv.setBaseUrl = function(url) {
		context_path = url;
	};
	// if the base js is not loaded via script tag, skip the evaluating of
	// embeded script.
	if (curScript) {
		var script = curScript.innerHTML;
		if (script) {
			globalEval(script);
		}
	}
})();sap.riv.module(
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'},
[

],
function Setup() {
	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var hasOwn = Object.prototype.hasOwnProperty;
	// Used for trimming whitespace
	var rdigit = /\d/;

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	/**
	 * Type Utilities for common variable type related tasks
	 * 
	 * @name sap.viz.base.utils.TypeUtils
	 * @class
	 */
	var typeUtils = {

		/**
		 * Returns a boolean value indicating whether the parameter is of type
		 * function
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction : function(obj) {
			return type(obj) === "function";
		},

		/**
		 * Returns a boolean value indicating whether the parameter is of type
		 * array
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isArray : Array.isArray || function(obj) {
			return type(obj) === "array";
		},

		/**
		 * Returns a boolean value indicating whether the parameter is of type
		 * string
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isString : function(obj) {
			return type(obj) === "string";
		},

		/**
		 * Returns a boolean value indicating whether the parameter is a
		 * non-empty string
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isNonEmptyString : function(obj) {
			return this.isString(obj) && obj.length !== 0;
		},


		/**
		 * Returns a boolean value indicating whether the parameter is NaN
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isNaN : function(obj) {
			return obj === null || obj === undefined || !rdigit.test(obj) || isNaN(obj);
		},

		/**
		 * Returns a boolean value indicating whether the parameter is a number
		 * 
		 * @param {object}
		 * @returns {boolean} Caution: isNumber(Infinity) returns false.
		 */
		isNumber : function(n) {
			return !typeUtils.isNaN(parseFloat(n)) && isFinite(n);
		},

		/**
		 * Returns a boolean value indicating whether the parameter is defined
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isDefined : function(v) {
			return typeof (v) !== 'undefined';
		},

		/**
		 * Returns a boolean value indicating whether the parameter is undefined
		 * 
		 * @param {object}
		 * @returns {boolean}
		 */
		isUndefined : function(v) {
			return typeof (v) === 'undefined';
		},

		/**
		 * Returns a boolean value indicating whether the parameter is a plain
		 * object
		 * 
		 * @param {object}
		 * @returns {boolean} Caution: A plain object is an object that has no
		 *          prototype method and no parent class. Null, undefined, DOM
		 *          nodes and window object are not considered as plain object.
		 */
		isPlainObject : function(obj) {
			// Must be an Object.
			// Because of IE, we also have to check the presence of the
			// constructor property.
			// Make sure that DOM nodes and window objects don't pass through,
			// as well
			if (!obj || type(obj) !== "object" || obj.nodeType
					|| (obj && typeof obj === "object" && "setInterval" in obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor")
					&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.

			var key;
			for (key in obj) {
			}

			return key === undefined || hasOwn.call(obj, key);
		},

		/**
		 * Returns a boolean value indicating whether the parameter is an empty
		 * object
		 * 
		 * @param {object}
		 * @returns {boolean} Caution: An empty is a plain object without any
		 *          properties.
		 */
		isEmptyObject : function(obj) {
			for ( var name in obj) {
				return false;
			}
			return typeUtils.isPlainObject(obj);
		},

		equals : function(x, y) {
		    var p;
			if (x === y){
				return true;
			}
			if (!(x instanceof Object) || !(y instanceof Object) || (x.constructor !== y.constructor)){
				return false;
			}
				
			for (p in x) {
				if (!x.hasOwnProperty(p))
					continue;
				if (!y.hasOwnProperty(p))
					return false;
				if (x[p] === y[p])
					continue;
				if (typeof (x[p]) !== "object" || !typeUtils.equals(x[p], y[p]))
					return false;
			}

			for (p in y) {
				if (y.hasOwnProperty(p) && !x.hasOwnProperty(p)){
					return false;
				}
			}
			return true;
		}
	};

	return typeUtils;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils) {
	var msgparas = /\{(\d+)\}/g;
	var ArraySlice = Array.prototype.slice
	function emptyFn() {
	}

	function error(msg) {
		var args = arguments;
		if (args[0]) {
			var msg = args[0].replace(msgparas, function(m, n) {
				return args[parseInt(n) + 1];
			});
			throw msg;
		} else {
			throw 'Unknown error!';
		}
	}

	function createCallChain() {
		var callChain = [];
		function ChainedFunc() {
			for ( var i = 0, len = callChain.length; i < len; i++) {
				callChain[i].apply(this, arguments);
			}
		}
		function buildChain() {
			for ( var i = 0, len = arguments.length; i < len; i++) {
				if (TypeUtils.isFunction(arguments[i])) {
					callChain.push(arguments[i]);
				} else {
					error('Could not create call chain for non-function object');
				}
			}
		}
		ChainedFunc.chain = function() {
			return createCallChain.apply(null, [].concat(callChain, ArraySlice.call(arguments)));
		};
		buildChain.apply(null, arguments);
		return ChainedFunc;
	}

	var funcUtils = {
		/**
		 * empty function
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#noop
		 * @function
		 */
		noop : emptyFn,

		/**
		 * Function throwing unsupported exception with constant error message,
		 * or make a new function which could throw exception with specified
		 * error message
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#unsupported
		 * @function
		 * 
		 * @param {String}
		 *            (msg)
		 * @return {Function}
		 * @throw {Error}
		 */
		unsupported : function(msg) {
			if (arguments.length) {
				return function() {
					throw new Error(msg || 'Unsupported function!');
				};
			} else
				throw new Error('Unsupported function!');
		},

		/**
		 * function throwing unimplemented exception
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#unimplemented
		 * @function
		 */
		unimplemented : function(msg) {
			if (arguments.length) {
				return function() {
					throw new Error(msg || 'Unimplemented function!');
				};
			} else
				throw new Error('Unimplemented function!');
		},

		/**
		 * function throwing error
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#error
		 * @param {String}
		 *            msg the error message
		 * @function
		 */
		error : error,

		/**
		 * Return a number comparator for ascendent sorting
		 * 
		 * @param a
		 * @param b
		 * @returns todo
		 */
		ascending : function(a, b) {
			return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
		},
		/**
		 * Return a number comparator for descendent sorting
		 * 
		 * @param a
		 * @param b
		 * @returns todo
		 */
		descending : function(a, b) {
			return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
		},

		createCallChain : createCallChain
	};

	return funcUtils;
});sap.riv.module(
{
  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils, FunctionUtils){


   /**
    * @name sap.viz.data.MultiAxesDataAdapter
    * @constructor
      */
   function MultiAxesDataAdapter(bindingInfo){
     this._bindingInfo = bindingInfo;
     this._aa  = [];
     this._mg  = [];
     this._fakeData = false;
     this._dataPointCount = 0;
     this._emptyDataset = false;
   }
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#addAnalysisAxis
    * @function
    * @param {Object} aa
    */
   MultiAxesDataAdapter.prototype.addAnalysisAxis = function(aa){
        if(aa){
           this._aa.push(aa);
        }
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#addMeasureValuesGroup
    * @function 
    * @param {Object} mg
    */
   MultiAxesDataAdapter.prototype.addMeasureValuesGroup = function(mg){
        if(mg){
          this._mg.push(mg);
        }
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#getAnalysisAxisDataByIdx
    * @function 
    * @param {Object} index
    */
   MultiAxesDataAdapter.prototype.getAnalysisAxisDataByIdx = function(idx){
     if(!arguments.length){
        return this._aa;
     }
     
     for(var i = 0; i < this._aa.length; i++){
       if(this._aa[i].index === idx){
          return this._aa[i];
       }
     }
     
     return null;
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#getMeasureValuesGroupDataByIdx
    * @function 
    * @param {Object} index
    */
   MultiAxesDataAdapter.prototype.getMeasureValuesGroupDataByIdx = function(idx){
     if(!arguments.length){
        return this._mg;
     }
     
     for(var i = 0; i < this._mg.length; i++){
       if(this._mg[i].index === idx){
          return this._mg[i];
       }
     }
     
     return null;
   };
   
   MultiAxesDataAdapter.prototype.createDataAdapterForModule = function(ctx){
     
      var subDataAdapter = new MultiAxesDataAdapter();
      var i;
      if(ctx && ctx.aa){
        for(i = 0; i < ctx.aa.length; i++){
          var aa = this.getAnalysisAxisDataByIdx(ctx.aa[i] - 1);
          if(aa){
             subDataAdapter.addAnalysisAxis({index:i, values: aa.values});
          }
        } 
      }
      
      if(ctx && ctx.mg){
        for(i = 0; i < ctx.mg.length; i++){
          var mg = this.getMeasureValuesGroupDataByIdx(ctx.mg[i] - 1);
          if(mg){
             subDataAdapter.addMeasureValuesGroup({index: i, values: mg.values});
          }
        }
      }
      
      return subDataAdapter;
     
   };
   
   MultiAxesDataAdapter.prototype.getBindingInfo = function(){
        return this._bindingInfo;
   };
   
   MultiAxesDataAdapter.prototype.fakeData = function(_){
     if (!arguments.length){
         return this._fakeData;
     }
     
     this._fakeData = _;
   };
   

   MultiAxesDataAdapter.prototype.dataPointCount = function(_){
     if (!arguments.length){
       return this._dataPointCount;
     }
     
     this._dataPointCount = _;
   };
   
   MultiAxesDataAdapter.prototype.emptyDataset = function(_){
     if (!arguments.length){
         return this._emptyDataset;
     }
     
     this._emptyDataset = _;
   };
   
   return MultiAxesDataAdapter;
   
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils, FuncUtils) {
	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/, rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
			rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
			rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;

	/**
	 * Frequently used object utilities
	 * 
	 * @name sap.viz.base.utils.ObjectUtils
	 * @class
	 */
	var objUtils = {
		// Copy from jQuery
		extend : function() {
			var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

			// Handle a deep copy situation
			if (typeof target === "boolean") {
				deep = target;
				target = arguments[1] || {};
				// skip the boolean and the target
				i = 2;
			}

			// Handle case when target is a string or something (possible in
			// deep
			// copy)
			if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
				target = {};
			}

			// extend jQuery itself if only one argument is passed
			if (length === i) {
				target = this;
				--i;
			}

			for (; i < length; i++) {
				// Only deal with non-null/undefined values
				if ((options = arguments[i]) != null) {
					// Extend the base object
					for (name in options) {
						src = target[name];
						copy = options[name];

						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (TypeUtils.isPlainObject(copy) || (copyIsArray = TypeUtils.isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && TypeUtils.isArray(src) ? src : [];

							} else {
								clone = src && TypeUtils.isPlainObject(src) ? src : {};
							}
							// Never move original objects, clone them
							target[name] = objUtils.extend(deep, clone, copy);
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}
			}
			// Return the modified object
			return target;
		},

		// args is for internal usage only
		each : function(object, callback, args) {
			var name, i = 0, length = object.length, isObj = length === undefined || TypeUtils.isFunction(object);

			if (args) {
				if (isObj) {
					for (name in object) {
						if (callback.apply(object[name], args) === false) {
							break;
						}
					}
				} else {
					for (; i < length;) {
						if (callback.apply(object[i++], args) === false) {
							break;
						}
					}
				}

				// A special, fast, case for the most common use of each
			} else {
				if (isObj) {
					for (name in object) {
						if (callback.call(object[name], name, object[name]) === false) {
							break;
						}
					}
				} else {
					for ( var value = object[0]; i < length && callback.call(value, i, value) !== false; value = object[++i]) {
					}
				}
			}
			return object;
		},

		parseJSON : function(data) {
			if (typeof data !== "string" || !data) {
				return null;
			}

			// Make sure leading/trailing whitespace is removed (IE can't handle
			// it)
			data = data.trim();

			// Make sure the incoming data is actual JSON
			// Logic borrowed from http://json.org/json2.js
			if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {

				// Try to use the native JSON parser first
				return window && window.JSON && window.JSON.parse ? window.JSON.parse(data) : (new Function("return "
						+ data))();

			} else {
				TypeUtils.error("Invalid JSON: " + data);
			}
		},

		/**
		 * Generate a guid
		 * 
		 * @name sap.viz.base.utils.ObjectUtils#guid
		 * @function
		 * @return {String}
		 */
		guid : function() {// guid generator
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
				var r = Math.random() * 16 | 0, v = c == 'x' ? r : r & 0x3 | 0x8;
				return v.toString(16);
			});
		}
	};
	return objUtils;
});sap.riv.module(
{
  qname : 'sap.viz.data.info.Handler',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
}
],
function Setup(ObjectUtils, TypeUtils) {
  var ANALYSISAXIS = "analysisAxis";
  var MEASUREVALUESGROUP = "measureValuesGroup";
  var handler = {};
  var _handlers = {};
  /*
   {
   'analysisAxis': [{
   'index': 1,
   'data': [{
   'name': 'Product',
   'values': ['Car', 'Truck', 'Motorcycle', 'Bicycle']
   }]
   }, {
   'index' : 2,
   'data': [{
   'name': 'Country',
   'values': ['China', 'USA']
   }, {
   'name': 'Year',
   'values': ['2001', '2001']
   }]
   }],
   'measureValuesGroup': [{
   'index': 1,
   'data': [{
   'name': 'Profit',
   'values': [[25, 136, 23, 116], [58, 128, 43, 73]]
   }, {
   'name': 'Revenue',
   'values': [[50, 236, 43, 126], [158, 228, 143, 183]]
   }]
   }]};
   * */
  
  function findInJson(jsondata, targetname){
    var anax = jsondata[ANALYSISAXIS].concat(jsondata[MEASUREVALUESGROUP]);
    var ret = [];
    anax.forEach(function(ana, idx){
      var anad = ana.data;
      anad.forEach(function(d, didx){
        if(d.name === targetname){
          ret.push(d);
        }
      }, this);
    }, this);
    return ret;
  }
  var valueinfo = {
    'type' : 'valueinfo',
    'process' : function(value, jsondata){
      var i, iLen, j, jLen, k, kLen, m, mLen;
      var iterate, mgValue, mg, dValues, measureGroups = jsondata[MEASUREVALUESGROUP];
      for (i = 0, iLen = value.length; i < iLen; i++) {
        iterate = value[i];
        if (iterate !== undefined) {
          for (j = 0, jLen = measureGroups.length; j < jLen; j++) {
            mg = measureGroups[j];
            mgValue = mg.data;
            for (k = 0, kLen = mgValue.length; k < kLen; k++) {
              dValues = mgValue[k];
              if (!dValues.infos) {
                dValues.infos = [];
              }
              for (m = 0, mLen = dValues.values.length; m < mLen; m++) {
                if (!dValues.infos[m]) {
                  dValues.infos[m] = [];
                }
                if (!dValues.infos[m][i]) {
                  dValues.infos[m][i] = {};
                }
                dValues.infos[m][i][valueinfo.type] = iterate;
              }
            }
          }
        }
      }
//      var iterate, dname, finds, d, dvalue;
//      var i, iLen, j, jLen, k, kLen, m, mLen;
//      for(i = 0, iLen = value.length; i < iLen; i++) {
//        iterate = value[i];
//        dname = iterate.name;
//        finds = findInJson(jsondata, dname);
//        for(j = 0, jLen = finds.length; j < jLen; j++){
//          d = finds[j];
//          if (iterate.value) {
//            if (!d.infos) {
//              d.infos = [];
//            }
//            for(k = 0, kLen = d.values.length; k < kLen; k++){
//              d.infos[k] = [];
//              dvalue = d.values[k];
//              for(m = 0, mLen = dvalue.length; m < mLen; m++){
//                if(d.infos[k][m] === undefined){
//                  d.infos[k][m] = {};
//                }
//                d.infos[k][m][valueinfo.type] = iterate.value[k][m];
//              }
//            }
//          }
//        }
//      }
    },
    'merge' : function(jsondata){

    }, 

    'remove' : function(jsondata) {
      measureInfoRemove(valueinfo.type, jsondata);
    }
  };  

  /**
   * [26-Feb-2013 Nick]
   * Default selection is bind with data model, it has the similar mechanism as custom label has.
   */
  
    var defaultSelection = {
    'type' : 'defaultSelection',
    'process' : function(info, data) {
      var iterate;
      var aa1, aa2, len;
      var hasAA2 = (data[ANALYSISAXIS] &&  data[ANALYSISAXIS][1]) ? true : false;
      var aa1Length = data[ANALYSISAXIS] ? data[ANALYSISAXIS][0].data[0].values.length : data[MEASUREVALUESGROUP][0].data[0].values[0].length, 
          aa2Length = hasAA2 ? data[ANALYSISAXIS][1].data[0].values.length : 1;
      var i, m, n;
      var defaultSelectionInfo, temp;

      for (i = 0, len = info.length; i < len; i++) {
        aa1 = new Array(aa1Length), aa2 = new Array(aa2Length);
        defaultSelectionInfo = [];
        iterate = info[i];
        AAContextConstructor(data, iterate, aa1, aa2);
        // if analysis axis 2 does not exit, we think it is selected by default.
        if (!hasAA2) {
          aa2[0] = true;
        }
        // Construct a two-dimensional array, which is aa2.length * aa1.length. Each member is a object like:
        //    'defaultSelection' : {
        //        isSelected : false,
        //        index : i
        //      }
        // According to aa1 and aa2 arrays, the 'isSelected' of corresponding object is changed from false to true.
        for (m = 0; m < aa2.length; m++) {
          temp = [];
          for (n = 0; n < aa1.length; n++) {
            var ctxObj = {
              'defaultSelection' : {
                isSelected : false,
                index : i
              }
            };
            if (aa2[m] && aa1[n]) {
              ctxObj.defaultSelection.isSelected = true;
            }
            temp.push(ctxObj);
          }
          defaultSelectionInfo.push(temp);
        }
        // Attach the default selection object to each data object.
        MGContextConstructor(data, iterate, defaultSelectionInfo);
      }

    },
  
  'remove' : function(jsondata) {
    measureInfoRemove(defaultSelection.type, jsondata);
  },
    'merge' : function(jsondata){}
  };
  
  function measureInfoRemove(infoName, jsondata) {
    var iterate, d, dvalue, value = jsondata[MEASUREVALUESGROUP];
    var i, iLen, j, jLen, k, kLen, m, mLen;
    var stillHasInfo = false;
    for (i = 0, iLen = value.length; i < iLen; i++) {
      iterate = value[i].data;
      for (j = 0, jLen = iterate.length; j < jLen; j++) {
        d = iterate[j];
        if (d.infos) {
          stillHasInfo = false;
          for (k = 0, kLen = d.infos.length; k < kLen; k++) {
            dvalue = d.infos[k];
            for (m = 0, mLen = dvalue.length; m < mLen; m++) {
              if (dvalue[m]) {
                delete dvalue[m][infoName];
                if (TypeUtils.isEmptyObject(dvalue[m])) {
                  dvalue[m] = undefined;
                } else {
                  stillHasInfo = true;
                }
              }
            }
          }
        }
        if (!stillHasInfo) {
          delete d.infos;
        }
      }
    }
  }
  
  /**
   * [26-Feb-2013 Nick] 
   * This function is to process which elements are selected in analysis axises 1 and 2.
   * aa1 is the array that records which elements are selected in analysis axis 1.
   * aa2 is the array that records which elements are selected in analysis axis 2.
   */
  function AAContextConstructor(jsondata, target, aa1, aa2){
    var analysisAxis = jsondata[ANALYSISAXIS];
    if(!analysisAxis){
      for(var index = 0; index < aa1.length; index++){
        aa1[index] = true;
      }
      return;
    }
    analysisAxis.forEach(function(ana, idx){
		var anad = ana.data;
		
		anad.forEach(function(d, didx){
			var value = target[d.name];
			for(var i=0; i<d.values.length; i++){
				var isMatch = (value === '*' || (value !== null && d.values[i] === value ));
				if( isMatch ){
					if(didx === 0){
						if(ana.index === 1){
							aa1[i] = true;
						}else{
							aa2[i] = true;
						}
					}else{
						if(ana.index === 1){
							if(aa1[i] !== true){
								aa1[i] = undefined;
							}
						}else{
							if(aa2[i] !== true){
								aa2[i] = undefined;
							}
						}
					}
				}else{
					if(ana.index === 1){
						aa1[i] = undefined;
					}else{
						aa2[i] = undefined;
					}
				}
				}
			}, this);
		}, this);
  }
  
  /**
   * [26-Feb-2013 Nick] 
   * This function is to process which elements are selected in measures.
   */
  function MGContextConstructor(jsondata, target, defaultSelectionInfo) {
    var measureGroup = jsondata[MEASUREVALUESGROUP];
    var unSelectionInfo = [], temp, m, n;
    for (m = 0; m < defaultSelectionInfo.length; m++) {
      temp = [];
      for (n = 0; n < defaultSelectionInfo[m].length; n++) {
        var ctxObj = {
          'defaultSelection' : {
            isSelected : false
          }
        };
        temp.push(ctxObj);
      }
      unSelectionInfo.push(temp);
    }
    measureGroup.forEach(function(ana, idx) {
      var anad = ana.data;
      var i, j, selectedTarget;
      anad.forEach(function(d, didx) {
        if (d.name === target['Measure']) {
          selectedTarget = defaultSelectionInfo;
        } else {
          selectedTarget = unSelectionInfo;
        }
        if (!d.infos) {
          d.infos = selectedTarget;
        } else {
          for (i = 0; i < selectedTarget.length; i++) {
            var aa1 = selectedTarget[i];
            var daa1 = d.infos[i];
            for (j = 0; j < aa1.length; j++) {
              var alreadySelected = daa1[j]['defaultSelection'].isSelected;
              if (!alreadySelected) {
                daa1[j]['defaultSelection'] = aa1[j]['defaultSelection'];
              }
            }
          }
        }
      }, this);
    }, this);
  }
  
  var customlabel = {
    'type' : 'customlabel',
    /*'value': [{
     'name': 'Country', //dimension name
     'mapping': {'CHN', {'type': 'url', 'val': 'http://xxxx/xxxx.png'},
     'GER', {'type': 'string', 'val': 'Germany'},
     'FRA', {'type': 'string', 'val': 'France'}} //support both string and url
     }] //you can have several mappings, it will be merged inside crosstable dataset. no info will be created (existed will be deleted) if the mapping value is same as the original value.*/
    'process' : function(value, jsondata) {
      var iterate, dname, finds, mapping, m, dvalues, mappingfound, removeinfo;
      for(var i = 0, len = value.length; i < len; i++) {
        iterate = value[i];
        dname = iterate.name;
        finds = findInJson(jsondata, dname);
        finds.forEach(function(d, tdidx) {
          //if no infos exist, create one, delete it if no info found
          mappingfound = false;
          if(!d.infos){
            removeinfo = true;
            d.infos = [];
          }
          
          dvalues = d.values;          
          mapping = iterate.mapping;
          dvalues.forEach(function(v, idx) {
            if(mapping[v]){
              if(mapping[v].type === 'string' && mapping[v].val === v){
                //we won't create mapping for it. existing mapping should be deleted
                if(d.infos[idx]){
                  delete d.infos[idx][customlabel.type];
                  //if it becomes empty, set it to undefined
                  if(TypeUtils.isEmptyObject(d.infos[idx])){
                    d.infos[idx] = undefined;
                  }
                }else{
                  //https://tipjira.pgdev.sap.corp/browse/BITVIZA-1181
                  //if current value happens to be the last value, we won't create anything for it
                  //then d.infos will be shorter than d.values which is not allowed
                  //so here we should create something for it.
                  d.infos[idx] = undefined; 
                } 
              }else{
                mappingfound = true;
                d.infos[idx] = d.infos[idx] ? d.infos[idx] : {};
                d.infos[idx][customlabel.type] = mapping[v];  
              }
            }else{
              if(!d.infos[idx]){
                d.infos[idx] = undefined;
              }
            }  
          }, this);

          if(removeinfo && !mappingfound){
            delete d.infos;
          }
        }, this);
      }
    },
    
    'merge' : function(jsondata){
      var ret = {};
      ret.type = customlabel.type;
      ret.value = [];
      var anax = jsondata[ANALYSISAXIS];
      var found;
      anax.forEach(function(ana, idx){
        var anad = ana.data;
        anad.forEach(function(d, didx){
          if(d.infos){
            var dmapping = {};
            dmapping.name = d.name;
            dmapping.mapping = {};
            found = false;
            d.infos.forEach(function(dinfo, dinfoidx){
              if(dinfo && dinfo[customlabel.type]){
                found = true;
                dmapping.mapping[d.values[dinfoidx]] = dinfo[customlabel.type];
              }
            }, this);
            if(found){
              ret.value.push(dmapping);
            }
          }
        }, this);
      }, this);
      if(ret.value.length > 0){
        return ret;
      }  
    },
    
    'remove' : function(jsondata){
      var anax = jsondata[ANALYSISAXIS];
      var stillHasInfo = false;
      anax.forEach(function(ana, idx){
        var anad = ana.data;
        anad.forEach(function(d, didx){
          if(d.infos){
            stillHasInfo = false;
            d.infos.forEach(function(dinfo, dinfoidx){
              if(dinfo){
                delete dinfo[customlabel.type];
                if(TypeUtils.isEmptyObject(dinfo)){
                  d.infos[dinfoidx] = undefined;
                }else{
                  stillHasInfo = true;
                }
              }
            }, this);
            if(!stillHasInfo){
              delete d.infos;
            }
          }
        }, this);
      }, this);
    }
  };

  handler.register = function(hndl) {
    _handlers[hndl.type] = hndl;
  };

  handler.get = function(type) {
    return _handlers[type];
  };
  
  /*
   * call each handler to extract corresponding info to an object and return
   */
  handler.mergeInfo = function(jsondata){
    var iter, ret = [], mr;
    for(var type in _handlers){
      if(_handlers.hasOwnProperty(type)){
        iter = _handlers[type];
        mr = iter.merge(jsondata);
        if(mr){
          //return a copy, intend to use ObjectUtils as we want to deep copy the array
          ret.push(ObjectUtils.extend(true, {}, mr));
        }
      }
    }
    return ret;
  };
  
  handler.register(customlabel);
  handler.register(defaultSelection);
  handler.register(valueinfo);
  
  return handler;

});sap.riv.module(
{
  qname : 'sap.viz.base.Class',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
}
],
function Setup(FuncUtils, TypeUtils) {
	// inspired by http://ejohn.org/blog/simple-javascript-inheritance/
	var fnTest = /xyz/.test(function() {
		xyz;
	}) ? /\b_super\b/ : /.*/;
	var callChain = FuncUtils.createCallChain;
	function zeroClass() {
	}

	function extend(ext) {
		var _super = zeroClass.prototype = this.prototype;
		var subclass = this.chain ? this.chain(ext.constructor) : callChain(this, ext.constructor);
		var proto = subclass.prototype = new zeroClass();
		proto.constructor = subclass;
		delete ext.constructor;
		var fn;
		for ( var f in ext) {
			fn = ext[f];
			proto[f] = typeof fn === 'function' && typeof _super[f] === 'function' && fnTest.test(fn) ? (function(name,
					func) {
				return function() {
					this._super = _super[name];
					var ret = func.apply(this, arguments);
					return ret;
				};
			})(f, fn) : fn;
		}
		subclass.extend = extend;
		return subclass;
	}

	/**
	 * Define a class, make it extensible. The parameter could be an existing
	 * constructor or a Class config object.
	 * 
	 * <pre>
	 * {
	 * 		constructor : function(){...},
	 * 		method1		: function(){...},
	 * 		method2		: function(){...},
	 * 		...
	 * 		methodn		: function(){...}
	 * }
	 * </pre>
	 * 
	 * @param {Function|Object}
	 *            clazz constructor or an Class config object
	 * @returns {Function} the class
	 */
	function define(clazz) {
		if (typeof clazz === 'function') {
			clazz.extend = extend;
			return clazz;
		} else {
			var constructor = clazz.constructor || function() {
			}, proto = constructor.prototype;
			for ( var f in clazz) {
				if (clazz.hasOwnProperty(f)) {
					proto[f] = clazz[f];
				}
			}
			constructor.extend = extend;
			return constructor;
		}
	}
	return {
		define : define,
		extend : extend
	};
});sap.riv.module(
{
  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.Class',
  version : '4.0.2'
}
],
 function Setup(Class){
	var DataContainer = Class.define({
		constructor : function(uid){
			this._uId = uid; 
			this._isFake = false;
			this._infos = null;
		},
		getId : function(){
			return this._uId;
		},
		fake : function(_){
			if (!arguments.length){
				return this._isFake;
			}
			this._isFake = _;
		},
		infos : function(_){
			if (!arguments.length){
				return this._infos;
			}
			this._infos = _;
		} 
	});
	return DataContainer;
 });sap.riv.module(
{
  qname : 'sap.viz.data.description.MeasureValues',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.2'
}
],
 function Setup(ObjUtils, DataContainer){
   
   /**
    * @private
    * @name sap.viz.data.description.MeasureValues
    */
     var MeasureValues = DataContainer.extend({
      
       /** 
        * @constructor
        * @param uid    identifier of measure values, usually name
        * @param values 
        */
       constructor : function ( uid, values ) {
           this._values = values;
       },
       
         getValues : function(){
           return this._values;
         }
    
    });
     
     
     
     return MeasureValues;
});sap.riv.module(
{
  qname : 'sap.viz.data.description.MeasureValuesGroup',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.data.description.MeasureValues',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
 function Setup(MeasureValues, FunctionUtils){
   
   var MeasureValuesGroup = function(data){
       this._measureValues = [];
       this.init(data);
   };
   
   MeasureValuesGroup.prototype.init = function(data){
     
       for(var i = 0; i < data.length; i++){
           this._measureValues[i] = new MeasureValues(data[i]["name"], data[i]["values"]);
           this._measureValues[i].fake(data[i]["isFake"] ? data[i]["isFake"] : false);
           this._measureValues[i].infos(data[i]["infos"] ? data[i]["infos"] : null);
       }
   };
   
   MeasureValuesGroup.prototype.getMeasureValues = function(){
       return this._measureValues;
   };
   
   MeasureValuesGroup.prototype.getType = function(){
       return "measureValuesGroup";
   };
   
   MeasureValuesGroup.prototype.validate  = function(labels){
       
      var measures, value, i, j;
      if (!arguments.length){
        var label = [1,1];
        measures = this.getMeasureValues();
        for(i = 0; i < measures.length;i++){
          value = measures[i].getValues();
          if(i === 0){
           if(value.length !== label[1]){
              FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + label[1]);
           }
           
           label[0] = value[0].length;
           
          }else{
            if(value.length !== label[1]){
               FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + label[1]);
            }
            
            for(j = 0; j < value.length; j++){
              if(value[j].length !== label[0] ){
                 FunctionUtils.error(measures[i].getId() + " wrong values count in aa1. should be " + label[0]);
              }
            }  
          }
          
        }
        
        return label;
        
      }else{
        measures = this.getMeasureValues();
        for(i = 0; i < measures.length;i++){
          value = measures[i].getValues();
          if(value.length !== labels[1]){
             FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + labels[1]);
          }
          
          for(j = 0; j < value.length; j++){
            if(value[j].length !== labels[0] ){
               FunctionUtils.error(measures[i].getId() + " wrong values count in aa1. should be " + labels[0]);
            }
          }
        }
      }
     
   };
   
   MeasureValuesGroup.prototype.hasFakeData = function(){
      var measures = this.getMeasureValues();
      for(var i = 0; i < measures.length;i++){
        if(measures[i].fake()){
           return true;
        }
      }
      
      return false;
   };
   
   return MeasureValuesGroup;
 });sap.riv.module(
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils, ObjectUtils) {
  /**
   * Type Utilities for common variable type related tasks
   * 
   * @name sap.viz.util.TypeUtils
   * @class
   */
  var typeUtils = ObjectUtils.extend(TypeUtils, {

    /**
       * Returns a boolean value indicating whether the parameter is undefined or null
       *
       * @param {object}
       * @returns {boolean}
       */
    isExist : function(o) {
      if ((typeof (o) === 'undefined') || (o === null)) {
        return false;
      }
      return true;
    }
  });

  return typeUtils;
});sap.riv.module(
{
  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.2'
}
],
function Setup(ObjUtils, DataContainer){
   
  
     var DimensionLabels = DataContainer.extend({
      
       /**
          * @name sap.viz.data.description.DimensionLabels
          * @param   uid    identifier of dimension labels, usually name 
        */
      
       constructor : function ( uid, type, values ) {
           this._type = type;
           this._values = values;
       },
       
       getValues : function(){
           return this._values;
       },
         
       getType : function(){
           return this._type;
       }
       
    });
     
     
     return DimensionLabels;
  });sap.riv.module(
{
  qname : 'sap.viz.data.description.AnalysisAxis',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
}
],
 function Setup(DimensionLabels, FunctionUtils, TypeUtils){
   
   var AnalysisAxis = function(data){
     this._dimensionLabels = [];
     this.init(data);
    
   };
   
   AnalysisAxis.prototype.init = function(data){
     
       for(var i = 0; i < data.length; i++){
         this._dimensionLabels[i] = new DimensionLabels(data[i]["name"], data[i]["type"]? data[i]["type"] : "Dimension",
                                                    data[i]["values"] );
         
         this._dimensionLabels[i].fake( data[i]["isFake"] ? data[i]["isFake"] : false);
         this._dimensionLabels[i].infos( data[i]["infos"] ? data[i]["infos"] : null);
       }
   };
   
   AnalysisAxis.prototype.getDimensionLabels = function(){
     return this._dimensionLabels;
   };
   
   AnalysisAxis.prototype.getType = function(){
     return "analysisAxis";
   };
   
   AnalysisAxis.prototype.validate  = function(){
      
      var labels = 1;
      var dimensions = this.getDimensionLabels();
      for(var i = 0; i < dimensions.length;i++){
        if(i === 0){
           labels = dimensions[i].getValues().length;
           if(TypeUtils.isExist(dimensions[i].infos()) && labels !== dimensions[i].infos().length){
              FunctionUtils.error(dimensions[i].getId() + " wrong infos count");
           }
        }
        else{
         if(labels !== dimensions[i].getValues().length){
            FunctionUtils.error(dimensions[i].getId() + " wrong dimension labels count");
         }
         
         if(TypeUtils.isExist(dimensions[i].infos()) && labels !== dimensions[i].infos().length){
                FunctionUtils.error(dimensions[i].getId() + " wrong infos count");
         }
        }
      }
      
      return labels;
     
   };
   
   AnalysisAxis.prototype.hasFakeData = function(){
      var dimensions = this.getDimensionLabels();
      for(var i = 0; i < dimensions.length;i++){
        if(dimensions[i].fake()){
           return true;
        }
      }
      
      return false;
   };
   
   return AnalysisAxis;
 });sap.riv.module(
{
  qname : 'sap.viz.data.feed.feed',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
 function Setup(FunctionUtils){
   
   return function(feedId, feedName, type, min, max, aaIndex, acceptMND, mgIndex, maxStackedDims){
     
         var _feedId = feedId;
         var _feedName = feedName;
         var _type = type;
         var _min = min;
         var _max = max;
         var _aaIndex = aaIndex;
         var _acceptMND = acceptMND;
         var _mgIndex = mgIndex;
         var _maxStackedDims = maxStackedDims;
         
         var _data = [];
     
       function feed() {
         return feed;
       }
       
       feed.feedId = function(_){  
         if (!arguments.length){
             return _feedId;
         }
        
         _feedId = _;
         
         return feed;
       };
       
       feed.feedName = function(_){
         if (!arguments.length){
             return _feedName;
         }
         
         _feedName = _; 
         
         return feed;
       };
       
       feed.type = function(_){
         if (!arguments.length){
             return _type;
         }
         
        _type = _;
        
        return feed;
       };
       
       feed.min = function(_){    
         if (!arguments.length){
            return _min;     
         }
     
         _min =  _;
         return feed;
       };
       
       feed.max = function(_){
         if (!arguments.length){
             return _max;
         }
         
         
         _max = _;
         
         return feed; 
       };
       
       feed.analysisAxisIndex = function(_){
         if (!arguments.length){
             return _aaIndex;  
         }
         
         
         _aaIndex = _;
         
         return feed;
       };
      
       feed.measureGroupIndex = function(_){
         if (!arguments.length){
             return _mgIndex;
         }
         
         _mgIndex = _;
         
         return feed;
       };
       
       feed.acceptMND = function(_){
         if (!arguments.length){
             return _acceptMND;  
         }
         
         
         _acceptMND = _;
         
         return feed;
       };
       
       feed.maxStackedDims = function(_){
         if (!arguments.length){
             return _maxStackedDims;
         }
         
         _maxStackedDims = _;
         
         return feed;
       };
       
       feed.data = function(_){
         if (!arguments.length){
             return _data;
         }
         
         _data = _;
         
         return feed;
       };
       
       
       feed.addData = function(_){
         _data.push(_);
         return feed;
       };
       
       feed.getMeasureNames = function(){
         
         var mgIndex  =  _mgIndex - 1;
         var measureNames = [];
         for(var i = 0; i < _data.length; i++){
             measureNames.push({'val':_data[i]['name'],'ctx': {'mg': mgIndex, 'mi': i}});
         }
         
         return measureNames;
       };
       
         feed.getMeasureValues = function(){
         var values = [];
         if(_data.length > 0){
            return _data[0].getMeasureValues();
         }
         
         return values;
           
       };
       
         feed.getMeasureCount = function(){
            return _data.length;
       };
     
       /**
        * @returns check if the feed has been feeded MND
        */
       feed.hasMNDFeeded = function(){
          
          var data = feed.data();
          for(var i = 0; i < data.length; i++){
            if(data[i].getType() === "measureNamesDimension"){
               return true;
            }
          }
          
          return false;
       };
       
       feed.hasFeeded = function(){
          return feed.data().length > 0 ?  true : false;
       };
       
       feed.getIndex = function(){
          return feed.analysisAxisIndex() ? feed.analysisAxisIndex() : feed.measureGroupIndex();
       };
       
       feed.getDataCount = function(){
         if(feed.type() === "Dimension"){
            return feed.data().length;
         }
         else{
            return feed.data().length > 0 ? feed.data()[0].getMeasureValues().length : 0; 
         }
          
       };
       
     return feed;
   };
  
 });sap.riv.module(
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.data.feed.feed',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.2'
}
],
 function Setup(Feed, FunctionUtils, TypeUtils, DimensionLabels){
   
   return function(feedDefs, crossTableDS, feedingInfo){
    
     var FEED_D = 'Dimension';
     var FEED_M = 'Measure';
     
     var FEEDID = "feedId";
     
     var BINDTO = "binding";
     var TYPE = "type";
     var INDEX = "index";
     
     var _aaMap = []; // analysis axis index to feed map, _aamap[0] point to feed of axis 1 
     var _mgMap = []; // measure group index to feed map, _mgMap[0] point to feed of measure value group 1
     var _feeds = [];
     var _feedsMap = {};
     
     var _aaBindingInfo = [];
     
       function feeder() {
     
           return feeder;
       }
       
       feeder.init = function(){
         initFeeds(feedDefs);
         
         //TODO separate validation and init
         if(crossTableDS){
           if(feedingInfo){
             manualFeed(crossTableDS, feedingInfo);
           }else{
             autoFeed(crossTableDS);
           }
           
           feeder.checkValid();
         }
       };
       
       /**
        * @returns {feed}
        */
       feeder.getFeeds = function(){
         return _feeds;
       };
       
       /**
        * @param feedId
        *        feed id
        *        
        * @returns {feed}
        *           undefined if no feed matched
        * 
        */
       feeder.findFeed = function(feedId){
           return _feedsMap[feedId];
       };
       
      
       feeder.getAnalysisAxisIndex = function(feed){
        
         for(var i = 0; i < _aaMap.length; i++){
           if(_aaMap[i] === feed){
              return i;
           }
         }
         
       };
       
       feeder.getMeasureValuesGroupIndex = function(feed){
          
         for(var i = 0; i < _mgMap.length; i++){
           if(_mgMap[i] === feed){
              return i;
           }
         }
         
       };
       
       /**
        * TODO: add description
        */
       feeder.getMeasureValuesGroupFeeds = function(){
        
         return _mgMap;
       };
       
       /**
        * Check if meta data and raw data are matched. If not match, throw exception 
        */
       feeder.checkValid = function(){
         for(var i = 0; i < _feeds.length; i++){
           var feed = _feeds[i];
           var dataLength;
           if(feed.type() === "Dimension"){
            dataLength = feed.getDataCount();
            if(dataLength < feed.min() || (feed.max() !== Number.POSITIVE_INFINITY && dataLength > feed.max())){ 
               FunctionUtils.error(feed.feedId() + ": does not meet min or max number of feed definition");
            }
                
           }else if(feed.type() === "Measure"){
             dataLength = feed.getDataCount();
             if(dataLength < feed.min() || (feed.max() !== Number.POSITIVE_INFINITY && dataLength > feed.max())){ 
                FunctionUtils.error(feed.feedId() + ": does not meet min or max number of feed definition");
             }
             
           }else{
             FunctionUtils.error(feed.feedId() + ": wrong feed type");
           }
             
           
         }
         
        
       };
       
       feeder.getBindingInfo = function(){
        
         return _aaBindingInfo;
       };
       
       /**
        * TODO: add desc
        */
       function initFeeds(feedDefinitions){
           if( TypeUtils.isArray(feedDefinitions) ){
             
             var dimensonNumber  = 0;
             
             for(var i = 0; i < feedDefinitions.length; i++){
               
               var feedType = feedDefinitions[i]['type'];
               var aaIndex = feedDefinitions[i]['aaIndex'];
               var feedId = feedDefinitions[i]['id'];
                 
               if(feedType !== FEED_D && feedType !== FEED_M ){
                 FunctionUtils.error('wrong feed type in feed definition: ' + feedDefinitions[i]['id']); 
               }
               
                if(feedDefinitions[i]['type'] === FEED_D){
                 if(feedDefinitions[i]['aaIndex'] <= 0){
                    FunctionUtils.error('wrong analysis axis index in feed definition: ' + feedDefinitions[i]['id']);
                 }
                 
                 dimensonNumber++;
               }
                
                if(feedDefinitions[i]['type'] === FEED_M){
                 if(feedDefinitions[i]['mgIndex'] <= 0){
                    FunctionUtils.error('wrong  measure axis index in feed definition: ' + feedDefinitions[i]['id']);
                 }
                 
               }
              
               
               var arrayLength = _feeds.push(Feed(feedId, feedDefinitions[i]['name'],
                                         feedType, feedDefinitions[i]['min'],
                                         feedDefinitions[i]['max'], aaIndex,
                                         feedDefinitions[i]['acceptMND'], feedDefinitions[i]['mgIndex'],
                                         feedDefinitions[i]['maxStackedDims']));
               
               _feedsMap[feedId] = _feeds[arrayLength - 1];
               
               }
             
             for(i = 0; i < dimensonNumber; i++){
               _aaBindingInfo[i] = false; 
             }
           }
           
       }
       
             
       function autoFeed(crosstableDS){
         var axes = crosstableDS.getAnalysisAxisCount();
         var feed;
         for(var i = 0; i < axes; i++){
           feed = searchFeed(_feeds, FEED_D, i + 1);
           if(feed){
              var axis = crosstableDS.getAnalysisAxisByIdx(i);
              if(TypeUtils.isExist(feed.maxStackedDims()) && axis.getDimensionLabels().length > feed.maxStackedDims()){
                 FunctionUtils.error("Invalid Feeding: exceed max stacked dimension number " + feed.feedId() + " feed");
              }
             
              _aaMap[i] = feed;
              _aaBindingInfo[i] = true;
              feed.addData(axis);
           }
         }
         
         var mvgs = crosstableDS.getMeasureValuesGroupCount();
         for(i = 0; i < mvgs; i++){
           feed = searchFeed(_feeds, FEED_M, i + 1);
           if(feed){
              _mgMap[i] = feed;
              feed.addData(crosstableDS.getMeasureValuesGroupByIdx(i));
           }
           
         }
       }
       
       function searchFeed(feeds, type, index){
          for(var i = 0; i < feeds.length; i++){
            if(feeds[i].type() === type && feeds[i].getIndex() === index){
               return feeds[i];
            }
          }
      
          return null;
       }
       
       function manualFeed(crosstableDS, feedList){
         var dataLength;
         for(var i = 0; i < feedList.length; i++){
           var feeding = feedList[i];
           var feedId = feeding[FEEDID];
           if(!feedId){
              FunctionUtils.error("Invalid Feeding: no feed id");
           }
              
           var feed = _feedsMap[feedId];
           if(!feed){
              FunctionUtils.error("Invalid Feeding: no " + feedId + " feed");
           }
           
           var bindings = feeding[BINDTO];
           for(var j = 0; j < bindings.length; j++){
             var type = bindings[j][TYPE];
             var index = bindings[j][INDEX];
             
             if( type === "analysisAxis"){
               var aa =  crosstableDS.getAnalysisAxisByIdx(index - 1);
               if(!aa){
                  FunctionUtils.error("could not find axis " + index +  " in data set" + feedId + " feed");
               }
               
               if(TypeUtils.isExist(feed.maxStackedDims()) && aa.getDimensionLabels().length > feed.maxStackedDims()){
                  FunctionUtils.error("Invalid Feeding: exceed max stacked dimension number " + feedId + " feed");
               }
               
               dataLength = feed.getDataCount();
               if(feed.max() !== Number.POSITIVE_INFINITY && dataLength >= feed.max()){
                  FunctionUtils.error(feedId + " feed could not accept more data containers");
               }
               
               feed.addData(aa);  
               _aaMap[index - 1] = feed;
               _aaBindingInfo[feed.getIndex() - 1] = true;
               
             }else if(type === "measureValuesGroup"){
               
               var mvg = crosstableDS.getMeasureValuesGroupByIdx(index - 1);
               if(!mvg){
                  FunctionUtils.error("could not find measure values group " + index +  " in data set" + feedId + " feed");
               }
               
               dataLength = feed.getDataCount();
               if(feed.max() !== Number.POSITIVE_INFINITY && dataLength >= feed.max()){
                  FunctionUtils.error(feedId + " feed could not accept more data containers");
               }
               
               feed.addData(mvg);
               _mgMap[index-1] = feed;
               
             }else if(type === "measureNamesDimension"){
               if(feed.acceptMND() < 0){
                  FunctionUtils.error("could not accpet MeasureNamesDimension " + feedId + " feed");
               }
               
               dataLength = feed.getDataCount();
               if(feed.max() !== Number.POSITIVE_INFINITY && dataLength >= feed.max()){
                  FunctionUtils.error(feedId + " feed could not accept more data containers");
               }
               
               feed.addData(new DimensionLabels("", "measureNamesDimension", ""));
               
             }else{
               FunctionUtils.error("Invalid Binding");
             }
           }
           
         }
         
       }
       
       feeder.init();
       
       return feeder;
   };
   
});sap.riv.module(
{
  qname : 'sap.viz.data.CrosstableDataset',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.description.AnalysisAxis',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.description.MeasureValuesGroup',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.info.Handler',
  version : '4.0.2'
}
],
 function Setup(Feeder, TypeUtils, FunctionUtils, AnalysisAxis, MeasureValuesGroup, Handler){
 
   var TYPE   =    'type';
   var NAME   =    'name';
   var VALUES =    'values';
   
   var FEEDID =  'feedId';
   var MND    =  'MeasureNamesDimension';
   
   var ANALYSISAXIS = "analysisAxis";
   var MEASUREVALUESGROUP = "measureValuesGroup";
      
   function getMeasureValueDataPointCount(measureValue){
         var values = measureValue.getValues();
     
         return values.length > 0 ? values.length * values[0].length : 0;
   }
   
   /**
    * @name sap.viz.data.CrosstableDataset
    * @constructor
     */
   function crossTableDataSet(){
        this._analysisAxis = [];
        this._measureValuesGroup = [];
        this._dataSet = {};
        this._emptyDataset = false;
   }
   
   /**
    * Get/Set data
    * @name sap.viz.data.CrosstableDataset#data
    * @param data
    *        data with metaData and rawData
    * @returns {Object} {@link sap.viz.data.CrosstableDataset}
    */
   crossTableDataSet.prototype.data = function(data){
     if(!arguments.length){
       return this._dataSet;
     }
     this._analysisAxis = [];
     this._measureValuesGroup = [];
     this._dataSet = data;
     this.init(this._dataSet);
     return this;
   };
   
   //@deprecated
   crossTableDataSet.prototype.setData = function(in_data){
     this.data(in_data);
   };
   
   /**
    get/set additional info for the crosstable dataset
    @param {Object}info {
       'type': 'customlabel'|'geo'
       'value': [{
          'name': 'Country', //dimension name
          'mapping': {'CHN', {'type': 'url', 'val': 'http://xxxx/xxxx.png'},
                      'GER', {'type': 'string', 'val': 'Germany'},
                      'FRA', {'type': 'string', 'val': 'France'}} //support both string and url
       }] //you can have several mappings, it will be merged inside crosstable dataset. no info will be created (existed will be deleted) if the mapping value is same as the original value.
    }
    @returns {Object} return a copy of current additional info if no param provided
   */
   crossTableDataSet.prototype.info = function(info){
     if(!arguments.length){
       return Handler.mergeInfo(this._dataSet);
     }
     
     if(info && info.type){
       var handler = Handler.get(info.type);
       if(handler){
         handler.process(info.value, this._dataSet);
       }
       //Jimmy, 12/28/2012, AnalysisAxis reads info reference from this._dataset.
       //here the reference may be deleted (in clearInfo) and recreated(here), to make sure AnalysisAxis
       //still can get the right infos, we recreate them.
       //or we can optimize it to save infos in analysisAxis and merge them when we get data and info?
      this._analysisAxis = [];
      this._measureValuesGroup = [];
      this.init(this._dataSet);
     }
     return this;
   };
   
    /**
      clear specific additional info for the crosstable dataset
      @param {String}type "customlabel"||"geo" 
    */
    crossTableDataSet.prototype.clearInfo = function(type){
      if(type){
       var handler = Handler.get(type);
       if(handler){
         handler.remove(this._dataSet);
       }
      }
      return this;  
    };
   
   crossTableDataSet.prototype.init = function(data){
      if(!data || !data[MEASUREVALUESGROUP] || (data[ANALYSISAXIS] && !data[MEASUREVALUESGROUP])){
       //FIX ME Remove when multihandler is available
       return;// FunctionUtils.error("dataset is empty or invalid");
      }
      var aaLabels = [1,1];

      
      var axes = data[ANALYSISAXIS];
      var i = 0;
      var mvgs, mvg, mv;
      if(axes){
        if(axes.length > 2){
         FunctionUtils.error("could not accept more than 2 axes");
        }
        
        for(;i < axes.length; i++){
          var axis = axes[i];
          var axisIndex = axis["index"];
          if(axisIndex !== 1 && axisIndex !== 2){
           FunctionUtils.error("Axis index should be 1 or 2");
          }
          
          if(this._analysisAxis[axisIndex - 1]){
           FunctionUtils.error("Axis " + axisIndex + " already exists");
          }
          
          var aa = new AnalysisAxis(axis["data"]);
          aaLabels[axisIndex - 1] = aa.validate();
          this._analysisAxis[axisIndex - 1] = aa;
          
        }
        
       //TODO handle if only meta data exist in data set when layout
       if(aaLabels[0] === 0){
          aaLabels[1] = 0;
          this._emptyDataset = true;
       }

        mvgs = data[MEASUREVALUESGROUP];
        for(i = 0;i < mvgs.length; i++){
          mvg = mvgs[i];
          var mvgIndex = mvg["index"];
          if(this._measureValuesGroup[mvgIndex - 1]){
            FunctionUtils.error("MeausreValuesGroup " + mvgIndex + " already exists");
          }
          
          mv =  new MeasureValuesGroup(mvg["data"]);
          mv.validate(aaLabels);
          this._measureValuesGroup[mvgIndex - 1] = mv;
        }
      }else{ // no axes case
        
        mvgs = data[MEASUREVALUESGROUP];
        for(i = 0;i < mvgs.length; i++){
          mvg = mvgs[i];
          mv =  new MeasureValuesGroup(mvg["data"]);
          if(i === 0){
            aaLabels = mv.validate();
          }  
          else{
            mv.validate(aaLabels);
          }
          
          this._measureValuesGroup[mvg["index"] - 1] = mv;
        }
      }
      
      
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getAnalysisAxisCount
    * @ignore 
    */
   crossTableDataSet.prototype.getAnalysisAxisCount = function(){
      return this._analysisAxis.length;    
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getAnalysisAxisByIdx
    * @ignore
    * @param index 
    */
   crossTableDataSet.prototype.getAnalysisAxisByIdx = function(index){
     return this._analysisAxis[index];
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getMeasureValuesGroupCount
    * @ignore 
    */
   crossTableDataSet.prototype.getMeasureValuesGroupCount = function(){
      return this._measureValuesGroup.length;    
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getMeasureValuesGroupByIdx
    * @ignore
    * @param index 
    */
   crossTableDataSet.prototype.getMeasureValuesGroupByIdx = function(index){
     return this._measureValuesGroup[index];
   };
   
   /**
      * @name sap.viz.data.CrosstableDataset#hasFakeData
      * @ignore
      */
   crossTableDataSet.prototype.hasFakeData = function(){
     for(var i = 0; i < this._measureValuesGroup.length; i++){
       if(this._measureValuesGroup[i].hasFakeData()){
        return true;
       }
     }
     
     for(i = 0; i < this._analysisAxis.length; i++){
       if(this._analysisAxis[i].hasFakeData()){
        return true;
       }
     }
     
     return false;
   };
   
   /**
      * @name sap.viz.data.CrosstableDataset#getDataPointCount
      * @ignore
      */
   crossTableDataSet.prototype.getDataPointCount = function(){
     
     var dpCount = 0;
     var mvDPCount = getMeasureValueDataPointCount(this._measureValuesGroup[0].getMeasureValues()[0]);
     for(var i = 0; i < this._measureValuesGroup.length; i++){
       dpCount +=  mvDPCount * this._measureValuesGroup[i].getMeasureValues().length;
     }
     
     return dpCount;
   };
   
    /**
      * @name sap.viz.data.CrosstableDataset#isEmptyDataSet
      * @ignore
    */
   crossTableDataSet.prototype.isEmptyDataset = function(){
      return this._emptyDataset;
   };
   
    return crossTableDataSet;
 });sap.riv.module(
{
  qname : 'sap.viz.modules.event.Manager',
  version : '4.0.2'},
[

],
function Setup() {

    return function(){
        var component;

        var eventManager = {
            UIComponent : function(_) {
                if (!arguments.length) {
                    return component;
                }
                component = _;
                return eventManager;
            },

            on : function(type, listener) {
                component.on(type, listener);
                return eventManager;
            },

           addGestureDetector : function(_) {
                if (!arguments.length) {
                    return;
                }
                component.addGestureDetector(_);
                return eventManager;
            }
        };

        return eventManager;  
    };
});sap.riv.module(
{
  qname : 'sap.viz.base.Logger',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
function Setup(FncUtils) {
    var noop = FncUtils.noop;
    // var noop = function() {
    // };
    Date.now = Date.now ||
    function() {
        return +new Date();
    };

    var dispatcherIdleCounter = 0;

    function callAppender(appender) {
        var logTime, logLevel, logCate, logMsg, appenderLevel;

        if(logBuffer[0].length > 0) {
            if(appender) {
                appenderLevel = appender.getLevel();
                for(var i = 0, bl = logBuffer[0].length; i < bl; i++) {
                    logTime = logBuffer[0][i];
                    logLevel = logBuffer[1][i];
                    logCate = logBuffer[2][i];
                    logMsg = logBuffer[3][i];
                    if(logBuffer[1][i] >= appenderLevel)
                        appender.doAppend(logTime, logLevel, logCate, logMsg);
                }
                return;
            }

            //call all appenders
            //var appender;
            var appenderLevelMap = {};
            for(var appenderKey in appenders) {
                if(appenders.hasOwnProperty(appenderKey)) {
                    appenderLevelMap[appenderKey] = appenders[appenderKey].getLevel();
                }
            }
            while(logBuffer[0].length) {
                logTime = logBuffer[0].shift();
                logLevel = logBuffer[1].shift();
                logCate = logBuffer[2].shift();
                logMsg = logBuffer[3].shift();
                for(appenderKey in appenders) {
                    if(appenders.hasOwnProperty(appenderKey)) {
                        appender = appenders[appenderKey];
                        if(logLevel >= appenderLevelMap[appenderKey])
                            appender.doAppend(logTime, logLevel, logCate, logMsg);
                    }
                }
            }
            return;
        } else if(++dispatcherIdleCounter === 3)
            //pause on third time loop an empty Buffer
            pause();
    }

    function dispatcher() {
        callAppender();
        if(!paused)
            setTimeout(function() {
                dispatcher();
            }, 100);
    }
    function getLevel(){
        return this.threshold;
    }
    function setLevel(level){
        if(typeof level ==="string")
            this.threshold = levelStr2Int(level);
        else if(typeof level === "number")
            this.threshold = level;
    }
    var ConsoleAppender = function() {
        this.threshold = Logger.LEVEL.INFO;
        this.layout = new Logger.DefaultLayout();
        this.print = typeof console !== undefined ? function(msg) {
            console.log(msg);
        } : noop;
    };
    ConsoleAppender.prototype = {
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.print(this.layout.format(logTime, logLevel, logCate, logMsg));
        },
        setLayout : function(layout) {
            layout.format && (this.layout = layout);
        },
        getLevel : getLevel,
        setLevel : setLevel
    };
    var DefaultLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    DefaultLayout.prototype.format = function(logTime, logLevel, logCate, logMsg) {
        return "[" + logTime + "]" + "[" + getLevelStr(logLevel) + "]" + "[" + (logCate || "main") + "]-" + logMsg;
    };
    var DivAppender = function(div) {
//        if(!$) {  //remove jQuery dependency.
//            throw "need jQuery";
//        }
        this.threshold = Logger.LEVEL.INFO;
//        this.divSl = $(div);  //remove jQuery dependency.
		this.div = div;
        this.layout = new HTMLLayout();
    };
    DivAppender.prototype = {
        getLevel : getLevel,
        setLevel : setLevel,
        doAppend : function(logTime, logLevel, logCate, logMsg) {
//            this.divSl.append(this.layout.format(logTime, logLevel, logCate, logMsg));
			this.div.appendChild(this.layout.format(logTime, logLevel, logCate, logMsg));
        }
    };
    var HTMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    HTMLLayout.prototype = {
        getStyle : function(logLevel) {
            var style;
            if(logLevel === Logger.LEVEL.ERROR) {
                style = 'color:red';
            } else if(logLevel === Logger.LEVEL.WARN) {
                style = 'color:orange';
            } else if(logLevel === Logger.LEVEL.DEBUG) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.TRACE) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.INFO) {
                style = 'color:grey';
            } else {
                style = 'color:yellow';
            }
            return style;
        },
        format : function(logTime, logLevel, logCate, logMsg) {
            return "<div style=\"" + this.getStyle(logLevel) + "\">[" + logTime + "]" + "[" + getLevelStr(logLevel) + "][" + (logCate || "main") + "]-" + logMsg + "</div>";
        }
    };
    var FifoBuffer = function() {
        this.array = [];
    };

    FifoBuffer.prototype = {

        /**
         * @param {Object} obj any object added to buffer
         */
        push : function(obj) {
            this.array[this.array.length] = obj;
            return this.array.length;
        },
        /**
         * @return first putted in Object
         */
        pull : function() {
            if(this.array.length > 0) {
                var firstItem = this.array[0];
                for(var i = 0; i < this.array.length - 1; i++) {
                    this.array[i] = this.array[i + 1];
                }
                this.array.length = this.array.length - 1;
                return firstItem;
            }
            return null;
        },
        length : function() {
            return this.array.length;
        }
    };
    var AjaxAppender = function(url) {
        this.loggingUrl = url;
        this.isInProgress = false;
        this.threshold = Logger.LEVEL.INFO;
        this.bufferSize = 20;
        this.timeout = 2000;
        this.loggingEventMap = [];
        this.layout = new Logger.JSONLayout();
        this.httpRequest = null;
        this.timer = undefined;
    };
    function tryAppend() {
        var appender = this;
        if(this.isInProgress === true) {
            setTimeout(function() {
                tryAppend.call(appender);
            }, 100);
        }else{
            this.send();
        }
    }


    AjaxAppender.prototype = {
        getLevel : getLevel,
        setLevel : setLevel,
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.loggingEventMap.push([logTime, logLevel, logCate, logMsg]);
            if(this.loggingEventMap.length <= this.bufferSize || this.isInProgress === true) {
                var appender = this;
                if(this.timer === undefined) {
                    this.timer = setTimeout(function() {
                        tryAppend.call(appender);
                    }, 100);
                }
            }

            if(this.loggingEventMap.length >= this.bufferSize && this.isInProgress === false) {
                //if bufferSize is reached send the events and reset current bufferSize
                if(this.timer !== undefined)
                    clearTimeout(this.timer);
                this.send();
            }
        },
        send : function() {
            if(this.loggingEventMap.length > 0) {
                this.isInProgress = true;
                var a = [];
                var loggingEvent;
                for(var i = 0, lml = this.loggingEventMap.length; i < lml && i < this.bufferSize; i++) {
                    loggingEvent = this.loggingEventMap.shift();
                    a.push(this.layout.format(loggingEvent[0], loggingEvent[1], loggingEvent[2], loggingEvent[3]));
                }

                var content = this.layout.getHeader();
                content += a.join(this.layout.getSeparator());
                content += this.layout.getFooter();

                var appender = this;
                if(this.httpRequest === null) {
                    this.httpRequest = this.getXmlHttpRequest();
                }
                this.httpRequest.onreadystatechange = function() {
                    appender.onReadyStateChanged.call(appender);
                };

                this.httpRequest.open("POST", this.loggingUrl, true);
                // set the request headers.
                this.httpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                this.httpRequest.setRequestHeader("Content-length", content.length);
                //this.httpRequest.setRequestHeader("Content-type", this.layout.getContentType());
                this.httpRequest.send(content);
                appender = this;

                try {
                    setTimeout(function() {
                        appender.httpRequest.onreadystatechange = function() {
                        };
                        appender.httpRequest.abort();
                        //this.httpRequest = null;
                        appender.isInProgress = false;

                        if(appender.loggingEventMap.length > 0) {
                            appender.send();
                        }
                    }, this.timeout);
                } catch (e) {
                }
            }
        },
        onReadyStateChanged : function() {
            var req = this.httpRequest;
            if(this.httpRequest.readyState !== 4) {
                return;
            }

            var success = (( typeof req.status === "undefined") || req.status === 0 || (req.status >= 200 && req.status < 300));

            if(success) {

                //ready sending data
                this.isInProgress = false;

            } else {
            }
        },
        getXmlHttpRequest : function() {

            var httpRequest = false;

            try {
                if(window.XMLHttpRequest) {// Mozilla, Safari, IE7...
                    httpRequest = new XMLHttpRequest();
                    if(httpRequest.overrideMimeType) {
                        httpRequest.overrideMimeType(this.layout.getContentType());
                    }
                } else if(window.ActiveXObject) {// IE
                    try {
                        httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
                    } catch (e) {
                        httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
                    }
                }
            } catch (e) {
                httpRequest = false;
            }

            if(!httpRequest) {
                throw "browser don't support AJAX";
            }

            return httpRequest;
        }
    };
    var JSONLayout = function() {

    };
    JSONLayout.prototype = {
        /**
         * Implement this method to create your own layout format.
         * @param {Log4js.LoggingEvent} loggingEvent loggingEvent to format
         * @return formatted String
         * @type String
         */
        format : function(logTime, logLevel, logCate, logMsg) {

            var jsonString = "{\n \"LoggingEvent\": {\n";
            jsonString += "\t\"category\": \"" + (logCate || "main") + "\",\n";
            jsonString += "\t\"level\": \"" + getLevelStr(logLevel) + "\",\n";
            jsonString += "\t\"message\": \"" + logMsg + "\",\n";
            // jsonString += "\t\"referer\": \"" + referer + "\",\n";
            // jsonString += "\t\"useragent\": \"" + useragent + "\",\n";
            jsonString += "\t\"timestamp\": \"" + logTime + "\"\n";
            jsonString += "}\n}";

            return jsonString;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/json";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "{" + "\"ClientInfo\" : {\n" + "\t\"useragent\": \"" + useragent + "\",\n" + "\t\"referer\": \"" + referer + "\"\n},\n" + "\"VizLogger\": [\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "\n]}";
        },
        getSeparator : function() {
            return ",\n";
        }
    };

    /**
     * Get the XMLHttpRequest object independent of browser.
     * @private
     */
    var XMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    XMLLayout.prototype = {
        format : function(logTime, logLevel, logCate, logMsg) {

            var content = "<vizLogger:event category=\"";
            content += (logCate || "main") + "\" level=\"";
            content += getLevelStr(logLevel) + "\" timestamp=\"";
            content += logTime + "\">\n";
            content += "\t<vizLogger:message><![CDATA[" + this.escapeCdata(logMsg) + "]]></vizLogger:message>\n";
            content += "</vizLogger:event>";

            return content;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/xml";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "<vizLogger:eventSet useragent=\"" + useragent + "\" referer=\"" + referer.replace(/&/g, "&amp;") + "\">\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "</vizLogger:eventSet>\n";
        },
        getSeparator : function() {
            return "\n";
        },
        /**
         * Escape Cdata messages
         * @param str {String} message to escape
         * @return {String} the escaped message
         * @private
         */
        escapeCdata : function(str) {
            return str.replace(/\]\]>/, "]]>]]&gt;<![CDATA[");
        }
    };

    function getLevelStr(levelInt) {
        switch(levelInt) {
            case Logger.LEVEL.TRACE:
                return "TRACE";
            case Logger.LEVEL.DEBUG:
                return "DEBUG";
            case Logger.LEVEL.INFO:
                return "INFO";
            case Logger.LEVEL.WARN:
                return "WARN";
            case Logger.LEVEL.ERROR:
                return "ERROR";
        }
    }
    function levelStr2Int(levelStr) {
        switch(levelStr.toLowerCase()){
            case "trace":
                return Logger.LEVEL.TRACE;
            case "debug":
                return Logger.LEVEL.DEBUG;
            case "info":
                return Logger.LEVEL.INFO;
            case "warn":
                return Logger.LEVEL.WARN;
            case "error":
                return Logger.LEVEL.ERROR;
        }
    }
    var enabled = false;
    var paused = false;
    var logBuffer = [[/*logTime*/], [/*level*/], [/*category*/], [/*message*/]];
    var MaxBufferSize = 2000;
    var doLog = function(level, category, message) {
        if(logBuffer[0].length === MaxBufferSize)
            callAppender();
        logBuffer[0].push(Date.now());
        logBuffer[1].push(level);
        logBuffer[2].push(category);
        logBuffer[3].push(message.toString());
    };
    var awakeThenLog = function(level, category, message) {
        resume();
        doLog(level, category, message);
    };
    var log = noop;
    var pause = function() {
        paused = true;
        log = awakeThenLog;
    };
    var resume = function() {
        paused = false;
        log = doLog;
        setTimeout(function() {
            dispatcher();
        }, 100);
    };
    // id for appender
    var id = 0;
    var nextId = function() {
        return id++;
    };
    var appenders = {};
    /*
     * singleton Logger
     *
     */
    var Logger = {
        LEVEL : {
            TRACE : 5000,
            DEBUG : 10000,
            INFO : 20000,
            WARN : 30000,
            ERROR : 40000,
            NO : Number.MAX_VALUE
        },
        isEnabled : function() {
            return enabled;
        },
        enable : function() {
            log = doLog;
            enabled = true;
            setTimeout(function() {
                dispatcher();
            }, 100);
        },
        disable : function() {
            callAppender();
            log = noop;
            enabled = false;
        },
        toggleEnable : function() {
            if(enabled)
                this.disable();
            else
                this.enable();
        },
        addAppender : function(/*[key,] appender*/) {
            var _nextId = nextId();
            var key, appender;
            if(arguments.length === 1) {
                key = _nextId;
                appender = arguments[0];
            } else if(arguments.length >= 2) {
                key = arguments[0];
                appender = arguments[1];
            }
            if( typeof appender === "object" && appender.doAppend) {
                if(appenders[key] !== undefined)
                    return;
                callAppender();
                appenders[key] = appender;
                return key;
            }

        },
        setAppenders : function(apds) {
            appenders = [];
            for(var i = 0, l = apds.length; i < l; i++) {
                var appender = apds[i];
                if(appender.appenderKey)
                    this.addAppender(appender.appenderKey, appender.appender);
                else
                    this.addAppender(appender.appender);
            }
        },
        removeAppender : function(key) {
            if(appenders[key] === undefined)
                return false;
            //append immediately before remove
            callAppender(appenders[key]);
            return (
            delete appenders[key]);
        },
        getAppender : function(key) {
            return appenders[key];
        },
        ConsoleAppender : ConsoleAppender,
        DivAppender : DivAppender,
        AjaxAppender : AjaxAppender,
        //[time][level][category]-message [yyyy-MM-ddThh:mm:ss:ms][INFO][function1]-this is a piece of log.
        DefaultLayout : DefaultLayout,
        HTMLLayout : HTMLLayout,
        XMLLayout : XMLLayout,
        JSONLayout : JSONLayout,
        trace : function(message, category) {
            log(Logger.LEVEL.TRACE, category, message);
        },
        debug : function(message, category) {
            log(Logger.LEVEL.DEBUG, category, message);
        },
        info : function(message, category) {
            log(Logger.LEVEL.INFO, category, message);
        },
        warn : function(message, category) {
            log(Logger.LEVEL.WARN, category, message);
        },
        error : function(message, category) {
            log(Logger.LEVEL.ERROR, category, message);
        }
    };
    appenders["[default]"] = new Logger.ConsoleAppender();
    return Logger;
});sap.riv.module(
{
  qname : 'sap.viz.util.log.LogUtil',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.Logger',
  version : '4.0.2'
}
],
function Setup(LOG){
  var ret = {
    'profiling' : function(msg){
      //chrome supports window.performance.memory, we include it in profile message
      if(window && window.performance && window.performance.memory){
        var m = window.performance.memory;
        msg = '[' + m.usedJSHeapSize + '][' + m.totalJSHeapSize + '][' + m.jsHeapSizeLimit + ']' + msg;
      }
      LOG.debug(msg, 'PROFILING');
    },
    
    'context' : function(msg){
      //try to get as many env contexts as possible
      if(window && window.navigator){
        msg = "[" + window.navigator.userAgent + "]" + msg;
      }
      LOG.debug(msg, 'CONTEXT');
    }
  };
  return ret;
});sap.riv.module(
{
  qname : 'sap.viz.util.elementutil',
  version : '4.0.2'},
[

],
function Setup () {
  var ret = {
    'isSVG' : function(selection){
      return ret.isGElement(selection) || ret.isSVGElement(selection);
    },
    'isGElement' : function(selection){
      return selection.node().nodeName.toLowerCase() === 'g';
    },
    'isSVGElement' : function(selection){
      return selection.node().nodeName.toLowerCase() === 'svg';
    },
    'isDIV' : function(selection){
      return selection.node().nodeName.toLowerCase() === 'div';
    }
  };
  return ret;
});sap.riv.module(
{
  qname : 'sap.viz.Constants',
  version : '4.0.2'},
[

],
function Setup() {
  var constants = {
    SAPColorSingleAxis : [ "#748CB2", "#9CC677", "#EACF5E", "#F9AD79",
        "#D16A7C", "#8873A2", "#3A95B3", "#B6D949", "#FDD36C", "#F47958",
        "#A65084", "#0063B1", "#0DA841", "#FCB71D", "#F05620", "#B22D6E",
        "#3C368E", "#8FB2CF", "#95D4AB", "#EAE98F", "#F9BE92", "#EC9A99",
        "#BC98BD", "#1EB7B2", "#73C03C", "#F48323", "#EB271B", "#D9B5CA",
        "#AED1DA", "#DFECB2", "#FCDAB0", "#F5BCB4" ],

    SAPColorDualAxis1 : [ "#8FBADD", "#B8D4E9", "#7AAED6", '#A3C7E3',
        '#3D88C4', '#66A1D0', '#297CBE', '#5295CA', '#005BA3', '#146FB7',
        '#005395', '#0063B1' ],

    SAPColorDualAxis2 : [ "#F6A09B", "#F9C3C0", "#F58E88", '#F8B1AD',
        '#F05B52', '#F37D76', '#EE4A40', '#F16C64', '#D92419', '#ED382D',
        '#C52117', '#EB271B' ]
  };

  constants.SAPColor = constants.SAPColorSingleAxis;

  return constants;
});sap.riv.module(
{
  qname : 'sap.viz.util.fn.domposition',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.elementutil',
  version : '4.0.2'
}
],
function Setup (Constants, elementutil) {
  
  var positionSVG = function(target, info){
    if(target && info){
      if(elementutil.isSVGElement(target)){
        target.attr('width', info.width);
        target.attr('height', info.height);
      }
      target.attr('transform', 'translate(' + info.x +', ' + info.y + ')');
    }
  };
  
  var positionDIV = function(target, info){
    if(target && info){
      target.attr('style', 'position: absolute; box-sizing: border-box; overflow: hidden; width: ' + info.width + 'px; height: ' + info.height + 'px; left: ' + info.x + 'px; top: ' + info.y + 'px;');
    }
  };
  
  /*
   * this function helps you to position dom elements (selections) based on passed in layout info.
   * @returns 
   */
  var retfn = function ( layout, selections ) {
    var iter;
    
    for(iter in selections){
      if(selections.hasOwnProperty(iter)){
        if(layout[iter]){
          var info = layout[iter];
          if(elementutil.isSVG(selections[iter])){
            positionSVG(selections[iter], info.bounds);
          }else if(elementutil.isDIV(selections[iter])){
            positionDIV(selections[iter], info.bounds);
          }
        }
      }
    }
  };
  
  return retfn;
});sap.riv.module(
{
  qname : 'sap.viz.util.append',
  version : '4.0.2'},
[

],
function Setup () {
  return function ( markup, attrs ) {
    var node = this.append(markup);
    for ( var key in attrs ) {
      if ( attrs.hasOwnProperty(key) ) { node.attr(key, attrs[key]); }
    }
    return node;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.2'
}
],
function Setup(constants) {
  var moduleConstants = {
    Type : {
      Chart : 'CHART',
      Container : 'CONTAINER',
      Supplementary : 'SUPPLEMENTARY',
      Behavior : 'BEHAVIOR',
      Controller : 'CONTROLLER',
      
      Scientific : {
        Layout : 'Represents a layout algorithm'
      },
      
      Presentation : {
        Tooltip : 'Represents a tooltip'
      },
      
      ThirdParty : 'THIRDPARTY'
    },
    RenderTo : {
      SVG : 'SVG',
      DIV : 'DIV',
      NONE : 'NONE'
    },
    CSS : {
      CLASS : {
        DATAPOINT : "v-datapoint"
      }
    },
    LAYOUT_ADJUST_POLICY : {
      APPROXIMATE : 'APPROXIMATE',
      RELAYOUT : 'RELAYOUT'
    },
    Event : {
      SelectData : {
        name: 'selectData',
        desc : 'Event fires when certain data point(s) is(are) selected, data context of selected item(s) would be passed in accordance with the following format.'
          + '<code>{name: "selectData",'
          + 'data:[{\n//selected element\'s detail\n'
          + 'target:"Dom Element",//an object pointed to corresponding dom element\n'
          + 'data:[{val: "...",//value of this element\n'
          + 'ctx:{type:"Dimension"||"Measure"||"MND",\n'
          + '//for Dimension\n'
          + 'path:{aa:"...",di:"...",dii:"..."},\n'
          + '//for Measure\n'
          + 'path:{mg:"...",mi:"...",dii_a1:"...",dii_a2:"..."},\n'
          + '//for MND\n'
          + 'path:{mg:"...",mi:"..."}\n'
          + '//path: analysis path\n'
          + '//aa: analysis axis index // 0 for analysis axis 1,  1 for analysis 2\n'
          + '//di: dimension index //zero based\n'
          + '//dii: dimension item index //zero based\n'
          + '//mg: measure group index // 0 for measure group 1,1 for measure group 2\n'
          + '//mi: measure index // measure index in measure group zero based\n'
          + '//dii_a1: each dii of di in analysis axis 1 index\n'
          + '//dii_a2: each dii of di in analysis axis 2 index\n'
          + '}},{\n//for bubble, tagcloud and scatter, there will be more than one values in one selected element.\n'
          + 'var:"...",ctx:"..."}]},{\n//if under multi selection, there will be more than one selected elements\n'
          + 'target:"...",data:["..."]}]}'
      },
      DeSelectData : {
        name: 'deselectData',
        desc : 'Event fires when certain data point(s) is(are) deselected, data context of deselected item(s) would be passed in accordance with the following format.'
          + '<code>{name: "deselectData",'
          + 'data:["---the same as selectedData---"]}'
      },
      TooltipShow : {
        name: 'showTooltip',
        desc : 'Event fires when the mouse hover onto the specific part of chart, data context of tooltip would be passed in accordance with the following format.'
          + '<code>{name:"showTooltip",data:{body:[{\n//data of one group\n'
          + 'name:"...",val:[{\n//data of one row\n'
          + 'color:"...",label:"...",shape:"...",value:"..."},"..."]},"..."],footer:[{label:"...",value:"..."},"..."],'
          + 'plotArea:{\n//this object specifies the plot area of the chart\n'
          + 'height:"...",width:"...",x:"...",y:"..."},point:{\n//this object specifies a point which affects the position of tooltip\n'
          + 'x:"...",y:"..."}}}'
      },
      TooltipHide : {
        name: 'hideTooltip',
        desc : 'Event fires when the mouse hover out of the specific part of chart, no data is passed.'
      },
      Initialized : {
        name: 'initialized',
        desc : 'Event fires when the loading ends. To use the event listener when creating charts, you must use an event that is passed by the events option. For more information on events options, see the usrOptions section of the <a href="sap.viz.core.html#createViz" target="_blank">createViz</a> function in the API document.'
      },
      highlightedByLegend : {
        desc : "Event fires when legend item is clicked, which contains its data context."
      }   
    },
    
    mappings : {
      e2p : function ( em ) { return em * 12; }
    }
  };

  constants.Module = moduleConstants;

  return moduleConstants;
});sap.riv.module(
{
  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.2'
}
],
function Setup(constants) {
  var feed = {
    Type : {
      Dimension : "Dimension",
      Measure : "Measure"
    },
    Constraints : {
      INF : Number.POSITIVE_INFINITY
    }
  };
  constants.Feed = feed;
  return feed;
});sap.riv.module(
{
  qname : 'sap.viz.style.Element',
  version : '4.0.2'},
[

],
function Setup() {
  function StyleDef( value ) {
    this.update(value);
  }

  StyleDef.prototype = {
    toString : function() {
      var str = "", i;

      for (i in this) {
        if ( this.hasOwnProperty(i) ) {
          str += i + ":" + this[i] + ";";
        }
      }

      return str;
    },
    toAttrs : function( selection ) {
      for ( var i in this) {
        if ( this.hasOwnProperty(i) ) {
          selection.attr(i, this[i]);
        }
      }
    },
    update : function( obj ) {
      for ( var i in obj) {
        if ( obj.hasOwnProperty(i) ) {
          this[i] = obj[i];
        }
      }
    }
  };

  var html = document.documentElement, matches = html.matchesSelector || html.mozMatchesSelector ||
      html.webkitMatchesSelector || html.msMatchesSelector;

  function Element( el ) {

    if ( !el ) {
      el = d3.select(document.implementation.createHTMLDocument("").body);
    }

    this.el = el;
  }

  Element.prototype = {
    child : function( classNames, tagNames, defaultTagName, defaultStyle ) {
      if ( !Array.isArray(tagNames) ) {
        tagNames = [tagNames];
      }

      if ( !Array.isArray(classNames) ) {
        classNames = [classNames];
      }

      var el = this.el, create = false;
      var len = Math.max(tagNames.length, classNames.length);
      for ( var i = 0; i < len; i++) {
        var tagName = tagNames[i];
        var className = classNames[i];

        if ( !tagName && !className ) {
          create = true;
        }

        tagName = tagName || defaultTagName;

        if ( !create ) {
          var selector = tagName;
          if ( className ) {
            selector += "." + className.replace(" ", ".");
          }
          var node = el.node();
          var children = el.selectAll(selector).filter(function() {
            return this.parentNode === node;
          });

          if ( !children.empty() ) {
            el = children;
            continue;
          }

          create = true;
        }

        el = d3.select(el.node()).append(tagName).attr("class", className).datum({
          defaultStyle : new StyleDef(),
          currentStyle : new StyleDef(),
          meta : {}
        });
      }

      var result = new Element(el);
      if ( defaultStyle ) {
        var data = el.datum();
        data.defaultStyle.update(defaultStyle);
        data.currentStyle.update(defaultStyle);
      }

      return result;
    },

    defaultStyle : function() {
      return this.el.datum().defaultStyle;
    },

    currentStyle : function() {
      return this.el.datum().currentStyle;
    },

    queryAll : function( selectorText ) {
      var result = [];
      this.el.selectAll(selectorText).each(function() {
        result.push(new Element(d3.select(this)));
      });
      return result;
    },

    match : function( selectorText ) {
      return matches.call(this.el.node(), selectorText);
    },

    update : function( selector, properties ) {
      var currentStyle = this.currentStyle();
      var currentStyleValue = this.currentStyle();
      var currentStylePriority = this.el.datum().meta;
      $.each(properties, function( name, value ) {
        var currentPropertyPriority = currentStylePriority[name];
        var currentImportant = false, currentSelector;
        if ( currentPropertyPriority ) {
          currentImportant = currentPropertyPriority.important;
          currentSelector = currentPropertyPriority.selector;
        }
        var newImportant = value.important;
        if ( (newImportant && (!currentImportant || selector.nlt(currentSelector))) ||
            (!newImportant && !currentImportant && selector.nlt(currentSelector)) ) {
          currentStyleValue[name] = value.value;
          if ( !currentPropertyPriority ) {
            currentPropertyPriority = {};
            currentStylePriority[name] = currentPropertyPriority;
          }
          currentPropertyPriority.important = newImportant;
          currentPropertyPriority.selector = selector;
        }
      });
      return this;
    },
    
    cleanChildren : function() {
      var node = this.el.node();
      var child;
      while ((child = node.firstChild)) {
        node.removeChild(child);
      }
      return this;
    }
  };

  return Element;
});sap.riv.module(
{
  qname : 'sap.viz.style.Manager',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.style.Element',
  version : '4.0.2'
}
],
function Setup( Element ) {
  function StyleManager( sheets, moduleManifest, element, defaultTagName ) {
    var subEls = {};

    if ( !element ) {
      element = new Element();
    }

    this.el = element;

    if ( moduleManifest ) {
      var css = moduleManifest.css;
      if ( css ) {
        $.each(css, function( selector, obj ) {
          var className = selector.substring(1).replace(".", " ");
          var el = element.child(className, null, defaultTagName || "g", obj.value);
          className.split(" ").forEach(function( singleSelector ) {
            subEls[singleSelector] = el;
          });

          if ( sheets ) {
            sheets.forEach(function( sheet ) {
              sheet.iterate(function( selector, properties ) {
                if ( el.match(selector.text) ) {
                  el.update(selector, properties);
                }
              });
            });
          }
        });
      }
    }

    this.subEls = subEls;
    this.sheets = sheets;
  }

  StyleManager.prototype = {
    query : function( selector ) {
      var currentNode = this.subEls[selector];
      if ( currentNode ) {
        return currentNode.currentStyle();
      }
    },

    queryDefault : function( selector ) {
      var currentNode = this.subEls[selector];
      if ( currentNode ) {
        return currentNode.defaultStyle();
      }
    },

    cssText : function( selector ) {
      return this.query(selector).toString();
    },

    child : function( moduleManifest, classNames, tagNames, defaultTagName ) {
      return new StyleManager(this.sheets, moduleManifest, this.el.child(classNames, tagNames, defaultTagName || "g"),
          defaultTagName);
    },

    applyCSS : function( sheet ) {
      var root = this.el;
      sheet.rules.forEach(function( rule ) {
        rule.selectors.forEach(function( selector ) {
          root.queryAll(selector.text).forEach(function( match ) {
            match.update(selector, rule.properties);
          });
        });
      });
      return this;
    },

    cleanChildren : function() {
      this.el.cleanChildren();
      return this;
    }
  };

  return StyleManager;
});sap.riv.module(
{
  qname : 'sap.viz.util.fn.createContext',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.style.Manager',
  version : '4.0.2'
}
],
function Setup( StyleManager ) {
  return function( moduleManifest, parentCtx, classNames, tagNames ) {
    var styleManager = parentCtx.styleManager;
    if ( !styleManager ) {
      styleManager = new StyleManager();
    }
    styleManager = styleManager.child(moduleManifest, classNames, tagNames);
    var temp = {'styleManager' : styleManager};
    $.each(parentCtx, function(key, value){
        if (key !== 'styleManager'){
            temp[key] = value;
        }
    });
    return temp;
  };
});sap.riv.module(
{
  qname : 'sap.viz.util.Objects',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils) {

  var objects = {
    // copy from sap.viz.base.utils.ObjectUtils.extend
    // in this version, when target is array, just use src replace target
    extend : function() {
      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

      // Handle a deep copy situation
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in
      // deep
      // copy)
      if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if (length === i) {
        target = this;
        --i;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) !== null) {
          // Extend the base object
          for (name in options) {
            if (options.hasOwnProperty(name)){
              src = target[name];
              copy = options[name];

              // Prevent never-ending loop
              if (target === copy) {
                continue;
              }

              // Recurse if we're merging plain objects or arrays
              // in this version, when target is array, just src replace target
              if (deep && copy && (TypeUtils.isPlainObject(copy))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone = src && TypeUtils.isArray(src) ? src : [];

                } else {
                  clone = src && TypeUtils.isPlainObject(src) ? src : {};
                }
                // Never move original objects, clone them
                target[name] = objects.extend(deep, clone, copy);
                // Don't bring in undefined values
              } else if (copy !== undefined) {
                target[name] = copy;
              }              
            }
          }
        }
      }
      // Return the modified object
      return target;
    },    
    equal: function (objA, objB){
      if(typeof arguments[0] !== typeof arguments[1]){
        return false;
      }
      if (objA === undefined){
        if (objB !== undefined){
          return false;
        }
      }
      if (objA === null){
        if (objB !== null){
          return false;
        }
      }
      if(objA instanceof Array){
        if (!(objB instanceof Array)){
          return false;
        }
        if(objA.length !== objB.length){
          return false;
        }
        var arrayEqualResult = true;
        for(var i = 0; i < objA.length; i++){
          if(typeof objA[i] !== typeof objB[i]){
            return false;
          }
          if(typeof objA[i] === 'boolean' || typeof objA[i] === 'number' || typeof objA[i] === 'string' || typeof objA[i] === 'undefined' || objA[i] === null){
            arrayEqualResult = (objA[i] === objB[i]);
          }
          else if(objA[i] instanceof Object){
            arrayEqualResult = this.equal(objA[i] , objB[i]);
          }
          else{
            return false;
          }
          if(!arrayEqualResult){
            return false;
          }
        }
        return true;
      }
      if(objA instanceof Object && objB instanceof Object && typeof objA !== 'function' && typeof objB !== 'function'){
        if (objB === null || objB instanceof Array){
          return false;
        }
        var attrLenA = 0, attrLenB = 0;
        var attr;
        for(attr in objA){
          if (objA.hasOwnProperty(attr)){
            if(typeof objA[attr] === 'boolean' || typeof objA[attr] === 'number' || typeof objB[attr] === 'string' || typeof objA[attr] === 'undefined' || objA[attr] === null){
              if(objA[attr] !== objB[attr]){
                return false;
              }
            }
            else{
              if(!this.equal(objA[attr], objB[attr])){
                return false;
              }
            }
            attrLenA++;
          }
        }
        for(attr in objB){
         if(objB.hasOwnProperty(attr)){
           attrLenB++;
         }
        }
        if(attrLenA !== attrLenB){
          return false;
        }
        return true;
      }
      return objA === objB;
    },

    // returns an array of the plot's parent nodes, in the same order as the "plots" array
    getPlotNodes : function(plots) {
      var nodes = [];
      for (var i = 0, len = plots.length; i < len; i++) {
        if (plots[i].parent()) {
          nodes.push(plots[i].parent().node());
        }
      }
      return nodes;
    },

    // returns the index of the plot (in the "plots" array) that contains the target element
    // nodes is optional and should contain the container elements for the plots
    plotIndexContainingTarget : function(plots, target, nodes) {
      var n = target,
        plotNodes = nodes || this.getPlotNodes(plots),
        idx;

      for (; n && n.ownerSVGElement; n = n.parentNode) {
        idx = plotNodes.indexOf(n);
        if (idx !== -1) {
          return idx;
        }
      }

      return -1;
    },

    // returns the plot module object that contains the target element
    plotContainingTarget : function(plots, target, nodes) {
      var plotIdx = this.plotIndexContainingTarget(plots, target, nodes);

      if (plotIdx !== -1) {
        return plots[plotIdx];
      }

      return null;
    },
        
    isLabelArea : function(classname, selectionMode)
    {
        var isAxisLabelArea = false;
        if(classname && classname.indexOf('v-labelarea') >= 0)//find it
        {
          if(selectionMode !== 'single')
          {
              //do not have label selection in 'single'
              isAxisLabelArea = true;
          }
        }
        return isAxisLabelArea;
    },
    
    size : function(obj){
      var ret = 0;
      //here we want to filter both undefined and null
      /*jshint eqnull:true */
      if (obj != null){
        if (obj.length === +obj.length){
          ret = obj.length;
        }else{
          for(var i in obj){
            if(obj.hasOwnProperty(i)){
              ret++;
            }
          }
        }
      }
      return ret;
    },

    normalizeNumbersCeil : function(obj)
    {
        for(var prop in obj)
        {
            if(obj.hasOwnProperty(prop))
            {
                if((typeof obj[prop]) === "number")
                {
                    //we do not use toFixed, because toFixed makes 5.54 to 5.5, but we need 5.6
                    var standard = 100000000;
                    var tempInt = Math.ceil(obj[prop] * standard);
                    obj[prop] = tempInt/standard;
                }
            }
        }
    }
    
  };
  return objects;
});sap.riv.module(
{
  qname : 'sap.viz.manifest',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils, FunctionUtils, ObjectUtils) {
  /**
   * <pre>
   * Manifest is an internal collection to store all definitions/configurations.
   * There are three built-in categories:
   *      feeds: store definitions of all feed groups
   *      module: store definitions of all modules
   *      viz: store definitions of all charts
   * </pre>
   * @module sap.viz.manifest
   * @example
   * 
   * var Manifest = sap.viz.manifest;
   * @ignore
   */

  var manifest = {};
  /**
   * <pre>
   * register a new category in manifest.
   * Once a category is registered, you can access it by Manifest[name] or Manifest.name
   * </pre>
   * @method sap.viz.manifest#registerCategory
   * @param {String}name name of the new category
   * @param {Function} factory optional and if provided,it will become "item factory function" of this category
   * @param {Object} factoryThisObj optional and if provided, it will become the object executed by item factory function
   * @returns {[Object] category} the new category {link sap.viz.manifest.xxxcategory} 
   * @example
   * manifest.registerCategory("feeds", function(obj) {
   *
   * var feeds = {};
   *  obj.feeds.forEach(function(o) {
   *    feeds[o.id] = o;
   *  });
   *
   * Object.defineProperty(obj, "feedsMap", {
   *    value : feeds,
   *    writable : false,
   *    enumerable : false,
   *    configurable : false
   *  });
   *
   *  return obj;
   * });
   * @ignore
   */
  manifest.registerCategory = function(name, factory, factoryThisObj) {
    if (!TypeUtils.isNonEmptyString(name)) {
      FunctionUtils.error("The category name must be a non-empty string.");
    }

    if (factory && !TypeUtils.isFunction(factory)) {
      FunctionUtils.error("The category factory must be a function.");
    }

    if (manifest.hasOwnProperty(name)) {
      FunctionUtils.error("There is already a category named \"{0}\"", name);
    }

    var collection = d3.map();
    /**
     * xxx represents feeds, module and viz. The three categories have been registered into manifest and could provide some common APIs. 
     * @class sap.viz.manifest.xxx
     * @ignore
     */
    var category = {
        /**
           * Load an item from category by id.</br>
           * </br>
           * If the item is a Built-in_Manifest_Objects, it will provide some other APIs.Please see the corresponding object in Built-in_Manifest_Objects.</br>
           * @see Built-in_Manifest_Objects
           * @method sap.viz.manifest.xxx#get
           * @param {String} id the id of item
           * @param {Object} throwErrorIfNull optional, a exception type
           * @returns {Object} the item loaded from category by id
           * @example
           * 
           * var moduleFeeds =  manifest.feeds.get(id);//xxx represents feeds
           * var barModule = manifest.module.get(barId);//xxx represents module
           * var lineChart = manifest.viz.get(lineChartId);//xxx represents viz
           * @ignore
           */
      get : function(id, throwErrorIfNull) {
        var result = collection.get(id);
        if (result === undefined && throwErrorIfNull) {
          FunctionUtils.error("Cannot find \"{0}\" in category \"{1}\"", id,
              name);
        }
        
        if(result && result["__needParsed__"] === true){
          var isAbstract = result["abstract"] === true;
          result = ObjectUtils
              .extend(true, null, result.base !== undefined ? category.get(
                  result.base, true) : null, result);
  
          Object.defineProperty(result, "abstract", {
            value : isAbstract,
            enumerable : false
          });
  
          if (factory && !isAbstract) {
            factory.call(factoryThisObj, result, manifest);
          }
          
          delete result["__needParsed__"];
          collection.set(id, result);
        }
        return result;
      },
      /**
       * <pre>
       * Iterate whole category execute callback function for every item which has been registered into xxx. 
       * </pre>
       * @method sap.viz.manifest.xxx#each
       * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
       * @param {Object} thisObj optional and default value is obj self
       * @return {Object} manifest
       * @example
       * 
       * manifest.xxx.each(function(obj, id){
       *   .... 
       * });
       * @ignore
       */
      each : function(callback, thisObj) {
        collection.forEach(function(id) {
          callback.call(thisObj, category.get(id), id);
        });
        return manifest;
      },
      
      /**
       * unregister the item with specified id from category
       * @method sap.viz.manifest.xxx#unregister
       * @param {String} id id of the item being unregistered
       * @return {Object} the removed module Object
       * @example
       * manifest.module.unregister('sap.viz.modules.bar');
       * @ignore
       */
      unregister : function (id) {
        var ret;
        if(TypeUtils.isExist(id)){
          ret = collection.get(id);
          collection.remove(id);
        }
        return ret;
      },
      
      /**
       * Register an item into category
       * @method sap.viz.manifest.xxx#register 
       * @param {Object} newItems variable parameters, at least need one item to be registered into category
       * @return {Object} manifest
       * @example
       * 
       * manifest.viz.register(chartOne);//xxx represents viz
       * ....
       * manifest.viz.register(chartOne,chartTwo,chartThree);
       * ....
       * manifest.module.register(tooltip);//xxx represents module
       * @ignore
       */
      register : function() {
        Array.prototype.forEach.call(arguments, function(obj) {
          if (TypeUtils.isUndefined(obj)) {
            FunctionUtils.error("Cannot register a undefined object.");
          }

          var idStr = obj.id;

          if (!TypeUtils.isNonEmptyString(idStr)) {
            FunctionUtils.error("Cannot register without a valid id.");
          }

          if (collection.has(idStr)) {
            FunctionUtils.error(
                "There is already an item named \"{0}\" in category \"{1}\".",
                idStr, name);
          }
          
          obj["__needParsed__"] = true;          

          collection.set(idStr, obj);
        });

        return manifest;
      }
    };

    manifest[name] = category;
    return category;
  };
  
  /**
   * unregister category with the specified category name
   * @param {String} cname name of the category to be unregistered
   * @returns {Boolean} true if successfully deleted 
   * @ignore
   */
  manifest.unregisterCategory = function (cname){
    return cname in manifest && delete manifest[cname];
  };
  
  /**
   * {@link sap.viz.manifest.feeds} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.feeds
   */
  /**
  * Load an item from {@link sap.viz.manifest.feeds}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.feeds} will provide some API.</br>
  * @method sap.viz.manifest.feeds#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.feedsManifest}
  * @example
  * 
  * var moduleFeeds =  manifest.feeds.get(id);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.feeds} category execute callback function for every item which has been registered into {@link sap.viz.manifest.feeds}. 
  * 
  * @method sap.viz.manifest.feeds#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.feeds}
  * @example
  * 
  * manifest.feeds.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.feeds} category
   * @method sap.viz.manifest.feeds#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.feeds}
   * @example
   * 
   * manifest.feeds.register(chartOneFeeds);
   * manifest.feeds.register(chartTwoFeeds,chartThreeFeeds);
   */
  
  /**
   * unregister an item from {@link sap.viz.manifest.feeds} category
   * @method sap.viz.manifest.feeds#unregister 
   * @param {String} id id of the feed being unregistered
   * @return {Object} the removed feed object {@link sap.viz.manifest.feeds}
   * @example
   * 
   * manifest.feeds.unregister('CHART_FEED_ID');
   */

   /**
   * {@link sap.viz.manifest.viz} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.viz
   */
  /**
  * Load an item from {@link sap.viz.manifest.viz}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.viz} will provide some API.</br>
  * @method sap.viz.manifest.viz#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.vizManifest}
  * @example
  * 
  * var lineChart =  manifest.viz.get(lineChartId);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.viz} category execute callback function for every item which has been registered into {@link sap.viz.manifest.viz}. 
  * 
  * @method sap.viz.manifest.viz#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.viz}
  * @example
  * 
  * manifest.viz.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.viz} category
   * @method sap.viz.manifest.viz#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.viz}
   * @example
   * 
   * manifest.viz.register(lineChart);
   * manifest.viz.register(pieChart,radarChart);
   */
  
  /**
   * unregister an item from {@link sap.viz.manifest.viz} category
   * @method sap.viz.manifest.viz#unregister 
   * @param {String} id id of the viz being unregistered
   * @return {Object} the removed viz object {@link sap.viz.manifest.viz}
   * @example
   * 
   * manifest.viz.unregister('viz/bar');
   */

   /**
   * {@link sap.viz.manifest.module} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.module
   */
  /**
  * Load an item from {@link sap.viz.manifest.module}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.module} will provide some API.</br>
  * @method sap.viz.manifest.module#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.moduleManifest}
  * @example
  * 
  * var lineModule =  manifest.viz.get(lineModuleId);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.module} category execute callback function for every item which has been registered into {@link sap.viz.manifest.module}. 
  * 
  * @method sap.viz.manifest.module#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.module}
  * @example
  * 
  * manifest.module.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.module} category
   * @method sap.viz.manifest.module#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.module}
   * @example
   * 
   * manifest.module.register(lineModule);
   * manifest.module.register(pieModule,radarModule);
   */

  /**
   * unregister an item from {@link sap.viz.manifest.module} category
   * @method sap.viz.manifest.module#unregister 
   * @param {String} id id of the module being unregistered
   * @return {Object} the removed module object {@link sap.viz.manifest.module}
   * @example
   * 
   * manifest.module.unregister('sap.viz.modules.bar');
   */
  return manifest;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.fn.createContext',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
}
],
function Setup(manifest, FunctionUtils, Objects, TypeUtils, createContext) {
  var KEEP_DEFINITION = true;
  function loadModule(modules, moduleConfig, moduleRefName) {
    var moduleId = moduleConfig.id;
    if (moduleId === undefined) {
      FunctionUtils.error("Cannot find module id in sub module config \"{0}\"",
          JSON.stringify(moduleConfig));
    }

    var module = manifest.module.get(moduleConfig.id, true);
    modules.push({
      module : module,
      config : moduleConfig,
      moduleRef : moduleRefName,
      subModules : module.subModules(moduleConfig, moduleRefName)
    });
  }

  function exactDefaultProperties(props, keepDefinition) {
    var defaultProps = {}, n, prop;
    for (n in props) {
      if (props.hasOwnProperty(n)) {
        prop = props[n];
        if (prop) {
          if (keepDefinition === true) {
            defaultProps[n] = Objects.extend(true, {}, prop);
          } else {
            defaultProps[n] = prop.supportedValueType === 'Object' ? exactDefaultProperties(
                prop.supportedValues, !KEEP_DEFINITION)
                : prop.defaultValue;
          }
        }
      }
    }
    return defaultProps;
  }
  /**
   * This is a instantce , which already have been registered into
   * {@link sap.viz.manifest.module}.</br> </br> Now, once an item is loaded
   * from {@link sap.viz.manifest.module}, it will automatically provide some
   * APIs .</br> </br>
   * 
   * @example var legend = manifest.module.get(legendID);
   * @see sap.viz.manifest.module#get
   * @class Built-in_Manifest_Objects.moduleManifest
   */
  manifest.registerCategory("module", function(obj) {
    var defaultPropertyValues;
    var allPropertyDefinitions;

    Object.defineProperties(obj, {
      subModules : {
        value : function(moduleConfig, parentRefName) {
          var subModules;
          var subModuleConfigs = Objects.extend(true, {}, moduleConfig.modules, moduleConfig.controllers);
          // TODO: fix those hard code when new layout is cheched in.
          if (!TypeUtils.isEmptyObject(subModuleConfigs)) {
            subModules = [];
            var subModuleConfig;
            for (var key in subModuleConfigs ){
              if (subModuleConfigs.hasOwnProperty(key)){
                subModuleConfig = subModuleConfigs[key];
                if (subModuleConfig) {
                  loadModule(subModules, subModuleConfig, parentRefName + '.' + key);
                }               
              }
            }
          }
          
          return subModules;
        }
      },
      /**
       * return properties of this module with or without definitions,
       * controlled by the parameter. if without definition, only default value
       * is returned for each property.
       * 
       * @method Built-in_Manifest_Objects.moduleManifest#props
       * @param {Boolean}
       *          withDefinition whether include definitions in the return
       *          object. by default false
       * @return {Object} properties of this module
       */
      props : {
        value : function(withDefinition) {
          if (withDefinition === KEEP_DEFINITION) {
            if (!allPropertyDefinitions) {
              allPropertyDefinitions = exactDefaultProperties(obj.properties,
                  KEEP_DEFINITION);
            }
            return allPropertyDefinitions;
          } else {
            if (!defaultPropertyValues) {
              defaultPropertyValues = exactDefaultProperties(obj.properties,
                  !KEEP_DEFINITION);
            }
            return Objects.extend(true, {}, defaultPropertyValues);
          }
        }
      },
      /**
       * execute the fn(function) defined in selected module. The default
       * argument of fn is the module self.</br>
       * 
       * @method Built-in_Manifest_Objects.moduleManifest#execute
       * @return {Object} the result of executing fn
       * @example
       * 
       * var moduleManifest = manifest.module.get(id);//get the item from module's manifest by id
       * var result = moduleManifest.execute();//execute the fn defined in the item
       * 
       */
      execute : {
        value : function( parentCtx, classNames, tagNames ) {
          return obj.fn(obj, classNames === true ? parentCtx : createContext(this, parentCtx, classNames, tagNames));
        }
      }
    });
    return obj;
  });

  manifest.module.loadModule = loadModule;

  return manifest.module;
});sap.riv.module(
{
  qname : 'sap.viz.util.fn.dombuilder',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.append',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.elementutil',
  version : '4.0.2'
}
],
function Setup (Constants, ModuleDefs, append, FnUtil, elementutil) {

  /*
   * this function helps you create viz structure on parent based on passed in modules configuration.
   * @returns {Object} {'ModuleReferenceKey' : DOMElement/D3Selection(based on module's renderTo type)}
   */
  var retfn = function ( parent, conf ) {
    //if parent is svg/d3selection, we don't allow any more div children
    var parentSVG = elementutil.isSVG(parent);
    var root = parent;
    var ret = {};
    //if all sub modules is render to SVG/NULL, we need create only one SVG and append a 'g' for each of them
    //if sub modules have both SVG and DIV, we create div for DIV and create 'svg->g' element for each SVG sub modules
    var allSVG = true; 
    var key, module;
    for(key in conf){
      if(conf.hasOwnProperty(key)){
        module = ModuleDefs.get(conf[key].id);
        if(module && module.renderto === Constants.Module.RenderTo.DIV){
          if(parentSVG){
            FnUtil.error('Configuration Error! Does not allow append div under svg element!');  
          }else{
            allSVG = false;
            break;  
          }
        } 
      }
    }

    for(key in conf){
      if(conf.hasOwnProperty(key)){
        module = ModuleDefs.get(conf[key].id);
        if(module){
          if(module.renderto === Constants.Module.RenderTo.DIV){
            ret[key] = append.apply(root, ['div', {'class' : 'v-m-' + key}]);
          }else if (module.renderto === Constants.Module.RenderTo.NONE){
            ret[key] = undefined;
          }else{
            //Jimmy, by default all current modules are rendered to SVG.
            ret[key] = append.apply(root, [parentSVG ? 'g' : 'svg', {'class' : 'v-m-' + key}]);
          }
        } 
      }
    }
    
    return ret;
  };
  
  return retfn;
});sap.riv.module(
{
  qname : 'sap.viz.style.Selector',
  version : '4.0.2'},
[

],
function Setup() {
  function Specificity( selectorText ) {
    this.b = 0;
    this.c = selectorText ? (selectorText.split('.').length - 1) : 0;
    this.d = 0;
  }

  Specificity.prototype = {
    nlt : function( s ) {

      if ( this.b === s.b ) {
        if ( this.c === s.c ) {
          return this.d >= s.d;
        }
        return this.c > s.c;
      }

      return this.b > s.b;
    }
  };

  function Selector( text ) {
    this.text = text;

    var specificity;
    Object.defineProperty(this, "specificity", {
      get : function() {
        if ( !specificity ) {
          specificity = new Specificity(text);
        }
        return specificity;
      }
    });
  }

  Selector.prototype = {
    nlt : function( s ) {
      if ( !s ) {
        return true;
      }
      return this.specificity.nlt(s.specificity);
    }
  };

  return Selector;
});sap.riv.module(
{
  qname : 'sap.viz.style.Sheet',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.style.Selector',
  version : '4.0.2'
}
],
function Setup( Selector ) {
  function Sheet( source, id ) {
    this.source = source;
    var idSelector = "." + id + " ";

    this.styleElement = document.createElement("style");
    document.head.appendChild(this.styleElement);

    var sheet = this.styleElement.sheet;
    sheet.disabled = true;

    var ruleTexts = source.split("}");
    for ( var i = 0, len = ruleTexts.length - 1; i < len; i++) {
      sheet.insertRule(ruleTexts[i] + "}", i);
    }

    this.rules = [];
    var cssRules = sheet.cssRules;
    for (i = 0, len = cssRules.length; i < len; i++) {
      var cssRule = cssRules[i];
      var selectorTexts = cssRule.selectorText.split(",");

      cssRule.selectorText = selectorTexts.map(function( selector ) {
        return idSelector + selector;
      }).join(",");

      var selectors = selectorTexts.map(function( selector ) {
        return new Selector(selector);
      });

      var properties = {};
      var style = cssRule.style;
      for ( var j = 0, styleLen = style.length; j < styleLen; j++) {
        var name = style[j];
        properties[name] = {
          value : style.getPropertyValue(name),
          important : style.getPropertyPriority(name) === "important"
        };
      }

      this.rules.push({
        selectors : selectors,
        properties : properties
      });
    }

    sheet.disabled = false;
  }

  Sheet.prototype = {
    destroy : function() {
      this.styleElement.parentNode.removeChild(this.styleElement);
      return this;
    },

    iterate : function( cb ) {
      this.rules.forEach(function( rule ) {
        rule.selectors.forEach(function( selector ) {
          cb(selector, rule.properties);
        });
      });
      return this;
    }
  };

  return Sheet;
});sap.riv.module(
{
  qname : 'sap.viz.TemplateManager',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
}
],
function Setup( manifest, FunctionUtils, TypeUtils, ObjectUtils ) {

  function loadResource( url, cb, onError ) {
    var head = document.getElementsByTagName("head")[0] || document.documentElement;
    var script = document.createElement("script");
    script.type = 'text/javascript';
    script.src = url;

    var done = false;
    script.onload = script.onreadystatechange = function() {
      if ( !done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") ) {
        done = true;
        cleanScript(script);
        cb();
      }
    };
    if ( script.addEventListener ) {
      script.addEventListener('error', function() {
        cleanScript(script);
        onError();
      }, true);
    }

    head.insertBefore(script, head.firstChild);
  }

  function loadTemplate( loadPaths, index, templateId, cb, onError ) {
    if ( index < loadPaths.length ) {
      var url = loadPaths[index] + templateId + '/template.js';
      var done = function() {
        loadTemplate(loadPaths, index + 1, templateId, cb, onError);
      };
      loadResource(url, done, done);
    } else {
      var template = get(templateId);
      if ( template ) {
        cb(template);
      } else {
        onError();
      }
    }
  }

  function load( templateId, cb ) {
    loadTemplate(manager.loadPath, 0, templateId, cb, function() {
      FunctionUtils.error('Loading template {0} failed.', templateId);
    });
  }

  function cleanScript( script ) {
    script.onload = script.onreadystatechange = null;
    if(script.parentNode){
        script.parentNode.removeChild(script);
    }
  }

  var templateCategory = manifest.registerCategory("template", function( obj ) {
    var css = obj.css;
    if ( !TypeUtils.isString(css) ) {
      var text = "";
      for ( var selector in css) {
        if ( css.hasOwnProperty(selector) ) {
          text += selector + "{";
          var declaration = css[selector];
          for ( var name in declaration) {
            if ( declaration.hasOwnProperty(name) ) {
              text += name + ":" + declaration[name] + ";";
            }
          }
          text += "}";
        }
      }
      obj.css = text;
    }
    Object.defineProperties(obj, {
      props : {
        value : function( vizId ) {
          var properties = obj.properties;
          if ( properties ) {
            return properties[vizId];
          }
        }
      }
    });
    return obj;
  });

  var current;

  function get( id ) {
    return templateCategory.get(id);
  }

  function onTemplateChanged( template, cb, thisObj ) {
    current = template;
    if ( cb ) {
      cb.call(thisObj, current);
    }
  }

  var defaultTemplateId = "default", defaultTemplate = {
    id : defaultTemplateId,
    name : "Default"
  };
  var manager =
  /** @lends sap.viz.TemplateManager */
  {
    /**
     * @constructs
     */
    constructor : function() {
      return;
    },
    /**
     * The file paths of templates folder. {@link sap.viz.TemplateManager} will discover available templates in this
     * folder.
     * 
     * @default ["../../../resources/templates/"]
     */
    loadPath : ["../../../resources/templates/"],
    /**
     * Return current applied template.
     * 
     * @returns {Object} the manifest of template
     */
    current : function() {
      return current;
    },
    /**
     * Apply(switch) a template.
     * 
     * @param {String}
     *          id the template id
     * @param {Function}
     *          [cb] the call back function. It will be executed after template is applied successfully with current
     *          template as parameter. *
     * @param {Object}
     *          [thisObj] "this" object during calling call beck function.
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    apply : function( id, cb, thisObj ) {
      var template = get(id);
      if ( !template ) {
        load(id, function( template ) {
          onTemplateChanged(template, cb, thisObj);
        });
      } else {
        onTemplateChanged(template, cb, thisObj);
      }

      return manager;
    },
    /**
     * Register new templates.
     * 
     * @param {Object...}
     *          templates the template descriptors(may be multiple).
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    register : function() {
      templateCategory.register.apply(templateCategory, arguments);
      return manager;
    },
    /**
     * Extend/modify an existing template.
     * 
     * @param {String}
     *          id the template id
     * @param {Object}
     *          obj the extended part.
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    extend : function( id, obj ) {
      var template = templateCategory.get(id, true);
      ObjectUtils.extend(true, template.properties, obj.properties);
      template.css += obj.css || "";
      return manager;
    }
  };

  delete manager.constructor;

  var apiProp = {
    writable : false,
    configurable : false
  };
  Object.defineProperties(manager, {
    loadPath : {
      configurable : false
    },
    current : apiProp,
    apply : apiProp,
    register : apiProp
  });

  manager.register(defaultTemplate);
  current = get(defaultTemplateId);
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.config',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
function Setup(FunctionUtils) {
  
  var configs = {};
  
  var enableCanvg = false; 
  
  var manager = {
      
      constructor : function(){
        return;
      },
      
      enableCanvg : function(_) {
          if(!arguments.length){
            return enableCanvg;
          }
          enableCanvg = _;
          return manager;
      },
      
      register : function(obj) {
          if(configs[obj.id]){
            return;
          }
          configs[obj.id] = obj.value;
          return manager;
      },
        
      get: function(ids){
        if(configs[ids]){
          return configs[ids];
        }
      }
  };
  
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.Locale',
  version : '4.0.2',
  exported : true
},
[

],
function Setup(LangManager, FormatManager) {
  var locale = 'en',  listeners = [];
    
  function onLocaleChanged(locale) {
    listeners.forEach(function(listener) {
      listener.fn.apply(listener.scope, [locale]);
    });
  }
  
  var Locale = 
    /** @lends sap.viz.Locale */
  {    /**
           * @constructs
           */
          constructor : function(){
            return;
          },
          
          /**
           * 
           * @param {String}
           *       locale
           * 
           * @returns {Object} {@link sap.viz.Locale}
           */
          locale : function(loc){
            if(!arguments.length){
              return locale;
            }
            locale = loc;
            onLocaleChanged(locale);
            return Locale;
          },
          
          /**
           * Add a listener which will be executed when current language is changed.
           * 
           * @param {Object}
           *          listener
           * @param {Function}
           *          listener.fn the listener function
           * @param {Object}
           *          listener.scope the "this" object in the listener function
           * 
           * @returns {Object} {@link sap.viz.Locale}
           */
          addListener : function(listener) {
              listeners.push(listener);
              return Locale;
           },
           
           /**
            * Remove the listener.
            * 
            * @param {Object} listener
            *          the listener reference
            * 
            * @returns {Object} {@link sap.viz.Locale}
            */
           removeListener : function(listener) {
             var index = listeners.indexOf(listener);
             if (index !== -1){
				listeners.splice(index, 1);
             }
             return Locale;
           }
  };
  
  return Locale;
});sap.riv.module(
{
  qname : 'sap.viz.lang.langManager',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.Locale',
  version : '4.0.2'
}
],
function Setup(FunctionUtils, ObjectUtils, TypeUtils, Locale) {

  function loadResource(url,  cb, onError) {
    var head = document.getElementsByTagName("head")[0] || document.documentElement;
    var script = document.createElement("script");
    script.type = 'text/javascript';
    script.src = url;

    var done = false;
    script.onload = script.onreadystatechange = function() {
      if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
        done = true;
        script.onload = script.onreadystatechange = null;
        if (head && script.parentNode) {
          head.removeChild(script);
        }
        cb();
      }
    };
    if (script.addEventListener) {
      script.addEventListener('error', function() {
        //clear script
        script.onload = script.onreadystatechange = null;
        if(script.parentNode){
            script.parentNode.removeChild(script);
        }
        //call error callback
        onError();
      }, true);
    }

    head.insertBefore(script, head.firstChild);
  }
  
  function loadResources(loadPath, index, id, cb, onError ){
    if(index < loadPath.length){
      var url = loadPath[index] + 'language_' + id + '.js';
      var done = function(){
        loadResources(loadPath, index+1, id, cb, onError);
      };
      loadResource(url, done, done);
    }else{
      var c_language = get(id);
      if(c_language){ cb(c_language);}
      else {
        onError();
      }
    }
  }
  function initialLanguageMap(){
      
      var map = d3.map();
      //3 for ar
      map.set("ar_AE","ar");
      map.set("ar_EG","ar");
      map.set("ar_SA","ar");
      //1 for bg
      map.set("bg_BG","bg");
      //1 for ca
      map.set("ca_ES","ca");
      //1 for cs
      map.set("cs_CZ","cs");
      //1 for da
      map.set("da_DK","da");
      //5 for de
      map.set("de_CH","de");
      map.set("de_AT","de");
      map.set("de_BE","de");
      map.set("de_LU","de");
      map.set("de_DE","de");
      //2 for el
      map.set("el_CY","el");
      map.set("el_GR","el");
      //14 for en
      map.set("en_AU","en");
      map.set("en_CA","en");
      map.set("en_GB","en");
      map.set("en_HK","en");
      map.set("en_ID","en");
      map.set("en_IE","en");
      map.set("en_IN","en");
      map.set("en_IS","en");
      map.set("en_MY","en");
      map.set("en_NZ","en");
      map.set("en_PH","en");
      map.set("en_SG","en");
      map.set("en_US","en");
      map.set("en_ZA","en");
      //9 for es
      map.set("es_AR","es");
      map.set("es_BO","es");
      map.set("es_CL","es");
      map.set("es_CO","es");
      map.set("es_ES","es");
      map.set("es_MX","es");
      map.set("es_PE","es");
      map.set("es_UY","es");
      map.set("es_VE","es");
      //1 for et
      map.set("et_EE","et");
      //1 for fa
      map.set("fa_IR","fa");
      //1 for fi
    map.set("fi_FI","fi");
    //5 for fr
    map.set("fr_BE","fr");
    map.set("fr_CA","fr");
    map.set("fr_CH","fr");
    map.set("fr_FR","fr");
    map.set("fr_LU","fr");
    //1 for iw
    map.set("he_IL","iw");
    //1for hr
    map.set("hr_HR","hr");
    //1 for hu
    map.set("hu_HU","hu");
    //2 for it
    map.set("it_CH","it");
      map.set("it_IT","it");
      //1 for ja
    map.set("ja_JP","ja");
    //1 for ko
    map.set("ko_KR","ko");
    //1 for lt
    map.set("lt_LT","lt");
    //1 for lv
    map.set("lv_LV","lv");
    //2 for nl
    map.set("nl_BE","nl");
      map.set("nl_NL","nl");
      //1 for no
      map.set("nn_NO","no");
      //1 for pl
      map.set("pl_PL","pl");
      //2 for pt
      map.set("pt_BR","pt");
      map.set("pt_PT","pt");
      //1 for ro
      map.set("ro_RO","ro");
      //3 for ru
      map.set("ru_KZ","ru");
      map.set("ru_RU","ru");
      map.set("ru_UA","ru");
      //2 for sr
      map.set("sh_ME","sr");
      map.set("sh_RS","sr");
      //1 for sk
      map.set("sk_SK","sk");
      //1 for sl
      map.set("sl_SL","sl");
      //1 for sv
      map.set("sv_SE","sv");
      //1 for th 
      map.set("th_TH","th");
      //1 for tk
      map.set("tr_CY","tk");
      map.set("tr_TR","tk");
      //1 for uk
      map.set("uk_UA","uk");
      //1 for vi
      map.set("vi_VI","vi");
      //1 for zh_TW
      map.set("zf_TW","zh_TW");
      //2 for zh_Cn
      map.set("zh_CN","zh_CN");
      map.set("zh_HK","zh_CN");

      //
      map.set("ar","ar");
      map.set("bg","bg");
      map.set("ca","ca");
      map.set("cs","cs");
      map.set("da","da");
      map.set("de","de");
      map.set("el","el");
      map.set("en","en");
      map.set("es","es");
      map.set("et","et");
      map.set("fi","fi");
      map.set("fr","fr");
      map.set("iw","iw");
      map.set("hr","hr");
      map.set("hu","hu");
      map.set("it","it");
      map.set("ja","ja");
      map.set("ko","ko");
      map.set("lt","lt");
      map.set("lv","lv");
      map.set("nl","nl");
      map.set("no","no");
      map.set("pl","pl");
      map.set("pt","pt");
      map.set("ro","ro");
      map.set("ru","ru");
      map.set("sr","sr");
      map.set("sk","sk");
      map.set("sl","sl");
      map.set("sv","sv");
      map.set("th","th");
      map.set("tk","tk");
    map.set("uk","uk");
    map.set("vi","vi");
    map.set("zh_TW","zh_TW");
    //
      return map;
       
  }
  var listeners = [];
  var languageMap = initialLanguageMap();
  
  function onLocaleChanged(cb) {
    listeners.forEach(function(listener) {
      listener.fn.apply(listener.scope, [ currentLanguage ]);
    });
    
    if(cb) {
      cb();
    }
  }
  
  function get(id){
    return languageSetting[id];
  }
  
  var languageSetting = {};
  

  var currentLanguage = languageSetting['dev'] = {IDS_DEFAULTMND:"All Measures",IDS_DEFAULTCHARTTITLE:"Title of Chart",IDS_ISNOVALUE:"No value",IDS_BARCHART:"Bar Chart",IDS_COMBINATIONCHART:"Combined Column Line Chart",IDS_DUALBARCHART:"Bar Chart with 2 X-Axes",IDS_DUALCOMBINATIONCHART:"Combined Column Line Chart with 2 Y-Axes",IDS_DUALHORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart with 2 X-Axes",IDS_DUALHORIZONTALLINECHART:"Horizontal Line Chart with 2 X-Axes",IDS_DIUALLINECHART:"Line Chart with 2 Y-Axes",IDS_DUALPERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart with 2 X-Axes",IDS_DUALSTACKEDVERTICALBARCHART:"Stacked Column Chart with 2 Y-Axes",IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart with 2 Y-Axes",IDS_DUALSTACKEDBARCHART:"Stacked Bar Chart with 2 X-Axes",IDS_DUALVERTICALBARCHART:"Column Chart with 2 Y-Axes",IDS_HORIZONTALBOXPLOTCHART:"Horizontal Box Plot",IDS_HORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart",IDS_HORIZONTALLINECHART:"Horizontal Line Chart",IDS_HORIZONTALWATERFALLCHART:"Horizontal Waterfall Chart",IDS_HORIZONTALSTACKEDWATERFALL:"Horizontal Stacked Waterfall Chart",IDS_LINECHART:"Line Chart",IDS_PERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart",IDS_PERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart",IDS_SPARKLINECHART:"Spark Line Chart (POC)",IDS_STACKEDBARCHART:"Stacked Bar Chart",IDS_STACKEDVERTICALBARCHART:"Stacked Column Chart",IDS_STACKEDWATERFALLCHART:"Stacked Waterfall Chart",IDS_VARIANTBARCHART:"Variant Bar Chart (POC)",IDS_VERTICALBARCHART:"Column Chart",IDS_VERTICALBOXPLOTCHART:"Box Plot",IDS_WATERFALLCHART:"Waterfall Chart",IDS_DONUTCHART:"Donut Chart",IDS_PIECHART:"Pie Chart",IDS_BASEBUBBLECHART:"Base Scatter Chart",IDS_BUBBLECHART:"Bubble Chart",IDS_SCATTERCHART:"Scatter Plot",IDS_BASECHART:"Base Chart",IDS_BASEHORIZONTALCHART:"Base horizontal XY Chart",IDS_BASEVERTICALCHART:"Base Vertical XY Chart",IDS_BASEMULTIPLECHART:"Base Multiple Chart",IDS_BASEMULTIPLEXYCHART:"Base Multiple XY Chart",IDS_BASESINGLECHART:"Base Single Chart",IDS_HEATMAPCHART:"Heat Map",IDS_TREEMAPCHART:"Tree Map",IDS_MULTIBARCHART:"Multiple Bar Chart",IDS_MULTIBUBBLECHART:"Multiple Bubble Chart",IDS_MULTIDONUTCHART:"Multiple Donut Chart",IDS_MULTIDUALBARCHART:"Multiple Bar Chart with 2 X-Axes",IDS_MULTIDUALHORIZONTALLINECHART:"Multiple Horizontal Line Chart with 2 X-Axes",IDS_MULTIDUALLINECHART:"Multiple Line Chart with 2 Y-Axes",IDS_MULTIDUALPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart with 2 X-Axes",IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart with 2 Y-Axes",IDS_MULTIDUALSTACKEDBARCHART:"Multiple Stacked Bar Chart with 2 X-Axes",IDS_MULTIDUALSTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart with 2 Y-Axes",IDS_MULTIDUALVERTICALBARCHART:"Multiple Column Chart with 2 Y-Axes",IDS_MULTIHORIZONTALLINECHART:"Multiple Horizontal Line Chart",IDS_MULTILINECHART:"Multiple Line Chart",IDS_MULTIPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart",IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart",IDS_MULTIPIECHART:"Multiple Pie Chart",IDS_MULTISCATTERCHART:"Multiple Scatter Plot",IDS_MULTISTACKEDBARCHART:"Multiple Stacked Bar Chart",IDS_MULTISTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart",IDS_MULTIVERTICALBARCHART:"Multiple Column Chart",IDS_MULTIRADARCHART:"Multiple Radar Chart",IDS_RADARCHART:"Radar Chart",IDS_SCATTERMATRIXCHART:"Scatter Matrix Chart",IDS_TAGCLOUDCHART:"Tag Cloud",IDS_MEKKOCHART:"Mekko chart",IDS_HORIZONTALMEKKOCHART:"Horizontal Mekko Chart",IDS_PERCENTAGEMEKKOCHART:"100% Mekko Chart",IDS_PERCENTAGEHORIZONTALMEKKOCHART:"100% Horizontal Mekko Chart",IDS_AREACHART:"Area Chart",IDS_PERCENTAGEAREACHART:"100% Area Chart",IDS_HORIZONTALAREACHART:"Horizontal Area Chart",IDS_PERCENTAGEHORIZONTALAREACHART:"100% Horizontal Area Chart",IDS_MULTIAREACHART:"Multiple Area Chart",IDS_MULTIHORIZONTALAREACHART:"Multiple Horizontal Area Chart",IDS_MULTIPERCENTAGEAREACHART:"Multiple 100% Area Chart",IDS_MULTIPERCENTAGEHORIZONTALAREACHART:"Multiple 100% Horizontal Area Chart",IDS_3D_BAR:"3D Bar Chart",IDS_3D_COLUMN:"3D Column Chart",IDS_PIEWITHDEPTHCHART:"Pie With Depth Chart",IDS_DONUTWITHDEPTHCHART:"Donut With Depth Chart",IDS_REGIONCOLOR:"Region Color",IDS_PRIMARYVALUES:"Primary Values",IDS_SECONDARYVALUES:"Secondary Values",IDS_AXISLABELS:"Axis Labels",IDS_RECTANGLETITLE:"Rectangle Title",IDS_RECTANGLEWEIGHT:"Rectangle Weight",IDS_RECTANGLECOLOR:"Rectangle Color",IDS_TAGNAME:"Tags Name",IDS_TAGWEIGHT:"Tags Weight",IDS_TAGFAMILY:"Tags Family",IDS_CATEGORYAXIS:"Axis Labels Category",IDS_REGIONSHAPE:"Region Shape",IDS_BUBBLEWIDTH:"Bubble Width",IDS_BUBBLEHEIGHT:"Bubble Height",IDS_RADARAXES:"Radar Axes",IDS_RADARAXESVALUE:"Radar Axes Values",IDS_PIESECTORCOLORNAME:"Sector Color",IDS_PIESECTORSIZE:"Sector Size",IDS_PIEDEPTHSIZE:"Depth Size",IDS_MAINLABELAXISNAME:"Main Category Axis",IDS_SECONDARYAXISLABELNAME:"Secondary Category Axis",IDS_SELECTABILITY:"selectability",IDS_PRIMARYVALUECOLORPALETTE:"primaryValuesColorPalette",IDS_SECONDARYVALUESCOLORPALETTE:"secondaryValuesColorPalette",IDS_DRAWINGEFFECT:"drawingEffect",IDS_TOOLTIPVISIBLE:"tooltipVisible",IDS_ENABLEROUNDCORNER:"enableRoundCorner",IDS_ANIMATION:"animation",IDS_DATALOADING:"dataLoading",IDS_DATAUPDATING:"dataUpdating",IDS_BAR:"bar",IDS_LINE:"line",IDS_WIDTH:"width",IDS_HOVERLINEVISIBLE:"hoverlineVisible",IDS_MARKER:"marker",IDS_VISIBLE:"visible",IDS_SHAPE:"shape",IDS_SIZE:"size",IDS_HEADERVISIBLE:"headerVisible",IDS_AXISVISIBLE:"axisVisible",IDS_GRIDVISIBLE:"gridVisible",IDS_COLUMNSEQUENCE:"columnSequence",IDS_COLUMNCONFIG:"columnConfig",IDS_STARTCOLUMN:"startColumn",IDS_LABEL:"label",IDS_VALUEFORMAT:"valueFormat",IDS_ENDCOLUMN:"endColumn",IDS_HIGHCOLUMN:"highColumn",IDS_LOWCOLUMN:"lowColumn",IDS_LINECONFIG:"lineConfig",IDS_MARKERS:"markers",IDS_FILLVISIBLE:"fillVisible",IDS_REFINEVISIBLE:"reflineVisible",IDS_MODE:"mode",IDS_TITLE:"title",IDS_TEXT:"text",IDS_GRIDLINE:"gridline",IDS_SHOWFIRSTLINE:"showFirstLine",IDS_TYPE:"type",IDS_FORMAT:"format",IDS_POSITION:"position",IDS_BORDER:"border",IDS_STARTCOLOR:"startcolor",IDS_ENDCOLOR:"endcolor"};
  var currentId = 'dev', defaultLanguage = 'en';
  var manager = 
    /** @lends sap.viz.lang.langManager */
  {    /**
       * @constructs
       */
      constructor : function(){
        return;
      },
      /**
       * The file paths of language folder. 
       * 
       * @default ["../../../resources/langs/"]
       */
      loadPath : ["../../../resources/langs/"],
       /**
       * Return current applied language Id.
       * 
       * @returns {String}
       */
      current : function() {
          return currentId;
      },
      
      /**
       * Register new language.
       * 
       * @param {Object...}
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      register : function(obj) {
            currentId = obj.id;
          currentLanguage = languageSetting[obj.id] = ObjectUtils.extend(true, languageSetting[obj.id], obj.value);
          return manager;
      },
      
       /**
       * Apply(switch) language.
       * 
       * @param {String}
       *          id the language id
       * @param {Function}
       *          [cb] the call back function. It will be executed after language
       *          is applied successfully with current language as parameter. *
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      apply : function(id, callback) {
        if(id){
          id = languageMap.get(id);
          loadResources(manager.loadPath, 0, id, function(){
            onLocaleChanged(callback);
          }, function(){
            loadResources(manager.loadPath, 0, defaultLanguage, function(){
              onLocaleChanged(callback);
              FunctionUtils.error('Loading language {0} failed.', id);
            }, function(){
               currentId = 'dev', currentLanguage = languageSetting['dev'];
               onLocaleChanged(callback);
               FunctionUtils.error('Loading language {0}, {1} failed.', id, defaultLanguage);
            });
            
          });
        }
         return manager;
      },
      
      /**
       * Get globalization value.
       * 
       * @param {String} 
       *       id of labels
       * 
       * @returns {String}  globalization value
       */
      get: function(ids){
        if(currentLanguage[ids]){
          return currentLanguage[ids];
        }
        return languageSetting['dev'][ids];
      },
      
      /**
       * Add a listener which will be executed when current language is changed.
       * 
       * @param {Object}
       *          listener
       * @param {Function}
       *          listener.fn the listener function
       * @param {Object}
       *          listener.scope the "this" object in the listener function
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      addListener : function(listener) {
          listeners.push(listener);
          return manager;
       },
       
       /**
       * Remove the listener.
       * 
       * @param {Object} listener
       *          the listener reference
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      removeListener : function(listener) {
        var index = listeners.indexOf(listener);
        if (index !== -1){
          listeners.splice(index, 1);
        }
        return manager;
      }
  };
  
  Locale.addListener({
    fn:function(locale, callback){
      manager.apply(locale, callback);
    },
    scope:manager
  });
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.BaseDataHandler',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
}
],
 function Setup(FunctionUtils, TypeUtils, langManager){
 
   
   /**
    * determine which feed should be appended with MeasureNamesDimension 
    * @param feeds feeds Array
    * @returns feedId  to auto feed mnd
    */
   function determineMNDFeed(feeds){
     
     var dimensionFeed = [];
     var allFeeded = true;
     //first to see if MND is manually feeded
     var i = 0;
     for(; i < feeds.length; i++){
       var feed = feeds[i];
       if(feed.type() === "Dimension" && feed.acceptMND() >= 0){
         if(feed.hasMNDFeeded()){
            return feed.feedId();
         }else if(feed.getDataCount() < feed.max()){
           dimensionFeed[feed.acceptMND()] = feed;
           if(allFeeded){
              allFeeded = feed.hasFeeded();
           }
         }
           
       } 
     }
     
     if(dimensionFeed.length === 0){
        return "";
     }
     
     //Second, see which feed should be auto feeded MND
     //case 1: all feeds has been feeded, decide by mndPriority
     
     if(allFeeded){
        return dimensionFeed[dimensionFeed.length - 1].feedId();
     }
      
     //case 2: not all feeds has been feeded, feed MND to non-feeded feed with highest priority
     for(i = dimensionFeed.length - 1; i >= 0; i--){
       if(dimensionFeed[i] && !dimensionFeed[i].hasFeeded()){
          return dimensionFeed[i].feedId();
       }
     }
     
     return "";
   }
   
   /**
    * return a validate value according to val passed by user
    * 1 if val is string, just return
    * 2 if val is number, convert to string , return
    * 3 if val is other type, return null
    * 
    */
   function validateStringValue(val){
     if(TypeUtils.isString(val)){
        return val;
     }else if(TypeUtils.isNumber(val)){
        return val.toString();
     }else{
        return null;
     }
   }
   
   /**
    * return a validate value according to val passed by user
    * 1 if val is number, just return
    * 2 if val is string, convert to number , return
    * 3 if val is other type, return null
    * 
    */
   function validateNumberValue(val){
     if(TypeUtils.isNumber(val)){
        return parseFloat(val);
     }else{
        return null;
     }
   }
   
   function initDataPointUpperLimit(rawData, upperLimit){
       var limit = [ Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
       
       var rawDataCount = rawData.getDataPointCount();
       if(upperLimit === Number.POSITIVE_INFINITY || !TypeUtils.isNumber(upperLimit) || upperLimit >= rawDataCount){
          return limit;
       }
       
       //get total measure values count
       var mvCount = 0;
       var mvgCount = rawData.getMeasureValuesGroupCount();
       for(var i = 0; i < mvgCount; i++){
         mvCount += rawData.getMeasureValuesGroupByIdx(i).getMeasureValues().length;
       }
       
       //limit of one measure value
       var mvLimit = Math.floor(upperLimit / mvCount);
       
       var aaCount = rawData.getAnalysisAxisCount();
       if(aaCount === 0 || aaCount === 1){
          limit[0] = mvLimit; 
       }else if(aaCount === 2){
         var mv = rawData.getMeasureValuesGroupByIdx(0).getMeasureValues()[0];
         //var aa2Point = mv.getValues().length;
         var aa1Point = mv.getValues()[0].length;
         if(mvLimit/aa1Point < 1){
           limit[0] = mvLimit;
           limit[1] = 1;
         }else{
           limit[1] = Math.floor(mvLimit/aa1Point);
         }
       }
       
       return limit;
   }
   
   function BaseDataHandler(feeder, rawData, upperLimit){
          this._feeder  = feeder;
          this._feeds   = feeder.getFeeds();
          this._mndFeed = determineMNDFeed(this._feeds);
          this._limit = initDataPointUpperLimit(rawData, upperLimit);
   }
   
   
   BaseDataHandler.prototype.getFeedValues = function(feedId){
      var feed = this._feeder.findFeed(feedId);
      if(!feed){
         FunctionUtils.error('could not find feed definition of ' + feedId );
      }
      
      if(feed.type() === "Dimension"){
         return this.getDimensionFeedValues(feed);
      }else if(feed.type() === "Measure"){
         return this.getMeasureFeedValues(feed);
      }
     
   };
   
   
   BaseDataHandler.prototype.getDimensionFeedValues = function(feed){
     
      var feedValues = [];
      var hasManualMND = false;
      
      var datas = feed.data();
      
      var obj;
      
      var mndDefaultString = langManager.get('IDS_DEFAULTMND');
      if(datas.length > 0){
        
        for(var i = 0; i < datas.length; i++ ){
          var data = datas[i];
       
          if(data){
            if(data.getType() === "measureNamesDimension"){ 
                obj = {};
                
                //col
                obj['col'] = {'val': mndDefaultString};
                obj['type'] = 'MND';
                
                obj['rows'] = this.getMeasureNamesValues(); 
                feedValues.push(obj);
                hasManualMND = true;
                
            }else if(data.getType() === "analysisAxis"){
              
              var dimensionLabels = data.getDimensionLabels();
              var aaIndex = this._feeder.getAnalysisAxisIndex(feed);
              
              for(var j = 0 ; j < dimensionLabels.length; j++){
                  obj = {};
                  
                  //col
                  obj['col'] = {'val': validateStringValue(dimensionLabels[j].getId())};
                  //rows
                  var rows = [];
                  var values =  dimensionLabels[j].getValues();
                  var infos =  dimensionLabels[j].infos();
                  var limit = values.length;
                  if(this._limit[aaIndex] !== Number.POSITIVE_INFINITY){
                     limit = this._limit[aaIndex];
                  }
                  
                  for(var k = 0; k < limit; k++){
                        var value = { 'val':validateStringValue(values[k]), 
                                      'ctx': {
                                                          'type' : 'Dimension',
                                                          'path': {
                                                                     'aa': aaIndex,
                                                                     'di':  j,
                                                                     'dii': k  }
                                                         }
                                                };
                        
                        if(TypeUtils.isExist(infos)){
                           value.info = infos[k];
                        }
                        
                    rows.push(value);
     
                  }
                  
                  obj['rows'] = rows;
                    
                  feedValues.push(obj);
               }                
            }else{
              FunctionUtils.error('wrong type when getting data');
            } 
          }
          
        }
      }
     
      if(feed.feedId() === this._mndFeed && hasManualMND === false){
          //col
          obj = {};
          obj['col'] = {'val': mndDefaultString};
          obj['type'] = 'MND';
          
          obj['rows'] = this.getMeasureNamesValues();
          
          feedValues.unshift(obj);
      }
      
      return feedValues.length > 0 ? feedValues : null;
   };
   
     BaseDataHandler.prototype.getMeasureFeedValues = function(feed){
       var feedValues = [];
       var measureValues = feed.getMeasureValues();

         var mgIndex = this._feeder.getMeasureValuesGroupIndex(feed);
         for(var i = 0; i < measureValues.length; i++){
                 var obj = {};
                 
                 //col
                 obj['col'] =  validateStringValue(measureValues[i].getId());
                 
                 //rows
                 var rows = [];
                 var values =  measureValues[i].getValues(); //values is an aa2 * aa1 array;
                 var infos = measureValues[i].infos();
                 //aa2
                 var aa2Limit = values.length;
                 if(this._limit[1] !== Number.POSITIVE_INFINITY){
                    aa2Limit = this._limit[1];
                 }
                 
                 for(var j = 0; j < aa2Limit; j++){
                   var value = values[j];
                   var row = [], rowValue = {};
                   //aa1
                   var aa1Limit = value.length;
                   if(this._limit[0] !== Number.POSITIVE_INFINITY){
                      aa1Limit = this._limit[0];
                   }
                   
                   for(var k = 0; k < aa1Limit; k++){
                     rowValue = {
                        'val' : validateNumberValue(value[k]),
                        'ctx' : {
                          'type' : 'Measure',
                          'path' : {
                            'mg' : mgIndex,
                            'mi' : i,
                            'dii_a1' : k,
                            'dii_a2' : j
                          }
                        }
                      };
                     if(TypeUtils.isExist(infos)){
                       rowValue.info = infos[j][k];
                   }
                     row.push(rowValue);
                   }
                   
                   rows.push(row);
                 }
                 
                 obj['rows'] = rows;
                 
                 feedValues.push(obj);
         }
         
          return feedValues.length > 0 ? feedValues : null;
   };
   
   
     BaseDataHandler.prototype.getMeasureNamesValues = function(){
       var values = [];
     var mgFeeds = this._feeder.getMeasureValuesGroupFeeds();
     for(var i = 0; i < mgFeeds.length; i++){
       if(mgFeeds[i].hasFeeded()){   
           var mvs = mgFeeds[i].getMeasureValues();
           for(var j = 0; j < mvs.length; j++){
             values.push({'val':validateStringValue(mvs[j].getId()),'ctx': { 'path' : {'mg': i, 'mi': j}}});
           }   
         }    
       }  
     
     return values;
   };
   
   return BaseDataHandler;
 });sap.riv.module(
{
  qname : 'sap.viz.util.ignite',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
}
],
function Setup( TypeUtils, manifest ) {
  return function( moduleId, parentCtx, classNames, tagNames ) {
    var moduleManifest;
    if ( TypeUtils.isString(moduleId) ) {
      moduleManifest = manifest.get(moduleId);
    } else {
      moduleManifest = moduleId;
      classNames = true;
    }

    return moduleManifest.execute(parentCtx, classNames, tagNames);
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.controller.Base',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.controller.base',
    'abstract' : true,
    'type' : Constants.Module.Type.Controller,
    'renderto' : Constants.Module.RenderTo.NONE,
    'name' : 'controller base module',
    'properties' : null,
    'events' : null,
    'feeds' : null
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'},
[

],

function Setup() {
	var devicePixRatio = window.devicePixelRatio || 1;
	var versionSearchString;
	var searchString = function(data) {
		for ( var i = 0; i < data.length; i++) {
			var dataString = data[i].string;
			var dataProp = data[i].prop;
			versionSearchString = data[i].versionSearch || data[i].identity;
			if (dataString) {
				if (dataString.indexOf(data[i].subString) != -1) {
					return data[i].identity;
				}
			} else if (dataProp) {
				return data[i].identity;
			}
		}
	};
	var seps = [ ';', ' ' ];
	var searchVersion = function(dataString) {
		var index = dataString.indexOf(versionSearchString);
		if (index == -1)
			return;
		var versionStr = dataString.substring(index + versionSearchString.length + 1);
		var i = 0, l = seps.length, sepIndex = -1;
		while (sepIndex === -1 && i < l)
			sepIndex = versionStr.indexOf(seps[i++]);
		if (sepIndex !== -1)
			versionStr = versionStr.slice(0, sepIndex);
		return versionStr;
	};
	var dataBrowser = [ {
		string : navigator.userAgent,
		subString : "Chrome",
		identity : "Chrome"
	}, {
		string : navigator.userAgent,
		subString : "OmniWeb",
		versionSearch : "OmniWeb/",
		identity : "OmniWeb"
	}, {
		string : navigator.userAgent,
		subString : "Safari",
		identity : "Safari",
		versionSearch : "Version"
	}, {
		string : navigator.userAgent,
		subString : "Apple",
		identity : "UIWebView",
		versionSearch : "AppleWebKit"
	}, {
		prop : window.opera,
		identity : "Opera",
		versionSearch : "Version"
	}, {
		string : navigator.vendor,
		subString : "iCab",
		identity : "iCab"
	}, {
		string : navigator.vendor,
		subString : "KDE",
		identity : "Konqueror"
	}, {
		string : navigator.userAgent,
		subString : "Firefox",
		identity : "Firefox"
	}, {
		string : navigator.vendor,
		subString : "Camino",
		identity : "Camino"
	}, {// for newer Netscapes (6+)
		string : navigator.userAgent,
		subString : "Netscape",
		identity : "Netscape"
	}, {
		string : navigator.userAgent,
		subString : "MSIE",
		identity : "Explorer",
		versionSearch : "MSIE"
	}, {
		string : navigator.userAgent,
		subString : "Gecko",
		identity : "Mozilla",
		versionSearch : "rv"
	}, {// for older Netscapes (4-)
		string : navigator.userAgent,
		subString : "Mozilla",
		identity : "Netscape",
		versionSearch : "Mozilla"
	} ];

	var dataOS = [ {
		string : navigator.platform,
		subString : "Win",
		identity : "Windows"
	}, {
		string : navigator.platform,
		subString : "Mac",
		identity : "Mac"
	}, {
		string : navigator.userAgent,
		subString : "iPhone",
		identity : "iPhone/iPod"
	}, {
		string : navigator.userAgent,
		subString : "iPad",
		identity : "iPad"
	}, {
		string : navigator.platform,
		subString : "Linux",
		identity : "Linux"
	} ];

	var dataRenderEngine = [ {
		string : navigator.userAgent,
		subString : "Presto",
		identity : "Presto"
	}, {
		string : navigator.userAgent,
		subString : "KHTML",
		identity : "KHTML"
	}, {
		string : navigator.userAgent,
		subString : "Gecko",
		identity : "Gecko"
	}, {
		string : navigator.userAgent,
		subString : "Trident",
		identity : "Trident"
	} ];
	
	var dataMobile = [{
		string : navigator.userAgent,
		subString : 'Android',
		identity : 'Android',
	}, {
		string : navigator.userAgent,
		subString : 'iPhone',
		identity : 'iPhone'
	}, {
		string : navigator.userAgent,
		subString : 'iPad',
		identity : 'iPad'
	} ];
	
	var _userAgent = searchString(dataBrowser) || "An unknown browser", _version = searchVersion(navigator.userAgent)
			|| searchVersion(navigator.appVersion) || "an unknown version", _isIE = searchString(dataBrowser) === "Explorer", _isFirefox = searchString(dataBrowser) === 'Firefox', _isChrome = searchString(dataBrowser) === 'Chrome', _isSafari = searchString(dataBrowser) === 'Safari', _isUIWebView = searchString(dataBrowser) === 'UIWebView', _os = searchString(dataOS)
			|| "an unknown OS", _renderEngine = searchString(dataRenderEngine) || "An unknown RenderEngine",  _mobile = searchString(dataMobile);
	var UADetector = {
		userAgent : function() {
			return _userAgent;
		},
		version : function() {
			return _version;
		},
		isIE : function() {
			return _isIE;
		},
		isFirefox : function() {
			return _isFirefox;
		},
		isChrome : function() {
			return _isChrome;
		},
		isSafari : function() {
			return _isSafari;
		},
		isUIWebView : function() {
			return _isUIWebView;
		},
		os : function() {
			return _os;
		},
		devicePixelRatio : function() {
			return devicePixRatio;
		},
		renderEngine : function() {
			return _renderEngine;
		},
		isMobile : function(){
			return _mobile !== undefined;
		}
	};
	return (UADetector);
});sap.riv.module(
{
  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.2'},
[

],

function Setup() {
  var boundingbox = {};
  boundingbox.getBBox = function (node, rootNode) {
    var matrix;
    if (arguments.length === 1) {
      matrix = node.getCTM();
    } else {
      matrix = node.getTransformToElement(rootNode);
    }
    return boundingbox.getBBoxHelp(node, matrix);
  };

  boundingbox.getBBoxHelp = function (node, matrix) {
    var box = node.getBBox();
    var corners = [];
    var point = d3.select('svg')[0][0].createSVGPoint();
    point.x = box.x;
    point.y = box.y;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x + box.width;
    point.y = box.y;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x + box.width;
    point.y = box.y + box.height;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x;
    point.y = box.y + box.height;
    corners.push(point.matrixTransform(matrix));
    var minX = corners[0].x;
    var maxX = corners[0].x;
    var minY = corners[0].y;
    var maxY = corners[0].y;
    for (var i = 1; i < corners.length; i++) {
      var x = corners[i].x;
      var y = corners[i].y;
      if (x < minX) {
        minX = x;
      } else if (x > maxX) {
        maxX = x;
      }
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
    }

    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  };

  // return true if the two boxes intersect
  boundingbox.intersects = function(a, b) {
    return (a.x <= (b.x + b.width) &&
        b.x <= (a.x + a.width) &&
        a.y <= (b.y + b.height) &&
        b.y <= (a.y + a.height));
  };

  // returns a box representing the intersection of box1 and box2 if it exists, otherwise null
  boundingbox.intersection = function(box1, box2) {
    if (boundingbox.intersects(box1, box2)) {
      var x1 = Math.max(box1.x, box2.x),
          x2 = Math.min(box1.x + box1.width, box2.x + box2.width),
          y1 = Math.max(box1.y, box2.y),
          y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

      return {
        x: x1,
        y: y1,
        width: x2 - x1,
        height: y2 - y1
      };
    }

    return null;
  };

  return boundingbox;
});sap.riv.module(
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'},
[

],
function Setup() {
  return d3.dispatch;
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.mousemonitor',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
}
],
function Setup(dispatch) {
    
    return function(manifest, ctx){
        var MIN_LASSO_DISTANCE = 3;
        var m,
            g,
            node,
            props,
            mousedownpoint = null,
            status = 'hover', // lasso, unknown
            eventManager = ctx.eventManager;
        var d = dispatch('click', 'hover', 'lassostart', 'lassomove', 'lassoend', 'mousedown', 'mouseup', 'mouseover', 'mouseout', 'mouseleave');

        //mouse trigger
        var mm = function(){
            return mm;
        };
        
        mm.module = function(_){
            if(!arguments.length){
                return m;
            }
            m = _; g = m.parent(); node = g.node();
            return mm;
        };
        
        mm.properties = function(_){
            if(!arguments.length){
                return props;
            }
            props = _;
            return mm;
        };
        
        mm.registerEvent = function(g){
            g.on('mousedown.monitor', mousedown, true)
             .on('mouseup.monitor', mouseup)
             .on('mousemove.monitor', mousemove)
             .on('mouseover.monitor', mouseover)
             .on('mouseout.monitor', mouseout);
            
            $(g.node()).mouseleave(mouseleave);
        };
        
        mm.destroy = function(g){
            $(g.node()).unbind("mouseleave");
        };
        
        mm.dispatch = function(_){
            if(!arguments.length){
                return d;
            }
            d = _;
            return mm;
        };
              
        function mousedown(){
            //console.log('mousedown');
            var originalEvent = getCurrentEvent();
            mousedownpoint = {
               x : originalEvent.clientX,
               y : originalEvent.clientY
           };
            status = 'unknown';

            fireEvent('mousedown');
            
            //As in geo chart, the drag feature is implemented by d3. we should stop propagation if starting lasso
            if( isEnableLasso()){
                stopEvent();
            }
        };
        
        function mousemove(){
            //console.log('mousemove');
            if (status === 'lasso') {
                fireEvent('lassomove');
            } else if (status === 'hover') {
                fireEvent('hover');
            } else {
                if (checkMouseDownUpDistance()) {
                    if (isEnableLasso()) {
                        fireEvent('lassostart', mousedownpoint);
                        status = 'lasso';
                        fireEvent('lassomove');
                    } else {
                        status = 'hover';
                        fireEvent('hover');
                    } 
                }
            }
        };
               
        function mouseup(){
            //console.log('mouseup');
            if (status === 'lasso') {
                fireEvent('lassoend');
            } else {
                if (!checkMouseDownUpDistance()){
                    fireEvent('click');
                }
            }
            mousedownpoint = null;
            status = 'hover';

            fireEvent('mouseup');
        };
        
        function mouseout(){
            //console.log('mouseout');
            if( status !== 'lasso'){
                fireEvent('mouseout');
            }
        };
        
        function mouseover() {
            //console.log('mouseover');
            if( status !== 'lasso'){
                fireEvent('mouseover');
            }
        }

        function mouseleave(evt){
            var point = {
                    clientX : evt.clientX,
                    clientY : evt.clientY
            };
            var target = evt.target;

            if (status === 'lasso'){
                fireEvent('lassoend', point, target);
            }
            
            fireEvent('mouseleave', point, target);
        };
        
        function isEnableLasso(event) {
            var result = false;
            if (props.supportLassoEvent && (props.selectability.mode === 'multiple')) {
                result = true;
                if (props.selectability.lassoWithCtrlKey) {
                    var originalEvent = getCurrentEvent();
                    if (!originalEvent.ctrlKey) {
                        result = false;
                    }
                }
            }
            return result;
        }
        
        function distance(p1, p2) {
            return Math.sqrt((p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y));
        }

        function getCurrentEvent() {
            if (d3.event) {
                return d3.event;
            } else {
                return window.event;
            }
        }
        
        function checkMouseDownUpDistance() {
            var originalEvent = getCurrentEvent();
            var tmp = {
                    x : originalEvent.clientX,
                    y : originalEvent.clientY
                };
            if ((mousedownpoint !== null) && 
                (distance(mousedownpoint, tmp) < MIN_LASSO_DISTANCE)) {
                return false;
            } else {
                return true;
            }
        }

        function fireEvent(type, point, target) {
            var originalEvent = getCurrentEvent();
            var temppoint, temptarget;
            if (point) {
                temppoint = point;
            } else {
                temppoint = {
                       x : originalEvent.clientX,
                       y : originalEvent.clientY
                    };
            }
            if (target) {
                temptarget = target;
            } else {
                temptarget = originalEvent.target;
            }
            var tempEvent = {
                name: type,
                data : {
                    point : temppoint,
                    target : temptarget
                }
            };
            
            switch (type) {
            case 'mousedown':
                if (props.enableMouseDown) {
                    d.mousedown(tempEvent);
                }
                break;
            case 'mouseup':
                if (props.enableMouseUp) {
                    d.mouseup(tempEvent);
                }
                break;
            case 'mousemove':
                if (props.enableMouseMove) {
                    d.mousemove(tempEvent);
                }
                break;
            case 'mouseover':
                if (props.enableMouseOver) {
                    d.mouseover(tempEvent);
                }
                break;
            case 'mouseout':
                if (props.enableMouseOut) {
                    d.mouseout(tempEvent);
                }
                break;
            case 'hover':
                if (props.enableHover) {
                    d.hover(tempEvent);
                }
                break;
            case 'lassostart':
                d.lassostart(tempEvent); break;
            case 'lassomove':
                d.lassomove(tempEvent); break;
            case 'lassoend':
                d.lassoend(tempEvent); break;
            case 'click':
                if (props.enableClick) {
                    d.click(tempEvent);
                }
                break;
            case 'mouseleave' :
                d.mouseleave(tempEvent);
            default:
                break;
            }
        }
        
        function stopEvent(){
            if ( d3.event ) {
                d3.event.stopPropagation();
                d3.event.preventDefault();
            }
        }
        return mm;
    };
});sap.riv.module(
{
  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.Class',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
function Setup(Class, FuncUtils) {
	var noop = FuncUtils.noop;
	/**
	 * Possible State. Gesture Detector is ready to detect gesture
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Possible
	 * @field
	 * 
	 */
	var Possible = 0;
	/**
	 * Began State. Gesture Detector is ready to detect continuous gesture
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Began
	 * @field
	 * 
	 */
	var Began = 1;
	/**
	 * Began State. Gesture Detector is continuous to detect continuous gesture
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Changed
	 * @field
	 * 
	 */
	var Changed = 2;
	/**
	 * Recognized State. Discrete Gesture is detected
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Recognized
	 * @field
	 * 
	 */
	var Recognized = 3; // Recognized == Ended
	/**
	 * Ended State. Continuous Gesture is detected
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Ended
	 * @field
	 * 
	 */
	var Ended = 3;
	/**
	 * Ended State. Continuous Gesture is stop to detected
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Canceled
	 * @field
	 * 
	 */
	var Canceled = 4;
	/**
	 * Ended State. Detector fails to detect in current touch sequence
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState#Failed
	 * @field
	 * 
	 */
	var Failed = 5;

	var GestureDetector = Class
			.define({
				/**
				 * The base abstract gesture detector class
				 * 
				 * @name sap.viz.mvc.GestureDetector
				 * @constructor
				 */
				constructor : function() {
					this._grEnabled = true;
					this._grTouchTotal = 0;
					this._grTouchTracker = {};
					this._grActions = [];
					this._grCancelTouches = true;
					var state = Possible;
					Object.defineProperties(this, {
						'state' : {
							get : function() {
								return state;
							},
							set : function(value) {
								switch (value) {
								case Possible:
									state = Possible;
									break;
								case Began:
									state = Began;
									this._grActions.forEach(function(action, i) {
										action(this);
									}, this);
									break;
								case Changed:
									if (state === Began) {
										state = Changed;
									}
									this._grActions.forEach(function(action, i) {
										action(this);
									}, this);
									break;
								case Canceled:
									state = Canceled;
									this._grActions.forEach(function(action, i) {
										action(this);
									}, this);
									break;
								case Failed:
									state = Failed;
									break;
								case Ended:
								case Recognized:
									state = value;
									this._grActions.forEach(function(action, i) {
										action(this);
									}, this);
									break;
								}
							}
						},
						'watchedComponent' : {
							value : undefined,
							writable : true,
							enumerable : true
						}
					});
				},

				/**
				 * Add gesture function callback which will get triggered when
				 * gesture is detected. One function instance could only be
				 * added once. The returned value indicates whether the adding
				 * is succeed.
				 * 
				 * @name sap.viz.mvc.GestureDetector#addGestureAction
				 * @function
				 * @param {Function}
				 *            actionFn
				 * @returns {Boolean}
				 */
				addGestureAction : function(actionFn) {
					var actions = this._grActions;
					if (actions.indexOf(actionFn) === -1) {
						actions.push(actionFn);
						return true;
					}
					return false;
				},

				/**
				 * Remove a previous added gesture function callback, the
				 * returned value indicates whether the removing is succeed.
				 * 
				 * @name sap.viz.mvc.GestureDetector#removeGestureAction
				 * @function
				 * @param {Function}
				 *            actionFn, the function to be removed.
				 * @returns {Boolean}
				 */
				removeGestureAction : function(actionFn) {
					var actions = this._grActions, i = actions.indexOf(actionFn);
					if (i > -1) {
						actions.splice(i, 1);
						return true;
					}
					return false;
				},

				/**
				 * Get the location of the gesture, the location is calculated
				 * as the average of the locations of all touches on the screen.
				 * Caution: This function only return meaningful point value IF
				 * and ONLY IF the current state of this gesture detector is in
				 * one of the <b>Recognizing</b> states, a.k.a Began, Changed,
				 * Canceled, Ended, Recognized, otherwise undefined will return.
				 * 
				 * @function
				 * @returns {POINT}
				 */
				globalLocOfGesture : function() {
					var state = this.state;
					if (this._grEnabled
							&& (state === Began || state === Changed || state === Canceled || state === Ended || state === Recognized)) {
						var count = 0;
						var ttracker = this._grTouchTracker, p;
						var x = y = 0;
						for ( var tId in ttracker) {
							p = ttracker[tId].globalXY;
							x += p.x;
							y += p.y;
							count++;
						}
						if (count) {
							return {
								x : x / count,
								y : y / count
							};
						}
					}
				},

				/**
				 * Return an array of identifier of the touches currently
				 * involved in the gesture detection, Caution: This function
				 * only return meaningful array of touches IF and ONLY IF the
				 * current state of this gesture detector is in one of the
				 * <b>Recognizing</b> states, a.k.a Began, Canceled, Ended,
				 * Recognized, otherwise empty array will return.
				 * 
				 * @function
				 * @returns {Array}
				 */
				involvedTouchePoints : function() {
					var ret = [], state = this.state;
					if (this._grEnabled
							&& (state === Began || state === Changed || state === Canceled || state === Ended || state === Recognized)) {
						var ttracker = this._grTouchTracker;
						for ( var tId in ttracker) {
							ret.push(tId);
						}
					}
					return ret;
				},

				/**
				 * Get the average position of all the touchs on the screen
				 * 
				 * @function
				 * @returns {POINT}
				 */
				globalLocOfTouchPoints : function() {
					var count = 0;
					var ttracker = this._grTouchTracker, p;
					var x = y = 0;
					for ( var tId in ttracker) {
						p = ttracker[tId].globalXY;
						x += p.x;
						y += p.y;
						count++;
					}
					if (count) {
						return {
							x : x / count,
							y : y / count
						};
					}
				},

				/**
				 * Return the number of touches currently on the screen
				 * 
				 * @function
				 * @returns {Number}
				 */
				totalTouches : function() {
					return this._grTouchTotal;
				},

				/**
				 * Get or set whether needs to cancel previous events of the
				 * touches when a gesture detected. Default is yes. The related
				 * logic like bookkeeping of the canceled touches among several
				 * gesture detectors, are currently implemented outside of
				 * gesture detector.
				 * 
				 * @function
				 * @returns {Boolean|this}
				 */
				cancelTouches : function(cancel) {
					if (arguments.length) {
						this._grCancelTouches = cancel ? true : false;
						return this;
					} else {
						return this._grCancelTouches;
					}
				},
				/**
				 * Get or set the <b>enable</b> status of the gesture detector.
				 * If the gesture detector is in detecting a continuous gesture,
				 * it will immediately transit to <b>canceled</b> state.
				 * Default is yes.
				 * 
				 * @function
				 * @returns {Boolean|this}
				 */
				enable : function(enable) {
					if (arguments.length) {
						enable = enable ? true : false;
						if (this._grEnabled !== enable) {
							this._grEnabled = enable;
							if (!enable) {
								if (this.state === Began || this.state === Canceled) {
									this.state = Canceled;
								} else {
									this.state = Failed;
								}
							}
						}
						return this;
					} else {
						return this._grEnabled;
					}
				},

				/**
				 * Process the touch start event of a touch sequence. This
				 * method is not intent to be overridden and is supposed to be
				 * called by the user.
				 * 
				 * @name sap.viz.mvc.GestureDetector#touchBegin
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchStartEvent
				 */
				touchBegin : function(touchStartEvent) {
					var newTouches = touchStartEvent.changedTouches;
					var ttracker = this._grTouchTracker;
					var ownerComp = this.watchedComponent;
					var pagePosition = ownerComp.pagePosition();
					for ( var i = 0, t, len = newTouches.length; i < len; i++) {
						t = newTouches.item(i);
						ttracker[t.identifier] = {
							globalXY : ownerComp.pointTo({
								x : t.pageX - pagePosition.x,
								y : t.pageY - pagePosition.y
							})
						};
						this._grTouchTotal++;
					}
					if (this._grEnabled && (this.state === Possible || this.state === Began || this.state === Changed)) {
						this.doTouchBegin(touchStartEvent);
					}
				},
				/**
				 * Process the touch move event of a touch sequence. This method
				 * is not intent to be overridden and is supposed to be called by
				 * the user.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#touchMove
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchMoveEvent
				 */
				touchMove : function(touchMoveEvent) {
					if (this._grEnabled && (this.state === Possible || this.state === Began || this.state === Changed)) {
						var movedTouches = touchMoveEvent.changedTouches;
						var ownerComp = this.watchedComponent;
						var pagePosition = ownerComp.pagePosition();
						var ttracker = this._grTouchTracker;
						for ( var i = 0, t, len = movedTouches.length; i < len; i++) {
							t = movedTouches.item(i);
							if (ttracker[t.identifier]) {
								ttracker[t.identifier].globalXY = ownerComp.pointTo({
									x : t.pageX - pagePosition.x,
									y : t.pageY - pagePosition.y
								});
							}
						}
						this.doTouchMove(touchMoveEvent);
					}
				},
				/**
				 * Process the touch end event of a touch sequence. This method
				 * is not intent to be overridden and is supposed to be called by
				 * the user.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#touchEnd
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchEndEvent
				 */
				touchEnd : function(touchEndEvent) {
					var endedTouches = touchEndEvent.changedTouches;
					var ttracker = this._grTouchTracker;
					var ownerComp = this.watchedComponent;
					var pagePosition = ownerComp.pagePosition();
					for ( var i = 0, t, tId, track, len = endedTouches.length; i < len; i++) {
						t = endedTouches.item(i);
						tId = t.identifier;
						if (track = ttracker[tId]) {
							track.globalXY = ownerComp.pointTo({
								x : t.pageX - pagePosition.x,
								y : t.pageY - pagePosition.y
							});
							this._grTouchTotal--;
						}
					}
					if (this._grEnabled && (this.state === Possible || this.state === Began || this.state === Changed)) {
						this.doTouchEnd(touchEndEvent);
					}
					// Reset the detector only when all fingers lifted and in
					// 'ending' state
					if (!this._grTouchTotal
							&& (this.state === Recognized || this.state === Failed || this.state === Canceled)) {
						this.reset();
					}
				},
				/**
				 * Process the touch cancel event of a touch sequence. This
				 * method is not intent to be override and is supposed to be
				 * called by the user.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#touchCancel
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchCancelEvent
				 */
				touchCancel : function(touchCancelEvent) {
					var cancelledTouches = touchCancelEvent.changedTouches;
					var ttracker = this._grTouchTracker;
					var ownerComp = this.watchedComponent;
					var pagePosition = ownerComp.pagePosition();
					for ( var i = 0, t, tId, track, len = cancelledTouches.length; i < len; i++) {
						t = cancelledTouches.item(i);
						tId = t.identifier;
						if (track = ttracker[tId]) {
							track.globalXY = ownerComp.pointTo({
								x : t.pageX - pagePosition.x,
								y : t.pageY - pagePosition.y
							});
							this._grTouchTotal--;
						}
					}
					if (this._grEnabled && (this.state === Possible || this.state === Began || this.state === Changed)) {
						this.doTouchCancel(touchCancelEvent);
					}
					// Reset the detector only when all fingers lifted and in
					// 'ending' state
					if (!this._grTouchTotal
							&& (this.state === Recognized || this.state === Failed || this.state === Canceled)) {
						this.reset();
					}
				},
				/**
				 * This method should be overridden in subclass, to handle
				 * actual gesture detection
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#doTouchBegin
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchStartEvent
				 */
				doTouchBegin : noop,
				/**
				 * Gesture Detector uses this method to receive touches in
				 * moving phase of a touch sequence. This method should be
				 * overridden in subclass.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#doTouchMove
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchMoveEvent
				 */
				doTouchMove : noop,
				/**
				 * This method should be overridden in subclass, to handle
				 * actual gesture detection
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#doTouchEnd
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchEndEvent
				 */
				doTouchEnd : noop,
				/**
				 * This method should be overridden in subclass, to handle
				 * actual gesture detection
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#doTouchCancel
				 * @function
				 * @param {DOMTouchEvent}
				 *            touchCancelEvent
				 */
				doTouchCancel : noop,
				/**
				 * Reset the state of this gesture detector. Subclass SHOULD NOT
				 * call this method. Override it if necessary.
				 * 
				 * 
				 * @name sap.viz.mvc.GestureDetector#reset
				 * @function
				 */
				reset : function() {
					this.state = Possible;
					this._grTouchTracker = {};
				}
			});

	/**
	 * The mask used to specify gesture detector's state
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState
	 * @class
	 */
	GestureDetector.TransitionState = {
		Possible : Possible,
		Began : Began,
		Changed : Changed,
		Recognized : Recognized,
		Ended : Ended,
		Canceled : Canceled,
		Failed : Failed
	};
	return GestureDetector;
});sap.riv.module(
{
  qname : 'sap.viz.base.Math',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(UADetector) {
    var OptMath = {
        PI : Math.PI,
        E : Math.E,
        LN10 : Math.LN10,
        LN2 : Math.LN2,
        LOG2E : Math.LOG2E,
        LOG10E : Math.LOG10E,
        SQRT1_2 : Math.SQRT1_2,
        SQRT2 : Math.SQRT2,

        abs : (function() {
            if(UADetector.isSafari() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)) {
                return function(n) {
                    return n < 0 ? -n : n;
                };
            } else {
                return Math.abs;
            }
        })(),

        acos : (function() {
            return Math.acos;
        })(),

        asin : (function() {
            return Math.asin;
        })(),

        atan : (function() {
            return Math.atan;
        })(),

        atan2 : (function() {
            return Math.atan2;
        })(),

        /**
         * Get the ceil of a number.
         *
         * @name sap.viz.base.Math#ceil
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the ceil of number
         */
        ceil : (function() {
            // if (UADetector.isFirefox()) {
            // return function(n) {
            // var i = n | 0;
            // return n <= 0 ? i : (i == n ? i : i + 1);
            // };
            // }
            // else if (UADetector.isChrome()) {
            // return function(n) {
            // return n <= 0 ? n | 0 : Math.ceil(n);
            // };
            // }
            // else {
            return Math.ceil;
            // }
        })(),

        cos : (function() {
            return Math.cos;
        })(),

        exp : (function() {
            return Math.exp;
        })(),

        /**
         * Get the floor of a number.
         *
         * @name sap.viz.base.Math#floor
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the floor of number
         */
        floor : (function() {
            // if(UADetector.isFirefox()) {
            // return function(n) {
            // var a = n | 0;
            // return n < 0 ? (a == n ? a : a - 1) : a;
            // };
            // } else
            return Math.floor;
        })(),

        log : (function() {
            return Math.log;
        })(),

        /**
         * Get the maximum number in an array.
         *
         * @name sap.viz.base.Math#max
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the maximum number in array
         */
        max : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.max;
            // } else
                // return function() {
                    // var max = arguments[0];
                    // var length = arguments.length;
                    // for(var i = 1; i < length; i++) {
                        // max = arguments[i] > max ? arguments[i] : max;
                    // }
                    // return max;
                // };
        })(),

        /**
         * Get the minimum number in an array.
         *
         * @name sap.viz.base.Math#min
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the minimum number in array
         */
        min : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.min;
			// }
			// else return function(){
		        // var min = arguments[0];
		        // var length = arguments.length;
				// for (var i=1; i<length; i++){
					// min = arguments[i] > min ? min : arguments[i];
				// }
				// return min;
            // };
        })(),

        pow : (function() {
            return Math.pow;
        })(),

        random : (function() {
            return Math.random;
        })(),

        /**
         * Get the round of a number.
         *
         * @name sap.viz.base.Math#round
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the round of number
         */
        round : (function() {
            return Math.round;
            //			if(UADetector.isFirefox() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)){
            //				return function(n) {
            //					return (n >= 0) ? (n + 0.5) | 0 : (n - 0.4999999999999999) | 0;
            //				};
            //			}
            //			else if(UADetector.isChrome()){
            //				return function(n) {
            //					return Math.floor(n + 0.5);
            //				};
            //			}
            //			else return Math.round;
        })(),

        sin : (function() {
            return Math.sin;
        })(),

        sqrt : (function() {
            return Math.sqrt;
        })(),

        tan : (function() {
            return Math.tan;
        })()
    };
    return OptMath;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.PanGestureDetector',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.Math',
  version : '4.0.2'
}
],
function Setup(GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};
	/**
	 * This class defines detector for detecting Panning gesture. Panning
	 * gesture is detected when required number of fingers touch the screen and
	 * move a reasonable distance.
	 * 
	 * @name sap.viz.mvc.PanGestureDetector
	 * @class
	 * @augments sap.viz.mvc.GestureDetector
	 */
	var PanGestureDetector = GestureDetector.extend({
		constructor : function(touchesRequired) {
			this._touchesRequired = (touchesRequired > 0 && touchesRequired < 6) ? touchesRequired : 1;
			this._startXY = undefined;
			this._lastXY = undefined;
			this._currentXY = undefined;
			this._startWhen = 0;
			this._stopWhen = 0;
		},

		/**
		 * The number of touches required for tap to be detected.
		 * 
		 * @function
		 * @param {Number}
		 *            numOfTouches
		 * @returns {Number|this}
		 */
		touchesRequired : function(numOfTouches) {
			if (arguments.length) {
				this._touchesRequired = +numOfTouches;
				return this;
			}
			return this._touchesRequired;
		},

		doTouchBegin : function(touchStartEvent) {
			var currentNumOfTouches = this.totalTouches();
			if (currentNumOfTouches === this._touchesRequired && this.state === ts.Possible) {
				this._startWhen = this._stopWhen = touchStartEvent.timeStamp;
				this._startXY = this._lastXY = this._currentXY = this.globalLocOfTouchPoints();
				this.state = ts.Began;
			} else if (currentNumOfTouches > this._touchesRequired) {
				if (this.state === ts.Began || this.state === ts.Changed) {
					this._stopWhen = touchStartEvent.timeStamp;
					this._lastXY = this._currentXY;
					this._currentXY = this.globalLocOfTouchPoints();
					this.state = ts.Canceled;
				} else {
					this.state = ts.Failed;
				}
			}
		},
		doTouchMove : function(touchMoveEvent) {
			switch (this.state) {
			case ts.Began:
				if (_distance(this._startXY, this.globalLocOfTouchPoints()) > 10) {
					this._startWhen = this._stopWhen;
					this._stopWhen = touchMoveEvent.timeStamp;
					this._lastXY = this._currentXY;
					this._currentXY = this.globalLocOfTouchPoints();
					this.state = ts.Changed;
				}
				break;
			case ts.Changed:
				this._startWhen = this._stopWhen;
				this._stopWhen = touchMoveEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this.state = ts.Changed;
				break;
			}
		},
		doTouchEnd : function(touchEndEvent) {
			if ((this.state === ts.Began || this.state === ts.Changed)) {
				this._startWhen = this._stopWhen;
				this._stopWhen = touchEndEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this.state = ts.Ended;
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state === ts.Began || this.state === ts.Changed) {
				this._startWhen = this._stopWhen;
				this._stopWhen = touchCancelEvent.timeStamp;
				this._lastXY = this._currentXY;
				this._currentXY = this.globalLocOfTouchPoints();
				this.state = ts.Canceled;
			}
		},

		/**
		 * The current moving range in X,Y direction of the gesture
		 * 
		 * <pre>
		 * {
		 * 		x : ###,
		 * 		y : ###
		 * }
		 * </pre>
		 * 
		 * @name sap.viz.mvc.PanGestureDetector#rangeInXY
		 * @function
		 * @return {POINT}
		 */
		rangeInXY : function() {
			return {
				x : this._currentXY.x - this._startXY.x,
				y : this._currentXY.y - this._startXY.y
			};
		},

		/**
		 * The current moving velocity in X,Y direction of the gesture
		 * 
		 * <pre>
		 * {
		 * 		x : ###,
		 * 		y : ###
		 * }
		 * </pre>
		 * 
		 * @name sap.viz.mvc.PanGestureDetector#velocityInXY
		 * @function
		 * @return {POINT}
		 */
		velocityInXY : function() {
			var duration = this._stopWhen - this._startWhen;
			if (duration) {
				return {
					x : (this._currentXY.x - this._lastXY.x) / duration,
					y : (this._currentXY.y - this._lastXY.y) / duration
				};
			} else {
				return 0;
			}
		},
		reset : function() {
			this._super();
			this._startXY = undefined;
			this._lastXY = undefined;
			this._currentXY = undefined;
			this._startWhen = 0;
			this._stopWhen = 0;
		}
	});
	return PanGestureDetector;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.TapGestureDetector',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.Math',
  version : '4.0.2'
}
],
function Setup(GestureDetector, Math) {
	var ts = GestureDetector.TransitionState;
	var _distance = function(xy1, xy2) {
		var dx = xy1.x - xy2.x;
		var dy = xy1.y - xy2.y;
		return Math.sqrt(dx * dx + dy * dy);
	};

	var _startNewTapSequence = function(tapDetector, event) {
		tapDetector._sequenceStarted = true;
		tapDetector._currentNumberOfTaps = 0;
		tapDetector._firstStartXY = tapDetector.globalLocOfTouchPoints();
	};

	// Defines the maximum distance from current tap to where
	// the first tap
	// starts
	var _maxDistance = 50;
	// Defines the maximum and minimum time for each tap
	var _maxTapTime = 150;
	var _minTapTime = 20;
	// Defines the maximum time gap
	// between the time the previous tap ends and the time the
	// next one starts
	var _maxTapGap = 150;

	/**
	 * This class defines detector for detecting Tapping gesture. Tapping
	 * gesture is detected when required number of fingers tap the screen for
	 * required number of times.
	 * 
	 * @name sap.viz.mvc.TapGestureDetector
	 * @class
	 * @augments sap.viz.mvc.GestureDetector
	 */

	var TapGestureDetector = GestureDetector.extend({
		constructor : function(touchesRequired, tapsRequired) {
			touchesRequired = +touchesRequired;
			tapsRequired = +tapsRequired;
			this._touchesRequired = (touchesRequired > 0 && touchesRequired < 6) ? touchesRequired : 1;
			this._tapsRequired = (tapsRequired > 0) ? tapsRequired : 1;

			this._currentNumberOfTaps = 0;
			this._firstStartXY = undefined;
			this._sequenceStarted = false;
			this._currentStartWhen = 0;
		},

		/**
		 * The number of touches required for tap to be detected.
		 * 
		 * @function
		 * @param {Number}
		 *            numOfTouches
		 * @returns {Number|this}
		 */
		touchesRequired : function(numOfTouches) {
			if (arguments.length) {
				this._touchesRequired = +numOfTouches;
				return this;
			}
			return this._touchesRequired;
		},

		/**
		 * The number of taps required for tap to be detected.
		 * 
		 * @function
		 * @param {Number}
		 *            numOfTaps
		 * @returns {Number|this}
		 */
		tapsRequired : function(numOfTaps) {
			if (arguments.length) {
				this._tapsRequired = +numOfTaps;
				return this;
			}
			return this._tapsRequired;
		},

		doTouchBegin : function(touchStartEvent) {
			if (this.state === ts.Possible) {
				var currentNumOfTouches = this.totalTouches();
				if (currentNumOfTouches === this._touchesRequired) {
					var currentTimeStamp = touchStartEvent.timeStamp;

					// Beginning of the first
					// tap in a tap
					// sequence
					if (this._currentNumberOfTaps == 0) {
						// Record the
						// information of first
						// tap
						// for later comparison
						_startNewTapSequence(this, touchStartEvent);
					}
					// Beginning of a tap (other
					// than the first
					// one) in a tap sequence
					else {
						if (this._currentNumberOfTaps < this._tapsRequired) {
							var distance = _distance(this._firstStartXY, this.globalLocOfTouchPoints());
							var preStartWhen = this._currentStartWhen;

							// If the tap breaks
							// a tap sequence,
							// start a new
							// sequence with it
							if (distance > _maxDistance
									|| (currentTimeStamp - preStartWhen) > (_maxTapTime + _maxTapGap)) {
								_startNewTapSequence(this, touchStartEvent);
							}
						}
					}

					this._currentStartWhen = currentTimeStamp;
				} else { // Fails if touch
					// number doesn't
					// match
					this.state = ts.Failed;
				}
			}
		},

		doTouchEnd : function(touchEndEvent) {
			if (this.state === ts.Possible && this._sequenceStarted) {
				// Fails if the touch ends too
				// far away from
				// where it starts
				if (_distance(this._firstStartXY, this.globalLocOfTouchPoints()) > _maxDistance) {
					this.state = ts.Failed;
					return;
				}
				// Fails if the tap is too short
				// or too long
				var tapTime = touchEndEvent.timeStamp - this._currentStartWhen;
				if (tapTime > _maxTapTime || tapTime < _minTapTime) {
					this.state = ts.Failed;
					return;
				}
				if (++this._currentNumberOfTaps === this._tapsRequired) {
					this.state = ts.Recognized;
				}
			}
		},

		doTouchCancel : function(touchCancelEvent) {
			if (this.state === ts.Possible) {
				this.state = ts.Failed;
			}
		},

		reset : function() {
			this._super();
			this._currentNumberOfTaps = 0;
			this._sequenceStarted = false;
			this._firstStartXY = undefined;
			this._firstStartWhen = 0;
			this._currentStartWhen = 0;
		}
	});
	return TapGestureDetector;
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.touchmonitor',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.TapGestureDetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.PanGestureDetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.2'
}
],
function Setup(dispatch, TapGestureDetector, PanGestureDetector,
		GestureDetector) {
	var lastX; // coordinate of last touch point
	var lastY;
	var target;

	return function(manifest, ctx) {
		var gnode, props, originaltouchstartpoint, eventManager = ctx.eventManager;
		var d = dispatch('click', 'hover', 'lassostart', 'lassomove',
				'lassoend', 'mousedown', 'mouseup', 'mouseover', 'mouseout',
				'mouseleave');
		var oTapGestureDetector;
		var oPanGestureDetector;
		// mouse trigger
		var tm = function() {
			return tm;
		};

		tm.properties = function(_) {
			if (!arguments.length) {
				return props;
			}
			props = _;
			return tm;
		};

		tm.registerEvent = function(g) {
			if (oTapGestureDetector === undefined) {
				oTapGestureDetector = new TapGestureDetector();
				oTapGestureDetector.addGestureAction(tapHandler);
				oTapGestureDetector.enable(true);
				eventManager.addGestureDetector(oTapGestureDetector);
			}

			if (oPanGestureDetector === undefined) {
				oPanGestureDetector = new PanGestureDetector();
				oPanGestureDetector.addGestureAction(panHandler);
				oPanGestureDetector.enable(true);
				eventManager.addGestureDetector(oPanGestureDetector);
			}

			gnode = g.node();
			g.on('touchstart.monitor', touchstart).on('touchend.monitor',
					touchend);
		};

		tm.dispatch = function(_) {
			if (!arguments.length) {
				return d;
			}
			d = _;
			return tm;
		};

		tm.destroy = function() {
		};

		function isDatalabel(temptarget) {
			var result = false;

			if (temptarget != null && temptarget.tagName == 'svg')
				return false;
			if (temptarget.getAttribute('class') == "v-datalabel") {
				return true;

			} else {

				result = isDatalabel(temptarget.parentNode);
			}

			return result;
		}
		
		function tapHandler(go) {
			// console.log("tap handler in touchmonitor");
			if (!isValid(getCurrentEvent())) {
				return;
			}

			fireEvent('click');
			if (!isAxisLabelArea(getCurrentEvent())) {

				var target = getCurrentEvent().target;

				if (target.tagName == 'text') {     

					if (isDatalabel(target)) {
						target = target.__data__.dataShape;
					}
				}
				fireEvent('hover');

				fireEvent('mouseover', undefined, target);
			}
		}
		;

		var islassoend = false;
		function panHandler(go) {
			if (go.state === GestureDetector.TransitionState.Began) {
				var target = document.elementFromPoint(
						getCurrentEvent().changedTouches[0].clientX,
						getCurrentEvent().changedTouches[0].clientY);
				if (isInMain(target)) {
					fireEvent('lassostart', originaltouchstartpoint);
				}

			} else if (go.state === GestureDetector.TransitionState.Changed) {
				var containerBox = go.watchedComponent.container
						.getBoundingClientRect(), pointOnGesture = go
						.globalLocOfGesture(), gnodeBox = gnode
						.getBoundingClientRect();
				var globalpointx = pointOnGesture.x + containerBox.left, globalpointy = pointOnGesture.y
						+ containerBox.top;

				var target = document.elementFromPoint(globalpointx,
						globalpointy);
				// If the gesture happened in the area of module, we fire lasso
				// move event, else fire lasso end event.
				if (isInMain(target)) {
					fireEvent('lassomove', {
						x : globalpointx,
						y : globalpointy
					});
				} else {
					if (!islassoend) {
						fireEvent('lassoend');
						// set lasso end to true, so that we can do not fire
						// lasso end event.
						islassoend = true;
					}
				}

			} else {
				if (islassoend) {
					islassoend = false;
				} else {
					var target = document.elementFromPoint(
							getCurrentEvent().changedTouches[0].clientX,
							getCurrentEvent().changedTouches[0].clientY);
					if (!isInMain(target)) {
						return;
					} else if (isAxisLabelArea(getCurrentEvent())) {
						fireEvent('lassoend');
						return;
					}
					var containerBox = go.watchedComponent.container
							.getBoundingClientRect(), pointOnGesture = go
							.globalLocOfGesture();
					var globalpointx = pointOnGesture.x + containerBox.left, globalpointy = pointOnGesture.y
							+ containerBox.top;

					// fire lasso end event
					fireEvent('lassoend');
					// fire hover event
					fireEvent('hover', {
						x : globalpointx,
						y : globalpointy
					});
					// fire mouse over event,we should figure out the target and
					// mouse point
					fireEvent('mouseover', {
						x : globalpointx,
						y : globalpointy
					}, target);

				}
			}
		}

		var touchscount = 0, hasMuitlTouches = false;
		function touchstart() {
			console.log('touchstart');
			var originalEvent = getCurrentEvent();
			var touch = originalEvent.touches[0];
			originaltouchstartpoint = {
				x : touch.clientX,
				y : touch.clientY
			};

			if (isAxisLabelArea(originalEvent)) {
				if (++touchscount >= 2) {
					hasMuitlTouches = true;
				}

				fireEvent('mouseout', { // mouseout from last touch point
					x : lastX,
					y : lastY
				}, target);
				

				fireEvent('mouseover');
				fireEvent('mousedown');

				target = document
						.elementFromPoint(touch.clientX, touch.clientY); 
				lastX = touch.clientX;
				lastX = touch.clientY;
			}
			return true;
		}

		function touchend() {
			if (isAxisLabelArea(getCurrentEvent())) {

				touchscount--;

				if (hasMuitlTouches) {
					if (touchscount > 0) {
						fireEvent('mouseup');
					} else {
						hasMuitlTouches = false;
					}
				} else {
					hasMuitlTouches = false;
					fireEvent('mouseup');
				}

			}
		}

		function isAxisLabelArea(event) {
			var target = event.target, classname = target.getAttribute('class');
			var isInAxisLabelArea = false;
			if (classname && classname.indexOf('v-labelarea') >= 0)// find it
			{
				if (props.selectability.mode !== 'single') {
					// do not have label selection in 'single'
					isInAxisLabelArea = true;
				}
			}
			return isInAxisLabelArea;
		}

		function isInMain(node) {
			var result = false;
			if (node.tagName == 'svg') {
				return false;
			} else {
				if (node === gnode) {
					return true;
				}
				result = isInMain(node.parentNode);
			}
			return result;
		}

		function isValid(event) {
			return isInMain(event.target);
		}

		function getCurrentEvent() {
			if (d3.event) {
				return d3.event;
			} else {
				return window.event;
			}
		}

		function fireEvent(type, point, target) {
			var temppoint, temptarget;
			if (point) {
				temppoint = point;
			} else {
				temppoint = originaltouchstartpoint;
			}
			if (target) {
				temptarget = target;
			} else {
				temptarget = getCurrentEvent().target;
			}
			var tempEvent = {
				name : type,
				data : {
					point : temppoint,
					target : temptarget
				}
			};
			

			switch (type) {
			case 'mousedown':
				if (props.enableMouseDown) {
					console.log('mousedown');
					d.mousedown(tempEvent);
				}
				break;
			case 'mouseup':
				if (props.enableMouseUp) {
					d.mouseup(tempEvent);
				}
				break;
			case 'mousemove':
				if (props.enableMouseMove) {
					d.mousemove(tempEvent);
				}
				break;
			case 'mouseover':
				if (props.enableMouseOver) {
					d.mouseover(tempEvent);
				}
				break;
			case 'mouseout':
				if (props.enableMouseOut) {
					d.mouseout(tempEvent);
				}
				break;
			case 'hover':
				if (props.enableHover) {
					d.hover(tempEvent);
				}
				break;
			case 'lassostart':
				d.lassostart(tempEvent);
				break;
			case 'lassomove':
				d.lassomove(tempEvent);
				break;
			case 'lassoend':
				d.lassoend(tempEvent);
				break;
			case 'click':
				if (props.enableClick) {
					d.click(tempEvent);
				}
				break;
			default:
				break;
			}
		}

		return tm;
	};
});sap.riv.module(
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup( TypeUtils, UADetector ) {
  var ns = "http://www.w3.org/2000/svg";
  var node;
  var canvasNode;
  var fasterFun;
  var sensitiveStyle = ["font", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style",
      "font-variant", "font-weight", "letter-spacing", "word-spacing", "alignment-baseline", "baseline-shift",
      "dominant-baseline"];
  var textSizeCache = [];
  var textSizeCacheForSuper = [];
  var myTextSizeCache = [];
  
  function getNode() {
    if ( !node ) {
      var svg = document.body.appendChild(document.createElementNS(ns, "svg"));
      svg.style.cssText = "position:absolute;left:-1000px;top:-1000px;z-index:-9000;width:1px;height:1px";
      node = svg.appendChild(document.createElementNS(ns, "text"));
    }

    return node;
  }

  function applyText( text, style ) {
    var node = getNode();

    if ( !style ) {
      node.removeAttribute("style");
    } else {
      if ( !TypeUtils.isString(style) ) {
        var computedStyle = UADetector.isIE() ? style.ownerSVGElement.getComputedStyle(style) : window
            .getComputedStyle(style);

        var cssText = "";
        sensitiveStyle.forEach(function( i ) {
          var s = computedStyle.getPropertyValue(i);
          if ( s !== null ) {
            cssText += i + ":" + s + ";";
          }
        });
        style = cssText;
      }
      node.style.cssText = style;
    }
    if ( text === undefined || text === null ) {
      text = "";
    }

    node.textContent = text;
    return node;
  }

  function ellipsis( text, textNode, expectedLength, cssStyle, textApplied ) {
    var index = "..." + cssStyle;
    if ( expectedLength > 0 ) {
      if (myTextSizeCache[index]) {
        if(text.length > 3) {
          if(expectedLength < myTextSizeCache[index]/3*4) {
            if ( textNode ) {
              textNode.textContent = "";
            }
            return "";
          }
        } else {
          if(expectedLength < myTextSizeCache[index]/3*text.length) {
            if ( textNode ) {
              textNode.textContent = "";
            }
            return "";
          }
        }
      }
      var node,initTextLength;
      index = text + cssStyle;
      node = textApplied ? getNode() : applyText(text, cssStyle || textNode);
      initTextLength = node.getComputedTextLength();
      
      if (initTextLength  <= expectedLength ) {
        if ( textNode ) {
          textNode.textContent = text;
        }
        return text;
      }
      
      index = "..." + cssStyle;
      if (!myTextSizeCache[index]) {
        node.textContent = "...";
        myTextSizeCache[index] = node.getComputedTextLength();
      }

      expectedLength -= myTextSizeCache[index];
      node.textContent = text;
      if ( expectedLength > 0 ) {
        var charNumber = text.length;
        var i = Math.floor(expectedLength/initTextLength*charNumber);
        var subStr = text.substring(0, i);
        index = subStr + cssStyle;
        var textLength = node.getSubStringLength(0, i);
        var reText;
        if(textLength <= expectedLength) {
          while(++i < charNumber) {
            subStr = text.substring(0, i);
            index = subStr + cssStyle;
            textLength = node.getSubStringLength(0, i);
            if(textLength > expectedLength) {
              reText = text.substring(0, i-1) + "...";
              if ( textNode ) {
                textNode.textContent = reText;
                textNode.appendChild(document.createElementNS(textNode.namespaceURI, "title")).textContent = text;
              }
              return reText;
            }
          }
        } else {
          while(--i > 0) {
            subStr = text.substring(0, i);
            index = subStr + cssStyle;
            textLength = node.getSubStringLength(0, i);
            
            if(textLength <= expectedLength) {
              reText = subStr + "...";
              if ( textNode ) {
                textNode.textContent = reText;
                textNode.appendChild(document.createElementNS(textNode.namespaceURI, "title")).textContent = text;
              }
              return reText;
            }
          }
        }
      } 
    }
    if ( textNode ) {
      textNode.textContent = "";
    }
    return "";
  }

  return {
    /**
     * Measure the dimension of the text in given style
     * 
     * @param {String}
     *          text the text to be measured
     * @param style
     *          the style definition text or a DOM node. If it is a node, its style will be used to measure text.
     * @returns {Object}
     */
    measure : function( text, style ) {
      if ( text === '' ) {
        return {
          width : 0,
          height : 0,
          x : 0,
          y : 0
        };
      }
      var box = applyText(text, style).getBBox();
      return {
        width : box.width,
        height : box.height,
        x : box.x,
        y : box.y
      };
    },

    /**
     * Measure text in a canvas
     * 
     * @param {String}
     *          the text to be measured
     * @param {String}
     *          fontSize
     * @param {String}
     *          fontWeight
     * @param {String}
     *          fontFamily
     * @returns {Object}
     */
    measureInCanvas : function( text,  tFontSize, tFontWeight, tFontFamily ) {
        if(!tFontFamily || !tFontSize || !tFontWeight)
        {
            //the function cannot get right value 
            return;
        }

        var strWidth = 0;
        if (!canvasNode)
        {        
            canvasNode = document.createElement("canvas");
            canvasNode.style.cssText = "position:absolute;left:-1000px;top:-1000px;z-index:-9000;width:0px;height:0px;visibility:hidden";
            document.body.appendChild(canvasNode);
        }

        if (canvasNode.getContext)
        {
            var ctx = canvasNode.getContext("2d");
            var fontString = tFontWeight + " " + tFontSize + " " + tFontFamily;
            ctx.font = fontString;
            strWidth = ctx.measureText(text).width;
        }

        var fontSizeFloat = parseFloat(tFontSize) * 1.2;
    
        return {
            width : strWidth,
            height : fontSizeFloat
        };    
    },

    /**
     * Fast measure the dimension of the text in given fontSize, fontWeight and fontFamily
     * 
     * @param {String}
     *          text the text to be measured
     * @param {String}
     *          fontSize
     * @param {String}
     *          fontWeight
     * @param {String}
     *          fontFamily
     * @returns {Object}
     */
    fastMeasure : function( text, tFontSize, tFontWeight, tFontFamily ) {
      var index = text + tFontSize + tFontWeight + tFontFamily;
      var cachedSize = textSizeCache[index];
      if ( !cachedSize ) {
        textSizeCache[index] = this.measure(text, "font-size:" + tFontSize + "; font-weight:" + tFontWeight +
            "; font-family:" + tFontFamily);

        cachedSize = textSizeCache[index];
      }
      return cachedSize;
    },
    
    //find the fastest measure function for the browser.
    //measureInCanvas may be faster in Chrome, but not in Firefox.
    bestMeasureFun : function(tFontSize, tFontWeight, tFontFamily)
    {
        if(!fasterFun)
        {
            var i; 
            var testTimes = 100;
            var testText = "Test";
            //test measureInCanvas
            var startC = new Date().getTime();
            for(i = 0; i < testTimes; i++)
            {
                this.measureInCanvas(testText, tFontSize, tFontWeight, tFontFamily);
            }
            var endC = new Date().getTime();
            var timeC = endC - startC;

            //test measure
            var startM = new Date().getTime();
            for(i = 0; i < testTimes; i++)
            {           
                this.measure(testText, "font-size:" + tFontSize + "; font-weight:" + tFontWeight +
                             "; font-family:" + tFontFamily);
            }
            var endM = new Date().getTime();
            var timeM = endM - startM;

            if(timeC < timeM)
            {
                fasterFun = "C";
            }
            else
            {
                fasterFun = "M";
            }
        }

        return fasterFun;
    },
    /**
     * Super fast measure the dimension of the text in given fontSize, fontWeight and fontFamily
     * 
     * @param {String}
     *          text the text to be measured
     * @param {String}
     *          fontSize
     * @param {String}
     *          fontWeight
     * @param {String}
     *          fontFamily
     * @returns {Object}
     */
    superFastMeasure : function( text, tFontSize, tFontWeight, tFontFamily ) {
      var index = text + tFontSize + tFontWeight + tFontFamily;
      var cachedSize = textSizeCacheForSuper[index];
      if ( !cachedSize ) {
        if(this.bestMeasureFun(tFontSize, tFontWeight, tFontFamily) === "C")
        {
            textSizeCacheForSuper[index] = this.measureInCanvas(text, tFontSize, tFontWeight, tFontFamily);
        }
        else
        {
            textSizeCacheForSuper[index] = this.measure(text, "font-size:" + tFontSize + "; font-weight:" + tFontWeight +
            "; font-family:" + tFontFamily);
        }
        cachedSize = textSizeCacheForSuper[index];
      }
      return cachedSize;
    },

    /**
     * Ellipsis long text.
     * 
     * @param {String}
     *          text the text to be processed
     * @param {Node}
     *          textNode the svg:text which will be display text
     * @param {Number}
     *          maxLength the max text length
     */
    ellipsis : function( text, textNode, maxLength, cssStyle ) {
      return ellipsis(text, textNode, maxLength, cssStyle, false);
    },

    /**
     * Ellipsis long text in a circle area.
     * 
     * @param {String}
     *          text the text to be processed
     * @param {Node}
     *          textNode the svg:text which will be display text
     * @param {Number}
     *          r the radius of circle
     * @param {Number}
     *          h the offset from center of circle
     * @param {Object}
     *          cssStyle the style object
     */
    ellipsisInCircle : function( text, textNode, r, h, cssStyle ) {
      var node = applyText(text, textNode);

      var maxLength = Math.sqrt(Math.pow(r, 2) - Math.pow(h + node.getBBox().height / 2, 2)) * 2;
      ellipsis(text, textNode, maxLength, cssStyle, true);
    },

    verticalCentralOffset : function( text, textNode ) {
      var tmpNode = applyText(text, textNode);
      var box = tmpNode.getBBox();
      var actualHeight = -box.y;
      var fontSize = parseInt(tmpNode.ownerSVGElement.getComputedStyle(tmpNode)["fontSize"], 0);
      return (actualHeight - (box.height - fontSize)) / 2;
    }
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.interaction',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.controller.touchmonitor',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.controller.mousemonitor',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(TextUtils, dispatch, TypeUtils,Constants, Objects, TouchMonitor, MouseMonitor, BoundingBox, ObjectUtils, UADetector) {
  return function(manifest,ctx){
    
    var g = null, m, eventLayer = null; 
    var eDispatch = new dispatch('selectData', 'deselectData', 'deselectLegend');

    var selectionMode = 'multiple', preserveSelectionWhenDragging = false, holdSelection = false;
    var defaultProps = {enableMouseUp:true, enableMouseDown:true, enableHover:true, enableClick:true};
    
    var lassoHelper, //a rect holder
        hitTestRect = {}, eFilter = '.v-datapoint';
    
    var plots = [], lastSelected = [], lastHovered = [], lastOvered = [],
        isRegister = false, mousedownPos = null, monitor;

    init();

    function init() {
        props = ObjectUtils.extend(true , defaultProps, manifest.props(null));
    
        if (UADetector.isMobile()){
          monitor = new TouchMonitor(manifest, ctx);
        }else{
          monitor = new MouseMonitor(manifest, ctx);
        }

        monitor.dispatch()
            .on('click', clickHandler)
            .on('hover', hoverHandler)
            .on('lassostart', lassoStartHandler)
            .on('lassomove', lassoMoveHandler)
            .on('lassoend', lassoEndHandler)
            .on('mousedown', mouseDownHandler)
            .on('mouseup', mouseUpHandler)
            .on('mouseover', mouseOverHandler)
            .on('mouseout', mouseOutHandler)
            .on('mouseleave', mouseLeaveHandler);
    }
    
    var reset = function(){
      isRegister = false;
      plots = [];
      lastSelected.splice(0, lastSelected.length);
      lastHovered.splice(0, lastHovered.length);
      lastOvered.splice(0, lastOvered.length);
    };

    /*
     * alternative to mouse
     * reason: the result is incorrect in chrome/ie9 when browser zoom != 1
     */
    var mouse = function(point) {
      // geo needs to use eventLayer due to the fact that domElement will a bounding rect
      // that is greater than the viewport
      node = !eventLayer.empty() ? eventLayer.node() : g.node(), 
      rect = node.getBoundingClientRect(),
      x = point.x - rect.left,
      y = point.y - rect.top;

      return [ x, y ];
    };

    // return a bounding box for the provided node
    var getBoundingBox = function(node) {
      var rect = node.getBoundingClientRect();
      return { x: rect.left, y: rect.top, height: rect.height, width: rect.width };
    };
    //filter the selectees to see whether the shape intersect with hitTestRect. 
    var filter = function(selectees, hitTestRect){
      var res = [];
      
      selectees.filter(function(d, m){
        var rect = getBoundingBox(this);
        if(BoundingBox.intersects(rect , hitTestRect)){
          res.push(this);
        }
      });

      return res;
    };

    function lassoStartHandler(event) {
      startPos = mouse(event.data.point);
      
      lassoHelper = g.append('rect')
        .attr('x', startPos[0])
        .attr('y', startPos[1])
        .attr('width', 0)
        .attr('height', 0)
        .attr('pointer-events', 'none')
        .attr('fill', 'rgba(64,176,240, 0.4)')
        .style('stroke-width', '2px')
        .attr('stroke', 'rgb(64, 176, 240)');
    }
    function lassoMoveHandler(event) {
      var pos = mouse(event.data.point),
        x = Math.min(pos[0], startPos[0]),
        y = Math.min(pos[1], startPos[1]),
        width = Math.abs(pos[0] - startPos[0]),
        height = Math.abs(pos[1] - startPos[1]);

      lassoHelper.attr('x', x).attr('y', y).attr('width', width).attr('height', height);
    }
    function lassoEndHandler(event) {
      var clientPoint = event.data.point;

      var bnode = lassoHelper.node(), 
          box = getBoundingBox(bnode), 
          bwidth = parseFloat(bnode.getAttribute('width')), 
          bheight = parseFloat(bnode.getAttribute('height')),
          selectedData = [], 
          deselectedData = [];

      // remove the lasso element after this function executes
      setTimeout(function() {
        lassoHelper.remove();
      }, 0);
    
      if(bwidth || bheight){
        var plot, candidates, isInShape = false, selectees = null, selectedObj = [], 
            plotSubLayer = null,
            plotBox = null,
            intersectedBox = null;
        for(var i = 0, len= plots.length; i< len; i++) {
          plot = plots[i];
          candidates = null;

          if (TypeUtils.isFunction(plot.getDatapointsInRect)) {
            // if the plot supports this function, use it to retrieve datapoints within the 
            // bounds of the lasso element
            candidates = plot.getDatapointsInRect(lassoHelper.node());
          }
          else {
            // get a rectangle that represent the viewbox of the plot module
            plotSubLayer = plot.parent().select('rect.viz-event-sub-layer').node();

            // find the intersection of the plot rectangle with the lasso rectangle
            plotBox = plotSubLayer ? getBoundingBox(plotSubLayer) : null;
            intersectedBox = plotBox ? BoundingBox.intersection(plotBox, box) : box; // fall back to lasso rect if plot rectangle not available

            if (!intersectedBox) {
              // this is null if the lasso was not over the plot's area
              // no need to check datapoints for this plot
              continue;
            }

            selectees = plot.parent().selectAll('.v-datapoint');

            if(selectees[0].length > 0){
              candidates = filter( selectees , intersectedBox );
            }
          }

          if(candidates && candidates.length > 0 ){
            selectedObj.push({
              plot: plot,
              selected: candidates
            });
          }
        }
        
        if(selectedObj.length > 0){
          if(lastSelected.length  == 0){
            unhighlightTarget(lastSelected, false);
            clearPlots(true);
          }
          
          //if the length of lastSelect is large than 0, it means that the chart is in highlight status, do not need to clear the chart to gray
          var plot = null, selected = null, isHighlight = false, lastSelectedBack = ObjectUtils.extend(true , [], lastSelected);
          for(var i=0, len= selectedObj.length; i < len; i++){
            plot = selectedObj[i].plot, selected = selectedObj[i].selected;
            for(var j=0, jlen = selected.length; j < jlen; j++){
              for(var t =0, tlen = lastSelectedBack.length; t < tlen; t++){
                if(selected[j] == lastSelectedBack[t]){
                  isHighlight = true;
                  break;
                }
              }
              
              //If the shape is not in queue of lastSelected
              //maybe we should deselect the shape which is already in highlight status, currently, do not need
              if(isHighlight){
                //lastSelected.splice((t - 1, 1));
                selectedData.push(selected[j]); // only fire the change the data
              }else{
                lastSelected.push(selected[j]);
                selectedData.push(selected[j]); // only fire the change the data
              }

              isHighlight = false;
            }
            //highlight selected shapes
            plot.highlight(selected);
          }
        }else{
          //there are no shapes selected
          if(lastSelected.length > 0){
            //if there are selected before, clear all
            unhighlightTarget(lastSelected, false);
            clearPlots();
          }
          
          deselectedData  = deselectedData.concat(lastSelected);
          lastSelected.splice(0, lastSelected.length);
        }
        
        //eDispatch.lassoEnd(candidates);
        if(selectedData.length > 0){
          fireSelectDataEvent(selectedData);
        }
        
        if(deselectedData.length >0){
          fireDeselectDataEvent(deselectedData);
        }
        
        //clear lastOvered effect
        for(var i =0, len = lastOvered.length; i< len;i++){
          if(lastOvered[i].plot.mouseout){
            lastOvered[i].plot.mouseout(lastOvered[i].target, true);
          }
        }
        
        lastOvered.splice(0, lastOvered.length);
      }
    }

    var selection = function(){
      return selection;
    };
    
    var clearPlots  = function(_){
      for(var i = 0; i< plots.length; i++){
        if(plots[i].clear){
          plots[i].clear(_);
        }
      }
    };

    var pointInPlot = function(t, plot){
      var p = plot.parent()[0][0].getBoundingClientRect();
      return (t.x >= p.left && t.x <= p.left + p.width && t.y >= p.top && t.y <= p.top + p.height);
    };

    // returns an array of the plot's parent nodes, in the same order as the "plots" array
    var getPlotNodes = function() {
      var nodes = [];
      for (var i = 0, len = plots.length; i < len; i++) {
        if (plots[i].parent()) {
          nodes.push(plots[i].parent().node());
        }
      }
      return nodes;
    };

    // returns the index of the plot (in the "plots" array) that contains the target element
    // nodes is optional and should contain the container elements for the plots
    var plotIndexContainingTarget = function(target, nodes) {
      var n = target,
        plotNodes = nodes || getPlotNodes(),
        idx;

      for (; n && n.ownerSVGElement; n = n.parentNode) {
        idx = plotNodes.indexOf(n);
        if (idx !== -1) {
          return idx;
        }
      }

      return -1;
    };

    // returns the plot module object that contains the target element
    var plotContainingTarget = function(target, nodes) {
      var plotIdx = plotIndexContainingTarget(target, nodes);

      if (plotIdx !== -1) {
        return plots[plotIdx];
      }

      return null;
    };

    // returns the input targets, organized by their parent plot
    // the result object is an array, with each entry corresponding to a plot in the "plot" array
    // each entry is an array of targets
    var groupTargetsByPlot = function(targets) {
      var plotNodes = getPlotNodes(),
          results = [];

      for (var i = 0, len = plots.length; i < len; i++) {
        results.push([]);
      }

      for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i],
          idx = plotIndexContainingTarget(target, plotNodes),
          plotTargets;

        if (idx !== -1) {
          plotTargets = results[idx];
          plotTargets.push(target);
        }
        else {
          // log/throw error?
        }
      }

      return results;
    };

    var highlightTarget = function(target) {
      var plot = plotContainingTarget(target);
      if (plot && plot.highlight) {
        plot.highlight(target, selectionMode);
      }
    };
    
    // CTIsDatapoint means the current target is datapoint shape or not
    // target can be an array or a single element
    var unhighlightTarget = function(target, CTIsDatapoint) {
      var targets = TypeUtils.isArray(target) ? target : [ target ],
          targetsGroupedByPlot = groupTargetsByPlot(targets);

      for (var i = plots.length - 1; i >= 0; i--) {
        var plot = plots[i],
            plotTargets = targetsGroupedByPlot[i];

        if (plotTargets && plotTargets.length > 0 && plot.unhighlight) {
          plot.unhighlight(plotTargets, CTIsDatapoint);
        }
      }
    };
    
    selection.defaultSelection = function(){
      var info, selectDatas = [], selectedTargets = [];
      var singleSelection = false;
     // clearPlots(true);
      for(var k=0; k<plots.length; k++){
        var targets = plots[k].parent().selectAll('.v-datapoint')[0];
        for(var i=0; i< targets.length; i++){
          if(singleSelection || selectionMode === 'none'){
            break;
          }
          info = targets[i].__data__.info;
          if( info ){
            if(info instanceof Array){
              for(var j=0; j<info.length; j++){
                if(info[j] && info[j].defaultSelection && info[j].defaultSelection.isSelected){
                  if(selectionMode === 'single'){
                    if(info[j].defaultSelection.index === 0){
                      selectedTargets.push(targets[i]);
                      singleSelection = true;
                      break;
                    }
                  }else{
                    selectedTargets.push(targets[i]);
                  }
                }
              }
            }else if(info.defaultSelection && info.defaultSelection.isSelected){
              if(selectionMode === 'single'){
                if(info.defaultSelection.index === 0){
                  selectedTargets.push(targets[i]);
                  break;
                }
              }else{
                selectedTargets.push(targets[i]);
              }
            }
          }
        }
      }
      if(selectedTargets.length > 0){
        clearPlots(true);
      }
      
      for(i=0; i<selectedTargets.length; i++){
        highlightTarget(selectedTargets[i]);
        lastSelected.push(selectedTargets[i]);
        selectDatas.push(selectedTargets[i]);
      } 
      
      if(selectDatas.length > 0){
        fireSelectDataEvent(selectDatas);
      }
      
    };
    
    
    selection.registerEvent = function(){
      //TODO, [Ian] register event function will be called more than once as in multi chart, modules will fire more than one complete animation event.
      if(isRegister == false) {
        isRegister = true;
        monitor.registerEvent(g);

        var temp = m.modules();
        for(var i in temp){
          if(temp.hasOwnProperty(i) && !(temp[i] instanceof Array) && temp[i].parent()){
            plots.push(temp[i]);
          }
        }
        
        if(!eventLayer){
          eventLayer = g.insert("rect", "g").attr("x", 0).attr("y", 0).attr("fill-opacity", 0);
        }
        eventLayer.attr("width", m.width()).attr("height", m.height());

        // if (preserveSelectionWhenDragging === true) {
          // g.on('mousedown.preserveSelectionWhenDragging', function() {
              // mousedownPos = d3.mouse(g.node());
            // }, true);
        // }
      } else {
        eventLayer.attr('width', m.width()).attr('height', m.height());

        for(var i=0, len =lastHovered.length; i<len; i++){
          if(lastHovered[i].blurOut){
            lastHovered[i].blurOut();
          }
        }
        lastHovered.splice(0, lastHovered.length);
        
        for(var i=0, len =lastOvered.length; i< len; i++){
          if(lastOvered[i].plot.mouseout){
            lastOvered[i].plot.mouseout();
          }
        }
        lastOvered.splice(0, lastOvered.length);
        
        if(holdSelection == false){
          lastSelected.splice(0, lastSelected.length);
        }
      }
    };
    
    //[2012/09/11 Christy] Get selection mode for legend.
    selection.getSelectionMode = function(){
      return selectionMode;
    };
    
    //[2012/09/10 Christy] Legend is selected.  
    selection.highlightedByLegend = function(selectedData, isSelected){
      if(selectionMode === 'single' || selectionMode === 'none'){
        //Doesn't work in single mode.
        return;
      }
      if(selectedData.ctx === undefined){
        return;
      }
      var datapoints = [], itemData, isSame = true, ctxDatapoints = [], isDeselected = true, selectedObjs = [], selectDatas = [], deselectDatas = [], selectDatapoints = [], deselectDatapoints = [];
      for(var i = 0, len = plots.length; i < len; i++){
        //Reset datapoints arrary which contains selectedData ctx.
        ctxDatapoints = [];
        
        if(selectedData.ctx.ranges){
          //MBC legend
          if(plots[i].getDatapointsByRange){
            ctxDatapoints = plots[i].getDatapointsByRange(selectedData);
            selectedObjs.push({
              plot: plots[i],
              ctxDatapoints : ctxDatapoints
            });
          }
        } else { 
          if (plots[i].getDatapointsByLegend) {
            ctxDatapoints = plots[i].getDatapointsByLegend(selectedData);
            selectedObjs.push({
              plot: plots[i],
              ctxDatapoints : ctxDatapoints
            });
          } else {
            datapoints = plots[i].parent().selectAll('.v-datapoint')[0];
            
            for(var j = 0, jLen = datapoints.length; j < jLen; j++){
              if(datapoints[j].__data__ && datapoints[j].__data__.ctx){
                if(datapoints[j].__data__.ctx.path) {
                  itemData = datapoints[j].__data__.ctx.path;
                }else{
                  //Multi measures. For bubble or tagcloud.
                  itemData = datapoints[j].__data__.ctx[0].path;
                }
                
                //Check selectedData contains this ctx.
                isSame = true;
                for(var k in itemData){
                  if(selectedData.ctx.path[k] != undefined){
                    if(selectedData.ctx.path[k].length > 0){
                      if(_contains(selectedData.ctx.path[k], itemData[k]) === false){
                        isSame = false;
                      }
                    }else{
                      if(selectedData.ctx.path[k] !== itemData[k]){
                        isSame = false;
                      }
                    }
                  }
                }
                if(isSame === true){
                  //Push datapoint which has the same ctx with selectedData.
                  ctxDatapoints.push(datapoints[j]);
                }
              }
            }
          
            if(datapoints.length > 0){
              selectedObjs.push({
                plot: plots[i],
                ctxDatapoints : ctxDatapoints
              });
            }
          }
        }
      }

      //Deselected this series datapoint or not.
      if(lastSelected.length === 0){
        isDeselected = false;
      } else {
        var numOfDataPoints = 0;
        
        for(var i = 0, len = selectedObjs.length; i < len; i++){
          ctxDatapoints = selectedObjs[i].ctxDatapoints;
          var kLen = ctxDatapoints.length;
          numOfDataPoints += kLen;
          for(var k= 0; k < kLen; k++){
            if(_contains(lastSelected, ctxDatapoints[k]) === false){
              //One ctxDatapoint is not selected. Highlight this series datapoints.
              isDeselected = false;
              break;
            }
          }
        }
        if (isDeselected && !numOfDataPoints) {
          isDeselected = false;
        }
      }
      
      for(var i = 0, len = selectedObjs.length; i < len; i++){
        ctxDatapoints = selectedObjs[i].ctxDatapoints;  
        selectDatapoints = [], deselectDatapoints = [];
        for(var k= 0, kLen = ctxDatapoints.length; k < kLen; k++){
          var index = _contains(lastSelected, ctxDatapoints[k]);
          if(isDeselected){
            //deselected
            deselectDatapoints.push(ctxDatapoints[k]);
            lastSelected.splice(index, 1);
            deselectDatas.push(ctxDatapoints[k]);
          }else{
            //selected
            if(lastSelected.length == 0){
              clearPlots(true);
            }
            selectDatapoints.push(ctxDatapoints[k]);
            selectDatas.push(ctxDatapoints[k]);
            if(index === false){
              lastSelected.push(ctxDatapoints[k]);
            }
          }
        }
        
        //update highlight and unhighlight effect.
        if(deselectDatapoints.length > 0){
          selectedObjs[i].plot.unhighlight(deselectDatapoints, false, selectionMode);
        }
        if(selectDatapoints.length > 0){
          selectedObjs[i].plot.highlight(selectDatapoints, false, selectionMode);
        }
        
        if(isDeselected){
          //remove legend selected effect.
          eDispatch.deselectLegend(selectedData);
        }
        if(lastSelected.length === 0){
          clearPlots();
        }
      }
      
      //Send select/deselect event
      if(selectDatas.length > 0){
          fireSelectDataEvent(selectDatas);
        }
        
        if(deselectDatas.length > 0){
          fireDeselectDataEvent(deselectDatas);
        }
        
      return isDeselected;
    };
    
    //[2012/09/10 Christy] utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return i;
            }
        }
        return false;
    };
    
    selection.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return selection;
    };
    
    function hoverHandler(event) {
        //console.log('in hover of interaction');
      var target = event.data.target;
      var cp = event.data.point;
      var hoveredplots = [];
      for(var i =0, len = plots.length; i<len; i++){
        if(plots[i].parent() && pointInPlot(cp, plots[i])){
          hoveredplots.push(plots[i]);
        }
      }
      
      var isHovered = false;
      for(var i =0, len= lastHovered.length; i< len; i++){
        for(var j=0, jlen = hoveredplots.length; j< jlen; j++){
          if(lastHovered[i] == hoveredplots[j]){
            isHovered = true;
            break;
          }
        }
        if(isHovered == false && lastHovered[i].blurOut){
          lastHovered[i].blurOut();
        }
        isHovered = false;
      }
      
      for(var i=0, len= hoveredplots.length; i < len; i++){
        if(hoveredplots[i].hoverOnPoint){
            var rect = hoveredplots[i].parent().node().getBoundingClientRect();
            // var node = !eventLayer.empty() ? eventLayer.node() : g.node(), 
                // rect = node.getBoundingClientRect();
             hoveredplots[i].hoverOnPoint({
               x : cp.x - rect.left,
               y : cp.y - rect.top,
               target : target
             });
        }
      }
      
      lastHovered.splice(0, lastHovered.length);
      for(var i=0, len = hoveredplots.length; i<len;i++){
        lastHovered.push(hoveredplots[i]);
      }
    }

    
    function mouseOverHandler (event){
        var target = event.data.target, classname = target.getAttribute('class');
        if(isAxisLabelArea(classname))
        {
            //plot is the axis
            var plot = plotContainingTarget(target);
            if (plot && plot.mouseover)
            {
                plot.mouseover(target);
            }
        }
        else
        {
           if(classname != null && classname.indexOf('v-datalabel') != -1){
             target = target.__data__.dataShape;
           }else {
             target = isDatapoint(target);
             classname = target.getAttribute('class');
           }
           
           if(classname != null && (classname.indexOf('v-datapoint') != -1 || classname.indexOf('v-datalabel') != -1) ){
             
             var isHighlighted = false;
             for(var i=0, len = lastSelected.length; i < len; i++){
               if(target === lastSelected[i]){
                 isHighlighted = true;
                 break;
               }
             }
            
             if(lastSelected.length == 0 ){
              isHighlighted = true;
            }

            var plot = plotContainingTarget(target);
            if (plot) {
              lastOvered.push({
                   plot: plot,
                   target: target
                });

              if(plot.mouseover){
                plot.mouseover(target, isHighlighted);
              }
            }
           }
        }
    };
    
    function mouseOutHandler (event){
       var target = event.data.target, classname = target.getAttribute('class');
       if(isAxisLabelArea(classname))
       {
            //plot is the axis
            var plot = plotContainingTarget(target);
            if (plot && plot.mouseout)
            {
                plot.mouseout(target);
            }
       }
       else
       {
           if(classname != null && classname.indexOf('v-datalabel') != -1){
             target = target.__data__.dataShape;
           }else {
             target = isDatapoint(target);
             classname = target.getAttribute('class');
           }
     
           if(classname != null && (classname.indexOf('v-datapoint') != -1 || classname.indexOf('v-datalabel') != -1) ){
             
             var isHighlighted = false;
             for(var i=0, len = lastSelected.length; i < len; i++){
               if(target === lastSelected[i]){
                 isHighlighted = true;
                 break;
               }
             }
             
            if(lastSelected.length == 0 ){
              isHighlighted = true;
            }
             
            var plot = plotContainingTarget(target);

            for (var i = 0, len = lastOvered.length; i < len; i++) {
              var lastOver = lastOvered[i];

              // FIXME always invoke mouseout event handler on plot?
              if (lastOver.target === target/* && lastOver.plot === plot*/) {
                lastOvered.splice(i, 1);
                if (plot.mouseout) {
                  plot.mouseout(target, isHighlighted);
                }
                break;
              }
            }
           }
       }
    };

    function mouseDownHandler (event){
       var target = event.data.target, classname = target.getAttribute('class');
       if(isAxisLabelArea(classname))
       {
            //plot is the axis
            var plot = plotContainingTarget(target);
            if (plot && plot.mousedown)
            {
                plot.mousedown(target);
            }
       }
    }
    
    function mouseUpHandler (event) {
       var target = event.data.target, classname = target.getAttribute('class');
       //clean all label areas
       var iPlot;
       for(iPlot = 0; iPlot < plots.length; iPlot++)
       {
           if(plots[iPlot] && plots[iPlot].cleanLabelAreas)
           {
               plots[iPlot].cleanLabelAreas();
           }
       }       
       if(isAxisLabelArea(classname))
       {
            //plot is the axis
            var plot = plotContainingTarget(target);
            if (plot && plot.mouseup)
            {
                plot.mouseup(target);
            }
       }
    }
    
    var isDatapoint = function(node){
      if(node === g.node()){
        return node;
      }else{
        var classname = node.getAttribute('class');
        if(classname != null && classname.indexOf('v-datapoint') != -1){
          return node;
        }else{
          return isDatapoint(node.parentNode);
        }
      }
      
    };

    var ctxMatch = function(labelCtx, dataPointCtx)
    {
        var isMatch = false;
        if(dataPointCtx)
        {
            if(labelCtx.path.aa !== undefined)
            {
                if(labelCtx.path.aa === 0 && labelCtx.path.dii === dataPointCtx.path.dii_a1)
                {
                    isMatch = true;
                }
                else if(labelCtx.path.aa === 1 && labelCtx.path.dii === dataPointCtx.path.dii_a2)
                {
                    isMatch = true;
                }
            }
            else //MND or 3D bar
            {
                if(labelCtx.path.mg !== undefined)
                {
                    if(   labelCtx.path.mg === dataPointCtx.path.mg
                       && labelCtx.path.mi === dataPointCtx.path.mi )
                    {
                        if(labelCtx.path.dii_a2 !== undefined)
                        {
                            if(labelCtx.path.dii_a2 === dataPointCtx.path.dii_a2)
                            {
                                isMatch = true;
                            }
                        }
                        else
                        {
                            isMatch = true;
                        }
                    }
                }
                else
                {
                    if(labelCtx.path.dii_a1 === dataPointCtx.path.dii_a1)
                    {
                        isMatch = true;
                    }
                }
            }
        }
        return isMatch;
    }
    
    var findTargets = function(labelContext, allPoints)
    {
        var targets = [];
        var i;
        var j;
        for(i = 0; i < allPoints.length; i++)
        {
            if(allPoints[i])
            {
                for(j = 0; j < allPoints[i].length; j++)
                {
                    if(allPoints[i][j].__data__.ctx instanceof Array)
                    {
                        var index;
                        for(index = 0; index < allPoints[i][j].__data__.ctx.length; index++)
                        {
                            if(ctxMatch(labelContext, allPoints[i][j].__data__.ctx[index]))
                            {
                                targets.push(allPoints[i][j]);
                                break;
                            }
                        }
                    }
                    else
                    {
                        if(ctxMatch(labelContext, allPoints[i][j].__data__.ctx))
                        {
                            targets.push(allPoints[i][j]);
                        }
                    }
                }
            }
        }    
        return targets;
    }

    //label selection functions
    var labelSelectedTargets = function(node)
    {
        var targets = [];
        if(node)
        {
            var allPoints = [];
            var i;    
            //plot is the axis
            var axisPlot = plotContainingTarget(node);
            var singleChart = axisPlot.parent().node().parentNode;

            allPoints = d3.select(singleChart).selectAll('.v-datapoint');


            var labelContexts = node.labelContexts;
            //find it
            if(labelContexts && labelContexts.length > 0)
            {
                for(i = 0; i < labelContexts.length; i++)
                {
                    if(labelContexts[i])
                    {
                        var tempTargets;
                        tempTargets = findTargets(labelContexts[i], allPoints);
                        targets = targets.concat(tempTargets);
                    }
                }
            }
        }
        return targets;
    };

    //handle label selection
    var selectMultiObjs = function(selectedTargets, lastSelected)
    {
        var returnObj = {};
        returnObj.lastSelectedObjs = lastSelected;
        returnObj.selectObjs = [];
        returnObj.deselectObjs = [];
        
        var isAllTargetsSelected = true;
        var unselectedTargets = [];

        for(var iTarget = 0; iTarget < selectedTargets.length; iTarget++)
        {
            var isSelected = false;
            for(var iLastSelected = 0; iLastSelected < lastSelected.length; iLastSelected++)
            {
                if(selectedTargets[iTarget] === lastSelected[iLastSelected])
                {
                    isSelected = true;
                    break;
                }
            }
            if(!isSelected)
            {
                isAllTargetsSelected = false;
                unselectedTargets.push(selectedTargets[iTarget]);
            }
        }

        //if all the selectedTargets are already selected, we should deselect them all
        if(isAllTargetsSelected)
        {
            //build deselected objects
            returnObj.deselectObjs = selectedTargets;
            //build selected objects
            returnObj.selectObjs = [];
            for(var iLastSelected = 0; iLastSelected < lastSelected.length; iLastSelected++)
            {
                var isTarget = false;
                for(var iTarget = 0; iTarget < selectedTargets.length; iTarget++)
                {
                    if(lastSelected[iLastSelected] === selectedTargets[iTarget])
                    {
                        isTarget = true;
                        break;
                    }
                }
                if(!isTarget)
                {
                    returnObj.selectObjs.push(lastSelected[iLastSelected]);
                }
            }
        }
        else//we should select all "selectedTargets"
        {
            //build deselected objects
            returnObj.deselectObjs = [];
            //build selected objects
            returnObj.selectObjs = unselectedTargets.concat(lastSelected);
        }

        //update lastSelected
        returnObj.lastSelectedObjs = returnObj.selectObjs;

        //update UI
        for(var iHi = 0; iHi < returnObj.deselectObjs.length; iHi++)
        {
            unhighlightTarget(returnObj.deselectObjs[iHi]);
        }

        //if all the itemas are unselected, we have to highlight them all
        if(returnObj.selectObjs.length <= 0)
        {
            clearPlots();
        }
        else
        {
            clearPlots(true);
            //unhighlightTarget(returnObj.deselectObjs);
            for(var iHi = 0; iHi < returnObj.selectObjs.length; iHi++)
            {
                highlightTarget(returnObj.selectObjs[iHi]);
            }
        }

        return returnObj;
    };

    var isAxisLabelArea = function(classname)
    {
        var isInAxisLabelArea = false;
        if(classname && classname.indexOf('v-labelarea') >= 0)//find it
        {
          if(selectionMode !== 'single')
          {
              //do not have label selection in 'single'
              isInAxisLabelArea = true;
          }
        }
        return isInAxisLabelArea;
    }

    function findTargetByDatalabel (node){
        if(node === g.node()){
          return node;
        }else{
          var classname = node.getAttribute('class');
          if(classname != null && classname.indexOf('v-datalabel') != -1){
            return node;
          }else{
            return findTargetByDatalabel(node.parentNode);
          }
        }
    }
    function clickHandler(event) {
        //console.log("in highlightHandler of interaction");
       
      if(selectionMode !== 'none'){
          
          var target = event.data.target,  classname = target.getAttribute('class'), selectDatas = [], deselectDatas = [];
          var isInAxisLabelArea = isAxisLabelArea(classname);
          
          if(!isInAxisLabelArea){
              var node = findTargetByDatalabel(target);
              classname =  node.getAttribute('class');
              
              if( classname != null && classname.indexOf('v-datalabel') != -1) {
                  target = target.__data__.dataShape;
                  classname = target.getAttribute('class');
                }else {
                  target = isDatapoint(target);
                  classname = target.getAttribute('class');
                }
          }
          
          if(isInAxisLabelArea )
          { 
              var selectedTargets = labelSelectedTargets(target);
              var res = selectMultiObjs(selectedTargets, lastSelected);
            
              //shoue update lastSelected, selectDatas, deselectDatas
              lastSelected = res.lastSelectedObjs;
              selectDatas = res.selectObjs;
              deselectDatas = res.deselectObjs;
          }
          
            //if  the click is on eventLayer, deselect all
          else if( classname == null || 
             (classname.indexOf('v-datapoint') == -1 && classname.indexOf('v-datalabel') == -1) ) 
          {
            unhighlightTarget(lastSelected, false);

            clearPlots();
            deselectDatas = deselectDatas.concat(lastSelected);
            lastSelected.splice(0, lastSelected.length);
            
            //[2012/09/11 Christy] deselect all legend items.
            eDispatch.deselectLegend();
          }
          else
          {
            var isHighlighted = false;
            for(var i =0, len = lastSelected.length; i<len; i++){
              if(target == lastSelected[i]){
                isHighlighted = true;
                break;
              }
            }
            if(lastSelected.length == 0) { //it means the isHighlighted false
              
              clearPlots(true);
              highlightTarget(target);
              lastSelected.push(target);
              
              selectDatas.push(target);
            } else {
              if(isHighlighted){
                if(selectionMode == 'single'){
                  unhighlightTarget(lastSelected[0]);
                  
                  clearPlots();
                  lastSelected.splice(0, lastSelected.length);
                  
                  deselectDatas.push(target);
                }else{
                  var changeSelected = lastSelected.splice((i),1);
                  deselectDatas = deselectDatas.concat(changeSelected);
                  
                  if(lastSelected.length == 0){
                    unhighlightTarget(target);
                    clearPlots();
                  }else{
                    unhighlightTarget(target);
                    deselectDatas.push(target);
                  }
                }
              } else {
                if(selectionMode == 'single'){
                  unhighlightTarget(lastSelected[0]);
                  deselectDatas.push(lastSelected[0]);
                  
                  highlightTarget(target);
                  selectDatas.push(target);
                  
                  lastSelected[0] = target;
                }else{
                  
                  selectDatas.push(target);
                  highlightTarget(target);
                  
                  lastSelected.push(target);
                }
              }
            }
          }
          
          if(selectDatas.length > 0){
            fireSelectDataEvent(selectDatas);
          }
          
          if(deselectDatas.length > 0){
            fireDeselectDataEvent(deselectDatas);
          }
        }
    }
    
    function mouseLeaveHandler(evt){
        //clean all label areas
        var iPlot;
        for(iPlot = 0; iPlot < plots.length; iPlot++)
        {
           if(plots[iPlot] && plots[iPlot].cleanLabelAreas)
           {
               plots[iPlot].cleanLabelAreas();
           }
        }    
        for(var i=0, len = lastHovered.length; i <len; i++){
            if(lastHovered[i].blurOut){
              lastHovered[i].blurOut();
            }
          }
          
          lastHovered.splice(0, lastHovered.length);
    }
    
    function fireSelectDataEvent(selectedShapes){
      var selectData = [];
      for(var i=0, len= selectedShapes.length; i < len; i++){
        var tarData = [], value = selectedShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen= value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: selectedShapes[i].__data__.val,
            ctx: selectedShapes[i].__data__.ctx
          });
        }
        selectData.push({
          target: selectedShapes[i],
          data: tarData
        });
      }
      
      eDispatch.selectData({
        name: Constants.Module.Event.SelectData.name,
        data: selectData
      });
    };
    
    function fireDeselectDataEvent(deselectShapes){
      var deselectData = [];
      for(var i=0, len= deselectShapes.length; i < len; i++){
        var tarData = [], value = deselectShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen=value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: deselectShapes[i].__data__.val,
            ctx: deselectShapes[i].__data__.ctx
          });
        }
        deselectData.push({
          target: deselectShapes[i],
          data: tarData
        });
      }
      
      eDispatch.deselectData({
        name: Constants.Module.Event.DeSelectData.name,
        data: deselectData
      });
    };
    
    function parseOptions(){
      selectionMode = props.selectability.mode;
      holdSelection = props.holdSelection;
      preserveSelectionWhenDragging = props.preserveSelectionWhenDragging;

    }
    selection.properties = function(_){
      if(!arguments.length){
        return props;
      }
      Objects.extend(true, props, _);
      parseOptions();
      if (monitor) {
        monitor.properties(props);
      }
    };
    
    selection.module = function(_){
      if(!arguments.length){
        return m;
      }
      reset();//clear flag to have another chance to register event
      m = _, g = m.parent();
      return selection;
    };
    
    selection.destroy = function(){
      monitor.destroy(g);
    };
    
    return selection;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.controller.interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Base',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.controller.interaction',
    'name' : 'selection',
    'base' : "sap.viz.modules.controller.base",
    'description': 'Settings for the interactions of the chart.',
    'properties' : {
      'selectability' : {
        'name' : 'selectability',
        'supportedValueType': 'Object',
        'supportedValues': {
          mode: {
             'name' : 'mode',
            'supportedValueType' : 'List',
            'supportedValues' : [ 'single', 'multiple', 'none' ],
            'defaultValue' : 'multiple',
            'description' : 'Set the selection mode. Single means you only can select one at the same time. Multiple means you can select several ones. None means you can not select anything. '
          },
          lassoWithCtrlKey: {
            name:"lassoWithCtrlKey",
            supportedValueType:"Boolean",
            defaultValue: false,
            description: "Set whether lasso selection needs ctrl key pressed.",
            isExported: false
          }
        },
        'description': 'Settings for selectability.'
      },
      supportedEventNames:{
        name: "supportedEventNames",
        supportedValueType: "StringArray",
        supportedValues: ['mouseup','mousedown','mousemove','mouseout','mouseover','touchstart'],
        defaultValue:['mouseup', 'mousedown', 'mousemove', 'mouseout', 'mouseover','touchstart'],
        description: "Set supported event names.",
        isExported: false
      },
      enableMouseMove:{
        name: "enableMouseMove",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse move is enabled.",
        isExported: false
     },
      enableMouseOver:{
        name: "enableMouseOver",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse over is enabled.",
        isExported: false
      },
      enableMouseOut:{
        name: "enableMouseOut",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether mouse out is enabled.",
        isExported: false
      },
      supportLassoEvent:{
        name: "supportLassoEvent",
        supportedValueType: "Boolean",
        defaultValue:true,
        description: "Set whether support lasso event is enabled.",
        isExported: false
      },
      holdSelection:{
        name: "holdSelection",
        supportedValueType: "Boolean",
        defaultValue:false,
        description: "Set whether hold selection is enabled.",
        isExported: false
      },
      preserveSelectionWhenDragging:{
        name: "preserveSelectionWhenDragging",
        supportedValueType: "Boolean",
        defaultValue:false,
        description: "Set whether preserve selection when dragging is enabled.",
        isExported: false
      }
    },
    'fn' : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.format.XCFormat',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
}
],
function Setup(Objects) {
	
	var NF = {
			format: function(value){
				return value;
			},
			locale: function(){
				
			},
			DEFAULT_FORMAT_DATE_TIME : '',
			DEFAULT_FORMAT_TIME : '',
			DEFAULT_FORMAT_SHORT_DATE : '',
			DEFAULT_FORMAT_LONG_DATE : '',
			DEFAULT_FORMAT_NUMBER : '',
			DEFAULT_FORMAT_BOOLEAN : ''
	}, snf = null, locale = 'en';
	
	if(sap && sap.common && sap.common.globalization && sap.common.globalization.NumericFormatManager){
		snf = sap.common.globalization.NumericFormatManager;
		
		NF = Objects.extend( true, NF, {
			
			format : function(value, pattern){
				return snf.formatToText(value, pattern, true); // we always try to convert number to string
			},
			
			locale : function(_){
				if(!arguments.length){
					return locale;
				}
				locale = _;
				snf.setPVL(locale);
				
				//reset default format string
				NF.DEFAULT_FORMAT_DATE_TIME = snf.DEFAULT_FORMAT_DATE_TIME;
				NF.DEFAULT_FORMAT_TIME = snf.DEFAULT_FORMAT_TIME;
				NF.DEFAULT_FORMAT_SHORT_DATE = snf.DEFAULT_FORMAT_SHORT_DATE;
				NF.DEFAULT_FORMAT_LONG_DATE = snf.DEFAULT_FORMAT_LONG_DATE;
				NF.DEFAULT_FORMAT_NUMBER = snf.DEFAULT_FORMAT_NUMBER;
				NF.DEFAULT_FORMAT_BOOLEAN = snf.DEFAULT_FORMAT_BOOLEAN;
			},
			
			DEFAULT_FORMAT_DATE_TIME : snf.DEFAULT_FORMAT_DATE_TIME,
			DEFAULT_FORMAT_TIME : snf.DEFAULT_FORMAT_TIME,
			DEFAULT_FORMAT_SHORT_DATE : snf.DEFAULT_FORMAT_SHORT_DATE,
			DEFAULT_FORMAT_LONG_DATE : snf.DEFAULT_FORMAT_LONG_DATE,
			DEFAULT_FORMAT_NUMBER : snf.DEFAULT_FORMAT_NUMBER,
			DEFAULT_FORMAT_BOOLEAN : snf.DEFAULT_FORMAT_BOOLEAN
			
		});
	}
	
	return NF;
});sap.riv.module(
{
  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.XCFormat',
  version : '4.0.2'
},
{  qname : 'sap.viz.Locale',
  version : '4.0.2'
}
],
function Setup(TypeUtil, XCFormat, Locale) {

  var locale = 'en', formatUtil = XCFormat, props = null;
  
  var FM = 
     /** @lends sap.viz.format.FormatManager */
  {
       /**
           * @constructs
          */
      constructor : function(){
        return;
      },
      
      /**
           * Apply a locale
           * 
           * @param {String}
           *       locale
           * 
           * @returns {Object} {@link sap.viz.format.FormatManager}
           */
      apply : function(_){
        locale = _;
        formatUtil.locale(locale);
      },
      
      /**
           * format a string
           * 
           * @param {String}
           *       value
           * 
           * @param {String}
           *       pattern
           * 
           * @returns {Object} {@link sap.viz.format.FormatManager}
           */
      format : function(value, pattern){
        return formatUtil.format(value, pattern);
      },
      
      /**
           * set/get format function
           * 
           * @param {Function}
           *       func
           * 
           * @returns {Object} {@link sap.viz.format.FormatManager}
           */
      formatFunc : function(_){
        if(!arguments.length){
          return formatUtil;
        }
        formatUtil = _;
      },
      
      /**
         * default data time format. It will changed by locale. 
        */
      DEFAULT_FORMAT_DATE_TIME : formatUtil.DEFAULT_FORMAT_DATE_TIME,
      /**
         * default time format. It will changed by locale. 
        */
      DEFAULT_FORMAT_TIME : formatUtil.DEFAULT_FORMAT_TIME,
      /**
         * default short data format. It will changed by locale. 
        */
      DEFAULT_FORMAT_SHORT_DATE : formatUtil.DEFAULT_FORMAT_SHORT_DATE,
      /**
         * default long data format. It will changed by locale. 
        */
      DEFAULT_FORMAT_LONG_DATE : formatUtil.DEFAULT_FORMAT_LONG_DATE,
      /**
         * default number format. It will changed by locale. 
        */
      DEFAULT_FORMAT_NUMBER : formatUtil.DEFAULT_FORMAT_NUMBER,
      /**
         * default boolean format. It will changed by locale. 
        */
      DEFAULT_FORMAT_BOOLEAN : formatUtil.DEFAULT_FORMAT_BOOLEAN
  };
  
  Locale.addListener({
    fn:function(locale){
      FM.apply(locale);
    },
    scope: FM
  });
  
  return FM;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tooltip',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
}
],
function Setup(Dispatch, Objects, formatManager, TypeUtils, ObjectUtils, langManager) {
  var tooltip =  function(manifest, ctx) {
    var imageInfo =
    {
        imageMode: false,
        imagePalette: [],
        radio: 1
    };

    var _display = {
      singleMeasure : {
        label : {
          font : 'bold 11px sans-serif',
          color : '#333333'
        },
        value : {
          font : 'bold 14px sans-serif',
          color : '#333333'
        },
        padding : {
          vertical : 9,
          horizontal : 10
        }
      },
      multipleMeasure : {
        label : {
          font :  "12px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        value : {
          font : "12px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        padding : {
          vertical : 8,
          horizontal : 10,
          inline : 6,
          symbolGap : 7,
          defaultSpace : 8
        }
      },
      title : {
        color : '#333333',
        font : "bold 13px 'Open Sans', Arial, Helvetica, sans-serif",
        formatString : ''
      },
      footer : {
        label : {
          font :  "bold 10.5px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        value : {
          font : "10.5px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        padding : {
          inline : 6
        }
      },
      valueFormat : [],
      labelFormat : [],
      maxDimensionLabelWidth : 150,
      maxMeasureLabelWidth : 80
    };

    var _shapeLayout = {
      padding : 5,
      radius : 4,
      markerWidth : 12,
      markerHeight : 8,
      borderWidth : 1,
      separationLineBorderWidth : 1
    };

    var _defaultToolTipColors = {
      backgroundColor : '#ffffff',
      borderColor : '#D8D8D8',
      separationLineColor : [ '#ffffff', '#8a8a8a', '#ffffff' ],
      separationLineSingleColor : '#D8D8D8',
      guideLineColor : '#D8D8D8'
    };

    var _svgPathCommand = {
      arcA : 'A',
      lineToA : 'L',
      moveToA : 'M',
      closePath: 'z'
    };
    
    var _symbol = {
      symbolSize : 8,
      hasSymbol : false
    };
    
    var _symbolClassName = 'tooltipsymbol', _paragraphTitleClassName = 'v-body-title tooltipparagraphtitle', _paragraphLabelTextClassName = 'v-body-label tooltipparagraphlabel', _paragraphValueTextClassName = 'v-body-value tooltipparagraphvalue', _footerLabelClassName = 'v-footer-label tooltipfooterlabel', _footerValueClassName = 'v-footer-value tooltipfootervalue', _tooltipBackgroundClassName = 'v-background', _tooltipSeparationLineClassName = 'v-separationline';
    var _cssName = {
        bodyName : 'v-body',
        footerName : 'v-footer'
    };
    
    var vis = null, gWrapper = null;
    var tooltipWidth = 0, tooltipHeight = 0, textMaxWidth = 0, effectManager = ctx.effectManager,
    zone = {
        width : 200,
        height : 100
    },
    
    plotArea = {
        width: 160,
        height: 70,
        x: 0,
        y: 0
    },
    
    _properties = {},
    
    //tooltip border marker orientation
    _orientation = null,

    //variables are for tooltip content truncation case
    _truncationParameter = {
      isTruncated : false,
      currentFooterIndex : -1,
      currentBodyIndex : -1,
      defaultValue : '...',
      font : 'bold 20px Arial',
      color : '#000000'
    },
    
    _tooltipFinalSize = {
      tooltipBodyTitleHeight : 0,
      tooltipBodyLineHeight : 0,
      tooltipFooterLineHeight : 0
    };
    
    var defaultString = langManager.get('IDS_ISNOVALUE');

    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };
    
    function clearGlobalValues() {
      _truncationParameter.isTruncated = false;
      _truncationParameter.currentFooterIndex = -1;
      _truncationParameter.currentBodyIndex = -1;
      _tooltipFinalSize.tooltipBodyTitleHeight = 0;
      _tooltipFinalSize.tooltipBodyLineHeight = 0;
      _tooltipFinalSize.tooltipFooterLineHeight = 0;
    }
    
    function tooltip(selection) {
        if (selection !== null && selection !== undefined) {
            vis = d3.select(selection).append('svg').style('position',
                    'absolute').attr('pointer-events', 'none').attr(
                    'width', '0').attr('height', 0).attr('class',
                    'v-m-tooltip');

        }
        // In first view, we should make tooltip invisible.
        tooltip.hideTooltip();
        return tooltip;
    }

    function getTooltipHeightV2(vis, data) {
      var bodyInline = _display.multipleMeasure.padding.inline, 
        multipleVertical = _display.multipleMeasure.padding.vertical,
        multipleLabelFont = _display.multipleMeasure.label.font,
        multipleValueFont = _display.multipleMeasure.value.font,
        footerInline = _display.footer.padding.inline,
        footerLabelFont = _display.footer.label.font,
        titleFont = _display.title.font;
      var tooltipHeight = 0, tooltipBody = data.body, tooltipFooter = data.footer;
       
        
        //First rule, make sure the content contains the first paragraph title and footer if the tooltip height is beyond zone height.
        if (tooltipBody && tooltipBody.length > 0) {
            tooltipHeight = multipleVertical;
          
            if (tooltipFooter && tooltipFooter.length > 0) {
              var firstPlaceHolderHeight = 0;
              if (tooltipBody[0].name !== null) {
                firstPlaceHolderHeight =  getTextBox(vis, tooltipBody[0].name,  titleFont).height + bodyInline + getTextBox(vis, _truncationParameter.defaultValue,  _truncationParameter.font).height;
              }
              
              if (tooltipFooter[0].label !== null) {
               //var footerlabelBox1 = getTextBox(vis, tooltipFooter[0].label, footerLabelFont);
                _tooltipFinalSize.tooltipFooterLineHeight = getTextBox(vis, tooltipFooter[0].label, footerLabelFont).height;
                
                tooltipHeight += multipleVertical * 3;
                
                tooltipHeight += (tooltipFooter.length * _tooltipFinalSize.tooltipFooterLineHeight + footerInline * (tooltipFooter.length - 1));
            
                tooltipHeight += firstPlaceHolderHeight;
                if (tooltipHeight > zone.height) {
                  _truncationParameter.isTruncated = true;
                  _truncationParameter.currentBodyIndex = 0;
                  
                  var num1 = 0;
                  while (tooltipHeight > zone.height) {
                    tooltipHeight -= _tooltipFinalSize.tooltipFooterLineHeight;
                    tooltipHeight -= footerInline;
                    num1++;
                  }
                  _truncationParameter.currentFooterIndex = tooltipFooter.length - num1 - 1;
                  
                  return tooltipHeight;
                }
                
                tooltipHeight -= firstPlaceHolderHeight;
              }
            } else {
              tooltipHeight += multipleVertical;
            }
            
            var paragraphTitleNum = 0, paragraphLineNum = 0, titleValue = '';
            for (var i = 0; i < tooltipBody.length; i++) {
              if (titleValue !== '' && tooltipBody[i].name !== null && tooltipBody[i].name !== '') {
                titleValue = tooltipBody[i].name;
              }
              paragraphTitleNum++;
              paragraphLineNum += tooltipBody[i].val.length;
            }
            
            //if (tooltipBody[0].name !== null) {
              //tooltipHeight += (paragraphTitleNum * getTextBox(vis, tooltipBody[0].name,  titleFont).height);
            //}
            
            var maxValue = 0;
            if (tooltipBody[0].val.length > 0) {
              if (tooltipBody[0].val[0].label !== null) {
                maxValue = getTextBox(vis, tooltipBody[0].val[0].label,  multipleLabelFont).height;
              }
              
              if (tooltipBody[0].val[0].value !== null) {
                var valueHeight = getTextBox(vis, tooltipBody[0].val[0].value,  multipleValueFont).height;
                if (valueHeight > maxValue) {
                  maxValue = valueHeight;
                }
              }
              
              tooltipHeight += (paragraphLineNum * maxValue);
            }
            
            _tooltipFinalSize.tooltipBodyLineHeight = maxValue;
            if (titleValue !== '') {
              _tooltipFinalSize.tooltipBodyTitleHeight = getTextBox(vis, titleValue,  titleFont).height;
            } else {
              _tooltipFinalSize.tooltipBodyTitleHeight = maxValue;
            }
            tooltipHeight += (paragraphTitleNum * _tooltipFinalSize.tooltipBodyTitleHeight);
            tooltipHeight += (bodyInline * (paragraphTitleNum + paragraphLineNum - 1));
          
            if (tooltipHeight > zone.height) {
              _truncationParameter.isTruncated = true;
              
              var num2 = 0;
              while (tooltipHeight > zone.height) {
                tooltipHeight -= maxValue;
                tooltipHeight -= bodyInline;
                num2++;
              }
              
              _truncationParameter.currentBodyIndex = paragraphTitleNum + paragraphLineNum - num2 - 2;
              var defaultValueBox1 = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
              
              return tooltipHeight + (defaultValueBox1.height - maxValue);
            }
        } else  if (tooltipFooter && tooltipFooter.length > 0) {
          if (tooltipFooter[0].label !== null) {
            var footerlabelBox2= getTextBox(vis, tooltipFooter[0].label, footerLabelFont);
            
            tooltipHeight += multipleVertical;
            
            tooltipHeight += (tooltipFooter.length * footerlabelBox2.height + footerInline * (tooltipFooter.length - 1));
        
              if (tooltipHeight > zone.height) {
                _truncationParameter.isTruncated = true;
                var num = 0;
                while (tooltipHeight > zone.height) {
                  tooltipHeight -= footerlabelBox2.height;
                  tooltipHeight -= footerInline;
                  num++;
                }
                
                _truncationParameter.currentFooterIndex = tooltipFooter.length - num - 1;
                var defaultValueBox2 = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                
                return tooltipHeight + (defaultValueBox2.height - footerlabelBox2.height);
              }
          }
        }    
        
        return tooltipHeight;
    }
        
    function getTooltipWidthV2(vis, data) {
        var tooltipWidth = 0, multipleHorizontal = _display.multipleMeasure.padding.horizontal, symbolGap = _display.multipleMeasure.padding.symbolGap, defaultSpace = _display.multipleMeasure.padding.defaultSpace, symbolSize = _symbol.symbolSize;
        
        tooltipWidth = textMaxWidth + (multipleHorizontal * 2) + defaultSpace;
        if (_symbol.hasSymbol) {
          tooltipWidth += symbolSize + symbolGap;
        }
        return tooltipWidth;
    }
        
    function getTextMaxWidthV2(vis, data) {
      var maxValue = 0, tmpWidth = 0, tooltipBody = data.body, tooltipFooter = data.footer;
      
      if (tooltipBody) {
        for (var i = 0; i < tooltipBody.length; i++) {
          if (tooltipBody[i].name !== null) {
            tmpWidth = getTextBox(vis, tooltipBody[i].name, _display.title.font).width;
            if (tmpWidth > maxValue) {
              maxValue = tmpWidth;
            }
          }
      
          var paragraphValue = tooltipBody[i].val;
          if (paragraphValue) {
            if (paragraphValue.length === 1 && (paragraphValue[0].value !== null)) {
              var valueBox = getTextBox(vis, paragraphValue[0].value, _display.multipleMeasure.value.font);
              _symbol.symbolSize = valueBox.height * 0.8;
              _symbol.hasSymbol = true;
              if (valueBox.width > maxValue) {
                maxValue = valueBox.width;
              }
            } else if (paragraphValue.length > 1) {
              if (paragraphValue[0].label !== null) {
                if (paragraphValue[0].shape !== null && paragraphValue[0].color !== null) {
                  _symbol.symbolSize = getTextBox(vis, paragraphValue[0].label, _display.multipleMeasure.label.font).height * 0.8;
                  _symbol.hasSymbol = true;
                }
              }
              
              if (paragraphValue[0].value !== null) {
                if (paragraphValue[0].shape !== null && paragraphValue[0].color !== null) {
                  _symbol.symbolSize = getTextBox(vis, paragraphValue[0].value, _display.multipleMeasure.value.font).height * 0.8;
                  _symbol.hasSymbol = true;
                }               
              }
              
              for (var j = 0; j < paragraphValue.length; j++) {
                if ((paragraphValue[j].label !== null) && (paragraphValue[j].value !== null)) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].label, _display.multipleMeasure.label.font).width + getTextBox(vis, paragraphValue[j].value, _display.multipleMeasure.value.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }
                } else if (paragraphValue[j].label !== null) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].label, _display.multipleMeasure.label.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }                    
                } else if (paragraphValue[j].value !== null) {
                  tmpWidth = getTextBox(vis, paragraphValue[j].value, _display.multipleMeasure.value.font).width;
                  if (tmpWidth > maxValue) {
                    maxValue = tmpWidth;
                  }                    
                }
              }
            }
          }
        }
      }
      
      if (tooltipFooter) {
        for (var m = 0; m < tooltipFooter.length; m++) {
          var item = tooltipFooter[m];
          
          if (item.label && item.value) {
            tmpWidth = getTextBox(vis, item.label, _display.footer.label.font).width + getTextBox(vis, item.value, _display.footer.value.font).width;
            if (tmpWidth > maxValue) {
              maxValue = tmpWidth;
            }
          }
        }
      }
    
      return maxValue;
    }
        
    function getSymbolPath(type, size){
      var symbolPath = '', r, rx, ry; 
      switch(type){
        case 'circle' :
          r = size / 2;
          symbolPath = "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
          break;
        case "cross" :
          rx = size / 6;
          ry = size / 6;
          symbolPath = "M" + -3 * rx + "," + -ry + "H" + -rx + "V" + -3 * ry + "H" + rx + "V" + -ry + "H" + 3 * rx + "V" + ry + "H" + rx + "V" + 3 * ry + "H" + -rx + "V" + ry + "H" + -3 * rx + "Z";
          break;
        case "triangle-down" ://TODO: remove duplicate
        case "triangleDown" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
          break;
        case "triangle-up" ://TODO: remove duplicate
        case "triangleUp" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
          break;
        case "diamond" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
          break;
        case 'squareWithRadius' : 
          r = size / 2;
          var radius = r - 3;
          symbolPath = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r + "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
          break;
        case 'square' :
          r = size / 2;
          symbolPath = "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
          break;
        case "triangle-left" ://TODO: remove duplicate
        case "triangleLeft" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + -rx + ",0L" + rx + "," + ry + " " + rx + "," + -ry + "Z";
          break;
        case "triangle-right" ://TODO: remove duplicate
        case "triangleRight" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + rx + ",0L" + -rx + "," + ry + " " + -rx + "," + -ry + "Z";
          break;
        case "intersection" :
          rx = size / 2;
          ry = size / 2;
          symbolPath = "M" + rx + ',' + ry + ' ' +  rx/3 + ',0 ' + rx + ',' + -ry + ' ' + rx / 2 + ',' + -ry + ' 0,' + -ry/3 + ' ' + -rx / 2 + ',' + -ry + ' ' + -rx + ',' + -ry + ' ' + -rx/3 + ',0 ' + -rx + ',' + ry + ' ' + -rx/2 + ',' + ry + ' 0,' + ry/3 + ' ' + rx/2 + ',' + ry;
          break;
      }
      
      return symbolPath;
    }

    var getImageURL = function(index)
    {
        var imageURL = "";

        var imageURLNumber = imageInfo.imagePalette.length;
        if(imageURLNumber > 0)
        {
            imageURL = imageInfo.imagePalette[index%imageURLNumber];
        }

        return imageURL;
    };
      
    function drawSymbolV2(index, vis, pos, symbolType, color, symbolSize, className) {
      if(!imageInfo.imageMode)
      {
          var parameter = {
            drawingEffect: _properties.drawingEffect,
            fillColor : color,
            graphType : symbolType,
            direction : 'vertical'
          };
            
          var fillId =  effectManager.register(parameter);
          vis.append('path').attr('d', getSymbolPath(symbolType, symbolSize)).attr('transform', 'translate(' + pos.x + ',' + pos.y + ')').attr('fill', fillId).attr('class', className);
      }
      else
      {
            var gImage = vis.append('g').attr('transform', 'translate(' + (pos.x - symbolSize/2) + ',' + (pos.y - symbolSize/2) + ')');

            var imageObjs = gImage.select("image");
            if(imageObjs.empty())
            {
                imageObjs = gImage.append("image");
            }

            imageObjs.attr("xlink:xlink:href", getImageURL(index))
                .attr("width",symbolSize)
                .attr("height",symbolSize);
      }
    } 
        
    function drawContentV2(vis, pos, data, markerPos) {
      //Because yStart starts at a offset radius in function drawShape, to substract radius here.
      var xStart = pos.x, yStart = pos.y - _shapeLayout.radius / 2;
      //var markerPos = properties.orientation;
      var markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
      
      if (markerPos === 'left') {
        xStart += markerHeight;
      }
      if (markerPos === 'top') {
        yStart += markerHeight;
      }
  
      var multipleHorizontal = _display.multipleMeasure.padding.horizontal, multipleVertical = _display.multipleMeasure.padding.vertical, multipleInline = _display.multipleMeasure.padding.inline, symbolGap = _display.multipleMeasure.padding.symbolGap, 
          defaultSpace = _display.multipleMeasure.padding.defaultSpace;
      var symbolSize = _symbol.symbolSize, hasSymbol = _symbol.hasSymbol;
      var titleColor = _display.title.color, titleFont = _display.title.font;
      var multipleLabelFont = _display.multipleMeasure.label.font, multipleLabelColor = _display.multipleMeasure.label.color, 
          singleLabelFont = _display.singleMeasure.label.font, singleLabelColor = _display.singleMeasure.label.color;
      var multipleValueFont = _display.multipleMeasure.value.font, multipleValueColor = _display.multipleMeasure.value.color, 
          singleValueFont = _display.singleMeasure.value.font, singleValueColor = _display.singleMeasure.value.color;
      var footerInline = _display.footer.padding.inline, footerLabelFont = _display.footer.label.font, 
          footerValueFont = _display.footer.value.font, footerLabelColor = _display.footer.label.color, 
          footerValueColor = _display.footer.value.color;
      var tooltipBody = data.body, tooltipFooter = data.footer;
      var currentBodyIndex = -1, currentFooterIndex = -1;
      var rowPos = {
                x : 0,
                y : 0
            };
        
      var isBreak = false;
        
        if (tooltipBody) {
          var gBody = vis.append('g').attr('class', 'v-body');
          for (var i = 0; i < tooltipBody.length; i++) {
            
            if (isBreak) {
              break;
            }
            
            var paragraph = tooltipBody[i];
            if (paragraph.name !== null) {
              //var titleBox = getTextBox(gBody, paragraph.name, titleFont);
              var titleHeight = _tooltipFinalSize.tooltipBodyTitleHeight;          
              rowPos.x = xStart + multipleHorizontal;
              if (i === 0) {
                rowPos.y = yStart + titleHeight + multipleVertical;
              }
              else {
                rowPos.y += (yStart + titleHeight + multipleInline);
              }
              
              drawTextV2(gBody, rowPos, paragraph.name, titleColor, titleFont, _paragraphTitleClassName);
              currentBodyIndex++;
              if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                var valueBox1 = getTextBox(gBody, _truncationParameter.defaultValue, _truncationParameter.font);
                rowPos.x = xStart + (tooltipWidth - valueBox1.width - multipleHorizontal);
                rowPos.y += (multipleInline + valueBox1.height);
                drawTextV2(gBody, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);    
                break;
              }
            }
            
            if (paragraph.val.length > 0) {
              
              if (paragraph.val.length > 1) {
                var labelBox = null, valueBox = null, offset = null;
                for (var j = 0; j < paragraph.val.length; j++) {
                  
                  if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].label !== null) && (paragraph.val[j].value !== null)) {                     
                    labelBox = getTextBox(gBody, paragraph.val[j].label, multipleLabelFont);
                    valueBox = getTextBox(gBody, paragraph.val[j].value, multipleValueFont);
                    offset = (labelBox.height >= valueBox.height) ? labelBox.height: valueBox.height;
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + offset);
                    //drawSymbol
                    drawSymbolV2(i * paragraph.val.length + j, gBody, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape,  paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize + symbolGap;
                    drawTextV2(gBody, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
                    
                    rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                    drawTextV2(gBody, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);                          
                  } else if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].label !== null)) {
                    labelBox = getTextBox(gBody, paragraph.val[j].label, multipleLabelFont);
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + labelBox.height);
                    //drawSymbol
                    drawSymbolV2(i * paragraph.val.length + j, gBody, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape, paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + multipleHorizontal + symbolSize + symbolGap;
                    drawTextV2(gBody, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);

                  } else if ((paragraph.val[j].shape !== null) && (paragraph.val[j].color !== null) && (paragraph.val[j].value !== null)) {
                    valueBox = getTextBox(gBody, paragraph.val[j].value, multipleValueFont);
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    rowPos.y += (multipleInline + valueBox.height);
                    //drawSymbol
                    drawSymbolV2(i * paragraph.val.length + j, gBody, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape, paragraph.val[j].color, symbolSize, _symbolClassName);
                    
                    rowPos.x = xStart + tooltipWidth - valueBox.width - multipleHorizontal;
                    drawTextV2(gBody, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  
                  } else if ((paragraph.val[j].label !== null) && (paragraph.val[j].value !== null)) {
                    labelBox = getTextBox(gBody, paragraph.val[j].label, multipleLabelFont);
                    valueBox = getTextBox(gBody, paragraph.val[j].value, multipleValueFont);
                    offset = (labelBox.height >= valueBox.height) ? labelBox.height: valueBox.heigth;
     
                    rowPos.x = xStart + multipleHorizontal;
                    rowPos.y += (multipleInline + offset);
                    drawTextV2(gBody, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
                    
                    rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                    drawTextV2(gBody, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  }
                  
                  currentBodyIndex++;
                  if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                    var valueBox2 = getTextBox(gBody, _truncationParameter.defaultValue, _truncationParameter.font);
                    rowPos.x = xStart + (tooltipWidth - valueBox2.width - multipleHorizontal);
                    rowPos.y += (multipleInline + valueBox2.height);
                    drawTextV2(gBody, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);
                    isBreak = true;
                    break;
                  }  
                }
                
              } else if (paragraph.val.length === 1) {
                if (paragraph.val[0].value !== null) {
                  var tempValueBox = getTextBox(gBody, paragraph.val[0].value, multipleValueFont);
                  rowPos.y += (multipleInline + tempValueBox.height);
                  
                  if (_properties.chartType === 'heatmap' || _properties.chartType === 'treemap' || _properties.chartType === 'tagcloud' || _properties.chartType === 'geo' ||_properties.chartType === 'mekko') {
                    rowPos.x = xStart + (tooltipWidth - tempValueBox.width - multipleHorizontal);

                  } else if (paragraph.val[0].shape !== null && paragraph.val[0].color !== null) {
                    rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                    drawSymbolV2(i * paragraph.val.length + 0, gBody, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[0].shape, paragraph.val[0].color, symbolSize, _symbolClassName);
                    rowPos.x = xStart + (tooltipWidth - tempValueBox.width - multipleHorizontal);
                    
                  }
                  drawTextV2(gBody, rowPos, paragraph.val[0].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                  
                  currentBodyIndex++;
                  if (_truncationParameter.isTruncated && currentBodyIndex === _truncationParameter.currentBodyIndex) {
                    var valueBox3 = getTextBox(gBody, _truncationParameter.defaultValue, multipleValueFont);
                    rowPos.x = xStart + (tooltipWidth - valueBox3.width - multipleHorizontal);
                    rowPos.y += (multipleInline + valueBox3.height);
                    drawTextV2(gBody, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);    
                    break;
                  }
                }
              }
            }
          }
        }
        
        if (tooltipFooter && tooltipFooter.length > 0) {
          //draw seperated line
          var separateLineStart = {
                x: xStart,
                y: rowPos.y + multipleVertical
              };
 
          var separateLineEnd = {
                x: xStart + tooltipWidth,
                y: rowPos.y + multipleVertical
              };
          var gFooter = vis.append('g').attr('class', 'v-footer');      
          vis.append('line').attr('class', _tooltipSeparationLineClassName).attr('x1', separateLineStart.x + 1).attr('y1', separateLineStart.y).attr('x2', separateLineEnd.x - 1).attr('y2', separateLineEnd.y).attr('stroke',  _defaultToolTipColors.separationLineSingleColor).attr('stroke-width', _shapeLayout.separationLineBorderWidth).style('shape-rendering', 'crispEdges');
          rowPos.y += (multipleVertical * 2);
      
          //draw footer
          for (var k = 0; k < tooltipFooter.length; k++) {
            if (TypeUtils.isExist(tooltipFooter[k].label) && TypeUtils.isExist(tooltipFooter[k].value)) {
              var footerLabelBox = getTextBox(gFooter, tooltipFooter[k].label, footerLabelFont), footerValueBox = getTextBox(gFooter, tooltipFooter[k].value, footerValueFont);
              rowPos.x = xStart + multipleHorizontal;
              if (k > 0) {
                rowPos.y += footerInline;
              }
              
              rowPos.y += (footerLabelBox.height);
              //draw label
              drawTextV2(gFooter, rowPos, tooltipFooter[k].label, footerLabelColor, footerLabelFont, _footerLabelClassName);
              
              rowPos.x = xStart + (tooltipWidth - footerValueBox.width - multipleHorizontal);
              //draw value
              drawTextV2(gFooter,rowPos, tooltipFooter[k].value, footerValueColor, footerValueFont, _footerValueClassName);
              
              currentFooterIndex++;
              if (_truncationParameter.isTruncated && currentFooterIndex === _truncationParameter.currentFooterIndex) {
                break;
              }
            }
          }
        }            
    }
        
    var formatTooltipData = function(data){
      if(TypeUtils.isExist(_properties.formatString)){
        var body = data.body, ibody;
        var indexAxis0 = 0, indexAxis1 = 0, indexOfiFS;
        var formatString = _properties.formatString, iFormatString;
        if(TypeUtils.isExist(body)){
          for(var i=0, len=body.length; i< len; i++){
            ibody = body[i];
            
            if (TypeUtils.isPlainObject(ibody.name)) {
              if(TypeUtils.isExist(formatString)) {
                iFormatString = formatString[ibody.name.ctx.path.mg];
                if(TypeUtils.isExist(iFormatString)){
                  indexOfiFS = ibody.name.ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : ibody.name.ctx.path.mi;
                  for(var j = 0, jlen = ibody.val.length; j < jlen; j++){
                    ibody.val[j].value = formatManager.format(ibody.val[j].value, iFormatString[indexOfiFS]);
                  }
                }
              }
            } else {
              var indexOfFS;
              if(TypeUtils.isExist(ibody.val[0].valueAxis)){
                indexOfFS = ibody.val[0].valueAxis;
              }
              else {
                indexOfFS = 0;
              }
              iFormatString = formatString[indexOfFS];
              //if formatstring is unll or undefined ,we will use the default value
              if(TypeUtils.isExist(iFormatString)){
                indexOfiFS = 0;
                if(indexOfFS === 0){
                  indexOfiFS = indexAxis0 >= iFormatString.length ? iFormatString.length -1 : indexAxis0;
                  indexAxis0++;
                }
                else if(indexOfFS === 1){
                  indexOfiFS = indexAxis1 >= iFormatString.length ? iFormatString.length -1 : indexAxis1;
                  indexAxis1++;
                }
                for(var k = 0, klen = ibody.val.length; k < klen; k++){
                  ibody.val[k].value = formatManager.format(ibody.val[k].value, iFormatString[indexOfiFS]);
                }
              }
            }
          }
        }
      }
      return data;
    };

    tooltip.imageInfo = function(_) {
      if(!arguments.length){
        return imageInfo;
      }
      imageInfo = _;
      return tooltip;
    };
    
    tooltip.showTooltip = function (eventData) {
      //To fix the bug, tooltip show the last position in android.
      vis.attr('visibility', 'hidden');
      var data = ObjectUtils.extend(true, {}, eventData.data);
      data = formatTooltipData(data);
      if(gWrapper !== null){
        gWrapper.remove();
      }
      
      if (_properties.visible) {
        if (data.plotArea) {
            tooltip.plotArea(data.plotArea);
        }
        
        _orientation = _properties.orientation;
        gWrapper = vis.append('svg:g');
        updateTooltipStyle();
      
        textMaxWidth = getTextMaxWidthV2(vis, data);
        tooltipWidth = getTooltipWidthV2(gWrapper, data);
        
        /*if (_properties.chartType !== 'geo' && tooltipWidth > (plotArea.width * 0.5)) {
          if(gWrapper !== null){
            gWrapper.remove();
          }
          return;
        }*/
        
        tooltipHeight = getTooltipHeightV2(gWrapper, data);
          
        var tmpWidth = tooltipWidth, tmpHeight = tooltipHeight;
        if (_orientation === 'top' || _orientation === 'bottom') {
          tmpHeight += _shapeLayout.markerHeight;
        }
        
        if (_orientation === 'left' || _orientation === 'right') {
          tmpWidth += _shapeLayout.markerHeight;
        }
        vis.attr('width', tmpWidth + _shapeLayout.padding).attr('height', tmpHeight + _shapeLayout.padding);
        
        //appendLinearGradient(gWrapper);
  
        var tooltipPos = calculatePos(data.point, plotArea, zone, tooltipWidth, tooltipHeight);
        drawShape(gWrapper, {x:0,y:0, absoluteMarkerOffset : tooltipPos.absoluteMarkerOffset}, tooltipWidth, tooltipHeight, _orientation);
        drawContentV2(gWrapper, {x:0,y:0}, data, _orientation);
        vis.style('left', tooltipPos.x + 'px').style('top', tooltipPos.y + 'px');
        clearGlobalValues();
        vis.attr('visibility', 'visible');
      }
    };  
    
    tooltip.hideTooltip = function () {
      if (gWrapper !== null) {
        gWrapper.remove();
        vis.attr('width', 0).attr('height', 0);
        gWrapper = null;
      }
    };
    
    function calculateSymbolSize(data) {
      if (data.labels) {
        _symbol.symbolSize = getTextBox(vis, data.labels[0].label, _display.multipleMeasure.label.font).height;
      }
    }
    
      function calculatePos(point, plotArea, zone, tooltipWidth, tooltipHeight) {
      var tooltipPos = {
          x: 0,
          y: 0,
          absoluteMarkerOffset: 0
      };
      
      var chartType = _properties.chartType;
      var markerHeight = _shapeLayout.markerHeight, markerWidth = _shapeLayout.markerWidth;
      var rightOffset = 0,  leftOffset = 0, topOffset = 0, bottomOffset = 0;

//      if (tooltipWidth > zone.width || tooltipHeight > zone.height) {
//        return tooltipPos;
//      } 
      
      if (_properties.chartType === undefined) {
        tooltipPos.x = point.x;
        tooltipPos.y = point.y - tooltipHeight/2;
      } else if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') {
        
        if (_orientation === 'bottom') {
          var upBorder = zone.height - point.y + tooltipHeight + markerHeight;
          if (upBorder > zone.height) {
            _orientation = 'top';
            tooltipPos.y = point.y;
          } else {
            tooltipPos.y = point.y - tooltipHeight - markerHeight;
          }
        }
        
        var tooltipPosX;
        if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') 
        {
            tooltipPosX = calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth);
        }
        else
        {
            tooltipPosX = calculateTooltipPosX(point, plotArea, zone, tooltipWidth);
        }

        tooltipPos.x = tooltipPosX.x;
        tooltipPos.absoluteMarkerOffset = tooltipPosX.absoluteMarkerOffset;
        
      } else if (chartType === 'line' || chartType === 'verticalboxplot' || chartType === 'verticalbar') {
        if (_orientation === 'left') {
          var rightBorder = point.x + tooltipWidth + markerHeight;
          if (rightBorder > zone.width) {
            _orientation = 'right';
            tooltipPos.x = point.x - tooltipWidth - markerHeight;
          } else {
            tooltipPos.x = point.x;
          }
        }
        if (tooltipHeight / 2 < plotArea.y) {
          //tooltip marker is over chart top border.
          tooltipPos.y = plotArea.y - (tooltipHeight - markerWidth) / 2;
        } else {
          tooltipPos.y = 0;
        }
        
      } else if (chartType === 'radar') {
        rightOffset = 0;
        leftOffset = 0;
        topOffset = 0;
        bottomOffset = 0;
        var x = 0, y = 0;
        
        _orientation = point.orientation;
        tooltipPos.x = point.x;
        tooltipPos.y = point.y - tooltipHeight / 2;
        
        if (point.orientation === 'right') {
          tooltipPos.x -= (tooltipWidth + markerHeight);
        }
        
        if (point.orientation === 'left') {
          rightOffset = point.x + tooltipWidth + markerHeight - zone.width;

        }
        
        if (point.orientation === 'right') {
          leftOffset = point.x - tooltipWidth - markerHeight;
        }
        
        topOffset = point.y - tooltipHeight / 2;
        bottomOffset = point.y + tooltipHeight / 2 - zone.height;
        
        if (rightOffset <= 0 && leftOffset >= 0 && topOffset >= 0 && bottomOffset <= 0) {
          return tooltipPos;
        }
        
        if (rightOffset > 0 &&  rightOffset > point.range.x) {
          return tooltipPos;
        }
        
        if (leftOffset < 0 && Math.abs(leftOffset) > point.range.x) {
          return tooltipPos;
        }
        
        if (topOffset < 0 && Math.abs(topOffset) > point.range.y) {
          return tooltipPos;
        }
        
        if (bottomOffset > 0 && bottomOffset > point.range.y) {
          return tooltipPos;
        }
        
        var angle = point.angle * 180 / Math.PI, radian = point.angle;
        
        if (angle >= 0) {

          if (angle === 0 && rightOffset > 0) {
            tooltipPos.x -= rightOffset;
          } else if (angle === 90 && topOffset < 0) {
            tooltipPos.y -= topOffset;
          } else if (angle === 180 && leftOffset < 0) {
            tooltipPos.x -= leftOffset;
          } else if (angle > 0 && angle < 90) {
            if (topOffset < 0 && rightOffset > 0) {
              //both tooltip top and right border cross chart top and right border
              var  topOffsetAbs1 = Math.abs(topOffset);
              if (topOffsetAbs1 >= rightOffset) {
                y = topOffsetAbs1;
                x = y / Math.tan(radian);
              } else  {
                x = rightOffset;
                y = x * Math.tan(radian);
                
              }
            } else if (topOffset < 0 && rightOffset <= 0) {
              //only tooltip top border cross chart top border
              y = Math.abs(topOffset);
              x = y / Math.tan(radian);
            } else if (topOffset >= 0 && rightOffset > 0) {
              //only tooltip right border cross chart right border
              x = rightOffset;
              y = x * Math.tan(radian);
            }
            
            tooltipPos.x -=x;
            tooltipPos.y += y;
            
          } else if (angle > 90 && angle < 180) {
            if (topOffset < 0 && leftOffset < 0) {
              //both tooltip top and left border cross chart top and left border
              var topOffsetAbs2 = Math.abs(topOffset), leftOffsetAbs1 = Math.abs(leftOffset);
              if (topOffsetAbs2 >= leftOffsetAbs1) {
                y = topOffsetAbs2;
                x = y / Math.tan(Math.PI - radian);
              } else {
                x = leftOffsetAbs1;
                y = x * Math.tan(Math.PI - radian);
              }
              
            } else if (topOffset < 0 && leftOffset >= 0) {
              //only tooltip top border cross chart top border
              y = Math.abs(topOffset);
              x = y / Math.tan(Math.PI - radian);
              
            } else if (topOffset >= 0 && leftOffset < 0) {
              //only tooltip left border cross chart left border
              x = Math.abs(leftOffset);
              y = x * Math.tan(Math.PI -radian);
            }
            
            tooltipPos.x +=x;
            tooltipPos.y += y;
          }
          
        } else {
          
          var angleAbs = Math.abs(angle);
          if (angleAbs === 0 && rightOffset > 0) {
            tooltipPos.x -= rightOffset;
          } else if (angleAbs === 90 && bottomOffset > 0) {
            tooltipPos.y -= bottomOffset;
          } else if (angleAbs === 180 && leftOffset < 0) {
            tooltipPos.x -= leftOffset;
          } else if (angleAbs > 0 && angleAbs < 90) {
            if (bottomOffset > 0 && rightOffset > 0) {
              //both tooltip bottom and right border cross chart top and right border
              if (bottomOffset >= rightOffset) {
                y = bottomOffset;
                x = y / Math.tan(Math.abs(radian));
              } else  {
                x = rightOffset;
                y = x * Math.tan(Math.abs(radian));
                
              }
            } else if (bottomOffset > 0 && rightOffset <= 0) {
              //only tooltip bottom border cross chart bottom border
              y = bottomOffset;
              x = y / Math.tan(Math.abs(radian));
            } else if (bottomOffset <= 0 && rightOffset > 0) {
              //only tooltip right border cross chart right border
              x = rightOffset;
              y = x * Math.tan(Math.abs(radian));
            }
            
            tooltipPos.x -=x;
            tooltipPos.y -= y;            
          } else if (angleAbs > 90 && angleAbs < 180) {
            if (bottomOffset > 0 && leftOffset < 0) {
              var leftOffsetAbs2 = Math.abs(leftOffset);
              //both tooltip bottomOffset and left border cross chart top and left border
              if (bottomOffset >= leftOffsetAbs2) {
                y = bottomOffset;
                x = y / Math.tan(Math.PI - Math.abs(radian));
              } else {
                x = leftOffsetAbs2;
                y = x * Math.tan(Math.PI - Math.abs(radian));
              }
              
            } else if (bottomOffset > 0 && leftOffset >= 0) {
              //only tooltip bottom border cross chart bottom border
              y = bottomOffset;
              x = y / Math.tan(Math.PI - Math.abs(radian));
              
            } else if (bottomOffset <= 0 && leftOffset < 0) {
              //only tooltip left border cross chart left border
              x = Math.abs(leftOffset);
              y = x * Math.tan(Math.PI -Math.abs(radian));
            }
            
            tooltipPos.x +=x;
            tooltipPos.y -= y;            
          }      
        }
        
      } else if (chartType === 'geo' && _orientation === 'left'){
        // In this style, tooltip will always point to the plot origin horizontally.
       topOffset = point.y - tooltipHeight / 2;
       bottomOffset = point.y + tooltipHeight / 2 - zone.height;
        
        tooltipPos.y = topOffset;
        
        if (plotArea.x + plotArea.width + tooltipWidth - markerHeight > zone.width) {
          tooltipPos.x = plotArea.x - plotArea.width - tooltipWidth;
          _orientation = 'right';
        } else {
          tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
        }

        if (topOffset < 0) {
          tooltipPos.y = 0;
          tooltipPos.absoluteMarkerOffset = topOffset;
        }
        
        if (bottomOffset > 0) {
          tooltipPos.y = zone.height - tooltipHeight;
          tooltipPos.absoluteMarkerOffset = bottomOffset;
        }
      } else {
        
        if (_properties.orientation === 'left') {
          
          rightOffset = plotArea.x + plotArea.width + tooltipWidth + markerHeight - zone.width;
          topOffset = point.y - tooltipHeight / 2;
          bottomOffset = point.y + tooltipHeight / 2 - zone.height;
          
          tooltipPos.y = point.y - tooltipHeight / 2;
          
          if (chartType === 'pie_with_depth') {
            tooltipPos.x = point.x;
          } else if (rightOffset > 0) {
            tooltipPos.x = zone.width - markerHeight - tooltipWidth;
          } else {
            tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
          }
          
          if (topOffset < 0) {
            tooltipPos.y = 0;
            tooltipPos.absoluteMarkerOffset = topOffset;
          }
          
          if (bottomOffset > 0) {
            tooltipPos.y = zone.height - tooltipHeight;
            tooltipPos.absoluteMarkerOffset = bottomOffset;
          }

        } else if (_properties.orientation === 'bottom') {      
  
          var top = plotArea.y - tooltipHeight;
          if (top < 0) {
            tooltipPos.y = 0;
          } else {
            tooltipPos.y = plotArea.y - tooltipHeight;
          }
          
          var posX;
          if (chartType === 'heatmap' || chartType === 'treemap' || chartType === 'tagcloud') 
          {
              posX = calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth);
          }
          else
          {
              posX = calculateTooltipPosX(point, plotArea, zone, tooltipWidth);
          }
          tooltipPos.x = posX.x;
          tooltipPos.absoluteMarkerOffset = posX.absoluteMarkerOffset;
        }
        
      }

      return tooltipPos;
    }
    
    function calculateTooltipPosX(point, plotArea, zone, tooltipWidth) {
      var tooltipPosX = {
          x: 0,
          absoluteMarkerOffset: 0
      };
      
      var leftBorder = tooltipWidth / 2 - (point.x - plotArea.x) + plotArea.width;
      var rightBorder = point.x - plotArea.x + tooltipWidth / 2;
      if (leftBorder > zone.width) {
        tooltipPosX.x = plotArea.x;
        tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - tooltipWidth / 2;
      } else if (rightBorder > zone.width) {
        tooltipPosX.x = plotArea.x + (plotArea.width - tooltipWidth);
        tooltipPosX.absoluteMarkerOffset = plotArea.width - (point.x - plotArea.x) - tooltipWidth / 2;
      } else {
        tooltipPosX.x = point.x - tooltipWidth / 2;
        tooltipPosX.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosX;
    }

    function calculateTooltipPosXForMBCCharts(point, plotArea, zone, tooltipWidth) {
      var tooltipPosX = {
          x: 0,
          absoluteMarkerOffset: 0
      };
      
      var leftBorder = tooltipWidth - (point.x - plotArea.x) + plotArea.width;
      var rightBorder = point.x - plotArea.x + tooltipWidth;

      if (leftBorder > zone.width) {
        tooltipPosX.x = plotArea.x;
        tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - tooltipWidth / 2;
      } else if (rightBorder > zone.width) {
        tooltipPosX.x = plotArea.x + (plotArea.width - tooltipWidth);
        
        if(tooltipPosX.x + tooltipWidth > plotArea.width)
        {
            tooltipPosX.absoluteMarkerOffset = point.x - plotArea.x - plotArea.width + tooltipWidth / 2;
        }
        else
        {
            tooltipPosX.absoluteMarkerOffset = plotArea.width - (point.x - plotArea.x) - tooltipWidth / 2;
        }
      } else {
        tooltipPosX.x = point.x - tooltipWidth / 2;
        tooltipPosX.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosX;
    }
    
    function calculateTooltipPosY(point, plotArea, zone, tooltipHeight) {
      var tooltipPosY = {
          y: 0,
          absoluteMarkerOffset: 0
      };
      
      var upBorder = plotArea.height + (tooltipHeight / 2 - (point.y - plotArea.y));
      var downBorder = point.y - plotArea.y + tooltipHeight / 2;
      if (upBorder > zone.height) {
        tooltipPosY.y = plotArea.y;
        tooltipPosY.absoluteMarkerOffset = point.y - plotArea.y - tooltipHeight / 2;
      } else if (downBorder > zone.height) {
        tooltipPosY.y = plotArea.y + plotArea.height - tooltipHeight;
        tooltipPosY.absoluteMarkerOffset = point.y - (plotArea.height - tooltipHeight) - plotArea.y - tooltipHeight / 2;
      } else {
        tooltipPosY.y = point.y - tooltipHeight / 2;
        tooltipPosY.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosY;
    }
    
    function drawShape(vis, pos, width, height, markerPos) {
      
      var xStart = pos.x, yStart = pos.y, offset = pos.absoluteMarkerOffset, radius = _shapeLayout.radius, markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
      var space = ' ';
      var lineTo = _svgPathCommand.lineToA, moveTo = _svgPathCommand.moveToA, arc = _svgPathCommand.arcA, closePath = _svgPathCommand.closePath;
      //var markerPos = properties.orientation;
      
      if (markerPos === 'left') {
        xStart += markerHeight;
      }
      if (markerPos === 'top') {
        yStart += markerHeight;
      }

      var path = moveTo + space + xStart + space + (yStart + radius) + space;

      if (markerPos === 'left') {
          path += lineTo + space + xStart + space + (yStart + height / 2 + offset - markerWidth / 2 ) + space;
          path += lineTo + space + (xStart - markerHeight) + space + (yStart + height / 2 + offset ) + space;
          path += lineTo + space + xStart + space + (yStart + height / 2 + offset + markerWidth / 2 ) + space;
      }

      path += lineTo + xStart + space + (yStart + height - radius) + space;

      path += arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + radius) + space + (yStart + height) + space;

      if (markerPos === 'bottom') {
          path += lineTo + space + (xStart + width / 2 + offset - markerWidth / 2) + space + (yStart + height) + space;
          path += lineTo + space + (xStart + width / 2 + offset) + space + (yStart + height + markerHeight) + space;
          path += lineTo + space + (xStart + width / 2 + offset + markerWidth / 2) + space + (yStart + height) + space;
      }

      path += lineTo + space + (xStart + width - radius) + space + (yStart + height) + space;

      path += space + arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + width) + space + (yStart + height - radius) + space;

      if (markerPos === 'right') {
          path += lineTo + space + (xStart + width) + space + (yStart + height / 2 + offset + markerWidth / 2) + space;
          path += lineTo + space + (xStart + width + markerHeight) + space + (yStart + height / 2 - offset) + space;
          path += lineTo + space + (xStart + width) + space + (yStart + height / 2 + offset - markerWidth / 2) + space;
      }

      path += lineTo + space + (xStart + width) + space + (yStart + radius) + space;

      path += space + arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + width - radius) + space + yStart + space;

      if (markerPos === 'top') {
          path += lineTo + space + (xStart + width / 2 + offset + markerWidth / 2) + space + yStart + space;
          path += lineTo + space + (xStart + width / 2 + offset) + space + (yStart - markerHeight) + space;
          path += lineTo + space + (xStart + width / 2 + offset - markerWidth / 2) + space + yStart + space;
      }

      path += lineTo + space + (xStart + radius) + space + yStart + space;

      path += arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + xStart + space + (yStart + radius) + space;

      path += closePath;
      
      //draw the shadow below the tooltip background
      vis.append('path').attr('d', path).attr('class', _tooltipBackgroundClassName).style('-webkit-svg-shadow', '1px 1px 4px rgba(0, 0, 0, 0.25)');
      vis.append('path').attr('d', path).attr('class', _tooltipBackgroundClassName).attr('fill', _defaultToolTipColors.backgroundColor).attr('stroke', _defaultToolTipColors.borderColor).attr('stroke-width', _shapeLayout.borderWidth);

    }

    function getCustomlabel(rawObj){
      var ret;
      if(rawObj.info){
        var clobj = rawObj.info.customlabel;
        if(clobj){
          if(clobj.type === 'url'){
            ret = rawObj.val;
          }else if(clobj.type === 'string'){
            ret = clobj.val;
          }
        }else{
          ret = rawObj.val;
        }
      }else{
        ret = rawObj.val;
      }
      ret = handleNull(ret);
      return ret;
    }
    
    function resolveText(rawObj){
      var ret = [];
      if(TypeUtils.isPlainObject(rawObj)){ 
        ret.push(getCustomlabel(rawObj));
      }else if(TypeUtils.isArray(rawObj)){
        rawObj.forEach(function(iter, index){
          ret.push(resolveText(iter));
        }, this);
      }else{
        ret.push(rawObj);
      }
      return ret;
    }
    
    function getTextBox(vis, text, style) {
      /*[Jimmy/1/2/2013]we extend text to also accepts Object with following structure: 
       * {
       *   val: xxxx
       *   info: xxxx
       * }, same structure as we used in module. then we can support additional info like customlabel in tooltip
       * text can also be array, we will compose each member with '/' (hard coded currently) and measure the final result
       */
      var resolvedTexts = resolveText(text);
      var composedText = resolvedTexts.join('*');
      var textHandler = vis.append('svg:text').attr('x', 0).attr('y', 0).attr('visibility', 'hidden').style('font', style).text(composedText);
      var bbox = textHandler.node().getBBox();
      textHandler.remove();
      return bbox;
    }

    function getTextMaxWidth(vis, data) {
      var maxValue = 0, textWidth = 0;
      if (data.title !== null) {
          if (data.labels.length > 0) {
              var bBox = getTextBox(vis, data.title, _display.title.font);
              var currentMax = bBox.width;

              for (var i = 0, len = data.labels.length; i < len; i++) {
                 textWidth = getTextBox(vis, data.labels[i].label, _display.multipleMeasure.label.font).width + getTextBox(vis, data.labels[i].value, _display.multipleMeasure.value.font).width;
                  if (textWidth > currentMax) {
                      currentMax = textWidth;
                  }
              }
              maxValue = currentMax;
          }
      } else {
          maxValue = getTextBox(vis, data.labels[0].label, _display.singleMeasure.label.font).width;
          textWidth = getTextBox(vis, data.labels[0].value, _display.singleMeasure.value.font).width;

          if (textWidth > maxValue) {
              maxValue = textWidth;
          }
      }
      return maxValue;
    }

    function getTooltipWidth(vis, data) {
      var tooltipWidth = 0, symbolSize = _symbol.symbolSize;
      var singleHorizontal = _display.singleMeasure.padding.horizontal, multipleHorizontal = _display.multipleMeasure.padding.horizontal, symbolGap = _display.multipleMeasure.padding.symbolGap, defaultSpace = _display.multipleMeasure.padding.defaultSpace;
      if (data.title !== null) {
        tooltipWidth = textMaxWidth + (multipleHorizontal * 2) + defaultSpace; //+ radius * 2;
        if (data.shapes && data.colors) {
          tooltipWidth +=  symbolSize + symbolGap;
        }
      } else {
        tooltipWidth = textMaxWidth + (singleHorizontal * 2); 
      }
      return tooltipWidth;
    }

    function getTooltipHeight(vis, data) {
      var inline = _display.multipleMeasure.padding.inline, multipleVertical = _display.multipleMeasure.padding.vertical, singleVertical = _display.singleMeasure.padding.vertical;
      var multipleValueFont = _display.multipleMeasure.value.font, singleValueFont = _display.singleMeasure.value.font;
      var titleFont = _display.title.font;
      var tooltipHeight = 0;
        if (data.title !== null) {
            tooltipHeight = (multipleVertical * 3) + (inline * (data.labels.length - 1)) + getTextBox(vis, data.title, titleFont).height + getTextBox(vis, data.labels[0].value, multipleValueFont).height * data.labels.length;

        } else {
            tooltipHeight = (singleVertical * 3 ) + getTextBox(vis, data.labels[0].value, singleValueFont).height;
        }
        return tooltipHeight;
    }
        
    function appendLinearGradient(vis) {
      var gradient = vis.append('svg:defs').append('svg:linearGradient').attr('id', 'tooltipGradient1').attr('x1', '0%').attr('y1', '0%').attr('x2', '80%').attr('y2', '0%').attr('x3', '100%').attr('y3', '0%');
      gradient.append('svg:stop').attr('offset', '30%').attr('style', 'stop-color:' + _defaultToolTipColors.separationLineColor[0]);
      gradient.append('svg:stop').attr('offset', '60%').attr('style', 'stop-color:' + _defaultToolTipColors.separationLineColor[1]);
      gradient.append('svg:stop').attr('offset', '100%').attr('style', 'stop-color:' + _defaultToolTipColors.separationLineColor[2]);          
    }
  
    function drawSymbol(vis, pos, symbolSize, symbolType, color) {
      var symbolPath = d3.svg.symbol().type(symbolType).size(symbolSize * symbolSize);
      var parameter = {
          drawingEffect: _properties.drawingEffect,
          fillColor : color,
        graphType : symbolType,
          direction : 'vertical'
      };
      var fillId =  effectManager.register(parameter);
      vis.append('path').attr('d', symbolPath).attr('transform', 'translate(' + pos.x + ',' + pos.y + ')').attr('fill', fillId);
    } 
        
    function drawText(vis, pos, text, color, style) {
      vis.append('text').attr('x', pos.x).attr('y', pos.y).attr('fill', color).style('font', style).text(text);
    }
        
    function drawTextV2(vis, pos, text, color, style, className) {
      /*[Jimmy/1/2/2013]we extend text to also accepts Object with following structure: 
       * {
       *   val: xxxx
       *   info: xxxx
       * }, same structure as we used in module. then we can support additional info like customlabel in tooltip
       * text can also be array, we will compose each member with '/' (hard coded currently) and measure the final result
       */
      var resolvedTexts = resolveText(text);
      var composedText = resolvedTexts.join('/');
      vis.append('text').attr('x', pos.x).attr('y', pos.y).attr('fill', color).style('font', style).text(composedText).attr('class', className);
    }
    
    function drawContent(vis, pos, data) {}
        
    tooltip.zone = function(_){
      if(!arguments.length){
        return zone;
      }
      zone = _;
      return this;
    };
  
    tooltip.plotArea = function(_){
      if(!arguments.length){
        return plotArea;
      }
      plotArea = _;
      return this;
    };
        
    tooltip.properties = function (_) {
      if (!arguments.length){
          return _properties;
       }
      Objects.extend(true, _properties, _);
      return this;
    };
    
    function updateTooltipStyle() {
      var cssDef;
      
      cssDef = ctx.styleManager.queryDefault('viz-tooltip-background');
      if (cssDef && (cssDef['fill']) && (_defaultToolTipColors.backgroundColor !== cssDef['fill'])) {
        _defaultToolTipColors.backgroundColor = cssDef['fill'];
      }
      
      cssDef = ctx.styleManager.queryDefault('viz-tooltip-title');
      if (cssDef && (cssDef['fill']) && (_display.title.color !== cssDef['fill'])) {
        _display.title.color = cssDef['fill'];
      }

      cssDef = ctx.styleManager.queryDefault('viz-tooltip-label');
      if (cssDef && cssDef['fill']) {
        _display.singleMeasure.label.color  = cssDef['fill'];
        _display.multipleMeasure.label.color = cssDef['fill'];
      }

      cssDef = ctx.styleManager.queryDefault('viz-tooltip-value');
      if (cssDef && cssDef['fill']) {
        _display.singleMeasure.value.color  = cssDef['fill'];
        _display.multipleMeasure.value.color = cssDef['fill'];
      }
      
      cssDef = ctx.styleManager.queryDefault('v-footer-label');
      if (cssDef && cssDef['fill']) {
        _display.footer.label.color  = cssDef['fill'];
      }
      
      cssDef = ctx.styleManager.queryDefault('v-footer-value');
      if (cssDef && cssDef['fill']) {
        _display.footer.value.color  = cssDef['fill'];
      }
  
      cssDef = ctx.styleManager.queryDefault('v-separationline');
      if (cssDef && cssDef['fill']) {
        _defaultToolTipColors.separationLineSingleColor  = cssDef['fill'];
      }
    }
    
    _properties = manifest.props(null);
    return tooltip;
  };
  return tooltip;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.tooltip',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.tooltip',
    'type' : Constants.Module.Type.Presentation.Tooltip,
    'name' : 'tooltip',
    'description': 'Settings for the tooltip that appears when the user hovers over a series or point.',
    'properties' : {
      'visible' : {
        'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : true,
          'description' : 'Set visibility of tooltip.'
      },
     'drawingEffect':{
       'name' : 'drawingEffect',
       'supportedValueType' : 'List',
       'supportedValues' : [ 'normal', 'glossy' ],
           'defaultValue' : 'normal',
           'description' : 'Set drawing effect of Tooltip.',
           'isExported' : true
    },
	'formatString': {
	'name' : 'formatString',
	'supportedValueType': 'Two-Dimensions-Array',
  'defaultValue' : null,
	'description' : 'Set format string of tooltip. As we may have dual axis with serveral measures, the first array is applied to primary axis and the second one is applied to the second one.'
		+'If the length of format string list is less than the length of data series, the last format string in the list will be applied to exceeded data series.' 
	}
      },
    'css' : {
      '.viz-tooltip-background.v-background' : {
        'description' : 'Define color for the tooltip background.',
        'value' : {
          'fill' : '#ffffff'
        }
      },
      '.viz-tooltip-title.v-body-title' : {
        'description' : 'Define color for the title of tooltip body.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.viz-tooltip-label.v-body-label' : {
        'description' : 'Define color for the label of tooltip body.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.viz-tooltip-value.v-body-value' : {
        'description' : 'Define color for the value of tooltip body.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.v-footer-label' : {
        'description' : 'Define color for the label of tooltip footer.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.v-footer-value' : {
        'description' : 'Define color for the value of tooltip footer.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.v-separationline' : {
        'description' : 'Define color for the value of tooltip separation line.',
        'value' : {
          'stroke' : '#AAAAAA'
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'},
[

],
function Setup() 
{
  var classname = 'v-bound';
  var BoundUtil = {
      drawBound : function(selection, width, height ){
          if(selection.select('.' + classname).node() == null){
            selection.insert('rect', ':first-child').attr('class', classname).attr('width', width).attr('height', height).attr('visibility', 'hidden');
          }else{
            selection.select('.' + classname).attr('width', width).attr('height', height);
          }
      }
  };
  
  return BoundUtil;
});sap.riv.module(
{
  qname : 'sap.viz.modules.background',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
}
],
function Setup(ObjectUtils, dispatch, Objects, BoundUtil) {
  return function(manifest, ctx) {
 
     var CSSCLASS_BORDER = 'v-background-border',
         CSSCLASS_BORDER_2 = 'viz-plot-background-border',
         CSSCLASS_BODY = 'v-background-body',
         CSSCLASS_BODY_2 = 'viz-plot-background';

    var randomSuffix = ObjectUtils.guid();
    var width = 0, 
      height = 0;
    var effectManager = ctx.effectManager,
      properties,
      d3root;
    var eDispatch = new dispatch('initialized');
    
    function background(selection) {
      d3root = selection;
      //BoundUtil.drawBound(selection, width, height); //background module should not need to use bound rect
      
      if (properties.visible) {
        getCSSStyle();

        var d3rect = d3root.select('#' + 'background-rect-' + randomSuffix);
        if (d3rect.empty()) {
          d3rect = d3root.append('svg:rect').attr('class', CSSCLASS_BODY + ' ' + CSSCLASS_BODY_2).attr('id', 'background-rect-' + randomSuffix);
        }
        var fillID = effectManager.register({
          graphType : 'background',
          fillColor : properties.style.body.fill,
          drawingEffect : properties.drawingEffect,
          direction : properties.direction
        });
        d3rect.attr('x', 0).attr('y', 0).attr('width', width).attr('height', height).attr('style', "fill:" + fillID);
        
        var borderData = [];
        if (properties.border.left.visible) {
          borderData.push({
            x1: 0, y1: 0, x2: 0, y2: height
          });
        }
        if (properties.border.right.visible) {
          borderData.push({
            x1: width, y1: 0, x2: width, y2: height
          });
        }
        if (properties.border.top.visible) {
          borderData.push({
            x1: 0, y1: 0, x2: width, y2: 0
          });
        }
        if (properties.border.bottom.visible) {
          borderData.push({
            x1: 0, y1: height, x2: width, y2: height
          });
        }
        
        var d3border = selection.selectAll("." + CSSCLASS_BORDER).data(borderData);
        d3border.enter().append('svg:line').attr('class', CSSCLASS_BORDER + ' ' + CSSCLASS_BORDER_2);
        d3border.exit().remove();
        d3border.attr('x1', function(d){return d.x1;}).attr('y1', function(d){return d.y1;})
          .attr('x2', function(d){return d.x2;}).attr('y2', function(d){return d.y2;});
        // now we use attribute in dom element to let customer css file work.
        d3border.each(function(d){
            d3.select(this).attr('shape-rendering' , 'crispEdges');
            for (var key in properties.style.border) {
              if (properties.style.border.hasOwnProperty(key)) {
                d3.select(this).attr(key, properties.style.border[key]);
              }
            }
        });
      } else {
        var temp = d3root.node();
        while(temp.hasChildNodes()) {
            temp.removeChild(temp.firstChild);
        }
      }
      
      //currently, we do not have animation. If it has, should fire initialized event after animation complete.
      eDispatch.initialized();
      
      return background;
    }
    
    background.properties = function(_){
      if (!arguments.length){
        return properties;
       }
      Objects.extend(true, properties, _);
      return background;
    };
    background.size = function(_size) {
      if (arguments.length === 0) {
        return {
            "width" : width,
            "height": height
        };
      }
      width = _size.width;
      height = _size.height;
      return background;
    };
    background.width = function(_width) {
      if (arguments.length === 0) {
        return width;
      }
      width = _width;
      return background;
    };
    background.height = function(_height) {
      if (arguments.length === 0) {
        return height;
      }
      height = _height;
      return background;
    };
    background.data = function(_) {
      if(!arguments.length) {
        return {};
      }
      return background;
    };
    background.parent = function() {
      return null;
    };

    background.dispatch = function(_){
      if(!arguments.length) {
        return eDispatch;
      }
      eDispatch = _;
      return background;
    };
    
    function getCSSStyle() {
      if (!properties.style) {
        properties.style = {};
      }
      properties.style.body = ctx.styleManager.query(CSSCLASS_BODY);
      if (!properties.style.border) {
        properties.style.border = ctx.styleManager.queryDefault(CSSCLASS_BORDER);
      }
    }

    properties = manifest.props(null);
    return background;

  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.background',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var visibleObj = {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of background.'
      };
  var module = {
    'id' : 'sap.viz.modules.background',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'background',
    'description': 'Settings for the background for the outer chart area.',
    'properties' : {
      'visible' : visibleObj,
    'border' : {
        'name' : 'border',
      'description' : 'Settings for border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : { 
      'left' : {
        'name' : 'left',
        'description' : 'Set left border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'right' : {
        'name' : 'right',
        'description' : 'Set right border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'top' : {
        'name' : 'top',
        'description' : 'Set top border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'bottom' : {
        'name' : 'bottom',
        'description' : 'Set bottom border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          },
          },
    },
        'drawingEffect':{
          'name' : 'drawingEffect',
            'description' : 'Set drawing effect of background.',
          'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'isExported' : true,
        },
        'direction':{
          'name' : 'direction',
            'description' : 'Set gradient direction of background, only taking effect when drawingEffect of background has been set to \'golossy\'.',
          'supportedValueType' : 'List',
            'supportedValues' : [ 'horizontal', 'vertical' ],
            'defaultValue' : 'vertical',
        }
    },
    'css' : {
      '.v-background-body.viz-plot-background' : {
        'description' : 'Define style for the plot background body.',
        'value' : {
          'fill' : 'none',
        }
      },
      '.v-background-border.viz-plot-background-border' : {
        'description' : 'Define style for the plot background border.',
        'value' : {
          'stroke' : '#d8d8d8',
          'stroke-width' : 1,
        }
      },
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.Vector',
  version : '4.0.2'},
[

],
function Setup(Point) {
  function Vector() {
    this.values = [];
    for ( var i = 0, len = arguments.length; i < len; i++) {
      this.values.push(arguments[i]);
    }
  }

  Vector.prototype.dotProduct = function(v) {
    var dimension = v.dimension();
    if (dimension !== this.dimension()) {
      throw new Error(
          "The vectors to be dot-producted must have same dimension, but the dimension of this vector is " +
              this.dimension + " and another one is " + dimension + ".");
    }
    var sum = 0;
    for ( var i = 0; i < dimension; i++) {
      sum += this.value(i) * v.value(i);
    }
    return sum;
  };

  Vector.prototype.dimension = function(v) {
    return this.values.length;
  };

  Vector.prototype.value = function(i, d) {
    if (arguments.length >= 2) {
      this.values[i] = d;
    }
    return this.values[i];
  };

  return Vector;
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.Vector4D',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.threeD.Vector',
  version : '4.0.2'
}
],
function Setup(Vector) {
  function Vector4D(p1, p2, p3, p4) {
    Vector.apply(this, arguments);
  }

  Vector4D.prototype = Object.create(Vector.prototype);

  return Vector4D;
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.threeD.Vector4D',
  version : '4.0.2'
}
],
function Setup(Vector4D) {
  var dimension = 4;
  var length = dimension * dimension;

  function radian(deg) {
    return deg * Math.PI / 180;
  }

  var matrixBuilder = function() {
    var values = new Array(length);

    var matrix = {
      unit : function() {
        for ( var i = 0; i < length; i++) {
          values[i] = (i % (dimension + 1) === 0) ? 1 : 0;
        }
        return matrix;
      },

      value : function(row, col, v) {
        var index = row * dimension + col;
        if (arguments.length >= 3) {
          values[index] = v;
          return matrix;
        }
        return values[index];
      },

      row : function(row) {
        var array = [];
        var start = row * dimension;
        for ( var i = 0; i < dimension; i++) {
          array[i] = values[start + i];
        }
        return new Vector4D(array[0], array[1], array[2], array[3]);
      },

      col : function(col) {
        var array = [];
        for ( var i = 0; i < dimension; i++) {
          array[i] = values[dimension * i + col];
        }
        return new Vector4D(array[0], array[1], array[2], array[3]);
      },

      translate : function(tx, ty, tz) {
        return matrix.transform(matrixBuilder().value(0, 3, tx || 0).value(1,
            3, ty || 0).value(2, 3, tz || 0));
      },

      scale : function(tx, ty, tz) {
        return matrix.transform(matrixBuilder().value(0, 0, tx || 0).value(1,
            1, ty || 0).value(2, 2, tz || 0));
      },

      rotateX : function(deg) {
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(1, 1, cos).value(1, 2,
            -sin).value(2, 1, sin).value(2, 2, cos));
      },

      rotateY : function(deg) {
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(0, 0, cos).value(0, 2,
            sin).value(2, 0, -sin).value(2, 2, cos));
      },
      
      rotateZ : function(deg){
        var r = radian(deg);
        var sin = Math.sin(r);
        var cos = Math.cos(r);
        return matrix.transform(matrixBuilder().value(0, 0, cos).value(0, 1,
            -sin).value(1, 0, sin).value(1, 1, cos));
      },
      
      transform : function(m) {
        if (m) {
          var rows = [], cols = [], i;
          for ( i = 0; i < dimension; i++) {
            rows.push(m.row(i));
            cols.push(matrix.col(i));
          }
          for ( i = 0; i < dimension; i++) {
            var start = i * dimension;
            for ( var j = 0; j < dimension; j++) {
              var index = start + j;
              values[index] = rows[i].dotProduct(cols[j]);
            }
          }
        }
        return matrix;
      },

      clone : function() {
        var newMatrix = matrixBuilder();
        for ( var i = 0; i < dimension; i++) {
          for ( var j = 0; j < dimension; j++) {
            newMatrix.value(i, j, matrix.value(i, j));
          }
        }
        return newMatrix;
      },

      projection : function() {
        return "matrix(" + matrix.value(0, 0) + "," + matrix.value(1, 0) + "," +
            matrix.value(0, 1) + "," + matrix.value(1, 1) + "," +
            matrix.value(0, 3) + "," + matrix.value(1, 3) + ")";
      },

      translatedProjection : function(){
        return "translate(" + this.value(0,3) + "," + this.value(1,3) +")";
      },
      
      toString : function() {
        var str = "";

        for ( var i = 0; i < length; i++) {
          if (i % 4 !== 0) {
            str += ", ";
          }
          str += values[i];
          if ((i - 3) % 4 === 0) {
            str += "\n";
          }
        }

        return str;
      }
    };

    return matrix.unit();
  };

  return matrixBuilder;
});sap.riv.module(
{
  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils) {
  var NumberUtils = {
    isNoValue: function(n) {
      return TypeUtils.isNaN(n);
    }
  };
  return NumberUtils;
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.threeD.Vector4D',
  version : '4.0.2'
}
],
function Setup(Vector4D) {
  function Point(x, y, z) {
    this.x = x;
    this.y = y;
    this.z = z;
  }
  Point.prototype.transform = function(m) {
    var vector = new Vector4D(this.x, this.y, this.z, 1);
    this.x = m.row(0).dotProduct(vector);
    this.y = m.row(1).dotProduct(vector);
    this.z = m.row(2).dotProduct(vector);
    return this;
  };

  return Point;
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis.categoryAxisCore',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
}
],
function Setup(TextUtils, NumberUtils, Objects, langManager, TypeUtils, Point, matrix, FormatManager) {

  return function() {
        
        var m_position;
        var m_axScale;
        var m_selection;

        var m_textOffset;
        var m_tickSize = 5;
        
        var m_styleLineSrokeWidth = 1;
        var m_styleGridLineColor = "#d8d8d8";
        var m_axLabelClassName = "viz-axis-label";   
        
        var m_labelAreaMouseOverColor = "#cccccc";
        var m_labelAreaMouseDownColor = "#808080";

        var m_disableSpaceLimit = false;
        
        var m_style = null; //used to hold style passed from axis
        var m_props = 
        { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": false, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "formatString": "", hideStrategy : '' },
            "position": "left",
            "color": "#333333",
            "shapeRendering": true,
            "forceVerticalFont": false
        }; 

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
        };

        var m_matrix = matrix(), labelAngle = null, labelAlign=null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;

            if(!m_disableSpaceLimit)
            {
                m_spaceLimit = _spaceLimit;
            }

            return axis;
        }

        var adjustScale = function()
        {
            //we have to adjust the scale because we may not draw all the levels.
            var scaleToDraw = [];
            var isMultilayer = m_axScale.length > 1 ? true : false;
            if(isMultilayer){
                m_textOffset= 6;
            }else{
                m_textOffset= 11;
            }
            
            for(var iScale = 0; iScale < m_axScale.length; iScale++)
            {
                var axDomain = m_axScale[iScale].domain;//["a", "b"]
                var axRange = m_axScale[iScale].range;//[[0, 100], [100. 200], ...]

                //count the max text size
                var re = maxLabelTextHeight(axDomain, axRange);
                var isVertical = re.isVertical;

                if(m_position == "left" || m_position == "right")
                {
                    m_axScale[iScale].labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange, isMultilayer);
                }
                else
                {
                    m_axScale[iScale].labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical, isMultilayer);
                }
                
                if(iScale === 0){
                  scaleToDraw.push(m_axScale[iScale]);
                }
                else if(m_axScale[iScale].labelsToDraw.length == m_axScale[iScale].domain.length)
                {
                  scaleToDraw.push(m_axScale[iScale]);
                }
                //for mekko chart ,the scale is not equal. So if a label can be draw, we should draw the whole layer.
                else if(m_axScale[iScale].labelsToDraw.length > 0 && TypeUtils.isExist(m_axScale.noEqual)&&m_axScale.noEqual === true )
                {
                  scaleToDraw.push(m_axScale[iScale]);
                }
            }
            return scaleToDraw;
        }
        
        var drawGridLine = function(selection, x1, y1, x2, y2){
          var gridline = selection.append("line")
                          .attr("y1", y1)
                          .attr("y2", y2)
                          .attr("x1", x1)
                          .attr("x2", x2)
                          .attr("stroke", m_props.gridline.color)
                          .attr("stroke-width", m_props.gridline.size)
                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
          if(m_props.gridline.type == "dotted")
          {
               gridline.attr("stroke-dasharray", "3, 2");
          }                        
        };

        function axis(selection)
        {
            m_selection = selection;
            //we have to adjust the scale
            var scaleToDraw = adjustScale();

            //---we should dicide show or hide somethings because of the spaceLimit
            if(m_spaceLimit >= 0)
            {
                var scaleToAdjust = [];
                var spacings = axis.getPreferredSize().spacings;
                var spaceLeft = m_spaceLimit;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        scaleToAdjust.push(scaleToDraw[i]);
                        spaceLeft -= spacings[i];
                    }
                    else
                    {
                        break;
                    }
                }

                if(scaleToAdjust.length == 0 && scaleToDraw.length > 0)
                {
                    //scaleToAdjust.push(scaleToDraw[0]);//always draw one
                    var lastDomain = [];
                    for (var i = 0; i < scaleToDraw[0].domain.length; i++) {
                        lastDomain.push('');
                    }
                    scaleToAdjust.push({
                            domain : lastDomain, 
                            range : scaleToDraw[0].range
                        });
                }

                scaleToDraw = scaleToAdjust;
            }
            //------------------------------------------------------
            var isMultilayer = scaleToDraw.length > 1 ? true : false;
            if(m_position == "left")
            {
                var iDraw = 0;
                var lastLevelWidth = 0;
                
                for(var iScale = 0; iScale < scaleToDraw.length; iScale++, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextWidth(axDomain, axRange);
                    var maxTextWidth = re.maxLabelTextWidth;
                    //var isVertical = re.isVertical;

                    if(!m_props.label.visible)
                    {
                        maxTextWidth = 0;
                    }
                    
                    
                      
                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                  axRange[axRange.length-1][1], 
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                  axRange[axRange.length-1][1]);
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                  axRange[0][0], 
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                  axRange[0][0]);
                        }
                    }

                    ///////////////drawing the most inner vertical line////////////////
                    if( scaleToDraw.length == 1 ) {
                        ////////////////in single case, also include the first and last tick////////
                        //<path d="M150 0 L75 200 L225 200 Z" />
                        var x1 = lastLevelWidth + (maxTextWidth + 2*m_textOffset);
                        var x2 = lastLevelWidth + (maxTextWidth + 2*m_textOffset);
                        var y1 = axRange[0][0];
                        var y2 = axRange[axRange.length-1][1];
                        if(m_props.axisline.visible){
                        var dPath  = "M" + (x1-m_tickSize) + " " + y1
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2-m_tickSize) + " " + y2;

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                        }

                    }else if(scaleToDraw.length >= 2 && (iScale == scaleToDraw.length -1)) {
                        var axLine = selection.append("line")
                                    .attr("x1", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                                    .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                                    .attr("y1", axRange[0][0])
                                    .attr("y2", axRange[axRange.length-1][1])
                                    .attr("class", "domain")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    /////////////// end of drawing the most inner vertical line////////////////


                    ///////////////drawing vertical line for each level, based on lastLevelWidth///// 
                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", lastLevelWidth)
                        .attr("x2", lastLevelWidth)
                        .attr("y1", axRange[0][0])
                        .attr("y2", axRange[axRange.length-1][1])
                        .attr("class", "domain")
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    ///////////////end of drawing vertical line for each level, based on lastLevelWidth/////

                    //draw gridline in the last scaleToDraw///////////////////////
                    //FIXME Jimmy/9/22/2012 currently the grid line only used for
                    //multi charts. we have a bug for the last gridline here, if for example
                    //we draw gridline for yaxis on [i][1], then the last gridline
                    //will override xaxis. so we have to seperate last gridline
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][0]);
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][1], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][1]);
                        }
                      }
                      //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
                      drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length,
                                axRange[0][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length,
                                axRange[i - 1][1]
                                );
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////


                    for(var i = 0; i < axDomain.length; i++)
                    {
                        /////////////////////////////draw tick for single case, horizontal line for multi case////////
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {

                          //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][0] will not be equal with axRange[i-1][1]?
                          if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                          {
                              var axTick1 = selection.append("line")
                                          .attr("x1", (maxTextWidth + 2*m_textOffset) - m_tickSize)
                                          .attr("x2", (maxTextWidth + 2*m_textOffset))
                                          .attr("y1", axRange[i][0])
                                          .attr("y2", axRange[i][0])
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");

                          }
                          
                          ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                          if(i != (axDomain.length - 1)){
                            var axTick2 = selection.append("line")
                                        .attr("x1", (maxTextWidth + 2*m_textOffset) - m_tickSize)
                                        .attr("x2", (maxTextWidth + 2*m_textOffset))
                                        .attr("y1", axRange[i][1])
                                        .attr("y2", axRange[i][1])
                                        .attr("stroke", m_props.color)
                                        .attr("stroke-width", m_props.lineSize)
                                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                          }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", lastLevelWidth)
                            .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                            .attr("y1", axRange[i][0])
                            .attr("y2", axRange[i][0])
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            
                            //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", lastLevelWidth)
                              .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                              .attr("y1", axRange[i][1])
                              .attr("y2", axRange[i][1])
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto"); 
                            }
                        }
                        /////////////////////////////draw tick for single case, horizontal line for multi case////////
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    var customlabelCfg;
                    for(var i = 0; i < labelsToDraw.length; i++)
                    {
                      customlabelCfg = labelsToDraw[i].custom;
                      if(customlabelCfg && customlabelCfg.type === 'url'){
                        //draw as an icon, same size as text
                      }else{
                        var m_label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                        if(m_props.label.visible)
                        {
                            var labelG = selection;
                            
                            var offsetForBorder = 1;
                            var labelRectX = lastLevelWidth + offsetForBorder;

                            var rect = labelG.append("rect")
                              .attr("x", labelRectX)
                              .attr("y", labelsToDraw[i].startY + offsetForBorder)
                              .attr("width", maxTextWidth + 2*m_textOffset - offsetForBorder)
                              .attr("height", labelsToDraw[i].rectHeight - offsetForBorder)
                              .attr("opacity", 0)
                              .attr("class","v-labelarea");

                            rect.node().labelContexts = labelsToDraw[i].labelContexts;

                            //selection.append("circle").attr("cx", lastLevelWidth + maxTextWidth - m_textOffset).attr("cy", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2). attr("r", 3);
                            var axLabels = labelG
                                          .append("g")                          
                                          .attr("fill", m_style.defaultStyle.label.fill)
                                          .attr("class", m_vClassNames.axisLabel + " " + m_axLabelClassName)
                                          .attr("font-size", m_style.defaultStyle.label['font-size'])
                                          .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                                          .attr("font-family", m_style.defaultStyle.label['font-family'])
                                          .append("text")
                                          .attr("pointer-events","none")
                                          .attr("x", lastLevelWidth + maxTextWidth + m_textOffset)
                                          .attr("y", labelsToDraw[i].y)
                                          .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                          .attr("text-anchor", "end") // text-align
                                          .text(m_label);

                            adjustLabelForIE(axLabels);
                        }   
                      }
                    }

                    lastLevelWidth += (maxTextWidth + 2*m_textOffset);
                }
            }
            else if(m_position == "right")
            {
                var iDraw = 0;
                var lastLevelWidth = 0;
                
                for(var iScale = (scaleToDraw.length-1); iScale >= 0; iScale--, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextWidth(axDomain, axRange);
                    var maxTextWidth = re.maxLabelTextWidth;
                    //var isVertical = re.isVertical;

                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth, 
                                  axRange[axRange.length-1][1], 
                                  lastLevelWidth-m_props.gridline.length, 
                                  axRange[axRange.length-1][1]);
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth, 
                                  axRange[0][0], 
                                  lastLevelWidth-m_props.gridline.length, 
                                  axRange[0][0]);
                        }
                    }

                    if((scaleToDraw.length == 1) )
                    {
                        //<path d="M150 0 L75 200 L225 200 Z" />
                        var x1 = lastLevelWidth;
                        var x2 = lastLevelWidth;
                        var y1 = axRange[0][0];
                        var y2 = axRange[axRange.length-1][1];

                        var dPath  = "M" + (x1+m_tickSize) + " " + y1
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x1+m_tickSize) + " " + y2;

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    else if(scaleToDraw.length >= 2 && (iScale == (scaleToDraw.length-1)) ) 
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", lastLevelWidth)
                                    .attr("x2", lastLevelWidth)
                                    .attr("y1", axRange[0][0])
                                    .attr("y2", axRange[axRange.length-1][1])
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                        .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                        .attr("y1", axRange[0][0])
                        .attr("y2", axRange[axRange.length-1][1])
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][0]);
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][1], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][1]);
                        }
                      }

                    }

                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", 0)
                                            .attr("x2", m_tickSize)
                                            .attr("y1", axRange[i][0])
                                            .attr("y2", axRange[i][0])
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            if(i != (axDomain.length - 1)){
                              var axTick2 = selection.append("line")
                                          .attr("x1", 0)
                                          .attr("x2", m_tickSize)
                                          .attr("y1", axRange[i][1])
                                          .attr("y2", axRange[i][1])
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", lastLevelWidth)
                            .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                            .attr("y1", axRange[i][0])
                            .attr("y2", axRange[i][0])
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", 1)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", lastLevelWidth)
                              .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                              .attr("y1", axRange[i][1])
                              .attr("y2", axRange[i][1])
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    var customlabelCfg;
                    for(var i = 0; i < labelsToDraw.length; i++)
                    {
                      customlabelCfg = labelsToDraw[i].custom;
                      if(customlabelCfg && customlabelCfg.type === 'url'){
                        //draw as an icon, same size as text
                      }else{
                        var m_label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                        if(m_props.label.visible)
                        {
                            var labelG = selection;
                            
                            //var offsetForBorder = 1;
                            //var labelRectX = lastLevelWidth + offsetForBorder;

                            //var rect = labelG.append("rect")
                            //  .attr("x", labelRectX)
                            //  .attr("y", labelsToDraw[i].startY + offsetForBorder)
                            //  .attr("width", maxTextWidth + 2*m_textOffset - offsetForBorder)
                            //  .attr("height", labelsToDraw[i].rectHeight - offsetForBorder)
                            //  .attr("opacity", 0)
                            //  .attr("class","v-labelarea");

                            //rect.node().labelContexts = labelsToDraw[i].labelContexts;
                            //selection.append("circle").attr("cx", lastLevelWidth + 100000).attr("cy", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2). attr("r", 3);
                            var axLabels = labelG
                                          .append("g")                          
                                          .attr("fill", m_style.defaultStyle.label.fill)
                                          .attr("class", m_vClassNames.axisLabel + " " + m_axLabelClassName)
                                          .attr("font-size", m_style.defaultStyle.label['font-size'])
                                          .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                                          .attr("font-family", m_style.defaultStyle.label['font-family'])
                                          .append("text")
                                          .attr("x", lastLevelWidth + m_textOffset)
                                          .attr("y", labelsToDraw[i].y)
                                          .attr("text-anchor", "start") // text-align
                                          .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                          .text(m_label);

                            adjustLabelForIE(axLabels);
                        }
                      }
                    }
                    
                    lastLevelWidth += (maxTextWidth + 2*m_textOffset);
                }
            }
            else if(m_position == "bottom")
            {
                var iDraw = 0;
                var lastLevelHeight = 0;
                
                for(var iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextHeight(axDomain, axRange);
                    var maxTextHeight = re.maxLabelTextHeight;
                    var isVertical = re.isVertical;

                    if(iScale == (scaleToDraw.length - 1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  axRange[0][0],  
                                  lastLevelHeight, 
                                  axRange[0][0],
                                  lastLevelHeight-m_props.gridline.length
                                  );
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  axRange[axRange.length-1][0],  
                                  lastLevelHeight, 
                                  axRange[axRange.length-1][0],
                                  lastLevelHeight-m_props.gridline.length
                                  );
                        }
                    }

                    if(scaleToDraw.length == 1)
                    {
                        var x1 = axRange[0][0];
                        var x2 = axRange[axRange.length-1][1];
                        var y1 = lastLevelHeight;
                        var y2 = lastLevelHeight;

                        var dPath  = "M" + x1 + " " + (y1+m_tickSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2+m_tickSize);
                    if(m_props.axisline.visible){
                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                        
                        if(angle){
                          var aAngle = angle * Math.PI /180;
                          var cosAngle = Math.cos(aAngle);
                          var sinAngle = (45 == angle)? cosAngle: Math.sin(aAngle); 
                          dPath = 'M ' + axRange[0][0] + ' ' + lastLevelHeight;
                          dPath += 'L' + (axRange[0][0] + axRange[axRange.length-1][1] * sinAngle) + ' ' + (lastLevelHeight - axRange[axRange.length-1][1] * cosAngle);
                          dPath += 'Z';
                          
                          axLine.attr('d', dPath);
                        }
                        }
                    }
                    else if( scaleToDraw.length >= 2 && (iScale == scaleToDraw.length-1) )
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", axRange[0][0])
                                    .attr("x2", axRange[axRange.length-1][1])
                                    .attr("y1", lastLevelHeight)
                                    .attr("y2", lastLevelHeight)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", axRange[0][0])
                        .attr("x2", axRange[axRange.length-1][1])
                        .attr("y1", lastLevelHeight + maxTextHeight + 2*m_textOffset)
                        .attr("y2", lastLevelHeight + maxTextHeight + 2*m_textOffset)
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    
                    //draw gridline in the last scaleToDraw///////////////////////
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset),
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset), 
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        }
                      }
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////


                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", axRange[i][0])
                                            .attr("x2", axRange[i][0])
                                            .attr("y1", 0)
                                            .attr("y2", m_tickSize)
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            if(i != (axDomain.length - 1)){
                              var axTick2 = selection.append("line")
                                          .attr("x1", axRange[i][1])
                                          .attr("x2", axRange[i][1])
                                          .attr("y1", 0)
                                          .attr("y2", m_tickSize)
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                              
                              if(angle){
                                var aAngle = angle * Math.PI /180;
                                var cosAngle = Math.cos(aAngle);
                                var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                                var tAngle = tickAngle * Math.PI / 180;
                                var cosTAngle = Math.cos(tAngle);
                                var sinTAngle = Math.sin(tAngle);
                                
                                var tickStartX  =   axRange[i][1] * sinAngle;
                                tickStartY =  -axRange[i][1] * cosAngle;
                                var x2 = tickStartX + m_tickSize * cosTAngle,
                                  y2 = tickStartY + m_tickSize * sinTAngle;
                                  
                                axTick2.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);  
                                }
                              
                            }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", axRange[i][0])
                            .attr("x2", axRange[i][0])
                            .attr("y1", lastLevelHeight)
                            .attr("y2", lastLevelHeight + 2*m_textOffset + maxTextHeight)
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                             
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", axRange[i][1])
                              .attr("x2", axRange[i][1])
                              .attr("y1", lastLevelHeight)
                              .attr("y2", lastLevelHeight + 2*m_textOffset + maxTextHeight)
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length != 1);

                    lastLevelHeight += (maxTextHeight + 2*m_textOffset);
                }
            }
            else if(m_position == "top")
            {
                var iDraw = 0;
                var lastLevelHeight = 0;
                
                for(var iScale = 0; iScale < scaleToDraw.length; iScale++, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextHeight(axDomain, axRange);
                    var maxTextHeight = re.maxLabelTextHeight;
                    var isVertical = re.isVertical;

                    if(!m_props.label.visible)
                    {
                        maxTextHeight = 0;
                    }

                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  axRange[0][0],  
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight, 
                                  axRange[0][0],
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight+m_props.gridline.length
                                  );
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  axRange[axRange.length-1][1],  
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight, 
                                  axRange[axRange.length-1][1],
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight+m_props.gridline.length
                                  );
                        }
                    }

                    if( (scaleToDraw.length == 1) )
                    {
                        var x1 = axRange[0][0];
                        var x2 = axRange[axRange.length-1][1];
                        var y1 = maxTextHeight + 2*m_textOffset + lastLevelHeight;
                        var y2 = maxTextHeight + 2*m_textOffset + lastLevelHeight;

                        var dPath  = "M" + x1 + " " + (y1-m_tickSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2-m_tickSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    else if( scaleToDraw.length >= 2 && (iScale == scaleToDraw.length-1) )
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", axRange[0][0])
                                    .attr("x2", axRange[axRange.length-1][1])
                                    .attr("y1", maxTextHeight + 2*m_textOffset + lastLevelHeight)
                                    .attr("y2", maxTextHeight + 2*m_textOffset + lastLevelHeight)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", axRange[0][0])
                        .attr("x2", axRange[axRange.length-1][1])
                        .attr("y1", lastLevelHeight)
                        .attr("y2", lastLevelHeight)
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                    }
                    
                    //draw gridline in the last scaleToDraw///////////////////////
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset),
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset), 
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        }
                      }
                      //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
                      drawGridLine(selection,
                                axRange[0][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i - 1][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////

                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", axRange[i][0])
                                            .attr("x2", axRange[i][0])
                                            .attr("y1", (maxTextHeight + 2*m_textOffset))
                                            .attr("y2", (maxTextHeight + 2*m_textOffset)-m_tickSize)
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                            ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                          if(i != (axDomain.length - 1)){
                            var axTick2 = selection.append("line")
                                        .attr("x1", axRange[i][1])
                                        .attr("x2", axRange[i][1])
                                        .attr("y1", (maxTextHeight + 2*m_textOffset))
                                        .attr("y2", (maxTextHeight + 2*m_textOffset)-m_tickSize)
                                        .attr("stroke", m_props.color)
                                        .attr("stroke-width", m_props.lineSize)
                                        .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                          }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", axRange[i][0])
                            .attr("x2", axRange[i][0])
                            .attr("y1", lastLevelHeight)
                            .attr("y2", lastLevelHeight + (maxTextHeight + 2*m_textOffset))
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                             
                            //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", axRange[i][1])
                              .attr("x2", axRange[i][1])
                              .attr("y1", lastLevelHeight)
                              .attr("y2", lastLevelHeight + (maxTextHeight + 2*m_textOffset))
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        }
                    }

                    var labelsToDraw = scaleToDraw[iScale].labelsToDraw;
                    drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length != 1);
                    lastLevelHeight += (maxTextHeight + 2*m_textOffset);
                }
            }

        };

        var adjustLabelForIE = function(text)
        {
            if(jQuery.browser.msie)
            {
                //dominant-baseline does not work
                var textHeight = m_style.realStyle.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.realStyle.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        //get customlabel text from from the rawObj, if the type is url, return the original text
        var getCustomlabelText = function(rawObj){
          var ret;
          if(rawObj.info){
            var clobj = rawObj.info.customlabel;
            if(clobj){
              if(clobj.type === 'url'){
                ret = rawObj.val;
              }else if(clobj.type === 'string'){
                ret = clobj.val;
              }
            }else{
              ret = rawObj.val;
            }
          }else{
            ret = rawObj.val;
          }
          //so we will first resolve customlabel and then do format
          ret = isInvalidString(ret) ? langManager.get('IDS_ISNOVALUE'): ret;
          ret = FormatManager.format(ret, m_props.label.formatString);
          return ret;
        };
        
        var getCustomlabelCfg = function(rawObj){
          if(rawObj.info && rawObj.info.customlabel){
            return rawObj.info.customlabel;
          }
        };
        
        var buildLeftRightToDrawLabels = function(allLabels, allLabelsLocation, isMultilayer)
        {
          //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
            //we always draw the bottom label for yAxis.

            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var fullHeight = 0;
            var allTicksLabels = [];
            for(var i = 0; i < allLabels.length; i++)
            {
                var item = {};
                item.text = getCustomlabelText(allLabels[i]);
                item.custom = getCustomlabelCfg(allLabels[i]);
                item.labelContexts = allLabels[i].labelContexts;
                //count y1 and y2
                var itemMeasure = fastMeasure (item.text, m_style.realStyle.label);
                var centerY = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0])/2;
                item.width = itemMeasure.width;
                item.height = itemMeasure.height;
                item.startY = allLabelsLocation[i][0];
                item.rectHeight = allLabelsLocation[i][1] - allLabelsLocation[i][0];
                item.y = centerY;
                item.y1 = centerY - item.height/2;
                item.y2 = centerY + item.height/2;
                allTicksLabels.push(item);

                fullHeight += item.rectHeight;
            }

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];
            if(m_props.label.hideStrategy != 'greedy'){
                for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
                {
                    var isDrawable = true;
                    for(var i = (allTicksLabels.length - 1); i >= 0 ; i-=(iBeyond+1))
                    {   
                        var item = allTicksLabels[i];
                        if(i != (allTicksLabels.length - 1))
                        {
                            var previousIndex = i + (iBeyond+1);

                                if(allTicksLabels[i].y2 >= allTicksLabels[previousIndex].y1)
                                {
                                    isDrawable = false;
                                    break;
                                }
                        }

                        if(item.height > fullHeight)
                        {
                            break;
                        }

                        ticksLabelsToDraw.push(item);
                    }
                    if(isDrawable)
                    {
                        break;
                    }
                    else
                    {
                        ticksLabelsToDraw = [];
                    }
                }
            }else{
                
              for(var previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >=0; iBeyond--){
                    var item = allTicksLabels[iBeyond];
                     
                     if(previousIndex === iBeyond&&allLabelsLocation[iBeyond][1]!=allLabelsLocation[iBeyond][0]){
                          if(isMultilayer && item.y1>allLabelsLocation[iBeyond][0]&&item.y2<allLabelsLocation[iBeyond][1]){
                            ticksLabelsToDraw.push(item);
                          }else if(!isMultilayer){
                            if(item.height <= fullHeight)
                            {
                                ticksLabelsToDraw.push(item);
                            }
                          }
                     }else{
                        if(item.y2 <= allTicksLabels[previousIndex].y1&&allLabelsLocation[iBeyond][1]!=allLabelsLocation[iBeyond][0]){
                            if(isMultilayer)
                            {
                              //if have more than one layers, need to detecte whether the label is between gridlines
                              if(item.y1>allLabelsLocation[iBeyond][0]&&item.y2<allLabelsLocation[iBeyond][1])
                              {
                                ticksLabelsToDraw.push(item);
                                previousIndex = iBeyond;
                              }
                            }
                            else
                            {
                            //if have only one layer , just need to detecte whether overlap is exist
                              ticksLabelsToDraw.push(item);
                              previousIndex = iBeyond;
                            }
                        }
                     }
                  }
            }
            
            if(ticksLabelsToDraw.length === 1)
            {
                if(ticksLabelsToDraw[0].height > ticksLabelsToDraw[0].rectHeight)
                {
                    ticksLabelsToDraw = [];
                }
            }            

            return ticksLabelsToDraw;
        }

        var buildTopBottomToDrawLabels = function(allLabels, allLabelsLocation, isVertical, isMultilayer)
        {
          //Jimmy/12/26/2012 extend allLabels from stringArray to objectArray to support customlabel
            //we always draw the first label for xAxis.

            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var fullWidth = 0;
            var allTicksLabels = [];
            for(var i = 0; i < allLabels.length; i++)
            {
                var item = {};
                item.text = getCustomlabelText(allLabels[i]);
                item.custom = getCustomlabelCfg(allLabels[i]);
                item.labelContexts = allLabels[i].labelContexts;
                //count x1 and x2
                var itemMeasure = fastMeasure (item.text, m_style.realStyle.label);
                if(isVertical)
                {
                    item.width = itemMeasure.height;
                    item.height = itemMeasure.width;
                }
                else
                {
                    item.width = itemMeasure.width;
                    item.height = itemMeasure.height;
                }

                var centerX = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0])/2;

                item.x = centerX;
                item.x1 = centerX - item.width/2;
                item.x2 = centerX + item.width/2;

                item.startX = allLabelsLocation[i][0];
                item.rectWidth = allLabelsLocation[i][1] - allLabelsLocation[i][0];
                
                allTicksLabels.push(item);

                fullWidth += item.rectWidth;
            }

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];
            if(m_props.label.hideStrategy != 'greedy'){
              for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
              {
                  var isDrawable = true;
                  for(var i = 0; i < allTicksLabels.length; i+=(iBeyond+1))
                  {   
                      var item = allTicksLabels[i];
                      if(i != 0)
                      {
                          var previousIndex = i - (iBeyond+1);

                          if(allTicksLabels[i].x1 <= allTicksLabels[previousIndex].x2 || allLabelsLocation[iBeyond][1] === allLabelsLocation[iBeyond][0])
                          {
                              isDrawable = false;
                              break;
                          }
                      }
                      
                      if(item.width > fullWidth)
                      {
                          break;
                      }
                      
                      ticksLabelsToDraw.push(item);
                  }
                  if(isDrawable)
                  {
                      break;
                  }
                  else
                  {
                      ticksLabelsToDraw = [];
                  }
              }
            }else{

              for(var previousIndex = iBeyond = (allTicksLabels.length - 1); iBeyond >=0; iBeyond--){
                    var item = allTicksLabels[iBeyond];
                     
                     if(previousIndex === iBeyond && allLabelsLocation[iBeyond][1] != allLabelsLocation[iBeyond][0]){
                        if(isMultilayer && item.x1 > allLabelsLocation[iBeyond][0] && item.x2 < allLabelsLocation[iBeyond][1]){
                          ticksLabelsToDraw.push(item);
                        }else if(!isMultilayer){
                          if(item.width <= fullWidth)
                          {
                              ticksLabelsToDraw.push(item);
                          }
                        }
                     }else{
                        if(item.x2 <= allTicksLabels[previousIndex].x1&&allLabelsLocation[iBeyond][1]!=allLabelsLocation[iBeyond][0]){
                        if(isMultilayer)
                        {
                            //if have more than one layers, need to detecte whether the label is between gridlines
                            if(item.x1>allLabelsLocation[iBeyond][0]&&item.x2<allLabelsLocation[iBeyond][1])
                            {
                              ticksLabelsToDraw.push(item);
                              previousIndex = iBeyond;
                            }
                          }
                          else
                          {
                          //if have only one layer , just need to detecte whether overlap is exist
                            ticksLabelsToDraw.push(item);
                            previousIndex = iBeyond;
                          }
                        }
                     }
                  }
            }

            if(ticksLabelsToDraw.length === 1)
            {
                if(ticksLabelsToDraw[0].width > ticksLabelsToDraw[0].rectWidth)
                {
                    ticksLabelsToDraw = [];
                }
            }
            
            return ticksLabelsToDraw;
        }

        var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical)
        {
            if (labelsToDraw === undefined) {
              return;
            }

            for(var i = 0; i < labelsToDraw.length; i++)
            {
              var label = TypeUtils.isExist(labelsToDraw[i].text)? labelsToDraw[i].text:'';
                if(m_props.label.visible)
                {
                  if(angle){
                    var labelAreaOffset = 2;

                    var aAngle = angle * Math.PI /180;
                    var cosAngle = Math.cos(aAngle);
                    var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                    var tAngle = tickAngle * Math.PI / 180;
                    var cosTAngle = Math.cos(tAngle);
                    var sinTAngle = Math.sin(tAngle);
                    
                    var tickStartX = labelsToDraw[i].x * sinAngle;
                    tickStartY = - labelsToDraw[i].x * cosAngle;

                    var labelTextX = tickStartX + ( m_tickSize + m_textOffset ) * cosTAngle;
                    var labelTextY = tickStartY + lastLevelHeight + ( m_textOffset + m_tickSize ) * sinTAngle;

                    var labelAreaX = labelTextX - labelAreaOffset;
                    var labelAreaY = labelTextY - labelsToDraw[i].width/2 - labelAreaOffset;
                    var labelAreaWidth = labelsToDraw[i].height + 2*labelAreaOffset;//the text is vertical
                    var labelAreaHeight = labelsToDraw[i].width + 2*labelAreaOffset;

                    //for debug
                    //selection.append("circle").attr("cx", tickStartX).attr("cy", tickStartY).attr("r", 3);
                    if(tickAngle > 90)
                    {
                        labelAreaX -= (labelAreaWidth - 2*labelAreaOffset);
                    }

                    //label G
                    var axLabels = selection
                            .append("g")
                            .attr("fill", m_style.defaultStyle.label.fill)
                            .attr("class", m_vClassNames.axisLabel + " " + m_axLabelClassName)
                            .attr("font-size", m_style.defaultStyle.label['font-size'])
                            .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                            .attr("font-family", m_style.defaultStyle.label['font-family']);

                    //draw labelArea
                    var labelArea = axLabels.append("rect")
                                  .attr("x", labelAreaX)
                                  .attr("y", labelAreaY)
                                  .attr("width",labelAreaWidth)
                                  .attr("height", labelAreaHeight)
                                  .attr("opacity", 0)
                                  .attr("class","v-labelarea");
                    labelArea.node().labelContexts = labelsToDraw[i].labelContexts;

                    //draw label text
                    var axLabelText = axLabels.append("text")
                            .attr("x", labelTextX)
                            .attr("y", labelTextY)
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", 'start') // text-align
                            .attr("pointer-events","none")
                            .text(label);
                            
                    if(tickAngle > 90){
                      axLabelText.attr("text-anchor", 'end');
                      axLabels.attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' + labelTextX + ' ' + labelTextY + ')');
                    }else{
                    axLabels.attr('transform', 'rotate( ' + (tickAngle) + ' ' + labelTextX + ' ' + labelTextY + ')');
                    }
                  }else{
                    var labelG = selection;

                    if(m_position === "bottom")
                    {
                        var offsetForBorder = 1;

                        var rect = labelG.append("rect")
                          .attr("x", labelsToDraw[i].startX)
                          .attr("y", lastLevelHeight + offsetForBorder)
                          .attr("width", labelsToDraw[i].rectWidth)
                          .attr("height", maxTextHeight + 2*m_textOffset - offsetForBorder)
                          .attr("opacity", 0)
                          .attr("class","v-labelarea");

                        rect.node().labelContexts = labelsToDraw[i].labelContexts;
                    }
                    else if(m_position === "top")
                    {
                        var rect = labelG.append("rect")
                          .attr("x", labelsToDraw[i].startX)
                          .attr("y", lastLevelHeight)
                          .attr("width", labelsToDraw[i].rectWidth)
                          .attr("height", maxTextHeight + 2*m_textOffset)
                          .attr("opacity", 0)
                          .attr("class","v-labelarea");

                        rect.node().labelContexts = labelsToDraw[i].labelContexts;
                    }

                    //selection.append("circle").attr("cx", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2).attr("cy", lastLevelHeight + maxTextHeight/2 + m_textOffset). attr("r", 5);                               
                    var axLabels = labelG
                                    .append("g")
                                    .attr("fill", m_style.defaultStyle.label.fill)
                                    .attr("class", m_vClassNames.axisLabel + " " + m_axLabelClassName)
                                    .attr("font-size", m_style.defaultStyle.label['font-size'])
                                    .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                                    .attr("font-family", m_style.defaultStyle.label['font-family'])                        
                                    .append("text")
                                    .attr("pointer-events","none")
                                    .attr("x", labelsToDraw[i].x)
                                    .attr("y", lastLevelHeight + maxTextHeight/2 + m_textOffset)
                                    .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                    .attr("text-anchor", "middle") // text-align
                                    .text(label);
                      
                      if(isVertical)
                      {
                          if(!isHierarchical){
                            if(m_position == 'top'){
                              axLabels.attr('text-anchor', 'start')
                              .attr("y", lastLevelHeight + maxTextHeight + m_textOffset);
                            }else if(m_position == 'bottom'){
                              axLabels.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                            }
                          }
                          
                          var ac = "-90";
                          axLabels.attr("transform","rotate( " + ac + " " + axLabels.attr("x") + " "  + axLabels.attr("y") + " )");
                         
                      }
                      adjustLabelForIE(axLabels);
                  }
                }
            }
        };
        
        axis.mouseover = function(target){
            //high light the target
            target.setAttribute("opacity", 1);
            target.setAttribute("class", "v-labelarea v-hovershadow");
            target.setAttribute("fill", m_labelAreaMouseOverColor);
        };
        
        axis.mouseout = function(target){
            //un high light all the label areas
            target.setAttribute("class", "v-labelarea");
            target.setAttribute("opacity", 0); 
        };   
        
        axis.cleanLabelAreas = function()
        {
            if(m_selection)
            {
                m_selection.selectAll(".v-labelarea")
                           .attr("class", "v-labelarea")
                           .attr("opacity", 0);
            }
        };

        axis.mouseup = function(target){
            //un high light the target
            target.setAttribute("opacity", 1);
            target.setAttribute("class", "v-labelarea v-hovershadow");            
            target.setAttribute("fill", m_labelAreaMouseOverColor); 
        };
        
        axis.mousedown = function(target){
            //high light the target
            target.setAttribute("opacity", 1); 
            target.setAttribute("class", "v-labelarea v-hovershadow-mousedown");
            target.setAttribute("fill", m_labelAreaMouseDownColor);
        };      

        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = Objects.extend(true, m_props, _properties);
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.getPreferredSize = function() {

            var scaleToDraw = adjustScale();

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            for(var i = 0; i < scaleToDraw.length; i++)
            {
                if(!m_props.label.visible && i != (scaleToDraw.length-1))
                {
                    continue;
                }

                var axDomain = scaleToDraw[i].domain;//["a", "b"]
                var axRange = scaleToDraw[i].range;//[[0, 100], [100. 200], ...]

                if(axDomain.length === 0 || axRange.length === 0)
                {
                    continue;
                }

                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = Math.abs(axRange[axRange.length-1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
                    
                    var offsetHeight = 0;
                    if(m_props.label.visible)
                    {
                        offsetHeight += maxLabelTextHeight(axDomain, axRange).maxLabelTextHeight;
                    }

                    offsetHeight += 2*m_textOffset;
                    axisHeight += offsetHeight;

                    axisSpacings.push(offsetHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    var offsetWidth = 0;

                    if(m_props.label.visible)
                    {
                        offsetWidth += maxLabelTextWidth(axDomain, axRange).maxLabelTextWidth;
                    }
                    offsetWidth += 2*m_textOffset;

                    axisWidth += offsetWidth;
                    axisSpacings.push(offsetWidth);

                    axisHeight = Math.abs(axRange[axRange.length-1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
                }
            }

            //--------------
            if(m_spaceLimit >= 0)
            {
                var spacings = axisSpacings;
                var spaceLeft = m_spaceLimit;

                var spacingToDraw = 0;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        spacingToDraw += spacings[i];
                        spaceLeft -= spacings[i];
                    }
                    else
                    {
                        break;
                    }
                }

                if(spacingToDraw == 0 && spacings.length > 0)
                {
                    spacingToDraw += spacings[0];
                }


                if(m_position == "bottom" || m_position == "top")
                {
                    axisHeight = spacingToDraw;
                }
                else if(m_position == "left" || m_position == "right")
                {
                    axisWidth = spacingToDraw;
                }
            }

            //------------------------------------

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,
            };
        };

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        var resolveMaxAndMinInDomain = function(domain, rangeArray){
          var heightArray = [];
          var widthArray = [];
          var isVerticalFont = false;
          for(var i = 0; i < domain.length; i++)
          {
              var tSize = fastMeasure( getCustomlabelText(domain[i]) , m_style.realStyle.label);

              var tHeight = tSize.height;
              var tWidth = tSize.width;
              var interval = rangeArray[i][1]-rangeArray[i][0];

              if((tHeight < tWidth) && interval!=0 && tWidth > interval )
              {
                  if(m_position == "top" || m_position == "bottom")
                  {
                      isVerticalFont = true;
                  }
              }

              heightArray.push(tHeight);
              widthArray.push(tWidth);
          }
          
          return {
            'heights' : heightArray,
            'widths' : widthArray,
            'isVerticalFont' : isVerticalFont
          };
        };
        
        var maxLabelTextHeight = function (domain, rangeArray)
        {
          //Jimmy/10/26/2012 we extend domain from string array to object to support customlabel
            var re = {"maxLabelTextHeight": 0, "isVertical": false};
            var maxTextHeight = 0;
            var isVerticalFont = false;
            var sizes = resolveMaxAndMinInDomain(domain, rangeArray);
            isVerticalFont = m_props.forceVerticalFont === true ? true: sizes.isVerticalFont;
            
            for(var i = 0; i < domain.length; i++)
            {
                if(isVerticalFont)
                {
                    if(maxTextHeight < sizes.widths[i])
                    {
                        maxTextHeight = sizes.widths[i];
                    }
                }
                else
                {
                    if(maxTextHeight < sizes.heights[i])
                    {
                        maxTextHeight = sizes.heights[i];
                    }
                }
            }
            re.maxLabelTextHeight = maxTextHeight;
            re.isVertical = isVerticalFont;
            return re;
        };

        var maxLabelTextWidth = function (domain, rangeArray)
        {
            var re = {"maxLabelTextWidth": 0, "isVertical": false};
            var maxTextWidth = 0;
            var isVerticalFont = false;
            var sizes = resolveMaxAndMinInDomain(domain, rangeArray);
            isVerticalFont = m_props.forceVerticalFont === true ? true: sizes.isVerticalFont;
            
            for(var i = 0; i < domain.length; i++)
            {
                if(isVerticalFont)
                {
                    if(maxTextWidth < sizes.heights[i])
                    {
                        maxTextWidth = sizes.heights[i];
                    }
                }
                else
                {
                    if(maxTextWidth < sizes.widths[i])
                    {
                        maxTextWidth = sizes.widths[i];
                    }
                }
            }

            re.maxLabelTextWidth = maxTextWidth;
            re.isVertical = isVerticalFont;

            return re;
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };
        
        var isInvalidString = function(str){
           if( typeof (str) != "string" && NumberUtils.isNoValue(str))
             {
                   return true;
             }
           return false;
        }

        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis.valueAxisCore',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.2'
}
],
function Setup(TextUtils, NumberUtils, Objects, FormatManager, Point, matrix) {

    return function() {
   
        var m_position;
        var m_axScale = null;

        var m_tickSize = 5;
        var m_textOffset = 6;

        var m_axDefaultTickNum = 7;

        var m_styleLineSrokeWidth = 1;
        var m_styleAxisColor = "#6c6c6c";
        var m_styleGridLineColor = "#d8d8d8";
        var m_styleGridIncisedLineColor = "#ffffff";
        var m_styleAxisLabelColor = "#333333";
        
        var m_axLabelClassName = "viz-axis-label";        
        
        var m_style = null;
        var m_props = { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": true, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true, "numberFormat" : "","formatString": "", },
            "position": "left",
            "color": m_styleAxisColor,
            "axisline" : {"visible": true},
            "shapeRendering": true
        };

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
        };

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;
            m_spaceLimit = _spaceLimit;
            return axis;
        }

        function axis(selection) {
                
                var axRange = m_axScale.range();//[0, 500]
                var axDomain = m_axScale.domain();//[-100, 2000]

                if(axRange[0] == 0 && axRange[1] == 0)
                {
                    return;//do not draw value axis
                }

                var axTicksLabels = getTicksLabel();

                if(m_position == "bottom")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if  ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", 0)
                                    .attr("y2", m_tickSize + 1)//line contains the first but not the last point
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        if(angle){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                            var tAngle = tickAngle * Math.PI / 180;
                            var cosTAngle = Math.cos(tAngle);
                            var sinTAngle = Math.sin(tAngle);
                            
                            var tickStartX  =   m_axScale(axTicksLabels[i].value) * sinAngle;
                            tickStartY =  -m_axScale(axTicksLabels[i].value) * cosAngle;
                            var x2 = tickStartX + ( m_tickSize + 1) * cosTAngle,
                              y2 = tickStartY + ( m_tickSize + 1) * sinTAngle;
                              
                            axTick.attr('x1', tickStartX).attr('y1', tickStartY).attr('x2', x2).attr('y2', y2);  
                          }
                        
                        var drawLine = function()
                        {
                             var line = selection.append("line")
                            .attr("x1", m_axScale(axTicksLabels[i].value))
                            .attr("x2", m_axScale(axTicksLabels[i].value))
                            .attr("y1", -m_props.gridline.length)
                            .attr("y2", 0)
                            .attr("stroke", m_props.gridline.color)
                            .attr("stroke-width", m_props.gridline.size)
                            .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 line.attr("stroke-dasharray", "3, 2");
                            }
                            
                            if(m_props.gridline.type == "incised")
                            {
                                var line = selection.append("line")
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", -m_props.gridline.length)
                                .attr("y2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "bottom", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = 0;
                        var y2 = 0;

                        var endSize = 0;//m_tickSize

                        var dPath  = "M" + x1 + " " + (y1 + endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 + endSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                        
                        if( angle ){
                            var aAngle = angle * Math.PI /180;
                            var cosAngle = Math.cos(aAngle);
                            var sinAngle = (45 == angle)? cosAngle: Math.sin(aAngle); 
                            dPath = 'M ' + axRange[0] + ' ' + y1;
                            dPath += 'L' + (axRange[0] + axRange[1] * sinAngle) + ' ' + (y2 - axRange[1] * cosAngle);
                            dPath += 'Z';
                            
                            axLine.attr('d', dPath);
                        }
                    }
                }
                else if(m_position == "top")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }
                    
                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", maxTextHeight + nOffset*m_textOffset)
                                    .attr("y2", maxTextHeight + nOffset*m_textOffset + m_tickSize)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("x1", m_axScale(axTicksLabels[i].value))
                                        .attr("x2", m_axScale(axTicksLabels[i].value))
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                        .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "top", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = maxTextHeight + m_tickSize + nOffset*m_textOffset;
                        var y2 = maxTextHeight + m_tickSize + nOffset*m_textOffset;

                        var endSize = 0;//m_tickSize
                        var dPath  = "M" + x1 + " " + (y1 - endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 - endSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }

                }
                else if(m_position == "left")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);

                    //count the max text width
                    var maxTextWidth = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", maxTextWidth + nOffset*m_textOffset)
                                    .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                            
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                        
                        //selection.append("circle").attr("cx", maxTextWidth).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						   .append("g")
                           .attr("fill", m_style.defaultStyle.label.fill)
                           .attr("class", m_vClassNames.axisLabel + " " + m_axLabelClassName)
                           .attr("font-size", m_style.defaultStyle.label['font-size'])
                           .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                           .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                           .append("text")
                           .attr("x", maxTextWidth + m_textOffset)
                           .attr("y", m_axScale(axTicksLabels[i].value))
                           .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                           .attr("text-anchor", "end") // text-align
                           .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var x2 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 - endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 - endSize) + " " + y2;
                        
                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
                else if(m_position == "right")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels, m_position);
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", 0)
                                    .attr("x2", m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }
                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }

                        //selection.append("circle").attr("cx", m_tickSize + m_textOffset).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection
						    .append("g")							
                            .attr("fill", m_style.defaultStyle.label.fill)
                            .attr("class", m_vClassNames.axisLabel + " " + m_axLabelClassName)
                            .attr("font-size", m_style.defaultStyle.label['font-size'])
                            .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                            .attr("font-family", m_style.defaultStyle.label['font-family'])                                
                            .append("text")
                            .attr("x", m_tickSize + m_textOffset)
                            .attr("y", m_axScale(axTicksLabels[i].value))
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", "start") // text-align
                            .text(axTicksLabels[i].text);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = 0;
                        var x2 = 0;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 + endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 + endSize) + " " + y2;

                        var axLine = selection.append("path")
                                .attr("d", dPath)
                                .attr("fill", "none")
                                .attr("stroke", m_props.color)
                                .attr("stroke-width", m_props.lineSize)
                                .attr("shape-rendering",  m_props.shapeRendering ? "crispEdges": "auto");
                    }
                }
            };

        var adjustLabelForIE = function(text)
        {
            if(jQuery.browser.msie)
            {
                //dominant-baseline does not work
                var textHeight = m_style.realStyle.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.realStyle.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = _;
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle = _;
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = _;
          return axis;
        };
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = extendObj(m_props, _properties);
            return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.startPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);
                
                var labelSize = 0;
                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[0].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.endPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = buildToDrawLabels(getTicksLabel(), m_position);

                var labelSize = 0;

                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[axTicksLabels.length-1].text, m_style.realStyle.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.getPreferredSize = function() {

            var axDomain = m_axScale.domain();//[0, 100]
            var axRange = m_axScale.range();//[0, 200]

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            if( !(axRange[0] == 0 && axRange[1] == 0) )
            {

                var absRange = Math.abs(axRange[0] - axRange[1]);
                
                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = absRange + m_styleLineSrokeWidth;
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = getTicksLabel();
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisHeight = maxLabelTextHeight(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisHeight = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = getTicksLabel();
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        
                        if( fastMeasure(textArray[0], m_style.realStyle.label).height > absRange ){
                            axisWidth = m_tickSize + 2*m_textOffset;
                        }else{
                            axisWidth =  maxLabelTextWidth(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;;
                        }
                    }
                    else
                    {
                        axisWidth = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisWidth);

                    axisHeight = absRange + m_styleLineSrokeWidth;
                }
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,

            };
        };

        var buildToDrawLabels = function(axTicksLabels, type)
        {
            if(axTicksLabels.length > 0)
            {
                if(m_axScale (axTicksLabels[0].value) > m_axScale (axTicksLabels[axTicksLabels.length-1].value))
                {
                    axTicksLabels.reverse();
                }
            }
            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {   
              if(!NumberUtils.isNoValue(axTicksLabels[i].value)){
                var item = {};
                item.value = axTicksLabels[i].value;
                item.text = axTicksLabels[i].text;

                //count y1 and y2
                var itemSize = fastMeasure (item.text, m_style.realStyle.label);
                var center = m_axScale (item.value);

                if (type == 'left' || type == 'right') {
                    item.start =  center - itemSize.height/2;
                    item.end =   center + itemSize.height/2;
                } else {
                    item.start = center - itemSize.width/2;
                    item.end = center + itemSize.width/2;
                }
                
                allTicksLabels.push(item);
              }
            }
            //console.log(allTicksLabels);

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels);

            //console.log(ticksLabelsToDraw);
            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, type, ticksLabels, maxTextHeight)
        {
            if(ticksLabels.length == 0)
            {
                return;
            }
            var ticksLabelsToDraw = buildToDrawLabels(ticksLabels, type);

            //console.log(ticksLabelsToDraw);
            for(var i = 0; i < ticksLabelsToDraw.length; i++)
            {
              if(angle){
                var aAngle = angle * Math.PI /180;
                var cosAngle = Math.cos(aAngle);
                var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                var tAngle = tickAngle * Math.PI / 180;
                var cosTAngle = Math.cos(tAngle);
                var sinTAngle = Math.sin(tAngle);
                
                var tickStartX  =    m_axScale(ticksLabelsToDraw[i].value) * sinAngle;
                tickStartY =  -  m_axScale(ticksLabelsToDraw[i].value) * cosAngle;
                
                var item = selection
			      .append("g")				
                  .attr("fill", m_style.defaultStyle.label.fill)
                  .attr("class", m_vClassNames.axisLabel + " " + m_axLabelClassName)
                  .attr("font-size", m_style.defaultStyle.label['font-size'])
                  .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                  .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                  .append('text')
                  .attr('x', tickStartX + ( m_textOffset + m_tickSize) * cosTAngle)
                  .attr('y', tickStartY + ( m_textOffset + m_tickSize) * sinTAngle)
                  .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                  .attr("text-anchor", 'start') // text-align
                  .text(ticksLabelsToDraw[i].text);
          
                  if(tickAngle > 90){
                    item.attr("text-anchor", 'end').attr('transform', 'rotate( ' + (tickAngle - 180) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }else{
                    item.attr('transform', 'rotate( ' + (tickAngle) + ' ' +item.attr("x") + ' ' +item.attr("y") + ')');
                  }
              }else{
              //selection.append("circle").attr("cx", m_axScale(axTicksLabels.value[i])).attr("cy", m_textOffset + m_tickSize). attr("r", 3);
                var item = selection
				 .append("g")				
                 .attr("fill", m_style.defaultStyle.label.fill)
                 .attr("class", m_vClassNames.axisLabel + " " + m_axLabelClassName)
                 .attr("font-size", m_style.defaultStyle.label['font-size'])
                 .attr("font-weight", m_style.defaultStyle.label['font-weight'])
                 .attr("font-family", m_style.defaultStyle.label['font-family'])                    
                 .append("text")
                 .attr("x", m_axScale(ticksLabelsToDraw[i].value))
                 .attr("y", m_textOffset + m_tickSize)
                 .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")
                 .attr("text-anchor", "middle") // text-align
                 .text(ticksLabelsToDraw[i].text);

                //IE does not support dominant-baseline
                item.attr("dominant-baseline", "auto");
                item.attr("y", maxTextHeight + m_textOffset);
              }
            }
        };

        var calculateLabelsToDraw = function(allTicksLabels)
        {
            var labelsToDraw = [];
            
            if(allTicksLabels.length > 0)
            {
                //split allTicksLabels if it is required.
                if( !(allTicksLabels[0].value >= 0 && allTicksLabels[allTicksLabels.length - 1].value >= 0) 
                  &&!(allTicksLabels[0].value <= 0 && allTicksLabels[allTicksLabels.length - 1].value <= 0)
                  )
                {
                    var negativeArray = [];
                    var positiveArray = [];
                    for(var i = 0; i < allTicksLabels.length; i++)
                    {
                        if(allTicksLabels[i].value <= 0) {
                            negativeArray.push(allTicksLabels[i]);
                        }

                        if(allTicksLabels[i].value >= 0) {
                            positiveArray.push(allTicksLabels[i]);
                        }
                    }

                    var head;
                    var nal = negativeArray.length;
                    if (negativeArray[0].value <= negativeArray[nal-1].value) {
                        head = negativeArray[0];
                    } else {
                        head = negativeArray[nal-1];
                    }
                    var tail;
                    var pal = positiveArray.length;
                    if (positiveArray[0].value <= positiveArray[pal -1].value) {
                        tail = positiveArray[pal -1];
                    } else {
                        tail = positiveArray[0];
                    }

                    negativeArray = calculateLabelsToDrawHelper(negativeArray);
                    positiveArray = calculateLabelsToDrawHelper(positiveArray);

                    if (negativeArray[0].value > negativeArray[negativeArray.length-1].value) {
                        negativeArray.reverse();
                    }
                    if (positiveArray[0].value > positiveArray[positiveArray.length-1].value) {
                        positiveArray.reverse();
                    }

                    if( negativeArray[negativeArray.length -1].value == 0
                        && positiveArray[0].value == 0)
                    {
                        negativeArray.pop();
                    }

                    //console.log(negativeArray);
                    labelsToDrawTemp = negativeArray.concat(positiveArray);
                    if (head.value !== labelsToDrawTemp[0].value) {
                        labelsToDrawTemp.splice(0, 0, head);
                    }
                    if (tail.value !== labelsToDrawTemp[labelsToDrawTemp.length-1].value) {
                        labelsToDrawTemp.push(tail);
                    }
                    if (labelsToDrawTemp[0].start > labelsToDrawTemp[labelsToDrawTemp.length-1].start) {
                        labelsToDrawTemp.reverse();
                    }
                    labelsToDraw = calculateLabelsToDrawHelper(labelsToDrawTemp);
                }
                else
                {
                    labelsToDraw = calculateLabelsToDrawHelper(allTicksLabels);
                }
            }

            //BITVIZA-454 [label management] When the height/width of 
            //vertical/horizontal axis is small that can only hold one axis label, the label 
            //should be hidden.
            if(labelsToDraw.length <= 1)
            {
                labelsToDraw = [];
            }

            return labelsToDraw;
        }

        var calculateLabelsToDrawHelper = function(allTicksLabels)
        {
            //allTicksLabels:
            //[0, X]
            //[-X, 0]
            //[X1, X2] (X1>0, X2>0)
            //[X1, X2] (X1<0, X2<0)

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];

            for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
            {
                var isDrawable = true;
                for(var i = 0; i < allTicksLabels.length-1; i+=(iBeyond+1))
                {
                    var item = allTicksLabels[i];
                    if(i != 0)
                    {
                        var previousItem = ticksLabelsToDraw[ticksLabelsToDraw.length-1];
                        if (allTicksLabels[i].start <= previousItem.end)
                        {
                            //for [0.9,1,2,3....], if cannot draw second axis label, just ignore second, then continue
                            if (ticksLabelsToDraw.length > 1) {
                                isDrawable = false;
                                break;
                            }
                        } else {
                            ticksLabelsToDraw.push(item);
                        }
                    } else {
                        //add the first axis tick label
                        ticksLabelsToDraw.push(item);
                    }
                }
                //for [.....5,5.1], always draw the last axis tick label
                var lastItem = allTicksLabels[allTicksLabels.length-1];
                if (lastItem.start < ticksLabelsToDraw[ticksLabelsToDraw.length-1].end) {
                    ticksLabelsToDraw.pop();
                }
                ticksLabelsToDraw.push(lastItem);
                
                if(isDrawable) {//find the labels
                    break;
                } else {
                    ticksLabelsToDraw = [];
                }
            }
            
            return ticksLabelsToDraw;
        }

        var getTicksLabel = function ()
        {
            var axDomain = m_axScale.domain();//[-100, 2000]

            var tickNum = m_axDefaultTickNum;
            if(m_axScale.tickHint)//after perfect
            {
                tickNum = m_axScale.tickHint;
            }

            var axTicksLabels = m_axScale.ticks(tickNum);//[0, 2000, 4000, ...]
            // [21-Sep-2012 Nick ] FIXME Comment out this part to fix bug BITVIZA-383, any particular reason to filter ticks?
            // if it is yes, what kind of criteria should be taken?
//            if(axTicksLabels.length > 20)
//            {
//                //too many ticks. filter some ticks
//                var tempTicks = [];
//                for(var i = 0; i < axTicksLabels.length; i++)
//                {
//                    if(axTicksLabels[i].toString().substr(0,1) == "1"
//                      || axTicksLabels[i].toString().substr(0,1) == "2"
//                      || axTicksLabels[i].toString().substr(0,1) == "5")
//                    {
//                        tempTicks.push(axTicksLabels[i]);
//                    }
//                }
//                axTicksLabels = tempTicks;
//            }

            for(var i=0; i < axTicksLabels.length; i++){
              axTicksLabels[i] = parseFloat( axTicksLabels[i].toFixed(8));
            }
            var beginLabel;
            var endLabel;
            if(axDomain[0] <= axDomain[axDomain.length -1])
            {
                beginLabel = axDomain[0];
                endLabel = axDomain[axDomain.length -1];
            }
            else
            {
                beginLabel = axDomain[axDomain.length -1];
                endLabel = axDomain[0];
            }

            if(axTicksLabels.length > 0)
            {
                if(axTicksLabels[0] != beginLabel) {
                    //the first label is not the first doamin. Add it.
                    axTicksLabels.unshift(beginLabel);
                }
                
                if(axTicksLabels[axTicksLabels.length -1] != endLabel) {
                    //the last label is not the end. Add it.
                    axTicksLabels.push(endLabel);
                }
            }

            var ticks = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {
                var tickItem = {};
                tickItem.value = axTicksLabels[i];
                if(m_props.isPercentMode)
                {
                    tickItem.text = parseFloat((axTicksLabels[i]*100).toFixed(8)).toString();
                }
                else
                {
                    tickItem.text = parseFloat(axTicksLabels[i].toFixed(8)).toString();
                }
                ticks.push(tickItem);
            }

          //format value label by d3
            if(m_props.label)
            {
                if(!m_props.label.formatString && m_props.label.numberFormat){
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var formatFun = d3.format(m_props.label.numberFormat);
                        ticks[i].text = (formatFun(axTicksLabels[i]));
                    }
                }else if(m_props.label.formatString){
                    var formatString = m_props.label.formatString;
                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        ticks[i].text = (FormatManager.format(axTicksLabels[i], formatString));
                    }
                }
                
            }
            
            return ticks;
        }

        var maxLabelTextHeight = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextHeight = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen =  0 ;
                if( isVerticalFont ){
                  tLen =  fastMeasure(textArray[i], m_style.realStyle.label).width;
                }else{
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                }
                if(maxTextHeight < tLen)
                {
                    maxTextHeight = tLen;
                }
            }
            return maxTextHeight;
        }

        var maxLabelTextWidth = function (textArray)
        {
            var isVerticalFont = m_props.forceVerticalFont === true ? true: false;
            var maxTextWidth = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = 0; 
                if( isVerticalFont ){
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).height;
                } else {
                  tLen = fastMeasure(textArray[i], m_style.realStyle.label).width;
                }
                
                if(maxTextWidth < tLen)
                {
                    maxTextWidth = tLen;
                }
            }
            return maxTextWidth;
        }
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        
        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.axis.valueAxisCore',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.axis.categoryAxisCore',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
}
],
function Setup(TextUtils, Objects, valueAxisCore, categoryAxisCore, langManager, NumberUtils, dispatch, FormatManager, matrix, BoundUtil) {

    return function(manifest, ctx) {
        //we should build the axis Data Module, and then draw the axis.
        var m_AxisDM = null;
        var m_axisCore;

        var parent = null;
        var m_width = 0;
        var m_height = 0;

        var m_isDrawBody = true;

        var m_spaceLimit = -1;

        var m_axClassName = "viz-axis";
        var m_axBodyClassName = "viz-axis-body";
        var m_axTitleClassName = "viz-axis-title";
        var m_axLabelClassName = "viz-axis-label";

        var m_vClassNames = 
        {
            axis:"v-axis",
            axisBody:"v-body",
            axisTitle:"v-title",
            axisLabel:"v-label",
        };

        var m_titleOffset = 11;

        var m_data = { };
        var m_dataAxis = { };
        
        var m_isTitleVisible = true;
        
        var m_props = manifest.props(null);
        
        var m_drawable = true;

        var eDispatch = new dispatch('initialized');
        
        var m_defaultColor = m_props.color;

        var m_scale = null;

        var m_effectManager;
        if(ctx)
        {
           m_effectManager = ctx.effectManager;
        }
        
        var m_title = null;
        
        var m_style = {
            "realStyle": {},
            "defaultStyle": {}
        };
        
        var getThemeStyleDef = function () {
          if(ctx)  {
              m_style.realStyle.title = Objects.extend(true, {}, ctx.styleManager.query(m_vClassNames.axisTitle));
              m_style.realStyle.label = Objects.extend(true, {}, ctx.styleManager.query(m_vClassNames.axisLabel));

              m_style.defaultStyle.title = Objects.extend(true, {}, ctx.styleManager.queryDefault(m_vClassNames.axisTitle));
              m_style.defaultStyle.label = Objects.extend(true, {}, ctx.styleManager.queryDefault(m_vClassNames.axisLabel));

              m_style.realStyle.titleString = ctx.styleManager.query(m_vClassNames.axisTitle).toString();
              m_style.realStyle.labelString = ctx.styleManager.query(m_vClassNames.axisLabel).toString();

              m_style.defaultStyle.titleString = ctx.styleManager.queryDefault(m_vClassNames.axisTitle).toString();
              m_style.defaultStyle.labelString = ctx.styleManager.queryDefault(m_vClassNames.axisLabel).toString();

              if (m_props.title.applyAxislineColor){
                m_style.realStyle.title.fill = m_props.color;
                m_style.defaultStyle.title.fill = m_props.color;
              }
          }
        };

        var m_matrix = matrix(), labelAngle = null, labelAlign = null, angle = null, tickAngle = null;
        
        var drawAll = function()
        {
            if(!m_drawable)
            {
                //do not draw bacause of smart layout
                return false;
            }
            else
            {
                if(!drawBody() && !drawTitle())
                {
                    return false;
                }
            }

            return true;
        };

        var drawTitle = function() 
        {
            return m_props.title.visible && m_props.visible;
        };

        var drawBody = function() 
        {
            if(!m_isDrawBody)
            {
                return false;
            }

            var rangeArray = m_scale.range();
            var domainArray = m_scale.domain();
            var rangeBand = null;
            if(m_props.type === "category")
            {
                rangeBand = m_scale.rangeBand();
            }

            var hasData = false;
            if(!m_props.isIndependentMode)
            {
                if(m_dataAxis)
                {
                    hasData = true;
                }
            }
            else
            {
                if(m_data)
                {
                    hasData = true;
                }
            }

            return !(!m_props.visible ||
                   (rangeArray[0] === 0 && rangeArray[rangeArray.length-1] === 0 && rangeArray.length >=2 ) ||
                   (rangeArray.length === 1 && rangeArray[0] === 0 &&
                    domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "value") ||
                   ((!rangeBand || !hasData) && rangeArray.length === 1 && rangeArray[0] === 0 &&
                     domainArray.length === 1 && domainArray[0] === 0 && m_props.type === "category")    
                );
        };

        var axis = function (selection) {
                var pre = axis.getPreferredSize();
                BoundUtil.drawBound(selection, pre.width, pre.height);
          
                parent = selection;
                //in axis, we cannot use data driven way like
                //        var e = selectDIV.selectAll("p")
                //.data(pdata,function(d){return d;});
             
                //e.enter().append("p")
                //.text(function(d){return d;});

                //e.exit().remove();
                //to control the redraw, because axis is not based on data, but based on scale

                //there should be only one axis Class
                var axisClass = selection.select("." + m_axClassName);

                var rangeArray = m_scale.range();
                var domainArray = m_scale.domain();
                if(!drawAll())
                {
                    //remove all the axis 
                    //to improve the performance, we should remove as less elements as possible.
                    axisClass.remove();
                }
                else
                {
                    //---we should dicide show or hide somethings because of the spaceLimit
                    var spacings = axis.getPreferredSize().spacings;

                    var titleSpace = spacings[0];
                    var bodySpace = 0;
                    for(var i = 1; i < spacings.length; i++)
                    {
                        bodySpace += spacings[i];
                    }

                    if(m_spaceLimit >= 0 && m_spaceLimit < (titleSpace + bodySpace))
                    {
                        m_isTitleVisible = false;
                    }

                    prepareProperties();

                    var core;
                    var coreScale;
                    var re = getCoreAndScale();
                    core = re.core;
                    coreScale = re.coreScale;

                    //the axis body
                    m_axisCore = core()
                                .properties(m_props)
                                .style(m_style)
                                .position(m_props.position)
                                .axScale(coreScale)
                                .spaceLimit(m_spaceLimit)
                                .matrix(m_matrix)
                                .labelAngle(labelAngle)
                                .labelAlign(labelAlign)
                                .angle(angle)
                                .tickAngle(tickAngle);

                    var axisBody;
                    if(axisClass.empty())
                    {
                        axisClass = selection.append("g")
                                 .attr("class", m_axClassName + " "+ m_vClassNames.axis);

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName + " " + m_vClassNames.axisBody);
                    }
                    else
                    {
                        //redraw axis body
                        var e=axisClass.select("." + m_axBodyClassName).remove();

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName + " "+ m_vClassNames.axisBody);

                        axisBody = axisClass.select("." + m_axBodyClassName);
                    }

                    if(drawBody())
                    {
                        axisBody.call(m_axisCore);
                    }

                    //build axis title Text
                    var title = "";
                    if(m_props.title.text !== undefined && m_props.title.text !== null)
                    {
                        title = m_props.title.text;
                    }
                    else
                    {
                        if(m_props.type === "value")
                        {
                            if(m_title) 
                            {
                                title = m_title;
                            }
                            else
                            {
                                title = langManager.get('IDS_ISNOVALUE');
                            }
                        }
                        else //let us build the title!
                        {
                            var dataset = [];
                            if(m_props.isIndependentMode)
                            {
                                if(m_data)
                                {
                                    for(var dataObj in m_data)
                                    {
                                        if (m_data.hasOwnProperty(dataObj))
                                        {
                                            dataset = m_data[dataObj].values;
                                            break;
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if(m_dataAxis)
                                {
                                    dataset = m_dataAxis.values;
                                }
                            }

                            for(var k = 0 ; k < dataset.length; k++)
                            {
                                if(dataset[k].type)
                                {
                                    if(dataset[k].type === "MND" && k === 0)
                                    {
                                        title += langManager.get('IDS_DEFAULTMND') + ((dataset.length === 1)? "" : " - ");
                                    }
                                    else if(dataset[k].type === "MND" && k === (dataset.length-1))
                                    {
                                        title += " - " + langManager.get('IDS_DEFAULTMND');
                                    }
                                }
                                else
                                {
                                    if(dataset[k].col.val)
                                    {
                                        title += dataset[k].col.val;
                                    }
                                    else
                                    {
                                        title += langManager.get('IDS_ISNOVALUE');
                                    }

                                    if(k !== (dataset.length-1) && !dataset[k+1].type)
                                    {
                                        title += " / ";
                                    }
                                }
                            }
                        }
                    }
                    

                    //redraw axis title
                    var titleOffset = m_titleOffset;
                    axisClass.select("." + m_axTitleClassName).remove();

                    if(drawTitle())
                    {
                        if(m_props.title.visible && m_isTitleVisible)
                        {  
                            var pSize = m_axisCore.getPreferredSize();
                            var axTitle = axisClass.append("g")
                                  .attr("class", m_axTitleClassName + " " + m_vClassNames.axisTitle)
                                  .attr("text-anchor", "middle")
                                  .attr("fill", m_style.defaultStyle.title.fill)
                                  .attr("font-size", m_style.defaultStyle.title['font-size'])
                                  .attr("font-weight", m_style.defaultStyle.title['font-weight'])
                                  .attr("font-family", m_style.defaultStyle.title['font-family'])
                                  .append("text"); // text-align
                                  
                            if(m_props.position === "bottom")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }
                                  axTitle.attr("x", pSize.width/2)
                                         .attr("y", pSize.height + titleOffset)
                                         .attr("dominant-baseline", "hanging");//"auto")//"hanging")//"central");
                                    
                                  if(jQuery.browser.msie)
                                  {
                                      //dominant-baseline does not work
                                      var textHeight = m_style.realStyle.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      axTitle.attr("y", Number(axTitle.attr("y")) + textHeight/2);
                                      axTitle.attr("dominant-baseline", "auto");
                                  }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.realStyle.titleString);
                                
                               if(angle){
                                    var aAngle = angle * Math.PI /180;
                                    var cosAngle = Math.cos(aAngle);
                                    var sinAngle = (45 === angle) ? cosAngle : Math.sin(aAngle);
                                    var tAngle = tickAngle * Math.PI / 180;
                                    var cosTAngle = Math.cos(tAngle);
                                    var sinTAngle = Math.sin(tAngle);
                    
                                    var aaAngle = angle - 90;
                                    if( aaAngle > 90 ){
                                        aaAngle -= 180;
                                    }else if( aaAngle < -90 )(
                                        aaAngle += 180
                                    )
                                    
                                    var size = fastMeasure(title, m_style.realStyle.title)
                                    var x = ( pSize.width)/2 * sinAngle;
                                    var y = - ( pSize.width )/2 * cosAngle;
                                    
                                    x += (pSize.height + titleOffset) * cosTAngle;
                                    y += (pSize.height + titleOffset) * sinTAngle;
                                    axTitle.attr('x', x).attr('y', y).attr("transform", 'rotate( ' + ( aaAngle) + ' ' + x + ' ' + y + ')');
                                }
                            }
                            else if(m_props.position === "top")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }

                                titleHieght = fastMeasure(title, m_style.realStyle.title).height;

                                axisBody.attr("transform", "translate(0, " + (titleHieght + titleOffset) + ")");

                                axTitle.attr("x", pSize.width/2)
                                  .attr("y", titleHieght)
                                  .attr("dx", "0") // padding-right
                                  .attr("dy", "0") // vertical-align: middle?
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.realStyle.titleString);
                            }
                            else if(m_props.position === "left")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.realStyle.title).height;

                                axisBody.attr("transform", "translate(" + (titleWidth + titleOffset) + ", " + 0 + ")");

                                var centerX = titleWidth;
                                var centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY)
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.realStyle.titleString);
                            }
                            else// if(m_props.position == "right")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.realStyle.title).height;
                                
                                centerX = pSize.width + titleWidth/2 + titleOffset;
                                centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY - titleWidth/2)
                                  .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")

                                if(jQuery.browser.msie)
                                {
                                    //dominant-baseline does not work
                                    var textHeight = m_style.realStyle.title['font-size'].toString();
                                    var indexPX = textHeight.indexOf("px");
                                    if(indexPX >= 0)
                                    {
                                        textHeight = textHeight.substr(0, indexPX);
                                    }

                                    centerY = Number(pSize.height/2) + textHeight/2;
                                    axTitle.attr("y", centerY);
                                    axTitle.attr("dominant-baseline", "auto");
                                }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.realStyle.titleString);
                            }
                        }
                    }
                    m_isTitleVisible = true;
                }
                
            eDispatch.initialized();
            
            return axis;
        };
        
        axis.matrix = function(_){
          if(!arguments.length){
            return m_matrix;
          }
          m_matrix = _;
          return axis;
        };
        
        axis.labelAngle = function(_){
          if(!arguments.length){
            return labelAngle;
          }
          labelAngle = pmod( _, 360);
          return axis;
        };
        
        axis.tickAngle = function(_){
          if(!arguments.length){
            return tickAngle;
          }
          tickAngle =pmod( _, 360);
          return axis;
        };
        
        axis.angle = function(_){
          if(!arguments.length){
            return angle;
          }
          angle = pmod( _, 360);
          return axis;
        };
        
        function pmod(a,m)
        {
          var ret = a % m;
          if (0 > ret)
            ret += m;
          return ret;
        }
        
        axis.labelAlign = function(_){
          if(!arguments.length){
            return labelAlign;
          }
          labelAlign = _;
          return axis;
        };
        
        axis.parent = function (_) {
          if ( !arguments.length ) return parent;
          parent = _;
          return axis;
        };

        axis.width = function(_width) {
            if (arguments.length == 0) {
                return m_width;
            }
            else {
                m_width = _width;

                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(m_height)
                    {
                        m_spaceLimit = m_height;

                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(m_width)
                    {
                        m_spaceLimit = m_width;
                    }
                }

                return axis;
            }
        };

        axis.height = function(_height) {
            if (arguments.length == 0)
                return m_height;
            
            m_height = _height;
            if(m_props.position == "bottom" || m_props.position == "top")
            {
                if(m_height)
                {
                    m_spaceLimit = m_height;

                }
            }
            else if(m_props.position == "left" || m_props.position == "right")
            {
                if(m_width)
                {
                    m_spaceLimit = m_width;
                }
            }

            
            return axis;
        };

        axis.gridlineLength = function(_gridlineLength) {
            if (arguments.length == 0)
                return m_props.gridline.length;
            m_props.gridline.length = _gridlineLength;
            return axis;
        };

        axis.startPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .startPadding();
            }
            return padding;
        };

        axis.endPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .endPadding();
            }
            return padding;
        };

        axis.mouseover = function(target){
            if(m_props.type !== "value")
            {
                m_axisCore.mouseover(target);
            }
        };

        axis.mouseout = function(target){
            if(m_props.type !== "value")
            {
                m_axisCore.mouseout(target);
            }
        };
        
        axis.cleanLabelAreas = function()
        {
            if(m_props.type !== "value"
               && m_axisCore
               && m_axisCore.cleanLabelAreas)
            {
                m_axisCore.cleanLabelAreas();
            }
        };

        axis.mouseup = function(target){
            if(m_props.type !== "value")
            {
                m_axisCore.mouseup(target);
            }
        };
        
        axis.mousedown = function(target){
            if(m_props.type !== "value")
            {
                m_axisCore.mousedown(target);
            }
        };
                        
        axis.size = function(_size) {
            if (arguments.length == 0)
                return {
                           "width" : m_width,
                           "height": m_height,
                       };
            m_width = _size.width;
            m_height = _size.height;
            return axis;
        };
        
        /*
         * Jimmy/9/22/2012 if axis works under independentMode(boxplot for now)
         * it doesn't rely on the data passed through this API from container, instead, boxplot
         * will pass calculated data through dependency 
         */
        axis.independentData = function(_data) {
          if(m_props.isIndependentMode) {
            if (arguments.length == 0)
                return m_data;
            m_data = _data;
          }
        },

        axis.data = function(_data) {
            if (arguments.length == 0)
                return m_data;
            
            if(!m_props.isIndependentMode)
            {
              m_data = _data;
              if(_data.getAnalysisAxisDataByIdx)
              {
                m_dataAxis = m_data.getAnalysisAxisDataByIdx(0);
              }
            }
            return axis;
        };

        axis.title = function(_title) {
            if (arguments.length == 0)
                return m_title;
            m_title = _title;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0){
                return m_props;
            }

            Objects.extend(true, m_props, _properties);

            if(_properties.color)
            {
                m_props.customizedColor = _properties.color;
            }

            return axis;
        };

        axis.range = function() {
            var range = null;
            if ((m_props.type === "value") && (m_props.scale.fixedRange)) {
                if ((m_props.scale.maxValue !== null) && (m_props.scale.minValue !== null)) {
                    range = {
                        max : m_props.scale.maxValue,
                        min : m_props.scale.minValue,
                        from : 'axis'
                    };
                }
            }
            return range;
        }

        axis.scale = function(_scale) {
            if (arguments.length == 0)
                return m_scale;

            m_scale = _scale;
            return axis;
        };

        axis.isDrawBody = function(_isDrawBody) {
            if (arguments.length == 0)
                return m_isDrawBody;

            m_isDrawBody = _isDrawBody;
            return axis;
        };

        axis.color = function(_color) {
          if (arguments.length == 0)
              return m_props.color;
          if (m_props.customizedColor){
            _color = m_props.customizedColor;              
          }
          if(!_color){
              _color = m_defaultColor;
          }

          m_props = Objects.extend(true, m_props, {"color":_color});

          if (m_props.title.applyAxislineColor && _color) {
            m_style.realStyle.title.fill = _color;
            m_style.defaultStyle.title.fill = _color;
          }

          return axis;
        };

        axis.drawable = function(_drawable) {
            //drawable or not because of smart layout
            if (arguments.length == 0)
                return m_drawable;

            m_drawable = _drawable;

            return axis;
        };

        axis.getPreferredSize = function() {
            getThemeStyleDef();
            var rangeArray = [0];
            var domainArray = [0];
            if(m_scale)
            {
                rangeArray = m_scale.range();
                domainArray = m_scale.domain();
            }

            if(!m_scale || (!drawAll()) )            
            {
                return {
                    width : 0,
                    height : 0,
                    manual: false,
                };
            }
            else {
                //body size && title size
                var reCS = getCoreAndScale();
                var axisCore = (reCS.core)()
                              .properties(m_props)
                              .style(m_style)
                              .position(m_props.position)
                              .axScale(reCS.coreScale)
                              .spaceLimit(m_spaceLimit);
                
                var title, resultSize;
                if(m_props.title.visible && m_props.visible)
                {
                    //console.log(m_props.title.text);
                    if(m_props.title.text !== undefined && m_props.title.text !== null)
                    {
                        title = m_props.title.text;
                    }
                    else
                    {
                        title = "Value";
                    }
                }
                
                var titleHieght = 0;
                var titleWidth = 0;
                var titleOffset = 0;
                var axisSpacings = [];

                var sizeCore = axisCore.getPreferredSize();

                
                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(!drawBody())
                    {
                        sizeCore.height = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        titleHieght = fastMeasure(title, m_style.realStyle.title).height; 
                        titleOffset = m_titleOffset;
                    }

                    var titleSpace = titleHieght + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullHeight = titleSpace + bodySpace;
                    var realHeight = fullHeight;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullHeight)
                    {
                        realHeight = sizeCore.height;//no title
                    }

                    resultSize = {
                        maxSizeConstant : 0.5,
                        width: sizeCore.width,
                        height: fullHeight,
                        realHeight: realHeight,
                        spacings: axisSpacings,
                        manual: false,
                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(!drawBody())
                    {
                        sizeCore.width = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible && m_props.visible)
                    {
                        //title is vertical
                        titleWidth = fastMeasure(title, m_style.realStyle.title).height; 
                        titleOffset = m_titleOffset;
                    }

                    var titleSpace = titleWidth + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullWidth = bodySpace + titleSpace;
                    var realWidth = fullWidth;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullWidth)
                    {
                        realWidth = sizeCore.width;//no title
                    }
                    

                    resultSize = {
                        maxSizeConstant : 0.5,
                        width: fullWidth,
                        realWidth: realWidth,
                        height: sizeCore.height,
                        spacings: axisSpacings,
                        manual: false,
                    }
                }
                if ((m_props.type == 'category') && (m_props.layoutInfo.width > 0) && (m_props.layoutInfo.height > 0) ) {
                    resultSize.width = m_props.layoutInfo.width;
                    resultSize.realWidth = m_props.layoutInfo.width;
                    resultSize.height = m_props.layoutInfo.height;
                    resultSize.realHeight = m_props.layoutInfo.height;
                    resultSize.manual = true;
                }
                
                Objects.normalizeNumbersCeil(resultSize);
                return resultSize;
            }
        };

        axis.dispatch = function(_){
          if(!arguments.length)
            return eDispatch;
          eDispatch = _;return axis;
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.superFastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };

        //Alex Su: to build a hierarchical structure basing on raw data.
        function hasMND(data){
          if (data[0].type === 'MND' || data[data.length - 1].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function hasOnlyMND(data){
          if (data.length === 1 && data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function isMNDBefore(data){
          if (data[0].type === 'MND'){
            return true;
          } else {
            return false;
          }
        }
        
        function getMNDData(data){
          if (! hasMND(data)){
            return;
          }
          if (isMNDBefore(data)){
            return data[0];
          } else {
            return data[data.length - 1];
          }
        }
        
        function processRawData(data){
          if (! hasMND(data) || hasOnlyMND(data)){
            return data;
          }
          var newData = [];
          var i, j, k;
          for (i = 0; i < data.length; ++i){
            newData.push({
              col: data[i].col,
              rows: []
            });
          }
          var mndData = getMNDData(data);
          var mndLength = mndData.rows.length;
          var cateLength;
          if (isMNDBefore(data)){
            cateLength = data[1].rows.length;
            for (i = 0; i < mndLength; ++i){
              for (j = 0; j < cateLength; ++j){
                newData[0].rows.push(data[0].rows[i]);
              }
            }
            for (i = 1; i < data.length; ++i){
              for (j = 0; j < mndLength; ++j){
                newData[i].rows = newData[i].rows.concat(data[i].rows);
              }
            }
          } else {
            cateLength = data[0].rows.length;
            for (i = 0; i < cateLength; ++i){
              newData[newData.length - 1].rows = newData[newData.length - 1].rows.concat(data[data.length - 1].rows);
            }
            for (i = 0; i < data.length - 1; ++i){
              for (j = 0; j < cateLength; ++j){
                for (k = 0; k < mndLength; ++k){
                  newData[i].rows.push(data[i].rows[j]);
                }
              }
            }
          }
          return newData;
        }
        
        function buildHierarchicalData(data){
          var i,j;
          var categoryHierarchicalData = [];
          var rowData, cellData, spaceCount;
          var tempCellCount, tempSpaceCount;
          for (i = 0; i < data.length; ++i){
            rowData = [];
            spaceCount = 0;
            tempSpaceCount = 0;
            tempCellCount = 0;
            var tempLabelContexts = [];
            for (j = 0; j < data[i].rows.length; ++j){
              cellData = {};
              if (i === data.length - 1){
                cellData.value = data[i].rows[j];
                cellData.space = 1;
              } else {
                ++spaceCount;
                ++tempSpaceCount;
                if (i > 0 && tempSpaceCount >= categoryHierarchicalData[i - 1][tempCellCount].space){
                  cellData.value = data[i].rows[j];
                  cellData.space = spaceCount;
                  spaceCount = 0;
                  tempSpaceCount = 0;
                  ++tempCellCount;
                }
                else {
                  if (j + 1 < data[i].rows.length && data[i].rows[j].val === data[i].rows[j + 1].val){

                    if(data[i].rows[j].ctx)
                    {
                        tempLabelContexts.push(data[i].rows[j].ctx);
                    }

                    if(data[i].rows[j].contexts)
                    {
                        tempLabelContexts = tempLabelContexts.concat(data[i].rows[j].contexts);
                    }
                    continue;
                  }
                  else {
                    cellData.value = data[i].rows[j];
                    cellData.space = spaceCount;
                    spaceCount = 0;                  
                  }
                }                
              }

              if(data[i].rows[j].ctx)
              {
                tempLabelContexts.push(data[i].rows[j].ctx);
              }

              if(data[i].rows[j].contexts)
              {
                  tempLabelContexts = tempLabelContexts.concat(data[i].rows[j].contexts);
              }

              cellData.value.labelContexts = tempLabelContexts;
              rowData.push(cellData);
              tempLabelContexts = [];
            }
            categoryHierarchicalData.push(rowData);
          }
          return categoryHierarchicalData;
        }
                
        function processData(data){
          var newData = processRawData(data);
          var hierarchicalData = buildHierarchicalData(newData);
          return hierarchicalData;
        }
        
        function reverseHierarchicalData(hData){
          for (var i = 0; i < hData.length; ++i){
            hData[i].reverse();
          }
        }
        
        var getCoreAndScale = function()
        {
            var re = { };
            var coreScale;
            if(m_props.type == "category") //a new scale is required
            {
                coreScale = [];
                //build labels (domain)
                var dataset = [];
                if(m_props.isIndependentMode) {
                    for(dataObj in m_data) {
                        dataset = m_data[dataObj].values;
                    }
                } else {
                    if(m_dataAxis) {
                        dataset = m_dataAxis.values;
                    }
                }
                var hierarchicalData = [];
                if (dataset && dataset.length){
                  hierarchicalData = processData(dataset);
                }
                //reverse domain or not,
                var oRange = m_scale.range();
                //by yuanhao 2012-12-17 ,
                if(oRange[0] > oRange[oRange.length -1 ])
                {
                    reverseHierarchicalData(hierarchicalData);
                }
                //if orRangeBand is 0, which means module do not use ordinal scale like normal, the scale is not equal every unit.
                var dataCount = hierarchicalData.length === 0 ? 0 : hierarchicalData[hierarchicalData.length - 1].length;
                var orRangeBand = m_scale.rangeBand(), orRangeBands = [];
                
                //Alex Su. Handling for boxplot.
                var isBoxPlotWithSingleAAFeed = false;
                if (dataset && dataset.length > 0 && dataset[0].rows.length === 0){
                  isBoxPlotWithSingleAAFeed = true;
                  dataCount = 1;
                  var cellData = {
                      value: {},
                      space: 1
                  };
                  cellData.value = {
                      val: !m_dataAxis.values ? null : m_dataAxis.values[0].col.val,
                      ctx:null
                  };
                  hierarchicalData = [[cellData]];
                }
                
                var di;
                if(!m_scale.noEqual){
                  if (! hasOnlyMND(dataset) && ! isBoxPlotWithSingleAAFeed){
                    for(di = 0; di < dataCount; di++){
                        orRangeBands[di] = orRangeBand;
                    }
                  } else {
                    var tickSpace = parseInt(oRange.length / dataCount, 10);
                    for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = orRangeBand * tickSpace;
                    }
                  }
                }else{
                  for(di = 0; di < dataCount; di++){
                      orRangeBands[di] = Math.abs(oRange[di] - oRange[di+1]);
                  }
                }
                
                function getRangeEnd(rangeStart, startIndex, spaceCount){
                    var sum = rangeStart;
                    for(var ix = 0; ix < spaceCount; ix++){
                        sum +=orRangeBands[startIndex + ix];
                    }
                    return sum;
                }
                var coreScaleItem = {};
                var cgDomain = [];
                var cgRange = [];
                var i, j, spaceCount = 0;
                var startIndex;
                var rangeStart, rangeEnd;
                for (i = 0; i < hierarchicalData.length; ++i){
                  cgDomain = [];
                  cgRange = [];
                  spaceCount = 0;
                  startIndex = 0;
                  for (j = 0; j < hierarchicalData[i].length; ++j){
                    spaceCount = 0;
                    cgDomain.push(hierarchicalData[i][j].value);
                    
                    spaceCount += hierarchicalData[i][j].space;
                    rangeStart = j > 0 ? cgRange[j - 1][1] : 0;
                    rangeEnd = getRangeEnd(rangeStart, startIndex, spaceCount);
                    startIndex += spaceCount;

                    cgRange.push([rangeStart, rangeEnd]);
                  }
                  var coreScaleItem = { 
                      "domain": cgDomain, 
                      "range":  cgRange,
                   };
       
                  coreScale.push(coreScaleItem);//add to the latest
                }
                
                core = categoryAxisCore;
            }
            else //value axis
            {   
                core = valueAxisCore;
                coreScale = m_scale;
            }
            re.core = core;
            re.coreScale = coreScale;
            re.coreScale.noEqual = m_scale.noEqual;
            return re;
        }
        
        function prepareProperties()
        {
            if (!m_effectManager) return;

            if(m_props.customizedColor) {
                m_props.color = m_props.customizedColor;
            }
            var parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_props.color,
            };
            m_props.color = m_effectManager.register(parameter);

            parameter = {
                drawingEffect : 'normal',
                fillColor : m_props.gridline.color,
            };
            m_props.gridline.color = m_effectManager.register(parameter);
            
            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.defaultStyle.label.fill,
            };
            m_style.defaultStyle.label.fill = m_effectManager.register(parameter);

            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.defaultStyle.title.fill,
            };
            m_style.defaultStyle.title.fill = m_effectManager.register(parameter);
        }

        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.axis',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.axis',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'axis',
    'properties' : {
      'isIndependentMode' : {
        'name' : 'isIndependentMode',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether axis works on independent mode, currently it is used specially for boxplot chart.',
        'isExported' : false
      },
      'isPercentMode' : {
        'name' : 'isPercentMode',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Show the label 0.1 as 10',
        'isExported' : false
      },
    'lineSize' : {
        'name' : 'lineSize',
        'supportedValueType' : 'String',
        'defaultValue' : '1',
        'description' : 'Set line size of axis.',
        'isExported' : true,
      },
      'title' : {
        'name' : 'title',
      'description' : 'Settings for axis title.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set visibility of axis title.'
        }, 
        'text' : {
        'name' : 'text',
        'supportedValueType' : 'String',
        'defaultValue' : null,
        'description' : 'Set text of axis title.'
        },
        'applyAxislineColor' : {
        'name' : 'applyAxislineColor',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set title color same with axisline color.',
        'isExported' : false,
        },
      },
      },
      'gridline' : {
        'name' : 'gridline',
      'description' : 'Settings for axis gridline.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible': {
          'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : true,
          'description' : 'Set visibility of axis gridline.'
        },
        showFirstLine : {
              'name' : 'showFirstLine',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled the first line of gridlines.',
              'isExported' : false,
        },
        showLastLine : {
              'name' : 'showLastLine',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled the last line of gridlines.',
              'isExported' : false,
        },
        'type' : {
          'name' : 'type',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'line', 'dotted', 'incised'],
          'defaultValue' : 'line',
          'description' : 'Set type of gridline.',
          'isExported' : true,
        },
        'color' : {
          'name' : 'color',
          'supportedValueType' : 'String',
          'defaultValue' : '#d8d8d8',
          'description' : 'Set color of gridline.',
          'isExported' : true,
        },
        'size' : {
          'name' : 'size',
          'supportedValueType' : 'String',
          'defaultValue' : '1',
          'description' : 'Set line size of gridline.',
          'isExported' : true,
        },        
          },
      }, 
    'color' : {
        'name' : 'color',
        'supportedValueType' : 'String',
        'defaultValue' : '#6c6c6c',
        'description' : 'Set color of axisline.',
          'isExported' : true,
      },
      'axisline' : {
        'name' : 'axisline',
      'description' : 'Settings for axisline.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axisline.'
        },
      },
      },    
      'type' : {
        'name' : 'type',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'value', 'category', ],
        'defaultValue' : 'value',
        'description' : 'Set type of axis.',
          'isExported' : false,
      },
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axis.',
      },
      'label' : {
        'name' : 'label',
      'description' : 'Settings for axis label.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axis label.'
        }, 
        'numberFormat' : {
        'name' : 'numberFormat',
        'supportedValueType' : 'String',
        'defaultValue' : '',
        'description' : 'Set number format of value axis.'
        },
        'formatString' : {
         'name' : 'formatString',
         'supportedValueType' : 'String',
         'defaultValue' : null,
         'description' : 'Set format string of value axis. If number format and format string are both set, number format will be ignored. '
        }
      },
      },
      'position' : {
        'name' : 'position',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'left', 'right', 'top', 'bottom' ],
        'defaultValue' : 'bottom',
        'description' : 'Set position of axis.',
          'isExported' : false,
      },
      'scale' : {
        'name' : 'scale',
        'description' : 'Set scale for value axis. this property just work on value type axis.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
            'fixedRange' : {
                'name' : 'fixedRange',
                'supportedValueType' : 'Boolean',
                'defaultValue' : false,
                'description' : 'Enable/disable fixed axis range according minValue and maxValue.',
                'isExported' : false
            },
            'minValue' : {
                'name' : 'minValue',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set minValue of yAxis.',
                'isExported' : false
            },
            'maxValue' : {
                'name' : 'maxValue',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set maxValue of yAxis.',
                'isExported' : false
            }
        },
        'isExported' : false
      },
      'layoutInfo' : {
        'name' : 'layoutInfo',
        'description' : 'Settings layoutInfo for category axis. this property just work on category type axis',
        'supportedValueType' : 'Object',
        'supportedValues' : {
            'width' : {
                'name' : 'width',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set width of xAxis.',
                'isExported' : false
            }, 
            'height' : {
                'name' : 'height',
                'supportedValueType' : 'Number',
                'defaultValue' : 0,
                'description' : 'Set height of xAxis.',
                'isExported' : false
            }
        },
        'isExported' : false
      }
    },
    'css' : {
      '.viz-axis-title.v-title' : {
        'description' : 'Define style for the axis title.',
        'value' : {
          'fill' : '#000000',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'bold'
        }
      },
      '.viz-axis-label.v-label' : {
        'description' : 'Define style for the axis label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils) {
  var dataUtil = function (){
    var hasSameSchema = function (dataA, dataB){
       if (!dataA || !dataB || TypeUtils.isEmptyObject(dataA) || TypeUtils.isEmptyObject(dataB) ){
        return false;
      } else {
        return hasSameAASchema(dataA, dataB) && hasSameMGSchema(dataA, dataB);        
      }
    };
    
    function hasSameAASchema(dataA, dataB){
      var dataA_aa = [], dataB_aa = [];
      var i = 0;
      var temp = dataA.getAnalysisAxisDataByIdx(i);
      while (temp) {
        dataA_aa.push(temp);
        ++i;
        temp = dataA.getAnalysisAxisDataByIdx(i);
      } 
      i = 0;
      temp = dataB.getAnalysisAxisDataByIdx(i);
      while (temp) {
        dataB_aa.push(temp);
        ++i;
        temp = dataB.getAnalysisAxisDataByIdx(i);
      } 
      if (dataA_aa.length !== dataB_aa.length){
        return false;
      }
      var aaLength = dataA_aa.length;
      for (i = 0; i < aaLength; ++i){
        if (dataA_aa[i].index !== dataB_aa[i].index){
          return false;
        }
        if (! equalAAArray(dataA_aa[i].values, dataB_aa[i].values)){
          return false;
        }
      }
      return true;
    }
    
    function hasSameMGSchema(dataA, dataB){
      var dataA_mg = [], dataB_mg = [];
      var i = 0;
      var temp = dataA.getMeasureValuesGroupDataByIdx(i);
      while (temp) {
        dataA_mg.push(temp);
        ++i;
        temp = dataA.getMeasureValuesGroupDataByIdx(i);
      }
      i = 0;
      temp = dataB.getMeasureValuesGroupDataByIdx(i);
      while (temp) {
        dataB_mg.push(temp);
        ++i;
        temp = dataB.getMeasureValuesGroupDataByIdx(i);
      } 
      if (dataA_mg.length !== dataB_mg.length){
        return false;
      }
      var aaLength = dataA_mg.length;
      for (i = 0; i < aaLength; ++i){
        if (dataA_mg[i].index !== dataB_mg[i].index){
          return false;
        }
        if (! equalMGArray(dataA_mg[i].values, dataB_mg[i].values)){
          return false;
        }
      }
      return true;
      
    }
    
    function equalAAArray(arrayA, arrayB){
      if (arrayA.length !== arrayB.length){
        return false;
      }
      var length = arrayA.length;
      for (var i = 0; i < length; ++i){
        if (arrayA[i].type !== arrayB[i].type){
          return false;
        }
        if (arrayA[i].col.val !== arrayB[i].col.val){
          return false;
        }
        if (arrayA[i].rows.length !== arrayB[i].rows.length){
          return false;
        }
      }
      return true;
    }
    
    function equalMGArray(arrayA, arrayB){
      if (arrayA.length !== arrayB.length){
        return false;
      }
      var length = arrayA.length;
      for (var i = 0; i < length; ++i){
        if (arrayA[i].col !== arrayB[i].col){
          return false;
        }
        if (arrayA[i].rows.length !== arrayB[i].rows.length){
          return false;
        }
      }
      return true;
    }
    
    return {hasSameSchema:hasSameSchema};
  };
  return dataUtil;
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],

function Setup(FunctionUtils){
  
  var MeasureValuesDataHandler = {
      
      makeMeasureValues: function(ctx, mvg, axisIndex, maxAxisNumber, matchMeasure){
          
          var values = [];
          for(var i = 0; i < mvg.values.length; i++){
              if(matchMeasure && i !== ctx.path.mi){
                 continue;
              }
            
              var value = {};
              var mv = mvg.values[i];
              var rows = mv["rows"];
              value["col"] = mv["col"];
              if(ctx){
                 value["rows"] = this.createMeasureValues(ctx, rows, axisIndex, maxAxisNumber);
              }else{
                value["rows"] = this.createMeasureValuesWithoutCtx(rows, axisIndex, maxAxisNumber);
              }
          
              values.push(value);
           }
          
          return values;
        },
       
        /**
         * Create Measure values without context
         *   
         * @param rows
         * @param axisIndex
         * @returns {Array}
         */
        createMeasureValuesWithoutCtx_1_2 : function(rows, axisIndex){
          var values = [], j, row;
          if(axisIndex[0] === 1){
             row = [];
             for(j = 0; j < rows[0].length; j++){
               row.push(rows[0][j]);
             }   
             values.push(row);
           
          }else if(axisIndex[0] === 2){     
             for(j = 0; j < rows[0].length; j++){
               row = [];
               row.push(rows[0][j]);
               values.push(row);
             }   
          }else{
             FunctionUtils.error("Not supported");
         } 
          
          return values;
        },
        
        createMeasureValuesWithoutCtx_1_3 : function(rows, axisIndex){
           var values = [], j, row;
           if(axisIndex[0] === 1){
              row = [];
              for(j = 0; j < rows[0].length; j++){
                  row.push(rows[0][j]);
           }   
              
           values.push([row]);
           
         }else if(axisIndex[0] === 2){
              row = [];
              for(j = 0; j < rows[0].length; j++){
                  row.push([rows[0][j]]);
              }
              
              values.push(row);
              
         }else if(axisIndex[0] === 3){   
               for(j = 0; j < rows[0].length; j++){
                   row = [];
                   row.push([rows[0][j]]);
                   values.push(row);
               }
         }else{
           FunctionUtils.error("Not supported");
         }  
           
         return values;
         
        },
        
        createMeasureValuesWithoutCtx : function(rows, axisIndex, maxAxisNumber){
           if(axisIndex.length === 1){
             if(maxAxisNumber === 1 || maxAxisNumber === 2){
                return this.createMeasureValuesWithoutCtx_1_2(rows, axisIndex); 
             }else if(maxAxisNumber === 3){
                return this.createMeasureValuesWithoutCtx_1_3(rows, axisIndex);
             }else{
                FunctionUtils.error("Not supported");
             }
           }else if(axisIndex.length === 2){
             if(maxAxisNumber === 2){
                return rows;
             }
             else if(maxAxisNumber === 3){
                return this.createMeasureValues_2_3(rows, axisIndex); 
             }else{
                FunctionUtils.error("Not supported");
             } 
             
           }else{
             FunctionUtils.error("Not supported");
           }
           
           FunctionUtils.error("Not supported");
      },
      
      /**
         * Create Measure values without context
         *   
         * @param rows
         * @param axisIndex
         * @returns {Array}
         */
        createMeasureValues_1_2 : function(ctx, rows, axisIndex){
          var values = [], j, row;
           if(axisIndex[0] === 1){
              row = [];
              for(j = 0; j < rows.length; j++){
                  row.push(rows[j][ctx.path.dii]);
              } 
              
           values.push(row);
           
         }else if(axisIndex[0] === 2){
           
           for(j = 0; j < rows.length; j++){
             row = [];
             row.push(rows[j][ctx.path.dii]);
             values.push(row);
           }  
           
         }else{
           FunctionUtils.error("Not supported");
         } 
          
          return values;
        },
        
        createMeasureValues_1_3 : function(ctx, rows, axisIndex){
          var values = [], j, row;
          if(axisIndex[0] === 1){
             
           row = [];
           for(j = 0; j < rows.length; j++){
             row.push(rows[j][ctx.path.dii]);
           }   
           values.push([row]);
           
         }else if(axisIndex[0] === 2){
           row = [];
           for(j = 0; j < rows.length; j++){
             
             row.push([rows[j][ctx.path.dii]]);
             
           }  
           values.push(row);
           
         }else if(axisIndex[0] === 3){
           
           for(j = 0; j < rows.length; j++){
             row = [];
             row.push([rows[j][ctx.path.dii]]);
             values.push(row);
           }
           
         }else{
           FunctionUtils.error("Not supported");
         }
           
           return values;
        },
      
      createMeasureValues : function(ctx, rows, axisIndex, maxAxisNumber){
         var values = [];
         if(axisIndex.length === 1){
             if(maxAxisNumber === 1 || maxAxisNumber === 2){
              return this.createMeasureValues_1_2(ctx, rows, axisIndex); 
             }else if(maxAxisNumber === 3){
               return this.createMeasureValues_1_3(ctx, rows, axisIndex);
             }else{
                FunctionUtils.error("Not supported");
             }
         }else if(axisIndex.length === 2){
             if(maxAxisNumber === 2){
                return rows;
             }else if(maxAxisNumber === 3){
                return this.createMeasureValues_2_3(rows, axisIndex);
             }else{
              FunctionUtils.error("Not supported");
             }
         }else{
             FunctionUtils.error("Not supported");
         }
           
         
           return values;
      },
     
        createMeasureValues_2_3 : function(rows, axisIndex){
          var i ,j, values;
          if(axisIndex[0] === 1 && axisIndex[1] === 2){
            return [rows];
          }else if(axisIndex[0] === 1 && axisIndex[1] === 3){
            values = [];
            for(i = 0 ; i < rows.length; i++){
                values.push([rows[i]]);
            }
            return values;
            
          }else if(axisIndex[0] === 2 && axisIndex[1] === 3){
            values = [];
            for(i = 0 ; i < rows.length; i++){
              var value = [];
              var cols = rows[i];
              for(j = 0; j < cols.length; j++){
                var col = cols[j];
                value.push([col]);
              }
              values.push(value);
            }
            
            return values;
          }else{
            FunctionUtils.error("Not supported");
          }
        }
        
     };
  
  return MeasureValuesDataHandler;
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.2'
}
],
 function Setup(FunctionUtils, MultiAxesDataAdapter, MeasureDataHandler){
    
   function initSubChartAxes(axes){
     
       var sub = axes.slice(0);
       sub.sort(function(a,b){return a.index -b.index;});
       sub.shift();  
       
       return sub;
   }
   
   function initMeasureValueAxisIndexForMeasure(bindingInfo){
     if(bindingInfo[0] === true){
       if(bindingInfo[1] === true){
          return [1,2];
       }else{
         return [1];
       }
      
     }else if(bindingInfo[1] === true){
       return [2];
     }else{
       return [1]; 
     }
     
   }
   
   function initMeasureValueAxisIndex(bindingInfo){
     
      //axis 1 has been feeded with crosstable
      if(bindingInfo[0] === true){
         if(bindingInfo[1] === true){
            return [1];
         }else if(bindingInfo[2] === true){
            if(bindingInfo.length > 3){
               return [1];//Multi Radar,pass crosstable to radar as single chart handler
            }else{
               return [2];
            }
         }else if(bindingInfo[3] === true){// Multi Radar, aa 4 could not be feeded
            FunctionUtils.error("Not Supported");
         }else{
            return [1];
         }
      }else if(bindingInfo[1] === true){
         if(bindingInfo[2] === true){
            return [1, 2];
         }else if(bindingInfo[3] === true){
            FunctionUtils.error("Not Supported");
         }else{
            return [1];
         }
      }else if(bindingInfo[2] === true){
        if(bindingInfo[3] === true){
           FunctionUtils.error("Not Supported");
        }
        else{
          if(bindingInfo.length > 3){
             return [1];//Multi Radar,pass crosstable to radar as single chart handler
          }else{
             return [2];
          }
        }
      }else{
        for(var i = 0; i< bindingInfo.length;i++){
          if(bindingInfo[i] === true){
             FunctionUtils.error("could not determin measure value axis index");
          }
        }
        //all false
        return [1];
      }
      
      FunctionUtils.error("could not determin measure value axis index");
     
     } 
   
   function MultiChartDataHandler(dataAdapter, type){
        this._dataAdapter =  dataAdapter;
        this._aa = this._dataAdapter.getAnalysisAxisDataByIdx();
        this._mg = this._dataAdapter.getMeasureValuesGroupDataByIdx();
        this._subAxes = initSubChartAxes(this._aa);
        this._type = type;
        
        if(this._type === undefined){
           this._measureValueAxisIndex = initMeasureValueAxisIndex(this._dataAdapter.getBindingInfo());
           this._maxMeasureAxis = 2;
        }else if(this._type === "measures"){
           this._measureValueAxisIndex = initMeasureValueAxisIndexForMeasure(this._dataAdapter.getBindingInfo());
           this._maxMeasureAxis = this._dataAdapter.getBindingInfo().length ;
        }
      
   }
   
   MultiChartDataHandler.prototype.getSubDataAdapter = function(ctx){
       if(this._type === undefined){
          return this.getSubDataAdapterByContext(ctx);
       }else if(this._type === "measures"){
          return this.getSubDataAdapterByMeasures(ctx);
       }
       
       return null;
     
   };
   
   MultiChartDataHandler.prototype.getSubDataAdapterByContext = function(ctx){
     var dataAdapter, subAxis, i, mvg;
     if(ctx){
        //Multiplier with MND
        if(ctx.path.mg !== undefined && ctx.path.mi !== undefined){
          if(ctx.path.di !== undefined && ctx.path.dii !== undefined){ // Mulitplier with Dimension and MND
             dataAdapter = new MultiAxesDataAdapter();
            
            for(i = 0; i < this._subAxes.length; i++){
              subAxis = this._subAxes[i];
              dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
            }
            
            mvg = this._mg[ctx.path.mg];
            dataAdapter.addMeasureValuesGroup({index: 0, values: MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxMeasureAxis, true)});
            
            
            return dataAdapter;

          }else{//Multiplier with MND only
           dataAdapter = new MultiAxesDataAdapter();
           
           for(i = 0; i < this._subAxes.length; i++){
             subAxis = this._subAxes[i];
             dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
           }
           
           mvg = this._mg[ctx.path.mg];
           //MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxAxisCount
           dataAdapter.addMeasureValuesGroup({index: 0, values:MeasureDataHandler.makeMeasureValues(null, {"values":[mvg.values[ctx.path.mi]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
           
           return dataAdapter;
          }
          
        }else{ //Multiplier without MND
          dataAdapter = new MultiAxesDataAdapter();
        
          for(i = 0; i < this._subAxes.length; i++){
            subAxis = this._subAxes[i];
            dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
          }
          
          for(i = 0; i < this._mg.length; i++){
            mvg = this._mg[i];
            dataAdapter.addMeasureValuesGroup({index: mvg.index, values:  MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
          }
          
          return dataAdapter;
          }
       }
     
     return null;
   };
   
   MultiChartDataHandler.prototype.getSubDataAdapterByMeasures = function(ctx){
     var dataAdapter = new MultiAxesDataAdapter();
      
     for(var i = 0; i < this._aa.length; i++){
        dataAdapter.addAnalysisAxis(this._aa[i]);
     }
      
     var mg = this._mg[0];
     
     dataAdapter.addMeasureValuesGroup({index : 0, values : MeasureDataHandler.makeMeasureValues(null, {"values":[mg.values[ctx.row]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
     dataAdapter.addMeasureValuesGroup({index : 1, values : MeasureDataHandler.makeMeasureValues(null, {"values":[mg.values[ctx.col]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
     
     return dataAdapter;
   };
   
   
   return MultiChartDataHandler;
   
 });sap.riv.module(
{
  qname : 'sap.viz.modules.util.DimensionalInfoHandler',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
}
],
function Setup(langManager) {
  //fake dataset
  return function(props, multiplier) {
    var data_ = multiplier;
    var props_ = props;
    var dimInCol_;
    var dimInRow_;
    var rowDimension_ = {
      'values' : []
    };

    var colDimension_ = {
      'values' : []  
    };
    var ctx_ = [];
    var rowCount_;
    var colCount_;
    var mndDefaultString = langManager.get('IDS_DEFAULTMND');
    var my = function() {

    };


    my.setData = function(data)
    {
      data_ = data;
      return my;
    };

    my.setProperties = function(props)
    {
      props_ = props;
      return my;
    };

    my.getColumnDimensionData = function()
    {
      return  colDimension_;
    };

    my.getRowDimensionData = function()
    {
      return rowDimension_;
    };

    my.getContexts = function()
    {
      return ctx_;
    };

    function buildIndexMeasuresOnly()
    {
      var i = 0;
      if(dimInCol_ > 0)
      {
        rowCount_ = 1;
        colCount_ = data_.values[0].rows.length;
        ctx_.push([]);
        var colDimVals = colDimension_.values;
        colDimVals[0] = { 
            'col':{
          'val': mndDefaultString
        },
        'rows':[]
        };

        for(i = 0; i < data_.values[0].rows.length; ++i)
        {
          colDimVals[0].rows.push({ 
            'val': data_.values[0].rows[i].val,
            'info': data_.values[0].rows[i].info
          });
          ctx_[0].push(data_.values[0].rows[i].ctx);
        }
      }
      else
      {
        rowCount_ = data_.values[0].rows.length;
        colCount_ = 1;
        var rowDimVals = rowDimension_.values;
        rowDimVals[0] = { 
            'col':{
        'val': mndDefaultString
        },
        'rows':[]
        };
        for(i = 0; i < data_.values[0].rows.length; ++i)
        {
          rowDimVals[0].rows.push({
            'val': data_.values[0].rows[i].val,
            'info': data_.values[0].rows[i].info
          });
          ctx_.push([data_.values[0].rows[i].ctx]);
        }
      }
    }

    function initilize()
    {
      rowDimension_.values = [];
      colDimension_.values = [];
      rowCount_ = 0;
      colCount_ = 0;
      ctx_ = [];
    }
    // compare tow title is the same
    function compare(index, preIndex, startDim, dimNum)
    {
      for(var i = startDim; i < startDim + dimNum; ++i)
      {
        if(data_.values[i].rows[index].val !== data_.values[i].rows[preIndex].val){
          return false;
        }
      }
      return true;
    }

    //  
    function buildUniqueIndexes(uniqueIndex, index, startDim, dimNum)
    {
      var start = 0;
      var end = uniqueIndex.length;
      var isFound = true;
      for ( var level = 0; isFound && level < dimNum; ++level) {
        var nextStart = end;
        var nextEnd = start;
        isFound = false;
        for ( var pos = start; pos < end; ++pos) {
          if (data_.values[startDim + level].rows[uniqueIndex[pos]].val=== data_.values[startDim + level].rows[index].val) {
            isFound = true;
            if (pos < nextStart){
              nextStart = pos;
            }
            if (pos >= nextEnd){
              nextEnd = pos + 1;
            }
          }
        }

        if (isFound) {
          start = nextStart;
          end = nextEnd;
        }
      }

      if (!isFound)
      {
        if (end < uniqueIndex.length){
          uniqueIndex.splice(end, 0, index);
        } else {
          uniqueIndex.push(index);}
      }       
    }

    // use one array to stroe one column header title
    function buildOneHeader(index, startDim, dimNum)
    {
      var result = [];
      for(var i = startDim; i < startDim + dimNum; ++i)
      {
        result.push(data_.values[i].rows[index].val);
      }
      return result;
    }

    // generate hashmap map from name to col index
    function generateIndexMap(allUniqueColIndex, startDim, dimNum)
    {
      var map = {};
      for(var i = 0; i < allUniqueColIndex.length; ++i)
      {
        map[buildOneHeader(allUniqueColIndex[i], startDim, dimNum)] = i;
      }
      return map;
    }

    function processColHeader(startDim, dimNum)
    {
      var colIndex = [];
      var allUniqueColIndex = [];
      allUniqueColIndex.push(0);
      var i;
      var element = {};
      for(i = 1; i < data_.values[startDim].rows.length; ++i)
      {
        buildUniqueIndexes(allUniqueColIndex, i, startDim, dimNum);
      }

      //build column dimension data set
      var colDimVals = colDimension_.values;
      for(i = 0; i < dimNum; ++i)
      {
        element = {};
        element.col = data_.values[startDim + i].col;
        element.rows = [];
        element.rows[0] = {
          'val': data_.values[startDim + i].rows[0].val,
          'info': data_.values[startDim + i].rows[0].info
        };
        colDimVals.push(element);
      }
      for(i = 0; i < allUniqueColIndex.length; ++i)
      {
        for(var j = 0; j < dimNum; j++)
        {
          colDimVals[j].rows[i] = {
            'val': data_.values[startDim + j].rows[allUniqueColIndex[i]].val,
            'info': data_.values[startDim + j].rows[allUniqueColIndex[i]].info
          };
        }

      }
      // to solve performance issue
      var hashMap = generateIndexMap(allUniqueColIndex, startDim, dimNum);
      for(i = 0; i < data_.values[startDim].rows.length; ++i)
      {
        element = buildOneHeader(i, startDim, dimNum);
        colIndex[i] = hashMap[element];
      }
      colCount_ = allUniqueColIndex.length;
      return colIndex;
    }
    
    
    function cloneOneContext(ctx)
    {
      if(!ctx) {return null;}
      return {
        'type': ctx.type,
        'path':{
          'aa': ctx.path.aa,
          'di': ctx.path.di,
          'dii': ctx.path.dii
        }
      };
    }
    
    function cloneOneRowContext(row)
    {
      var clones = [];
      for(var i = 0; i < row.length; ++i)
      {
        clones.push(cloneOneContext(row[i]));
      }
      return clones;
    }

    function addMeasureContext(row, ctx)
    {
      
      for(var i = 0; i < row.length; ++i)
      {
        if(!row[i]) {continue;}
        else if(!row[i].path)
        {
           row[i].path = {};
        }
        row[i].path.mg = ctx.path.mg;
        row[i].path.mi = ctx.path.mi;
      }
    }

    function expendContexts(num)
    {
      var totalRow = ctx_.length;
      for(var i = 0; i < num; ++i)
      {
        for(var j = 0; j < totalRow; ++j)
        {
          ctx_.push(cloneOneRowContext(ctx_[j]));
        }
      }
    }

    function addMND(bMNDInner, bMNDInRow, dimInRow, dimInCol)
    {
      var indexMND = bMNDInner ? data_.values.length - 1 : 0;
      var measures = data_.values[indexMND].rows;
      //new dimension to add row or column
      var row = {};
         row.col = data_.values[indexMND].col;
         row.rows = []; 
      var dimVals = bMNDInRow ? rowDimension_.values :colDimension_.values;
      var dimNums = bMNDInRow ? dimInRow : dimInCol;
      var i, j, k;
      var element;
      
      //1 MND in row and no dimension in row
      if(bMNDInRow && dimInRow === 0)
      {
        dimVals[0] = { 
            'col':{
            'val': mndDefaultString
          },
          'rows':[]
        };
        addMeasureContext(ctx_[0], measures[0].ctx);
        //Jimmy,12/27/2012 we don't have additional info for MND for now
        dimVals[0].rows.push({ 'val': measures[0].val});
        for(i = 1; i < measures.length; ++i)
        {
          dimVals[0].rows.push({ 'val': measures[i].val});
          ctx_.push(cloneOneRowContext(ctx_[0]));
          addMeasureContext(ctx_[i], measures[i].ctx);
        }
        rowCount_ = measures.length;
        return;
      }
      
      //2 MND in column and no dimension in column
      if(!bMNDInRow && dimInCol === 0)
      {
        //create column dimension and set value
        dimVals[0] = { 
            'col':{
            'val': mndDefaultString
            },
            'rows':[]
        };
        for(i = 0; i < measures.length; ++i)
        {
          dimVals[0].rows.push({'val' : measures[i].val});
        }
        
        // expand context  
        for(i = 0; i < ctx_.length; ++i)
        {
          ctx_[i][0].path.mg = measures[0].ctx.path.mg;
          ctx_[i][0].path.mi = measures[0].ctx.path.mi;
          for(j = 1; j < measures.length; ++j)
          {
            ctx_[i].push(cloneOneContext(ctx_[i][0]));
            ctx_[i][j].path.mg = measures[j].ctx.path.mg;
            ctx_[i][j].path.mi = measures[j].ctx.path.mi;
          }
        }
        return;
      }
      var count = bMNDInRow ? rowCount_ : colCount_;
      // 3 have dimensions in column and have dimensions in row
      if( bMNDInner)
      {
        // add measure data
        for(i = 0; i < count; ++i)
        {
          for(j = 0; j < dimVals.length; ++j)
          {
            for(k = 1; k < measures.length; ++k)
            {
              element =  {
                'val': dimVals[j].rows[i * measures.length + k - 1].val,
                'info': dimVals[j].rows[i * measures.length + k - 1].info
              };
              dimVals[j].rows.splice(i * measures.length + k, 0, element);
            }
          }
        }

        //add MND dimension to row/column
        for(i = 0; i < count; ++i)
        {
          for(j = 0; j < measures.length; ++j)
          {
            element =  {'val': measures[j].val};
            row.rows.push(element);
          }
        }
        dimVals.push(row);

        if(bMNDInRow)
        {
          rowCount_ *= measures.length;
          for(i = 0; i < rowCount_; i += measures.length)
          {
            addMeasureContext(ctx_[i], measures[0].ctx);
            for(j = 1; j < measures.length; ++j)
            {
              var oneRow = cloneOneRowContext(ctx_[i]);
              ctx_.splice(i + j, 0, oneRow);
              addMeasureContext(ctx_[i + j],  measures[j].ctx);
            }
          }

        }else{      
          colCount_ *= measures.length;
          for(i = 0; i < ctx_.length; ++i)
          {
            for(j = 0; j < colCount_; j+= measures.length)
            {
              ctx_[i][j].path.mg = measures[0].ctx.path.mg;
              ctx_[i][j].path.mi = measures[0].ctx.path.mi;    
              for(k = 1; k < measures.length; ++k)
              {
                ctx_[i].splice(j + k, 0, cloneOneContext(ctx_[i][j]));
                ctx_[i][j + k].path.mg = measures[k].ctx.path.mg;
                ctx_[i][j + k].path.mi = measures[k].ctx.path.mi;
              }
            }
          }
        }
        return;
      }
      else {

        //expand value first; 
        for(i = 1; i < measures.length; ++i)
        {
          for(j = 0; j < dimNums; ++j)
          {
            for(k = 0; k < count; ++k)
            {
              element = {
                'val': dimVals[j].rows[k].val,
                'info': dimVals[j].rows[k].info
              };
              dimVals[j].rows.push(element);
            }
          }
        }

        //add 
        for(j = 0; j < measures.length; ++j)
        {
          for(i = 0; i < count; ++i)
          {
            element =  {'val': measures[j].val};
            row.rows.push(element);
          }
        }
        dimVals.splice(0, 0, row);
        if(bMNDInRow)
        {
          rowCount_ *= measures.length;
          expendContexts(measures.length - 1);
          for(i = 0; i < rowCount_; ++i)
          {
            addMeasureContext(ctx_[i], measures[rowCount_ % measures.length].ctx);
          }
        }else{
          colCount_ *= measures.length;

          for(i = 0; i < ctx_.length; ++i)
          {
            var rows = [];
            addMeasureContext(ctx_[i], measures[0].ctx);
            for(j = 1; j < measures.length; ++j)
            {
              var addedRow = cloneOneRowContext(i);
              addMeasureContext(addedRow, measures[0].ctx);
              rows = rows.concat(cloneOneRowContext(i));
            }
            ctx_[i] = ctx_[i].concat(rows);
          }
        }
      }
    }
    
    function buildRowDimension(dimInRow, startIndex, rowIndexs){

      var rowDimVals = rowDimension_.values;
      var i = 0;
      for(i = 0; i < dimInRow; ++i)
      {
        var element = {};
        element.col = data_.values[startIndex + i].col;
        element.rows = [];
        element.rows[0] = {
          'val': data_.values[startIndex + i].rows[0].val,
          'info': data_.values[startIndex + i].rows[0].info
        };
        rowDimVals.push(element);
      }
      for (i = 1; i < data_.values[startIndex].rows.length; ++i)
      {
        if (compare(i, i - 1, startIndex, dimInRow)){
          rowIndexs[i] = rowCount_;
        }else {  
          ++rowCount_;
          for(var j = 0; j < dimInRow; j++)
          {
            rowDimVals[j].rows[rowCount_] = {
              'val': data_.values[startIndex + j].rows[i].val,
              'info': data_.values[startIndex + j].rows[i].info
            };
          }
          rowIndexs[i] = rowCount_;
        }
      }
      ++rowCount_;
    }
    
    // Mix MND and dimension case
    function processDimsWithMeasure()
    {
      var startIndex = 0,
        endIndex = data_.values.length;
      var dimInRow = dimInRow_,
        dimInCol = dimInCol_;
      var bMNDInner = false,
        bMNDInRow = true;
      var i;
      if(data_.values[0].type === "MND")
      {
        ++startIndex;
        if(dimInRow > 0){ 
          --dimInRow;
        } else {
          --dimInCol;
          bMNDInRow = false;
        }
      }

      if(data_.values[endIndex - 1].type === "MND")
      {
        bMNDInner = true;
        --endIndex;
        if(dimInCol > 0)
        {
          --dimInCol;
          bMNDInRow = false;
        }else{
          bMNDInRow = true;
          --dimInRow;
        }
      }

      //process no MND cases first
      if(startIndex < endIndex)
      {
        //some dimension in row and some in column 
        var rowIndexs = [];
        if(dimInCol > 0 || dimInRow > 0)
        {
          //process row dimension first
          rowIndexs[0] = 0;
          rowCount_ = 0;
          if(dimInRow > 0)
          {
            buildRowDimension(dimInRow, startIndex, rowIndexs);
          }else{
            rowCount_ = 1;
            for(i = 1; i < data_.values[startIndex].rows.length; ++i){
              rowIndexs[i] = 0;
            }
          }
          
          //build column dimensions and indexes
          var colIndexs = [];
          if(dimInCol > 0)
          {
            colIndexs = processColHeader(startIndex + dimInRow, dimInCol);
          }else{
            colCount_ = 1;
            for(i = 0; i < data_.values[startIndex].rows.length; ++i){
              colIndexs[i] = 0;
            }
          }
          
          //generate data context for each sub chart
          ctx_ = new Array(rowCount_);
          for(i = 0; i < rowCount_; ++i)
          {
            ctx_[i] = [];
            for(var j = 0; j < colCount_; ++j){
              ctx_[i][j] = null;
            }
          }

          for(i = 0 ; i < data_.values[startIndex].rows.length; ++i)
          {
            ctx_[rowIndexs[i]][colIndexs[i]] = data_.values[startIndex + dimInRow + dimInCol - 1].rows[i].ctx;
          }
        }
        
        //process measure names at last
        if(dimInRow < dimInRow_ || dimInCol < dimInCol_)
        {
          addMND(bMNDInner, bMNDInRow, dimInRow, dimInCol);
        }
      }
    }

    my.process = function()
    {
      initilize();
      if(!data_ || !data_.values || data_.values.length === 0) {return;}
      dimInCol_ =  props_ && props_["numberOfDimensionsInColumn"] !== undefined ?  props_["numberOfDimensionsInColumn"] : 1;
      if(!dimInCol_ || dimInCol_ < 0) { dimInCol_ = 0;}
      if(dimInCol_ > data_.values.length) {dimInCol_ = data_.values.length;}
      dimInRow_ = data_.values.length - dimInCol_;
      if(dimInRow_ < 0){ dimInRow_ = 0;}

      if(data_.values.length === 1 && data_.values[0].type === "MND")
      {
        buildIndexMeasuresOnly();
      }else{
        processDimsWithMeasure();
      }
    };

    return my;

  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.layout',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
}
],
function Setup(TypeUtils) {
  
  /*
   * Function set that represents a light-weight layout manager
   * who calculates optimal component layout data, rather than
   * operating on components directly.
   */
  var _ = function ( spec ) {
    
    var defaults = {
      resize : true,
      type : 'grid',
      padding : [0,0,0,0],
      hgap : 0,
      vgap : 0
    };  
  
    var hgap = spec.hgap || defaults.hgap,
        vgap = spec.vgap || defaults.vgap,
        padding = spec.padding || defaults.padding,
        bias = spec.bias || 'none';
    
    //Jimmy8/7/2012, different layout function may return different layoutSolution
    //so initialize it in each layout function
    var layoutSolution; // returning data
    
    switch ( spec.type ) {
    case 'border' : 
      border(spec.prefs);
      break;
    case 'grid' :
      grid(spec.prefs);
      break;
    case 'table' :
      //FIXME Elliott/Jimmy 8/7/2012, table layout has some special options
      //here we will read spec inside table layout function directly. consider
      //making it consistent with others 
      table();
      break;
    case 'border2' : 
      border2 (spec);
      break;
    default :
      grid(spec.prefs);
    }
    
    /*
     * this is a simple border layout which items are position from north to east, then south to west, the center is the last.
     * so the preferred size of north, east, south and west will be considered while the center will be ignored.
     */
    function border2 (config){
      var spec = config.specs;
      var size = config.size;
      var metadata = {};
      for(var item in spec){
        if(spec.hasOwnProperty(item)){
          metadata[spec[item].info] = {
            size: spec[item].preferSize,
            key: item
          };
        }
      }
      border(metadata);
      var ret = {};
      for ( var i in layoutSolution ) {
        if ( layoutSolution.hasOwnProperty(i) ) {
          ret[metadata[i].key] = layoutSolution[i];
        }
      }
      layoutSolution = ret;
    }
    
    /**
     * Represents a border-docking layout method which assigns components
     * with spaces of omni-directional border insets. Padding is leaved
     * prior to layout. Component marked as a bias will be processed first
     * to embody the predominance of it. North and South parts are naturally
     * biased against other parts due to the nature of border layout. So
     * the bias attribute supports up to two values: 'west', 'east' or both
     * (in an array and order matters). The center part is under passive 
     * control and queued last to be processed.
     * 
     * ---------------------------------------
     * |               Padding               |
     * |   -------------------------------   |
     * |   |     |     North       |     |   |
     * |   -------------------------------   |
     * |   |     |                 |     |   |
     * |   |  W  |                 |  E  |   |
     * |   |  e  |     Center      |  a  |   |
     * |   |  s  |                 |  s  |   |
     * |   |  t  |                 |  t  |   |
     * |   |     |                 |     |   |
     * |   |     |                 |     |   |
     * |   -------------------------------   |
     * |   |     |     South       |     |   |
     * |   -------------------------------   |
     * |                                     |
     * ---------------------------------------
     */
    function border( options ) {
      layoutSolution = {};
      var packedSize = {}, // Size without paddings.
          autoResizing = true;
      packedSize.width = spec.size.width - padding[1] - padding[3];
      packedSize.height = spec.size.height - padding[0] - padding[2];
      
      // Enclosing dimension bounds
      var minX = padding[3],
          minY = padding[0],
          maxX = spec.size.width - padding[1],
          maxY = spec.size.height - padding[2];

      var queue = new Array, i;
      
      // Layout ordering rule
      if ( bias instanceof Array ) {
        queue[0] = bias[0];
        queue[1] = bias[1];
        queue[2] = 'north';
        queue[3] = 'south';
      } else {
        switch ( bias ) {
        case 'west' :
          queue[0] = 'west';
          queue[1] = 'north';
          queue[2] = 'south';
          queue[3] = 'east';
          break;
        case 'east' :
          queue[0] = 'east';
          queue[1] = 'north';
          queue[2] = 'south';
          queue[3] = 'west';
          break;
        default :
          queue[0] = 'south';
          queue[1] = 'north';
          queue[3] = 'east';
          queue[2] = 'west';
        }
      }
      queue[4] = 'center';
      
      for ( i = 0; i < queue.length; i++ ) {
        doLayout(queue[i]);
      }
      
      function doLayout( division ) {
        function getAvailableSpacings ( maxSize ) {
          if ( arguments.length < 2 ) {
              return 0;
          }
          var spacings = Array.prototype.slice.apply(arguments).slice(1);
          var spacingsByOrder = [];
          for ( var i = 0; i < spacings.length; i++ ) {
            if ( spacings[i].length > 1 ) {
              spacingsByOrder[i] = spacings[i].slice(1);
              spacingsByOrder[i].push(spacings[i][0]);
            }
          }
          
          var availableSpacings = 0;
          var availableSpacingsSum = 0;
          for ( var i = 0; i < spacingsByOrder[0].length; i++ ) {
            for ( var j = 0; j < spacingsByOrder.length; j++ ) {
              availableSpacingsSum += spacingsByOrder[j][i];
            }
            if ( availableSpacingsSum > maxSize ) {
              return availableSpacings;
            }
            availableSpacings += spacingsByOrder[0][i];
          }
          return availableSpacings;
        }

        var node = {}, preferredSize = {};
        
        if ( division === 'north' && options.north ) {
          node = layoutSolution.north = {};
          preferredSize = options.north.size;
          var nodeHeight = preferredSize.height;
          var heightSum = nodeHeight;
          
          if ( autoResizing ) {
            if ( preferredSize.spacings && options.south && options.south.size.spacings ) {
                heightSum += options.south.size.height;
            }
            
            if ( preferredSize.maxSizeConstant && heightSum > packedSize.height * preferredSize.maxSizeConstant ) {
              if ( preferredSize.hideOversize ) {
                  nodeHeight = 0;
              } else if ( preferredSize.spacings ) {
                if (options.south && options.south.size.spacings) {
                    nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings, options.south.size.spacings);
                } else {
                    nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings);
                }
              } else {
                nodeHeight = packedSize.height * preferredSize.maxSizeConstant;
              }
            }
          }
          node.bounds = { 
            x : minX, 
            y : minY,
            width  : maxX - minX,
            height : nodeHeight
          };
          minY += (node.bounds.height + hgap);
          if (node.bounds.height == 0) {
              layoutSolution.north = null;
          }
        }
        
        if ( division === 'east' && options.east ) {
          node = layoutSolution.east = {};
          preferredSize = options.east.size;
          var nodeWidth = preferredSize.width;
          var widthSum = nodeWidth, x = 0;
          
          if ( autoResizing ) {
            if ( preferredSize.spacings && options.west && options.west.size.spacings ) {
              widthSum += options.west.size.width;
            }
            if ( preferredSize.maxSizeConstant && widthSum > packedSize.width * preferredSize.maxSizeConstant ) {
              if ( preferredSize.hideOversize ) {
                nodeWidth = 0;
              } else if ( preferredSize.spacings ) {
                if ( options.west && options.west.size.spacings ) {
                  nodeWidth = getAvailableSpacings(
                    packedSize.width * preferredSize.maxSizeConstant, 
                    preferredSize.spacings, options.west.size.spacings
                  );
                } else {
                  nodeWidth = getAvailableSpacings(
                    packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings);
                }
              } else {
                nodeWidth = packedSize.width * preferredSize.maxSizeConstant;
              }
            }
            if ( nodeWidth < preferredSize.minWidth ) { nodeWidth = 0; }
            x = maxX - nodeWidth;
          } else {
            x = layoutSolution.west.bounds.width + layoutSolution.south.bounds.width;
          }
          node.bounds = { 
            x : x,
            y : minY,
            width : nodeWidth,
            height : maxY - minY
          };
          
          if (node.bounds.height < preferredSize.minHeight) {
              node.bounds.width = 0;
          }
          
          maxX -= (node.bounds.width + vgap);
          if (node.bounds.width == 0) {
              layoutSolution.east = null;
          }
        }
        
        if ( division === 'south' && options.south ) {
          node = layoutSolution.south = {};
          preferredSize = options.south.size;
          autoResizing = !preferredSize.manual; // manual size enabled or disabled
          var nodeHeight = preferredSize.height, nodeWidth = 0;
          var heightSum = nodeHeight;
          
          if ( autoResizing ) {
            if ( preferredSize.spacings && options.north && options.north.size.spacings ) {
              heightSum += options.north.size.height;
            }
            if ( preferredSize.maxSizeConstant && heightSum > packedSize.height * preferredSize.maxSizeConstant ) {
              if ( preferredSize.hideOversize ) {
                  nodeHeight = 0;
              } else if ( preferredSize.spacings ) {
                if ( options.north && options.north.size.spacings ) {
                  nodeHeight = getAvailableSpacings(
                    packedSize.height * preferredSize.maxSizeConstant, 
                    preferredSize.spacings, options.north.size.spacings
                  );
                } else {
                  nodeHeight = getAvailableSpacings(
                    packedSize.height * preferredSize.maxSizeConstant, 
                    preferredSize.spacings);
                }
              } else {
                nodeHeight = packedSize.height * preferredSize.maxSizeConstant;
              }
            }
            nodeWidth = maxX - minX;
          } else {
            nodeWidth = preferredSize.width > packedSize.width ? 
                        packedSize.width : preferredSize.width;
            if ( nodeHeight > packedSize.height ) {
              nodeHeight = packedSize.height;
            }
          }
          
          node.bounds = {
            x : minX,
            y : (maxY - nodeHeight) < minY ? minY : (maxY - nodeHeight),
            width  : nodeWidth
          };
          node.bounds.height = nodeHeight;
          maxY -= (node.bounds.height + hgap);
          
          if ( node.bounds.height === 0 ) { layoutSolution.south = null; }
        }
        
        if ( division === 'west' && options.west ) {
          node = layoutSolution.west = {};
          preferredSize = options.west.size;
          var nodeWidth = preferredSize.width;
          var widthSum = nodeWidth;
          
          if ( autoResizing ) {
            if ( preferredSize.spacings && options.east && options.east.size.spacings ) {
              widthSum += options.east.size.width;
            }
            if ( preferredSize.maxSizeConstant && widthSum > packedSize.width * preferredSize.maxSizeConstant ) {
              if ( preferredSize.hideOversize ) {
                nodeWidth = 0;
              } else if (preferredSize.spacings) {
                if ( options.east && options.east.size.spacings ) {
                  nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings, options.east.size.spacings);
                } else {
                  nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings);
                }
              } else {
                nodeWidth = packedSize.width * preferredSize.maxSizeConstant;
              }
            }
          }
          node.bounds = {
            x : minX,
            y : minY,
            width  : nodeWidth,
            height : (minY + preferredSize.height) > maxY ? maxY : (minY + preferredSize.height)
          };
          minX += (node.bounds.width + vgap);
          if (node.bounds.width == 0) {
              layoutSolution.west = null;
          }
        }
        
        if ( division === 'center' && options.center ) {
          node = layoutSolution.center = {};
          var w = !autoResizing && layoutSolution.south ? layoutSolution.south.bounds.width : maxX - minX,
              h = maxY - minY; 
          node.bounds = {
            x : minX,
            y : minY,
            width  : w,
            height : h
          };
        }
      }
    }
    
    function grid( options ) {}
    
    /**
     * compared to HTML table, currently we only support cellpadding. we don't (need) support cellspacing 
     * @param {Object} options
     */
    function table( options ) {
      layoutSolution = [];//return layout solution by column * row
      //table layout options
      var columns = TypeUtils.isExist(spec.columns) ? spec.columns : 3;
      var rows = TypeUtils.isExist(spec.rows) ? spec.rows : 2;
      var cellpadding = TypeUtils.isExist(spec.cellpadding) ? spec.cellpadding : 5;
      var paddingThreshold = TypeUtils.isExist(spec.paddingThreshold) ? spec.paddingThreshold : 0.1;
      
      var packedSize = {}; // Size without paddings.
        packedSize.width = spec.size.width - padding[1] - padding[3];
        packedSize.height = spec.size.height - padding[0] - padding[2];
        
        var avgWidth = packedSize.width / columns;
        var avgHeight = packedSize.height / rows;
        //don't make the cellPadding too large
        if ( cellpadding > avgWidth * paddingThreshold || cellpadding > avgHeight * paddingThreshold ) {
          cellpadding = 2;
        }
        var cellWidth = ( packedSize.width - 2 * columns * cellpadding ) / columns;
        cellWidth = cellWidth > 0 ? cellWidth : 0;
        var cellHeight = ( packedSize.height - 2 * rows * cellpadding ) / rows;
        cellHeight = cellHeight > 0 ? cellHeight : 0;
      
        // Enclosing dimension bounds
        var minX = padding[3],
        minY = padding[0],
        maxX = spec.size.width - padding[1],
        maxY = spec.size.height - padding[2];
        
        for ( var col = 0; col < columns; col++ ) {
          var colia = [];//column iteration array
          for ( var row = 0; row < rows; row++ ) {
            var node = {};
            node.bounds = {
              x: col * avgWidth + avgWidth/2 - cellWidth/2,
              y: row * avgHeight + avgHeight/2 - cellHeight/2,
              width: cellWidth,
              height: cellHeight
            };
            colia.push(node);
          }
          layoutSolution.push(colia);
        }
        
    }
    
    return layoutSolution;
  };
  
  return _;
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.tablecontainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.DimensionalInfoHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ignite',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.fn.createContext',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
}
],
function Setup ( TypeUtils, Objects, Functions, layout, DIHandler, MCHandler, 
  Manifest, MultiAxesDataAdapter,dispatch, boundUtil, ignite, createContext, dataUtil ) {
  
  var retfn =  function (manifest, ctx) {
    var width = 0, 
        height = 0,
        centerWidth = 0, //size for the real table area without table headers
        centerHeight = 0, 
        properties = {},
        //for containers we use properties to hold any properties we have to pass to sub
        //then we use this internalProps to hold properties for container itself
        internalProps = manifest.props(null),
        internalRange = {}, //used for data range merge
        multiData = {
          
        },//used to save raw data process result
        subModuleNames = [], //used to update sub modules while data updating
        subControllerNames = [], //used to update controllers while data updating  
        data = null,
        config = {},
        modules = {},
        selections = {},
        parent = null, // a d3 selection
        rows = 3,
        columns = 2,
        xCategoryScale = d3.scale.ordinal(),
        yCategoryScale = d3.scale.ordinal(),
        eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0, avaModulesCount = 0,
        plotManifest, plotContext;
    
    //for container, we won't extract properties exactly for it. so we have to
    //get property by ourselves. the property category should be consistent with
    //module definition
    var PROPERTYCATEGORY = 'multiLayout';
    var initializedPlots = 0;

    //Alex Su: we need to hold a copy of animation flag settings to control animation flow.
    var plotAnimation = {
      dataLoading: true,
      dataUpdating:true,
      resizing:true
    };
    var bFirstCreation = true, bDataChanged = false;
    
    var PLOTAREAPROPCATE = 'plotArea';
    
    function setAnimationFlag(back){
      //Alex Su: FIXME hard coded here, need to be resolved in the future.
      var props = {};
      var propcate = (props[PLOTAREAPROPCATE] = {});
      var animation = (propcate.animation = {});
      Objects.extend(animation, plotAnimation);
      if (!back && bDataChanged){
        animation.dataLoading = plotAnimation.dataUpdating;
      }
      var plots = modules.plot;
      for(var i = 0, len = plots.length; i < len; i++){
        plots[i].properties(props);
      }      
    }
    
    function clearInternalRange(){
      for(var i in internalRange){
        if(internalRange.hasOwnProperty(i)){
          delete internalRange[i];
        }
      }
    }
    
    function initialize() {
      if ( TypeUtils.isEmptyObject(config) ) {
        Functions.error('Container configuration missing');
      }
      
      processRawData();
      avaPlotCount = 0, avaModulesCount = 0;
      //Jimmy/9/13/2012 we only support yAxis and xAxis2 for now, the other two won't be initialized
      initAxis(config, 'xAxis', multiData.columnData);
      initAxis(config, 'yAxis', multiData.rowData);
      initAxis(config, 'xAxis2', multiData.columnData);
      initAxis(config, 'yAxis2', multiData.rowData);
      
      initializePlots();
      updateProperties("plot");
      updateProperties("xAxis2");
      updateProperties("yAxis");
      updatePlotData();
      initializePlotElements();
      
      avaModulesCount = avaModulesCount + avaPlotCount;
    }
    
    function processRawData() {
      delete multiData.contexts;
      delete multiData.columnData;
      delete multiData.rowData;
      delete multiData.dataHandler;
      //get dimensional info
      //FIXME jimmy/8/8/2012, we assume to use dimensional layout by default
      //we may need support other layouts
      //FIXME jimmy/8/8/2012, how to know which feed is for multiplier?
      var dih = DIHandler({
        'numberOfDimensionsInColumn' : internalProps.numberOfDimensionsInColumn
      }, data.getAnalysisAxisDataByIdx(0));//data['sap.viz.multiplier']);
      
      dih.process();
      
      var rowD = dih.getRowDimensionData();
      var columnD = dih.getColumnDimensionData();
      var contexts = dih.getContexts();
      rows = contexts.length;
      columns = rows > 0 ? contexts[0].length : columns;
      
      var columnData = new MultiAxesDataAdapter();
      columnData.addAnalysisAxis({key:columnData.key, index : 0, values: columnD.values});
      var rowData = new MultiAxesDataAdapter();
      rowData.addAnalysisAxis({key:rowD.key, index : 0, values: rowD.values});

      //row data has no contexts. we have to add ctx to rowData and columnData
      var rowAAData;
      var colAAData;
      if(rowData.getAnalysisAxisDataByIdx)
      {
        rowAAData = rowData.getAnalysisAxisDataByIdx(0);
      }
      if(columnData.getAnalysisAxisDataByIdx)
      {
        colAAData = columnData.getAnalysisAxisDataByIdx(0);
      }

      var i;
      var j;

      var colNum = 0;
      var rowNum = contexts.length;
      if(rowNum > 0)
      {
          colNum = contexts[0].length;
      }

      var initContexts = function(aaDataValues, index)
      {
          var i;
          for(i = 0; i < aaDataValues.length; i++)
          {
              aaDataValues[i].rows[index].contexts = [];
          }
      };

      var pushContexts = function(aaDataValues, index, ctx)
      {
          var i;
          for(i = 0; i < aaDataValues.length; i++)
          {
              aaDataValues[i].rows[index].contexts.push(ctx);
          }
      };

      //for rowData
      for(i = 0; i < rowNum; i++)
      {
        initContexts(rowAAData.values, i);
        for(j = 0; j < colNum; j++)
        {
            pushContexts(rowAAData.values, i, contexts[i][j]);
        }
      }

      //for colData
      for(i = 0; i < colNum; i++)
      {
          if(colAAData.values.length > 0)
          {
            initContexts(colAAData.values, i);
            for(j = 0; j < rowNum; j++)
            {
                pushContexts(colAAData.values, i, contexts[j][i]);
            }
          }
      }
      
      multiData.contexts = contexts;
      multiData.columnData = columnData;
      multiData.rowData = rowData;
      multiData.dataHandler = new MCHandler(data);
    }
    
    function initAxis( config, id , axisData) {
      if ( !config.modules[id] ) {
        return;
      }
      
      var axisConfig = config.modules[id],
          axis = modules[id] = ignite(axisConfig.id, ctx, 'v-' + id); // Saves references to axis function.
      
      updateAxisData(id, axisData);
          
      var props = {}, usrProps, sysProps;
      if ( axisConfig.configure ) {
        usrProps = properties[axisConfig.configure.propertyCategory] || {};
        sysProps = axisConfig.configure.properties || {};
        Objects.extend( true, props, sysProps, usrProps );
        axis.properties(props);
      }
      
      if(axis.dispatch && axis.dispatch()['initialized']){
        avaModulesCount++;
        axis.dispatch().on('initialized.tablecontainer', initialized);
      }
      
      selections[id] = parent.append('g').attr('class', 'v-m-' + id);
    }
    
    function updateAxisData (id, axisData) {
      if(modules[id]){
        modules[id].data(axisData);
      }
    }
    
    function initializePlots() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) {
        return;
      }      
      
      cleanSubControllers();
      cleanSubModules();

      //we will create multi plot here
      var contexts = multiData.contexts;
      var plots = modules.plot = [], i = 0;
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          //contexts returned from dimensionalInfoHandler is rows*column
          var ctxI = contexts[rowI][colI];
          //[Jimmy/8/28/2012]we won't create sub plots when ctxI is undefined. but do we need
          //filter them out of the array? currently we will still have the full-size array with
          //some of them undefined. other parts who need read them should pay attention to (like
          //dependency resolving, and controller etc.)
          if(ctxI){
            
            
            if ( !plotManifest || !plotContext ) {
              plotManifest = Manifest.get(plotConfig.id);
              plotContext = createContext(plotManifest, ctx, "v-m-plot");
            }
            
            var plotI = plots[i] = ignite(plotManifest, plotContext);
            plotI.config(plotConfig);

            if(plotI.dispatch){
              avaPlotCount++;
              var dis =  plotI.dispatch();
                 if(dis.initialized) {
                   dis.on('initialized.tablecontainer', initialized);
                 }
                 if(dis.showTooltip) {
                   dis.on('showTooltip.tablecontainer', showTooltip);
                 }
                 if(dis.hideTooltip) {
                   dis.on('hideTooltip.tablecontainer', hideTooltip);
                 }
            }
            ++i;
          }
        }
      }
    }
    
    function updatePlotProperties() {
      var plots = modules.plot;
      if(plots){
        var plotConfig = config.modules.plot;
        if ( !plotConfig ) {
          return;
        }
        //Jimmy/8/23/2012 pay attention to the property structure, for container we will pass
        //all properties instead of properties under propsCat only.
        //FIXME currently it's hard coded here we assume the plot is container, actually we should
        //check the plot type
        var props = null, usrProps, sysProps;
        var nodeConfig = plotConfig.configure;
        if ( nodeConfig ) {
          sysProps = {};
          if ( nodeConfig.propertyCategory ) {
            sysProps[nodeConfig.propertyCategory]  = nodeConfig.properties;
          }
          usrProps = properties;
          props = {};
          Objects.extend( true, props, sysProps, usrProps ); 
        }else{
          props = properties;
        }
        
        for(var i = 0, len = plots.length; i < len; i++){
          if(props && plots[i]){
            plots[i].properties(props);
          }
        }
      }
    }
    //TO FIX: remove this work around.
    function updateProperties(moduleId){
      if (moduleId === 'plot'){
        updatePlotProperties();
      }
      else{
        var module = modules[moduleId];
        if(module){
          var moduleConfig = config.modules[moduleId];
          if ( !moduleConfig ) {
            return;
          }
          var props;
          var nodeConfig = moduleConfig.configure;
          if ( nodeConfig ) {
            props = Objects.extend(true, {}, properties[ nodeConfig.propertyCategory ]);
          }else{
            props = properties;
          }
         module.properties(props); 
        }
      }
    }
    
    function updatePlotData() {
      var dataHandler = multiData.dataHandler;
      var contexts = multiData.contexts;
      var plots = modules.plot, i = 0;
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          //contexts returned from dimensionalInfoHandler is rows*column
          var ctxI = contexts[rowI][colI];
          if(ctxI){
            var dataI = dataHandler.getSubDataAdapter(ctxI);
            if(plots[i]){
              plots[i].data(dataI);
              ++i;
            }  
          }
        }
      }
    }
    
    function initializePlotElements() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) {
        return;
      }
           
      var plots = modules.plot;
      var splots = selections.plot = [];
      var contexts = multiData.contexts;

      if(selections.plotRoot){
        selections.plotRoot.remove();
      }
      var plotRoot = selections.plotRoot = parent.append('g').attr('class', 'v-m-plot');
      var i = 0;
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          var ctxI = contexts[rowI][colI];
          if(ctxI){
            var plotI = plots[i];
            
            //create svg elements
            splots[i] = plotRoot.append('g').attr('class', 'v-m-plot' + i);
            plotI.parent(splots[i]);
            
            if(plotI.modules){
              var subModules = plotI.modules();
              var sname;
              for ( var m in subModules ){
                if ( subModules.hasOwnProperty(m) ){
                  sname = 'plot[' + i + ']' + '.' + m;
                  subModuleNames.push(sname);
                  modules['plot[' + i + ']' + '.' + m] = subModules[m];
                }
              }  
            }
            
             //Jimmy/8/22/2012 we introduce controller module which can be configured to any module (except controller module of course)
            //as for now, we only add the support to container. TODO
           
            var nodeController = plotConfig.controllers;
            if(nodeController){
              for(var nc in nodeController){
                if(nodeController.hasOwnProperty(nc)){
                  var controllerConfig = nodeController[nc];
                  var controller = ignite(controllerConfig.id, ctx);
                  controller().module(plotI);
                  var props = {};
                  var propsCat = controllerConfig.propertyCategory;
                  var usrProps = properties[ propsCat ];
                  var sysProps = controllerConfig.properties;
                  Objects.extend( true, props, sysProps, usrProps );
                  controller.properties(props);
                  subControllerNames.push('plot[' + i + ']' + '.' + nc);
                  modules['plot[' + i + ']' + '.' + nc] = controller;
                }
              }
            }
            ++i;
          }
        }
      }
    }
    
    function cleanSubControllers() {
      //clean all current submodules
      for(var i = 0, len = subControllerNames.length; i < len; i++){
        delete modules[subControllerNames[i]];
      }
      subControllerNames = [];
    }
    
    function cleanSubModules () {
      //clean all current submodules
      for(var i = 0, len = subModuleNames.length; i < len; i++){
        delete modules[subModuleNames[i]];
      }
      subModuleNames = [];
      
      if ( plotContext ) {
        plotContext.styleManager.cleanChildren();
      }
    }

    function relayout() {
      if ( TypeUtils.isEmptyObject(modules) || !width || !height ) {
        return;
      }
      
      var prefs = {};
      if ( modules.xAxis ) {
          modules.xAxis.drawable(true);
          prefs.south = { size : modules.xAxis.getPreferredSize() };
      }
      if ( modules.yAxis ) {
          modules.yAxis.drawable(true);
          prefs.west = { size : modules.yAxis.getPreferredSize() };
      }
      if ( modules.xAxis2 ) {
          modules.xAxis2.drawable(true);
          prefs.north = { size : modules.xAxis2.getPreferredSize() };
      }
      if ( modules.yAxis2 ) {
          modules.yAxis2.drawable(true);
          prefs.east = { size : modules.yAxis2.getPreferredSize() };
      }
      if ( modules.plot ) {
        prefs.center = {};
      }
      
      var solution = layout({
        type : 'border',
        bias : 'none',
        size : { width : width, height : height },
        prefs : prefs
      });
      
      centerWidth = solution.center.bounds.width;
      centerHeight = solution.center.bounds.height;
      
      //JIMMY/8/8/2012, WHY WE NEED DO THIS HERE?
      //the first time layout, we haven't set scale to axis (as dependency resolve happens after
       // the first layout), so the preferred size we get from axis is 0. then during dependency
       //resolving, we return scale to axis based on this inaccurate preferred size.
       
       //then during rendering, we will do layout again, this time we get a new preferred size from
       //axis as axis has scale now. but with this new preferred size, the scale has also to be updated,
       //but we won't do dependency resolving anymore. so we have to update the scale here. as axis
       //has the same reference of the scale, it can also get the new scale value.
       
       //so the preferred size returned by axis is actually based on the old scale and thus inaccurate. why
       //it doesn't affect the rendering result? for horizontal axis, the scale only matters the width of the axis
       //which we don't care, we only care height for horizontal axis. for vertical axis, the scale only matters
       //the height of the axis while we only care the width of it during layout.
       
       //so that's why we need layout again before rendering. we want to get the preferredsize from axis
       //even with a wrong scale. if axis can return preferredsize without scale (it's only possible for one
       //direction which is exactly we care during layout), we don't need do this.  
      xCategoryScale.rangeBands([0, centerWidth]);
      yCategoryScale.rangeBands([0, centerHeight]);
      
      if ( solution.north ) {
        // Modifies xAxis width and coordinate to handle horizontal offset
        // to ensure joints with yAxis.
        var xAxis2Width = 0, xAxis2X = 0;
        if ( solution.west ) {
          xAxis2Width = solution.north.bounds.width - solution.west.bounds.width;
          xAxis2X = solution.north.bounds.x + solution.west.bounds.width;
        }
        if ( solution.east ) {
          xAxis2Width = solution.north.bounds.width - solution.east.bounds.width;
        }
        
        selections.xAxis2.attr('transform', 
          'translate(' + xAxis2X + ',' + solution.north.bounds.y + ')');
        
        modules.xAxis2
          .width(xAxis2Width)
          .height(solution.north.bounds.height);
      
        modules.xAxis2.gridlineLength(solution.center.bounds.height);  
      } else if (modules.xAxis2) {
          modules.xAxis2.drawable(false);
      }
      
      if ( solution.east ) {
        selections.yAxis2.attr('transform', 
          'translate(' + solution.east.bounds.x + 
          ',' + solution.east.bounds.y + ')');
        modules.yAxis2
          .width(solution.east.bounds.width)
          .height(solution.east.bounds.height);
          
        modules.yAxis2.gridlineLength(solution.center.bounds.width);    
      } else if (modules.yAxis2) {
          modules.yAxis2.drawable(false);
      }
      
      if ( solution.south ) {
        // Modifies xAxis width and coordinate to handle horizontal offset
        // to ensure joints with yAxis.
        var xAxisWidth = 0, xAxisX = 0;
        if ( solution.west ) {
          xAxisWidth = solution.south.bounds.width - solution.west.bounds.width;
          xAxisX = solution.south.bounds.x + solution.west.bounds.width;
        }
        if ( solution.east ){
          xAxisWidth = solution.south.bounds.width - solution.east.bounds.width;
        }
        
        selections.xAxis.attr('transform', 
          'translate(' + xAxisX + ',' + solution.south.bounds.y + ')');
        
        modules.xAxis
          .width(xAxisWidth)
          .height(solution.south.bounds.height);

        modules.xAxis.gridlineLength(solution.center.bounds.height);
      } else if (modules.xAxis) {
          modules.xAxis.drawable(false);
      }
      
      if ( solution.west ) {
        selections.yAxis.attr('transform', 
          'translate(' + solution.west.bounds.x + 
          ',' + solution.west.bounds.y + ')');
        modules.yAxis
          .width(solution.west.bounds.width)
          .height(solution.west.bounds.height);
      
        modules.yAxis.gridlineLength(solution.center.bounds.width);       
      } else if (modules.yAxis) {
          modules.yAxis.drawable(false);
      }
      
      if ( solution.center ) {
        selections.plotRoot.attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ',' + solution.center.bounds.y + ')');
          
        var centersolution = layout({
          type : 'table',
          bias : 'none',
          size : { width : solution.center.bounds.width, height : solution.center.bounds.height },
          columns : columns,
          rows : rows,
          cellpadding : internalProps.cellPadding,
          paddingThreshold : internalProps.paddingThreshold
        });
        var i = 0;
        var contexts = multiData.contexts;
        for(var colI = 0; colI < columns; colI++){
          for(var rowI = 0; rowI < rows; rowI++){
            var ctxI = contexts[rowI][colI];
            if(ctxI){
              var plotI = modules.plot[i];
              var csi = centersolution[colI][rowI];
              var splotI = selections.plot[i];
              plotI.width(csi.bounds.width).height(csi.bounds.height);
              splotI.attr('transform',  'translate(' + csi.bounds.x +  ',' + csi.bounds.y + ')');
              ++i;
            }
          }
        }
      }
    }
    
    
    function dataRange(type) {
        return function(range) {
            if (!arguments.length) {
                return internalRange[type];
            } else {
                if (!internalRange[type]) {
                    internalRange[type] = range;
                } else {
                    var currentRange = internalRange[type];
                    if (range.distinctValuesObj) {
                        for (var i in range.distinctValuesObj) {
                            if (range.distinctValuesObj.hasOwnProperty(i)){
                              currentRange.distinctValuesObj[i] = range.distinctValuesObj[i];
                            }
                        }
                    }
                    
                    if (range.min < currentRange.min) {
                        currentRange.min = range.min;
                    }
                    if (range.max > currentRange.max) {
                        currentRange.max = range.max;
                    }
                    
                    if (range.hasNoValue) {
                      currentRange.hasNoValue = true;
                    }

                }
            }
        };
    }

    
    function resolveMergeDataRange (types){
      //for each type we will generate a function to set/get data range
      for(var i = 0, len = types.length; i < len; i++){
        container[types[i] + 'DataRange'] = dataRange(types[i]);
      }
    }
    
    function parseProperties (props){
      properties = props;
      if (properties[PLOTAREAPROPCATE]){
        Objects.extend(plotAnimation, properties[PLOTAREAPROPCATE].animation);
      }
      if(props[PROPERTYCATEGORY]){
        if(props[PROPERTYCATEGORY].mergeDataRange){
          internalProps.mergeDataRange = props[PROPERTYCATEGORY].mergeDataRange;
          resolveMergeDataRange(internalProps.mergeDataRange);
        }
        var formerDimsInCol = internalProps.numberOfDimensionsInColumn;
        Objects.extend(true, internalProps, props[PROPERTYCATEGORY]);
        if (modules.plot && formerDimsInCol !== internalProps.numberOfDimensionsInColumn){
          processRawData();
          clearInternalRange();
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          updatePlotData();
        }
      }
    }
    
    function buildXCateScale(){
      var domain = [];
      for (var i = 0; i < columns; i++){
         domain.push(i);
      }
      var xAxis = modules.xAxis ? modules.xAxis : modules.xAxis2;
      xCategoryScale.domain(domain).rangeBands([0, centerWidth]);
    }
    
    function buildYCateScale(){
      var domain = [];
      for (var i = 0; i < rows; i++){
         domain.push(i);
      }
      var yAxis = modules.yAxis ? modules.yAxis : modules.yAxis2;
      yCategoryScale.domain(domain).rangeBands([0, centerHeight]);
    }

    function container( selection ) {
      relayout();
      selection.each(function ( data ) {
        //Alex Su: if detected data changing, we set sub plot's dataLoading with container's dataUpdating to control its animation
        if (!bFirstCreation && bDataChanged){
          setAnimationFlag();
        }
        initializedPlots = 0;
        parent = selection;
        boundUtil.drawBound(selection, width, height);
        if ( TypeUtils.isEmptyObject(modules) ){ 
          initialize();
        }
        render();
        //Alex Su: and set animation flags back after rendering.
        if (!bFirstCreation && bDataChanged){
          setAnimationFlag(true);
        }
      });
      bFirstCreation = false, bDataChanged = false;
      return container;
    }
    
    container.width = function (_) {
      if ( !arguments.length ) {
        return width;
      }
      width = _;
      clearInternalRange();//Alex Su: internal data range needs reset, too.
      //Jimmy,8/20/2012, as a container, you don't know whether your
      //sub elements need relayout even if the container size remains
      //the same. so here we just give a chance to sub elements to relayout
      relayout();
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) {
        return height;
      }
      height = _;
      //see @width
      clearInternalRange();
      relayout();
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) {
        return {
          'width' : width,
          'height' : height
        };
      }
      height = _.height;
      width = _.width;
      //see @width
      clearInternalRange();
      relayout();
      return container;
    };
    
    container.data = function (_) {
      if ( !arguments.length ) {
        return data;
      }
      bDataChanged = true;
      var bDataSchmaChanged = false;
      if (! dataUtil().hasSameSchema(data, _)){
        bDataSchmaChanged = true;
      }
       data = _;
      
      //clean internal data range
       clearInternalRange();      
       
      if(!TypeUtils.isEmptyObject(modules)){
        processRawData();

        if (bDataSchmaChanged){
          avaModulesCount = avaModulesCount - avaPlotCount;
          updateAxisData('xAxis', multiData.columnData);
          updateAxisData('yAxis', multiData.rowData);
          updateAxisData('xAxis2', multiData.columnData);
          updateAxisData('yAxis2', multiData.rowData);
          
          avaPlotCount = 0;
          //Jimmy/9/13/2012 we may have chance to split data update and data
          //schema update in the future
          //done by Alex Su
          initializePlots();
          updateProperties("plot");
          updateProperties("xAxis2");
          updateProperties("yAxis");        
          updatePlotData();
          initializePlotElements();
          
          avaModulesCount = avaModulesCount + avaPlotCount;
          
        } else {
          updatePlotData();
        }
          
      }
      return container;
    };
    
    container.properties = function (_) {
      if ( !arguments.length ) {
        //Alex Su: for a container, it accept a full list properties including its submodules' but return its private ones.
        return internalProps;
      }
      //FIXME JIMMY/8/8/2012, columns/rows may be different with different properties
      parseProperties(_);
      //update properties of sub plots
      if(!TypeUtils.isEmptyObject(modules)){
        ///*Jimmy/9/19/2012, we may need deal with internalProps.numberOfDimensionsInColumn update
        //we don't need recreate plots but we need rearrange plots and change data*/
        //^^ fixed by Alex Su
        updateProperties("plot");
        updateProperties("xAxis2");
        updateProperties("yAxis");        
      }
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) {
        return config;
      }
      config = _;
      return container;
    };
    
    container.xCategoryScale = function (_) {
      if ( !arguments.length ) {
        buildXCateScale();
        return xCategoryScale;
      }
      xCategoryScale = _;
      return container;
    };
    
    container.yCategoryScale = function (_) {
      if ( !arguments.length ) {
        buildYCateScale();
        return yCategoryScale;
      }
      yCategoryScale = _;
      return container;
    };
    
    container.modules = function (_) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) {
          initialize();
        } 
        return modules;
      }
      modules = _;
      return container;
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) {
        return parent;
      }
      parent = _;
      return container;
    };
    
    container.dispatch = function(_){
      if( !arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return container;
    };

    container.infoForSizeLegend = function() {
      var plot;
      for ( var i = -1, j = modules.plot.length; ++i < j;) {
        plot = modules.plot[i];
        if (plot){
          break;
        }
      }
      return {
        space : plot ? (width - centerWidth + plot.infoForSizeLegend().space * columns) : 0,
        number : columns,
        plotHeight : plot ? plot.height() : 0
      };
    };
    
    container.plotRegion = function () {
      return {
        selection: selections.plotRoot,
        width: centerWidth,
        height: centerHeight
      };
    };
    
    function renderAxis ( id ) {
      if(selections[id]){
        parent.select('.v-m-' + id).datum(modules[id].data()).call(modules[id]);
      }
    }
    
    function render() {
      renderAxis('xAxis');
      renderAxis('xAxis2');
      renderAxis('yAxis');
      renderAxis('yAxis2');
      
      if(selections.plot){
        for(var i = 0, len = selections.plot.length; i < len; i++){
          if(selections.plot[i]){
            selections.plot[i].datum(modules.plot[i].data()).call(modules.plot[i]);
          }
        }
      }
    }
    
    function initialized(){
      if(++initializedPlots === avaModulesCount){
        initializedPlots = 0;
        eDispatch.initialized();
      }
    }
    
    function showTooltip(evt){
      eDispatch.showTooltip(evt);
    }
    
    function hideTooltip(evt){
      eDispatch.hideTooltip(evt);
    }
    
    return container;
  };
  
  return retfn;
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.tablecontainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, moduleConstants, fn, feedConstants, Constants) {
    var multiplierFeed = {
    'id' : 'multiplier',
    'name' : 'Chart Multiplier',
    'type' : feedConstants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND' : 0
  };

  var module = {
    'id' : 'sap.viz.modules.tablecontainer',
    'type' : moduleConstants.Type.Container,
    'name' : 'table container',
    'description': 'Settings for the subcharts layout of multiple charts.',
    //TODO support different layout: row/column/dimensional
    'properties' : {
      'mergeDataRange' : {
        'name' : 'mergeDataRange',
        'supportedValueType' : 'List',
        'supportedValues' : ['ANY DATA RANGE NAME'],
        'defaultValue' : null,
        'description' : 'Set mergeDataRange. Specify names of data range you want to merge, we will generate corresponding functions in this module to do the real merge. for example, if \'primary\' and \'second\' are specified here, two functions will be generated: \'primaryDataRange\' and \'secondDataRange\'. the function name is the range name plus \'DataRange\'. these generated functions support both getter and setter, for setter, you can pass any number of ranges {min:NUM, max:NUM} to it to merge, then you can get the merged result through the getter.',
        'isExported' : false
      },
      'numberOfDimensionsInColumn' : {
        'name' : 'numberOfDimensionsInColumn',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 1,
        'description' : 'Set the specified number of dimensions, retrieved from the end of the dimension list in multiplier, will be put in column when doing multiple layout.'
      },
      'cellPadding' : {
        'name' : 'cellPadding',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 15,
        'description' : 'Set padding between cells of sub plots. If cellPadding value exceeds containerSize * threshold, we set it to 0.'
      },
      'paddingThreshold' : {
        'name' : 'paddingThreshold',
        'supportedValueType' : 'Number',
        'defaultValue' : 0.2,
        'description' : 'Set paddingThreshold, if cellPadding value exceeds the containerSize * threshold, we set it to 0.',
        'isExported' : false
      }
    },
  'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
   },
    //TODO
    'css' : null,
    'feeds' : [multiplierFeed],
    'fn' : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.SingleChartDataHandler',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.2'
}
],
 function Setup(FunctionUtils, MultiAxesDataAdapter, MeasureDataHandler){
   
   
   function initMeasureValueAxisIndex(bindingInfo){
     
      //axis 1 has been feeded with crosstable
      if(bindingInfo[0] === true){
       if(bindingInfo[1] === true){
          return [1 ,2];
       }
       else if(bindingInfo[2] === true){
        // pass crosstable data to module if module accpet more than 2 axis feed
          return [1, 2];
       }
       else if(bindingInfo[3] === true){// Multi Radar, aa 4 could not be feeded
          FunctionUtils.error("Not Supported");
       }
       else{
          return [1];
       }
      }else if(bindingInfo[1] === true){
       if(bindingInfo[2] === true){
          //pass crosstable data to module if module accpet more than 2 axis feed
          return [1,2];
       }
       else if(bindingInfo[3] === true){
          FunctionUtils.error("Not Supported");
       }
       else{
         //pass crosstable data to module if module accpet more than 2 axis feed
         if(bindingInfo.length > 2){
            return [1];
         }
         else{
            return [2];
         }
       }
      }else if(bindingInfo[2] === true){
        if(bindingInfo[3] === true){
           FunctionUtils.error("Not Supported");
        }
        else{
         //pass crosstable data to module if module accpet more than 2 axis feed
         return [1];
        }
      }else{
        for(var i = 0; i< bindingInfo.length;i++){
          if(bindingInfo[i] === true){
            FunctionUtils.error("could not determin measure value axis index");
          }
        }
        //all false
        return [1];
      }
       
      FunctionUtils.error("could not determin measure value axis index");
     
    } 
   
   function SinngleChartDataHandler(dataAdapter){
        this._dataAdapter =  dataAdapter;
   }
   
   SinngleChartDataHandler.prototype.getDataAdapter = function(){
      if(this._dataAdapter.getBindingInfo() === null || this._dataAdapter.getBindingInfo() === undefined ){
         return this._dataAdapter;
      }
      else{
         return this.getChartDataAdapter();
      }
   };
   
   SinngleChartDataHandler.prototype.getChartDataAdapter = function(){
      var measureAxisIndex = initMeasureValueAxisIndex(this._dataAdapter.getBindingInfo());
      var aa = this._dataAdapter.getAnalysisAxisDataByIdx();
      var mg = this._dataAdapter.getMeasureValuesGroupDataByIdx();
      var dataAdapter = new MultiAxesDataAdapter();
      for(var i = 0; i < aa.length; i++){
        var axis = aa[i];
        dataAdapter.addAnalysisAxis({index: axis.index, values: axis.values});
      }
      
      for(i = 0; i < mg.length; i++){
        var mvg = mg[i];
        dataAdapter.addMeasureValuesGroup({index:mvg.index, values: MeasureDataHandler.makeMeasureValues(null, mvg, measureAxisIndex, 2, false)});
      }
      
      return dataAdapter;
   };
   
   return SinngleChartDataHandler;
 });sap.riv.module(
{
  qname : 'sap.viz.modules.xycontainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ignite',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.handler.SingleChartDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
}
],
function Setup ( TypeUtils, Objects, Functions, layout, Manifest, ignite, SingleChartDataHandler, dispatch, boundUtil ) {
  
  var xycontainer = function ( manifest, ctx ) {
      var width = 0, 
          height = 0, 
          properties = {}, 
          data = {},
          config = {},
          modules = {},
          selections = {},
          spaceWithoutPlot,
          parent = null, // a d3 selection
          wording = {
            class_prefix : { module : 'v-m-' }
          };
      
      var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), 
          initializedModules = 0;;
      var innerProperties = manifest.props(null);
      var initializedCount = 0;

      ///////////////////////can be moved to base container/////////////////////
      var resolveProperties = function(nodeConfig, isContainer){
        var props = {}, // Empty properties basket
            propsCat,   // Property category node
            usrProps,   // User set properties
            sysProps;   // Predefined properties in configure node
        if(isContainer){
          //Jimmy/8/15/2012 pay attention to the property structure, for container we will pass
          //all properties instead of properties under propsCat only.
          if ( nodeConfig ) {
            propsCat = nodeConfig.propertyCategory;
            usrProps = properties;
            sysProps = {};
            sysProps[propsCat] = nodeConfig.properties;
            Objects.extend( true, props, sysProps, usrProps ); 
          }else{
            props = properties;
          }
        }else{
          if ( nodeConfig ) {
            propsCat = nodeConfig.propertyCategory;
            usrProps = properties[ propsCat ];
            sysProps = nodeConfig.properties;
            // User properties will override predefined properties 
            Objects.extend( true, props, sysProps, usrProps );
          }
        }
        return props;
    };
    
    var updateProperties = function ( id, isContainer ) {
      var moduleManifest = config.modules; // Module configurations
      var props, nodeConfig, propsCat;
      if ( moduleManifest[id] && modules[id] ) {
        nodeConfig = moduleManifest[id].configure;
        if (isContainer){
          props = properties;
        }
        else {
          if (nodeConfig){
            propsCat = nodeConfig.propertyCategory;
            props = Objects.extend(true, {}, properties[propsCat]);
          }
          else{
            props = {};
          }
        }
        modules[id].properties(props);
      }
    };
    ///////////////////////can be moved to base container/////////////////////
    
    function initialize () {
      if ( TypeUtils.isEmptyObject(config) ) Functions.error('Container configuration missing');
      
      initializedModules = 0;
      
      initAxis('xAxis');
      initAxis('yAxis');
      initAxis('xAxis2');
      initAxis('yAxis2');
      initAxis('background');
      
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) return;
      var plot = modules.plot = ignite(plotConfig.id, ctx, 
        wording.class_prefix.module + "plot");
      var dataHandler = new SingleChartDataHandler(data); 
      plot.data(dataHandler.getDataAdapter());

      var props;
      if ( plotConfig.configure ) {
        props = resolveProperties(plotConfig.configure);
        plot.properties(props);
      }
      
      if ( plot.dispatch ) {
        var dis =  plot.dispatch();
        if ( dis.initialized ) { initializedModules++; dis.on('initialized.xycontainer', initialized);};
        if ( dis.showTooltip ) dis.on('showTooltip.xycontainer', showTooltip);
        if ( dis.hideTooltip ) dis.on('hideTooltip.xycontainer', hideTooltip);
      }
      
      var dataLabelConfig =  config.modules.dataLabel;
      if ( TypeUtils.isExist(dataLabelConfig) && TypeUtils.isExist(plot.dataLabel) ) {
        var dataLabel = modules.dataLabel = ignite(dataLabelConfig.id, ctx, wording.class_prefix.module + "datalabel");
        if ( dataLabel.dispatch() ) { initializedModules++; dataLabel.dispatch().on('initialized.xycontainer', initialized);};
        plot.dataLabel(dataLabel);
        dataLabel.plot(plot);
        if ( dataLabelConfig.configure ) {
          props = resolveProperties(dataLabelConfig.configure);
          dataLabel.properties(props);
        }
      }
      
      if ( modules.xAxis && !selections.xAxis )
        selections.xAxis = parent.append('g')
          .attr('class', wording.class_prefix.module + 'xAxis');
      if ( modules.xAxis2 && !selections.xAxis2 )
        selections.xAxis2 = parent.append('g')
          .attr('class', wording.class_prefix.module + 'xAxis2');
      if ( modules.yAxis && !selections.yAxis ) 
        selections.yAxis = parent.append('g')
          .attr('class', wording.class_prefix.module + 'yAxis');
      if ( modules.yAxis2 && !selections.yAxis2 ) 
        selections.yAxis2 = parent.append('g')
          .attr('class', wording.class_prefix.module + 'yAxis2');
      if ( modules.plot && !selections.plot ) 
        selections.plot = parent.append('g')
          .attr('class', wording.class_prefix.module + 'plot');
      if ( modules.background && !selections.background ) 
        selections.background = parent.insert('g', ':first-child')
          .attr('class', wording.class_prefix.module + 'background');        
    }
    
    function updateAxisData ( id ) {
      if ( modules[id] ) {
        var axisConfig = config.modules[id];
        var axisDataConfig = axisConfig.data;
        if ( axisDataConfig ) {
          modules[id].data(data.createDataAdapterForModule(axisDataConfig));
        } 
      }  
    };
    
    function initAxis( id ) {
      if ( !config.modules[id] ) return;
      
      var axisConfig = config.modules[id],
          axis = modules[id] = ignite(axisConfig.id, ctx, "v-m-" + id); // Saves references to axis function.
      
      updateAxisData(id);

      var props = resolveProperties(axisConfig.configure);
      axis.properties(props);
      
      if(axis.dispatch && axis.dispatch()['initialized']){
        initializedModules++;
        axis.dispatch().on('initialized.xycontainer', initialized);
      }
    }
    
    function relayout() {
      if ( TypeUtils.isEmptyObject(modules) || !width || !height) return;
      
      width = width < 0 ? 0 : width;
      height = height < 0 ? 0 : height;
      var prefs = {};
      
      if ( modules.plot ) {
        prefs.center = {};
        modules.plot.width(width).height(height);
      }
    
      var lastPlotWidth = -1, 
          lastPlotHeight = -1,
          autoResizing = true; // smart layout enabled by default

      var iLayout;
      //try 3 times FIXME remove '3 times'
      for ( iLayout = 0; iLayout <= 2; iLayout++ ) {
        if ( modules.xAxis ) {
            modules.xAxis.drawable(true);
            prefs.south = { size : modules.xAxis.getPreferredSize() };
            if ( prefs.south.manual ) autoResizing = false;
        }
        if ( modules.yAxis ) {
            modules.yAxis.drawable(true);
            prefs.west = { size : modules.yAxis.getPreferredSize() };
        }
        if ( modules.xAxis2 ) {
            modules.xAxis2.drawable(true);
            prefs.north = { size : modules.xAxis2.getPreferredSize() };
        }
        if ( modules.yAxis2 ) {
            modules.yAxis2.drawable(true);
            prefs.east = { size : modules.yAxis2.getPreferredSize() };
        }
        
        var solution = layout({
          type : 'border',
          bias : 'none',
          size : { width : width, height : height },
          prefs : prefs
        });

        // adjust axes start and end padding
        // TODO add more padding
        var rightPadding = 0, 
            rightPaddingxAxis = rightPaddingxAxis2 = 0;
            
        if ( !solution.east ) {
          if ( modules.xAxis && solution.south ) {
            rightPaddingxAxis = modules.xAxis.endPadding();
          }
          if ( modules.xAxis2 && solution.north ) {
            rightPaddingxAxis2 = modules.xAxis2.endPadding();
          }
          rightPadding = rightPaddingxAxis > rightPaddingxAxis2 ? rightPaddingxAxis : rightPaddingxAxis2;
        }

        var bottomPadding = 0, 
            bottomPaddingyAxis = bottomPaddingyAxis2 = 0;
            
        if ( !solution.south ) {
          if ( modules.yAxis && solution.west ) {
            bottomPaddingyAxis = modules.yAxis.startPadding();
          }
          if ( modules.yAxis2 && solution.east ) {
            bottomPaddingyAxis2 = modules.yAxis2.startPadding();
          }
          bottomPadding = bottomPaddingyAxis > bottomPaddingyAxis2 ? bottomPaddingyAxis : bottomPaddingyAxis2;
        }

        var topPadding = 0, yOffset = 0;

        if ( !solution.north ) {
          var topPaddingyAxis = 0, 
              topPaddingyAxis2 = 0;
              
          if ( modules.yAxis && solution.west ) {
            topPaddingyAxis = modules.yAxis.endPadding();
          }
          if ( modules.yAxis2 && solution.east ) {
            topPaddingyAxis2 = modules.yAxis2.endPadding();
          }

          topPadding = topPaddingyAxis2;
          if ( topPaddingyAxis > topPaddingyAxis2 ) {
            topPadding = topPaddingyAxis;
          }

          yOffset += topPadding;
        }

        if ( yOffset ) {
          if ( solution.east ) {
            solution.east.bounds.y += yOffset;
          }

          if ( solution.north ) {
            solution.north.bounds.y += yOffset;
          }

          if ( solution.west ) {
            solution.west.bounds.y += yOffset;
          }

          if ( solution.center ) {
            solution.center.bounds.y += yOffset;
          }
        }

        // we have to layout top and bottom axes firstly, because if you change the size of top or bottom axes, the 
        // height of the axis may be changed (vertical label). Left and right axes have no vertical labels.
        if ( solution.east ) {
          // Modifies yAxis height and coordinate to handle vertical offset
          // to ensure joints with xAxis.
          var yAxis2Height = 0, yAxis2Y = 0;
          if ( solution.south ) {
            if ( !autoResizing ) yAxis2Height = solution.east.bounds.height - solution.south.bounds.height;
            else yAxis2Height = solution.east.bounds.height;
          }
          if ( solution.north ) {
            if ( !autoResizing ) yAxis2Height = solution.east.bounds.height - solution.north.bounds.height;
            else yAxis2Height = solution.east.bounds.height;
          }

          yAxis2Y = solution.east.bounds.y;
          
          selections.yAxis2.attr('transform', 
            'translate(' + solution.east.bounds.x + ',' + yAxis2Y + ')');
          
          modules.yAxis2
            .width(solution.east.bounds.width)
            .height(yAxis2Height);
            
          modules.yAxis2.gridlineLength(solution.center.bounds.width); 
        } else if(modules.yAxis2) {
            modules.yAxis2.drawable(false);
        }

        if ( solution.north ) {
          var xAxis2Width = 0, xAxis2X = 0;
          if ( solution.west ) {
            xAxis2X = solution.north.bounds.x + solution.west.bounds.width;
          }

          selections.xAxis2.attr('transform', 
            'translate(' + xAxis2X + 
            ',' + solution.north.bounds.y + ')');

          modules.xAxis2
            .width(xAxis2X)
            .height(solution.north.bounds.height);
            
          modules.xAxis2.gridlineLength(solution.center.bounds.height);    
        } else if (modules.xAxis2) {
            modules.xAxis2.drawable(false);
        }
              
        if ( solution.west ) {
          // Modifies yAxis height and coordinate to handle vertical offset
          // to ensure joints with xAxis.
          var yAxisHeight = 0, yAxisY = 0;
          if ( solution.south ) {
            if ( !autoResizing ) yAxisHeight = solution.west.bounds.height - solution.south.bounds.height;
            else yAxisHeight = solution.west.bounds.height;
          }
          if ( solution.north ) {
            if ( !autoResizing ) yAxisHeight = solution.west.bounds.height - solution.north.bounds.height;
            else yAxisHeight = solution.west.bounds.height;
          }
          yAxisY = solution.west.bounds.y;

          selections.yAxis.attr('transform', 'translate(' + solution.west.bounds.x + ',' + yAxisY + ')');
      
          modules.yAxis
            .width(solution.west.bounds.width)
            .height(yAxisHeight);
            
          modules.yAxis.gridlineLength(solution.center.bounds.width);  
        } else if(modules.yAxis) {
            modules.yAxis.drawable(false);
        }

        if ( solution.south ) {

          var xAxisWidth = 0, xAxisX = 0;
          if ( solution.west ) {
              xAxisX = solution.south.bounds.x + solution.west.bounds.width;
          }

          selections.xAxis.attr('transform', 
            'translate(' + xAxisX + 
            ',' + solution.south.bounds.y + ')');
            
          modules.xAxis
            .width(solution.south.bounds.width)
            .height(solution.south.bounds.height);
            
          modules.xAxis.gridlineLength(solution.center.bounds.height);
        } else if ( modules.xAxis ) {
          modules.xAxis.drawable(false);
        }
        
        // if (!solution.south && modules.xAxis) {
            // modules.xAxis.drawable(false);
        // }
        // if (!solution.north && modules.xAxis2) {
            // modules.xAxis2.drawable(false);
        // }
              
        if ( solution.center ) {
          selections.plot.attr('transform', 
            'translate(' + solution.center.bounds.x + 
            ',' + solution.center.bounds.y + ')');
          var plotWidth = solution.center.bounds.width - rightPadding;
          var plotHeight = solution.center.bounds.height - topPadding - bottomPadding;
          modules.plot
            .width(plotWidth > 0 ? plotWidth : 0)
            .height(plotHeight > 0 ? plotHeight : 0);
          
          spaceWithoutPlot = width - plotWidth;

          if ( selections.background ) {
            selections.background.attr('transform', 
              'translate(' + solution.center.bounds.x + 
              ',' + solution.center.bounds.y + ')');
            modules.background
              .width(plotWidth > 0 ? plotWidth : 0)
              .height(plotHeight > 0 ? plotHeight : 0);
          }          
        }
        if ( solution.west ) {
          modules.yAxis.gridlineLength(solution.center.bounds.width - rightPadding); 
        }

        if ( solution.south ) {
          modules.xAxis.gridlineLength(solution.center.bounds.height - topPadding - bottomPadding); 
        }

        var currentPlotWidth = modules.plot.width();
        var currentPlotHeight = modules.plot.height();
        if ( lastPlotWidth === currentPlotWidth  && lastPlotHeight === currentPlotHeight ) {
          break;
        } else {
          lastPlotWidth = currentPlotWidth;
          lastPlotHeight = currentPlotHeight;
        }
      }
    }
    
    function container( selection ) {
      relayout();
      selection.each(function ( data ) {
        initializedCount = 0;
        boundUtil.drawBound(selection, width, height);
        parent = selection;
        if ( TypeUtils.isEmptyObject(modules) ) initialize();
        render();
      });
    }
    
    container.width = function (_) {
      if ( !arguments.length ) return width;
      width = _;
      if ( height ) { relayout(); }
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) return height;
      height = _;
      if ( width ) { relayout(); }
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) return {
        'width' : width,
        'height' : height
      };
      height = _.height;
      width = _.width;
      relayout();
      return container;
    };
    
    container.data = function (_) {
      if ( !arguments.length ) return data;
      data = _;
      
      if ( !$.isEmptyObject(modules) && !$.isEmptyObject(properties) ) {
        //plot exists, we need update its data
        var dataHandler = new SingleChartDataHandler(data); 
        modules.plot.data(dataHandler.getDataAdapter());
        updateAxisData('xAxis');
        updateAxisData('yAxis');
        updateAxisData('xAxis2');
        updateAxisData('yAxis2');
      }
      
      return container;
    };
    
    container.properties = function (xs) {
      if ( !arguments.length ) { return properties; }
      properties = $.extend(true, {}, properties, xs);
      if ( !$.isEmptyObject(modules) && !$.isEmptyObject(data) ) {
        updateProperties('xAxis');
        updateProperties('xAxis2');
        updateProperties('yAxis');
        updateProperties('yAxis2');
        updateProperties('plot');
        updateProperties('dataLabel');
        updateProperties('background');
      }
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) return config;
      config = _;
      if ( TypeUtils.isEmptyObject(modules) && 
          !$.isEmptyObject(data) && 
          !$.isEmptyObject(properties) && 
          parent !== null ) {
        initialize();
      }
      return container;
    };
    
    container.modules = function (xs) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) { initialize(); } 
        return modules;
      }
      modules = xs;
      return container;
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) return parent;
      parent = _;
      return container;
    };
    
    container.dispatch = function(_){
      if ( !arguments.length) return eDispatch;
      eDispatch = _;
      return container;
    };
    
    container.infoForSizeLegend = function(){
      return {
        space : spaceWithoutPlot,
        number : 1,
        plotHeight : modules.plot.height()
      };
    };
    
    container.rotate = function(_) {
      var plot = modules.plot;
      if (!arguments.length) return plot.rotate();
      plot.rotate(_);
      return container;
    };
    
    function render() {
      for ( var sel in selections ) {
        if ( selections.hasOwnProperty(sel) ) {
          selections[sel].datum(modules[sel].data()).call(modules[sel]);
        }
      }
      if(TypeUtils.isExist(modules.dataLabel)){
        modules.dataLabel();
      }
    }
    
    function initialized(){
      if ( initializedModules == ++initializedCount ) {
        initializedCount = 0;
        eDispatch.initialized();
      }
    };
    
    function showTooltip ( evt ) {
      eDispatch.showTooltip(evt);
    };
    
    function hideTooltip ( evt ) {
      eDispatch.hideTooltip(evt);
    };
    
    return container;
  };
  
  return xycontainer;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.xycontainer',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.xycontainer',
    'type' : Constants.Module.Type.Container,
    'name' : 'single container',
    'properties' : null,
    'css' : null,
    'configure' : null,
    'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.util.functional',
  version : '4.0.2'},
[

],
function Setup () {
  
  var _ = {
    // Represents a tail recursion combinator. 
    tailrec : function ( cond, then, before ) {
      return function () {
        var args = arguments;
        
        // for saving an intermediate storage of linear structure
        /*jshint noempty:false*/
        for (; !cond.apply(this, args); args = before.apply(this, args)){}
        
        // a resulting action taken after recursion completes
        return then.apply(this, args);
      };
    }
  };
  
  return _;
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.layout.dock',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.functional',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
}
],
function Setup ( registry, lambda, Objects ) {

  function dock_sort (a, b) { return a - b; }
  function dock_edge (x) { return x.position; }
  function dock_value (x) { return x.value; }
  function dock_filter (x) { return; }
  function dock_size (x) { return x.size(); }

  var _ = function () {
    var sort = dock_sort,
        edge = dock_edge,
        value = dock_value,
        filter = dock_filter,
        size = dock_size,
        width = 0,
        height = 0,
        charger = { func : null, scope : null },
        em = registry.mappings.e2p(1),
        padding = [2 * em, 2 * em, 2 * em, 2 * em],
        tolerance = 1,
        cache = [],
        // counters for position requests
        tops = 0, bottoms = 0, lefts = 0, rights = 0,
        // anchoring sentinels
        x1 = 0, x2 = 0, y1 = 0, y2 = 0;

    function dock () {
      // orientation test
      function isHorizontal (x) { return edge(x) === 'top' || edge(x) === 'bottom'; }
      function isVertical (x) { return edge(x) === 'left' || edge(x) === 'right'; }

      // minimum size accessing utility
      function minSize (x) {
        var pref = size(x);
        if ( pref === null ) return null;
        return filter(x) ? filter(x).call(this, { 
          edge : edge(x),
          result : { width : pref.minWidth, height : pref.minHeight },
          size : { width : width, height : height }
        }) : maxSize(x);
      }
      
      // maximum size accessing utility
      function maxSize (x) {
        var pref = size(x);
        if ( pref === null ) return null;
        return filter(x) ? filter(x).call(this, {
          edge : edge(x), 
          result : { width : pref.maxWidth, height : pref.maxHeight },
          size : { width : width, height : height }
        }) : minSize(x);
      }
      
      // re-wiring component links
      function rewire () { if ( charger.func ) charger.func.call(charger.scope); }

      // perfectly fits or not
      function perfect (x) {
        var module = x.module, pref = maxSize(x);
        if ( isVertical(x) ) return Math.abs(pref.width - module.width()) < tolerance;    
        if ( isHorizontal(x) ) return Math.abs(pref.height - module.height()) < tolerance;
        return true;
      }
      
      function enough (xs) {
        var result = true;
        xs.forEach(function (d) { result = perfect(d); });
        return result;
      }
      
      // reconciles space conflicts in orders of precedences
      function reconcile ( src, targets ) {
        // calculate viable improvement
        function improve (x) { // half-interval method
          var module = x.module, pref = maxSize(x);
          return isHorizontal(x) ?
            (pref.height - module.height()) / 2:
            (pref.width - module.width()) / 2;
        }
        
        var priority = targets.indexOf(src),
            result = {};
        result = targets.map(function ( d, i ) {
          if ( i <= priority ) return d;
          
          var vol = improve(src), 
              module = d.module, srcModule = src.module;
          
          if ( isVertical(src) ) {
            if ( vol > 0 ) {
              srcModule.width(srcModule.width() + vol);
              module.width(module.width() - vol);
            } else {
              srcModule.width(srcModule.width() - vol);
              module.width(module.width() + vol);
            }
          } else {
            if ( vol > 0 ) {
              srcModule.height(srcModule.height() + vol);
              module.height(module.height() - vol);
            } else {
              srcModule.height(srcModule.height() - vol);
              module.height(module.height() + vol);
            }
          }
          
          return d;
        });
        
        rewire();
        return result;
      }
      
      function layoutOnce (fullSize, elems) {
        var fullW = fullSize[0], fullH = fullSize[1];
        // FIXME thanks to the state-oriented programming style,
        // the dock function will be called with state. So this
        // refreshing has to be performed in order to react to 
        // resizing.
        x1 = 0, x2 = 0, y1 = 0, y2 = 0;
        tops = 0, bottoms = 0, lefts = 0, rights = 0;
        
        x1 = padding[3], x2 = fullW - padding[1];
        y1 = padding[0], y2 = fullH - padding[2];
        fullW -= ( padding[1] + padding[3] );
        fullH -= ( padding[0] + padding[2] );
        var area = [fullW, fullH];
        elems.forEach(function (d) {
          var module = d.module,
              osize = size(d), 
              max = maxSize(d),
              min = minSize(d),
              pref = {
                width : max !== null && min !== null ? 
                        d3.max([ max.width, min.width ]) : undefined,
                height : max !== null && min !== null ? 
                         d3.max([ max.height, min.height ]) : undefined
              };
          
          d.acceptable = true;
          
          if ( pref.width === 0 || pref.height === 0 ||
              ( edge(d) !== 'center' && (osize.minWidth > pref.width || osize.minHeight > pref.height || area[0] < osize.minWidth || area[1] < osize.minHeight) )) {
        	// FIXME refactor
			if ( d.module.alias === 'legends' && d.module.modules()['sizeLegend'] && Objects.size(d.module.modules()) === 1 ) {
		      d.acceptable = true;
		    } else {
              d.acceptable = false;
              module.width(0).height(0);
              return;
			}
          }
          
          // grant initial available space
          switch ( edge(d) ) {
            case 'top' :
              module.width(area[0]).height(pref.height);
              tops ?
                area[1] -= (pref.height + hgap * (tops - 1)) :
                area[1] -= (pref.height + hgap);
              tops++;
              break;
            case 'bottom' :
              module.width(area[0]).height(pref.height);
              bottoms ? 
                area[1] -= (pref.height + hgap * (bottoms - 1)) :
                area[1] -= (pref.height + hgap);
              bottoms++;
              break;
            case 'left' :
              module.width(pref.width).height(area[1]);
              lefts ? 
                area[0] -= (pref.width + vgap * (lefts - 1)) :
                area[0] -= (pref.width + vgap);
              lefts++;
              break;
            case 'right' :
              module.width(pref.width).height(area[1]);
              rights ? 
                area[0] -= (pref.width + vgap * (rights - 1)) :
                area[0] -= (pref.width + vgap);
              rights++;
              break;
            case 'center' :
              module.width(area[0]).height(area[1]);
              area[0] = 0, area[1] = 0;
              break;
            }
          });
      }
      
      function anchor (xs) {
        var map = xs.map(function ( d, i ) {
          var coord = { x : 0, y : 0 },
              module = d.module;
          
          if ( !d.acceptable ) {
            d.anchor = coord;
            return d;
          }
          
          switch ( edge(d) ) {
          case 'top' :
            coord.x = x1, coord.y = y1;
            y1 += (module.height() + hgap);
            break;
          case 'bottom' :
            coord.x = x1, coord.y = y1 - module.height();
            y2 -= (module.height() + hgap);
            break;
          case 'left' :
            coord.x = x1, coord.y = y1;
            x1 += (module.width() + vgap);
            break;
          case 'right' :
            coord.x = x2 - module.width(), coord.y = y1;
            x2 -= (module.width() + vgap);
            break;
          case 'center' :
            coord.x = x1, coord.y = y1;
            x1 = x2, y1 = y2;
            break;
          }
          
          d.anchor = coord;
          return d;
        }), result = {};
        
        for ( var key in map ) {
          if ( map.hasOwnProperty(key) ) {
            result[map[key].module.alias] = map[key].anchor;
          }
        }
        
        return result;
      }

      // start of processing
      var elems = [],
          adjustPolicy = arguments[1],
          result = {};
      
      // accepts array argument only
      if ( !$.isArray(arguments[0]) ) return result;
      
      // defensive copy and sort by custom needs
      elems = arguments[0].slice().sort(sort);
      
      cache = [];
      
      // first layout
      layoutOnce([width, height], elems);
      
      // re-wiring component links after initial calculation
      rewire();
      
      if ( adjustPolicy === registry.LAYOUT_ADJUST_POLICY.APPROXIMATE ) {
        /*
        // tail recursion of reconciliation against incomplete layout data
        return lambda.tailrec(
          perfect,  // * CONDITION * base condition
          anchor,   // * THEN *      action taken when recursion stops
          reconcile // * BEFORE *    action taken before next loop/recursion
        ).apply(this, elems);
        */
        return anchor.call(this, (function recur (xs) {
          var first = xs[0];
          if ( !first.acceptable || perfect(first) ) {
            cache.push( xs.shift() );
            if ( xs.length ) recur(xs);
          } else {
            recur( reconcile(first, xs) );
          }
          return cache;
        })(elems)); 
      } else if ( adjustPolicy === registry.LAYOUT_ADJUST_POLICY.RELAYOUT ){
        //layout again
        layoutOnce([width, height], elems);
        rewire();
        return anchor.call(this, elems);
      } else {
        // No further precise size approaching will be taken,
        // which trades possible layout preciseness for time.
        return anchor(elems);
      }
    }
    
    dock.filter = function (x) {
      if ( !arguments.length ) return filter;
      filter = x;
      return dock;
    };
    
    dock.sort = function (x) {
      if ( !arguments.length ) return sort;
      sort = x;
      return dock;
    };
    
    dock.size = function (x) {
      if ( !arguments.length ) return size;
      size = x;
      return dock;
    };
    
    dock.edge = function (x) {
      if ( !arguments.length ) return edge;
      edge = x;
      return dock;
    };
    
    dock.value = function (x) {
      if ( !arguments.length ) return value;
      value = x;
      return dock;
    };
    
    dock.rewire = function (xs) {
      if ( !arguments.length ) return charger;
      charger = xs;
      return dock;
    };
    
    dock.vgap = function () {
      if ( !arguments.length ) return vgap;
      vgap = $.isFunction(arguments[1]) ? 
             arguments[1](arguments[0]) : arguments[0];
      return dock;
    };
    
    dock.hgap = function () {
      if ( !arguments.length ) return hgap;
      hgap = $.isFunction(arguments[1]) ? 
             arguments[1](arguments[0]) : arguments[0];
      return dock;
    };
    
    dock.padding = function () {
      if ( !arguments.length ) return padding;
      var val = arguments[0], filter = arguments[1];
      
      if ( $.isArray(val) ) {
        val.forEach(function (d, i) {
          padding[i] = $.isFunction(filter) ? filter(d) : +d;
        });
      } else {
        padding.forEach(function (d, i) { padding[i] = val; });
      }
      
      return dock;
    };
    
    dock.width = function (x) {
      if ( !arguments.length ) return width;
      width = x;
      return dock;
    };
    
    dock.height = function (x) {
      if ( !arguments.length ) return height;
      height = x;
      return dock;
    };
    
    dock.tolerance = function (x) {
      if ( !arguments.length ) return tolerance;
      tolerance = x;
      return dock;
    };
    
    dock.properties = function () { return dock; };
    dock.data = function () { return dock; };
    
    return dock;
  };
  
  return _;

});sap.riv.module(
{
  qname : 'sap.viz.modules.util.BackgroundUtil',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ignite',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.background',
  version : '4.0.2'
}
],
function Setup(ModuleManifest, ignite) 
{
  var CLASSNAME = 'v-backgroundutil';
  var BackgroundUtil = {
      drawBackground : function(selection, backgroundModule, props ){
        var d3background = d3.selectAll(selection.node().childNodes).filter('.' + CLASSNAME);
        if (d3background.empty() ) {
            d3background = selection.insert('svg:g', ":first-child").attr('class', CLASSNAME);
        }
        if (!backgroundModule) {
            backgroundModule = ignite('sap.viz.modules.background', props.parentCtx, CLASSNAME);
        }

        backgroundModule.width(props.width).height(props.height).properties(props.properties);
        d3background.call(backgroundModule);

        return backgroundModule;
      }
  };
  
  return BackgroundUtil;
});sap.riv.module(
{
  qname : 'sap.viz.util.EffectManager',
  version : '4.0.2'},
[

],
function Setup(){

  /**
   * 
   * @param svgdef d3 svg defs to store all gradient effect
   * @return TODO: add desc
   */
  function EffectManager(svgdef, enableGhostEffect){
    this._defs  = svgdef;
    this._enableGhostEffect = enableGhostEffect;
  }

  function rgba (r_, g_, b_, a_) {
    var temp = {
        r: r_,
        g: g_,
        b: b_,
        a: a_,
        toHex : function() {
            return d3.rgb(temp.r, temp.g, temp.b).toString();
        },
        toString : function() {
          if (temp.a<1) {
            return "rgba(" + temp.r + "," + temp.g + "," + temp.b + "," + temp.a + ")";
          } else {
            return temp.toHex();
          }
        }
    };
    return temp;
  }

  function color2rgba(color) {
    var nc = d3.rgb(0,0,0), na=1;
    if (color !== undefined && typeof(color) === 'object') {
      if (color.rgb) {
        nc = color.rgb();
      } else {
        nc = color;
      }
    } else if (typeof(color) === 'string') {
        color = color.toLowerCase();
        var temp, i, j;
        if (color.indexOf('rgba') >= 0) {
            temp = color.substring(color.indexOf('(')+1);
            
            i = temp.lastIndexOf(',');
            j = temp.indexOf(')');
            if (i>=0 && j>=0) {
                var rgbStr = 'rgb(' + temp.substring(0,i) + ')';
                na = parseFloat(temp.substring(i+1,j));
                nc = d3.rgb(rgbStr);
            }
        } else if (color.indexOf('hsla') >= 0) {
            temp = color.substring(color.indexOf('(')+1);

            i = temp.lastIndexOf(',');
            j = temp.indexOf(')');
            if (i>=0 && j>=0) {
                var hslStr = 'hsl(' + temp.substring(0,i) + ')';
                na = parseFloat(temp.substring(i+1,j));
                nc = d3.hsl(hslStr).rgb();
            }
        } else if (color.indexOf('hsl') >= 0) {
            nc = d3.hsl(color).rgb();
        } else {
            nc = d3.rgb(color);
        }
    }
    return rgba(nc.r, nc.g, nc.b, na);
  }
  
  function rgba2gray (c) {
    var r = c.r, g = c.g, b = c.b, gc;

    if ((r === g) && (g === b)) {
      gc = Math.round(r + (255 - r)*0.6);
    } else {
      gc = Math.round((r*299 + g*587 + b*114 + 500) / 1000);
    }
    return rgba(gc, gc, gc, c.a);
  }

  function increaseBrightness(c, percent) {
    var r = c.r, g = c.g, b = c.b, nr,ng,nb;
    if (percent >= 0) {
      nr = Math.round(r + (255 - r) * percent / 100);
      ng = Math.round(g + (255 - g) * percent / 100);
      nb = Math.round(b + (255 - b) * percent / 100);
    } else {
      nr = Math.round(r * (100 + percent) / 100);
      ng = Math.round(g * (100 + percent) / 100);
      nb = Math.round(b * (100 + percent) / 100);
    }
    return rgba(nr,ng,nb,c.a);
  }
  
  function drawGlossySector(d3defs, id, c, radius) {
    var c0 = c.toHex();
    var c2 = increaseBrightness(c, 50).toHex();
    var c3 = increaseBrightness(c, -30).toHex();

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', 0);
    rg.setAttribute('cy', 0);
    rg.setAttribute('r', radius);
    rg.setAttribute('fx', 0);
    rg.setAttribute('fy', 0);
    rg.setAttribute('gradientUnits',"userSpaceOnUse");
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c3);
  }
   
  function drawGlossyCircle(d3defs, id, c) {
    var c0 = c.toHex();
    var c1 = increaseBrightness(c, 10).toHex();
    var c2 = increaseBrightness(c, 80).toHex();

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', '50%');
    rg.setAttribute('cy', '50%');
    rg.setAttribute('r', '50%');
    rg.setAttribute('fx', '50%');
    rg.setAttribute('fy', '20%');
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0.7).attr("stop-color", c1);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c0);
  }

  function drawGlossyRectangle(d3defs, id, c, direction) {
     var c1 = increaseBrightness(c, 30).toHex();
     var c2 = increaseBrightness(c, 50).toHex();
     var c3 = increaseBrightness(c, -10).toHex();
     var c4 = increaseBrightness(c, 10).toHex();
     var gradient = d3defs.append("svg:linearGradient").attr("id", id).attr("x1", "0%").attr("y1", "0%");
     if(direction === 'horizontal') {
       gradient.attr("y2", "0%").attr("x2", "100%");
     } else {
       gradient.attr("y2", "100%").attr("x2", "0%");
     }
     
     gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", c1);
     gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0.2).attr("stop-color", c2);
     gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0.8).attr("stop-color", c3);
     gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c4);
  }

  function drawGlossyBackground(d3defs, id, c, direction) {
     var gradient = d3defs.append("svg:linearGradient").attr("id", id);
     if(direction === 'horizontal') {
       gradient.attr("x1", "100%").attr("y1", "0%").attr("x2", "0%").attr("y2", "0%");
     } else {
       gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
     }
     
     gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 0).attr("stop-color", '#ffffff');
     gradient.append("stop").attr('stop-opacity', c.a).attr("offset", 1).attr("stop-color", c.toHex());
  }

  
  function getFillElementId(parameters, color)
  {
    var id;

    if(parameters.drawingEffect === "glossy")
    {
      var colorStr = color.toHex().slice(1) + color.a.toString().replace('.','');
      switch(parameters.graphType)
      {
      case 'sector':
        id = parameters.drawingEffect + parameters.graphType + colorStr + Math.round(parameters.radius);
        break;
      case 'circle':
        id = parameters.drawingEffect + parameters.graphType + colorStr;
        break;
      case 'triangle-up' ://TODO: remove duplicate
      case 'triangle-down' ://TODO: remove duplicate
      case 'triangleUp' :
      case 'triangleDown' :
        id = parameters.drawingEffect + 'triangle' + colorStr + 'vertical';
        break;
      case 'triangle-left' ://TODO: remove duplicate
      case 'triangle-right' ://TODO: remove duplicate
      case 'triangleLeft' :
      case 'triangleRight' :
        id =  parameters.drawingEffect + 'triangle' + colorStr + 'horizontal';
        break;
      case 'rectangle' :
      case 'diamond' :
      case 'cross' :
      case 'star' :
      case 'intersection' :
      case 'background' :
        id =  parameters.drawingEffect + 'rectangle' + colorStr + parameters.direction;
        break;
      default :
        id =  parameters.drawingEffect + 'rectangle' + colorStr + parameters.direction;
        break;
      case 'line' :
        id = null;
        break;
      }
    }

    return id;

  }
  /**
   * 
   * @param parameters
   * {
   *   graphType: 'circle','square','diamond'.....
   *   drawingEffect,
   *   fillColor,
   *   direction,  "horizontal" means left to right. "vertical" means top to bottom
   * }
   * @return id to use in "fill"
   */

  EffectManager.prototype.register = function(parameters)
  {
    var originalColor = parameters.fillColor;
    if (typeof(originalColor) === 'string') {
        if ((originalColor.toLowerCase() === 'transparent') ||
            (originalColor.toLowerCase() === 'none')) {
            return originalColor;
        }
    }

    var color = color2rgba(originalColor);
    if (this._enableGhostEffect) {
      color = rgba2gray(color);
    }

    var id = getFillElementId(parameters, color);
    if(!id) { return color.toString(); }

    var element = this._defs.select("#" + id);
    if(element.empty())
    {
      if(parameters.drawingEffect === "glossy") {
        switch (parameters.graphType)
        {
        case 'background' : 
          drawGlossyBackground(this._defs, id, color, parameters.direction);
          break;
         case 'sector' :
          drawGlossySector(this._defs, id, color, parameters.radius);
          break;
         case 'circle' :
          drawGlossyCircle(this._defs, id, color, parameters.direction);
          break;
         case 'triangle-up' :
         case 'triangle-down' :
          drawGlossyRectangle(this._defs, id, color, 'vertical');
          break;
         case 'triangle-left' :
         case 'triangle-right' :
          drawGlossyRectangle(this._defs, id, color, 'horizontal');
          break;
         case 'rectangle' :
         case 'diamond' :
         case 'cross' :
         case 'star' :
         case 'intersection' :
           drawGlossyRectangle(this._defs, id, color, parameters.direction);
           break;
         default :
          drawGlossyRectangle(this._defs, id, color, parameters.direction);
          break;
         }
       } else {
            return color.toString();
       }
     }
     return "url(#" + id + ")";
   };
   
  EffectManager.prototype.container = function(container){
    if(!arguments.length){
      return this._defs;
    }
    this._defs = container;
  };

  EffectManager.prototype.ghostEffect = function(_){
    if(!arguments.length) {
      return this._enableGhostEffect;
    }
    this._enableGhostEffect = _;
  };
  return EffectManager;
});sap.riv.module(
{
  qname : 'sap.viz.modules.rootContainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ignite',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.EffectManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.append',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BackgroundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.layout.dock',
  version : '4.0.2'
}
],
function Setup ( registry, category, ignite, EffectManager, append, evts, Layout, 
  objects, BackgroundUtil, dock ) {

  var lambda = function ( conf, context ) {
    var width = 0, 
        height = 0,
        data = {},
        properties = {},
        config = {},
        parentNode = null,
        container = null,
        modules = {},
        selections = {},
        dispatch = evts('initialized', 'ready'),
        count = 0,
        inits = 0,
        backgroundModule = null,
        wording = { class_prefix : 'v-m-', default_layout_key : 'sap_viz_modules_layout_dock_key'}, 
        effectManager = new EffectManager(),
        charger = { func : null, scope : null };
        
    context.effectManager = effectManager;
    
    function rewireControllers () {
      $.each(config.modules, function ( key, value ) {
        if ( value == null ) { return; }
        if ( category.get(value.id).type === registry.Type.Controller ) {
          modules[key]().module(modules[value.configure.clientID]);
        }
      });
    }
    
    // checklist items in order upon update against this module
    var update_checklist = [ rewireControllers ];
    
    var init = function ( args ) {
      var dataset = args.dataset,
          attrs = args.props,
          conf = args.conf, children = {};
      
      $.each(conf.modules, function ( key, value) {
        if ( value === null ) { return; }
        var target = ignite( value.id, context, wording.class_prefix + key ),
            data = value.data ? dataset.createDataAdapterForModule(value.data) : dataset,
            props = {},
            type = category.get(value.id).type;
        
        children[key] = key === 'tooltip' ? target(container) : target;
        if ( children[key].data ) { children[key].data(data); }
        
        children[key].alias = key;
        
        if ( type !== registry.Type.Controller && key !== 'tooltip' && key !== 'layout' ) {
          selections[key] = append.apply(parentNode, [ 'g', 
             { 'class' : wording.class_prefix + key } ]);
        }
        
        if ( children[key].dispatch && children[key].dispatch()['initialized']) {
            children[key].dispatch().on('initialized.rootContainer', initialized);
            count++;
        }
        
        // containers
        if ( category.get(value.id).type === registry.Type.Container ) {
          if ( value.configure ) {
            props[value.configure.propertyCategory] = value.configure.properties;
          }

          children[key].parent(selections[key]).config(value)
            .properties(objects.extend(true, {}, props, attrs));
          
        } else { // non-containers
          children[key].properties(objects.extend(
            true, 
            {}, 
            value.configure ? value.configure.properties : {}, 
            value.configure ? attrs[value.configure.propertyCategory] : {}));
          
          if ( children[key].parent ) { children[key].parent(selections[key]); }
        }
      });
      
      // special care for behavioral modules
      $.each(conf.modules, function ( key, value ) {
        if ( value === null ) { return; }
        if ( category.get(value.id).type === registry.Type.Controller ) {
          children[key]().module(children[value.configure.clientID]);
        }
      });
      
      return children;
    };
    
    var getDefaultLayout = function () {
      var defaultKey = wording['default_layout_key'];
      var defaultLayout = modules[defaultKey];
      if ( defaultLayout ) {
        return defaultLayout;
      } else {
        //actually we are hard coding package here
        modules[defaultKey] = ignite('sap.viz.modules.layout.dock', context, wording.class_prefix + defaultKey);
        return modules[defaultKey];
      }
    };
    
    var layout = function () {
      var algorithm = modules.layout || getDefaultLayout(),
          props = properties.general ?
                  properties.general.layout :
                    config.configure.properties ? config.configure.properties.layout : null; 
      
      // evaluates layout function
      function calc (xs, adjustPolicy) {
        return (algorithm.width(width).height(height))(xs, adjustPolicy);
      }
      
      // formulates layout data
      function create (xs) {
        var padding = [ 24, 24, 24, 24 ], 
            vgap = 0,
            hgap = 0,
            elements = [];
        
        if ( typeof props === 'undefined' || props === null ) props = conf.props().layout;
        // else props = $.extend(true, {}, conf.props().layout, props);
        vgap = conf.props().layout.vgap;
        hgap = conf.props().layout.hgap;
        
        if ( props.padding >= 0 ) {
          for ( var i = 0; i < padding.length; i++ ) padding[i] = props.padding;
        }
        
        if ( props['paddingLeft'] ) padding[3] = props['paddingLeft'];
        if ( props['paddingRight'] ) padding[1] = props['paddingRight'];
        if ( props['paddingTop'] ) padding[0] = props['paddingTop'];
        if ( props['paddingBottom'] ) padding[2] = props['paddingBottom'];
        
        algorithm
          .padding(padding, function (d) {
            return d > 1/3 * Math.min(width, height) ? d / 10 : d;
          })
          .vgap(vgap || 0, function (d) { return d; })
          .hgap(hgap || 0, function (d) { return d; })
          .width(width)
          .height(height)
          .rewire(charger)
          .sort(function (a, b) { return a.priority - b.priority; })
          .size(function (d) {
            return d.module.getPreferredSize ? d.module.getPreferredSize() : null; 
          })
          .value(function (d) { return a.priority; })
          .edge(function (d) { return d.position; })
          .filter(function (d) { return d.filter; })
          .tolerance(1);
        
        $.each(xs, function ( key, value ) {
          if ( category.get(config.modules[key].id).type !== registry.Type.Container &&
               category.get(config.modules[key].id).type !== registry.Type.Supplementary &&
               category.get(config.modules[key].id).type !== registry.Type.Chart ) {
            return;
          }
          
          var req = value.properties().layout || 
                    value.properties()[config.modules[key].configure.propertyCategory].layout,
              pos = req.position;
          
          elements.push({
            module : value,
            position : pos,
            filter : function (d) {
              var ret = {},
                  result = d.result,
                  size = d.size;
              if ( d.edge === 'top' || d.edge === 'bottom' ) {
                 result.height > 1/3 * (size.height - padding[0] - padding[2]) ? 
                   ret.height = 1/3 * (size.height - padding[0] - padding[2]) : 
                   ret.height = result.height;
                 ret.width = result.width;
              }
              if ( d.edge === 'left' || d.edge === 'right' ) {
                result.width > 1/3 * (size.width - padding[1] - padding[3]) ? 
                  ret.width = 1/3 * (size.width - padding[1] - padding[3]) : 
                  ret.width = result.width;
                ret.height = result.height;
              }
              return ret;
            },
            priority : req.priority
          }); 
        });
        
        return elements;
      }
      
      return calc(create(modules), 'RELAYOUT');
    };
    
    function drawBackground() {
      var props = {
        width: width,
        height: height,
        properties : {
          border : {
            left : { visible : false },
            right : { visible : false },
            top : { visible:false },
            bottom : { visible:false }
          }
        },
        parentCtx: context
      };
      backgroundModule = BackgroundUtil.drawBackground(parentNode, backgroundModule, props);
    }

    function chart ( canvas /* not a physical one */ ) {
      canvas.each(function ( datum ) {
        inits = 0;
        parentNode = d3.select(this);
        
        var map = layout();
        // special treatment against inefficient workflow
        // TODO refine work flow definition

        // charger.scope._doLayout(charger.scope.size());
		map = layout();
        $.each(map, function ( key, value ) {
          selections[key].attr('transform', 
            'translate(' + value.x + ',' + value.y + ')');
        });
        
        if ( modules.tooltip ) {
          modules.tooltip().plotArea({
            x : map.main.x,
            y : map.main.y,
            width : modules.main.width(),
            height : modules.main.height()
          }).zone({ width : width, height : height });
        }
          
        drawBackground();
        
        // execute module drawing logics
        for ( var key in modules ) {
          if ( modules.hasOwnProperty(key) && 
               category.get(config.modules[key].id).type !== registry.Type.Controller && 
               key !== 'tooltip' && key !== 'layout' ) {
             selections[key].call(modules[key]);
           }
        }
      });
    }
    
    // x stands for scalar values and xs stands for collection/compound values
    chart.width = function (x) {
      if ( !arguments.length ) { return width; }
      width = _;
      return chart;
    };
    
    chart.height = function (x) {
      if ( !arguments.length ) { return height; }
      height = _;
      return chart;
    };
    
    chart.size = function (xs) {
      if ( !arguments.length ) { return { width : width, height : height }; }
      width = xs.width;
      height = xs.height;
      return chart;
    };
    
    chart.config = function (xs) {
      if ( !arguments.length ) { return config; }
      config = xs;
      if ( !$.isEmptyObject(properties) && !$.isEmptyObject(data) ) {
        init({ dataset : data, conf : config, props : properties });
      }
      return chart;
    };
    
    chart.data = function (xs) {
      if ( !arguments.length ) { return data; }
      data = xs;
      if(effectManager){
        effectManager.ghostEffect(data.fakeData());  
      }
      if ( $.isEmptyObject(modules) && 
           !$.isEmptyObject(properties) && 
           !$.isEmptyObject(config) ) {
        init({ dataset : data, conf : config, props : properties });
      } 
      
      for ( var key in modules ) {
        if ( modules.hasOwnProperty(key) ) {
          if ( config.modules[key].data ) {
            modules[key].data(
              data.createDataAdapterForModule(config.modules[key].data));
          } else {
            if ( modules[key].data ) modules[key].data(data);
          }
        }
      }
      
      return chart;
    };
    
    chart.properties = function (xs) {
      if ( !arguments.length ) { return properties; }
      
      properties = xs; // FIXME retain local copy of default properties
      
      for ( var key in modules ) {
        if ( modules.hasOwnProperty(key) ) {
          if ( config.modules[key].modules ) {
            modules[key].properties(xs);
          } else if (config.modules[key].configure) {
            modules[key].properties(xs[config.modules[key].configure.propertyCategory]);
          }
        }
      }
      
      return chart;
    };
    
    chart.relayout = function ( evt ) {
      layout();
    };
    
    // Means of wiring up module dependencies
    chart.recharge = function (x) {
      if ( !arguments.length ) return charger;
      charger = x;
      return chart;
    };
    
    chart.dispatch = function (x) {
      if ( !arguments.length ) { return dispatch; }
      dispatch = x;
      return chart;
    };
    
    chart.refresh = function () {
      for ( var i = 0; i < update_checklist.length; i++ ) {
        update_checklist[i]();
      }
      return chart;
    };
    
    chart.parent = function (x) {
      if ( !arguments.length ) { return parentNode; }
      parentNode = x;
      if(effectManager){
        effectManager.container(parentNode.append("svg:defs"));  
      }
      return chart;
    };
    
    chart.container = function (x) {
      if ( !arguments.length ) { return container; }
      container = x;
      return chart;
    };
    
    chart.modules = function (xs) {
      if ( !arguments.length ) {
        if ( $.isEmptyObject(modules) ) {
          return modules = init({ dataset : data, props : properties, conf : config});
        }
        return modules;
      }
      modules = xs;
      return chart;
    };
    
    function initialized () {
      if ( ++inits === count ) {
        inits = 0;
        dispatch.initialized();
        dispatch.ready();
      }
    }
    
    return chart;
  };
  
  return lambda;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.rootContainer',
  version : '4.0.2'
}
],
function Setup ( Manifest, Constants, fn ) {
  
  var module = {
    id : "sap.viz.modules.rootContainer",
    type : Constants.Module.Type.Container,
    name : "rootContainer",
    description : "Represents the chart scoped properties.",
    properties : {
      layout : {
        name : 'layout',
        description : 'Layout properties',
        supportedValueType : 'Object',
        supportedValues : {
          adjustPolicy : {
            name : 'adjustPolicy',
            supportedValueType : 'String',
            defaultValue : undefined,
            description : 'Indicates the layout adjust policy.',
            isExported : false
          },
          padding : {
            name : 'padding',
            supportedValueType : 'PositiveInt',
            defaultValue : 24,
            description : 'Universal padding value settings. The single value will be applied to all laterals of the chart area. Explicit settings for each edge are supported.'
          },
          'paddingTop' : {
            name : 'paddingTop',
            supportedValueType : 'PositiveInt',
            defaultValue : 24,
            description : 'Padding value for the top side'
          },
          'paddingLeft' : {
            name : 'paddingLeft',
            supportedValueType : 'PositiveInt',
            defaultValue : 24,
            description : 'Padding value for the left side'
          },
          'paddingRight' : {
            name : 'paddingRight',
            supportedValueType : 'PositiveInt',
            defaultValue : 24,
            description : 'Padding value for the right side'
          },
          'paddingBottom' : {
            name : 'paddingBottom',
            supportedValueType : 'PositiveInt',
            defaultValue : 24,
            description : 'Padding value for the bottom side'
          },
          vgap : {
            name : 'vgap',
            supportedValueType : 'PositiveInt',
            defaultValue : 8,
            description : 'Vertical gap value between UI components',
            isExported : false
          },
          hgap : {
            name : 'hgap',
            supportedValueType : 'PositiveInt',
            defaultValue : 8,
            description : 'Horizontal gap value between UI components',
            isExported : false
          }
        }
      }
    },
    events : {
      selectData : Constants.Module.Event.SelectData.desc,
      deselectData : Constants.Module.Event.DeSelectData.desc,
      showTooltip : Constants.Module.Event.TooltipShow.desc,
      hideTooltip : Constants.Module.Event.TooltipHide.desc
    },
    configure : null,
    fn : fn
  };
  
  Manifest.register(module);
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.layout.stack',
  version : '4.0.2'},
[

],
function Setup () {
  
  function stack_sortDefault (a, b) { return a.order - b.order; }
  function stack_sizeDefault (x) { return x.size(); }
  function stack_orderDefault (x) { return x.order; }
  
  var _ = function () {
    var sort = stack_sortDefault,
        size = stack_sizeDefault,
        order = stack_orderDefault,
        gravity = -1, // top or bottom alignment
        width = 0,
        height = 0;
    
    function maxWidth (x) { return size(x).maxWidth; }
    function minWidth (x) { return size(x).minWidth; }
    function maxHeight (x) { return size(x).maxHeight; }
    function minHeight (x) { return size(x).minHeight; }
    
    function stack () {
      var data = arguments[0].slice().sort(stack_sortDefault),
        align = arguments[1],
        heights = [],
        result = {},
        isEnough = false;

      data.forEach(function(d) {
        heights.push(maxHeight(d));
      });

      if (d3.sum(heights) <= height) {
        isEnough = true;
      }
      var start = 0, _maxHeight, _minHeight, _availableHeight = height;
      data.forEach(function(d) {
        var anchor = { x : 0, y : 0 }, 
          w = 0; // preferred size;
        
        _maxHeight = maxHeight(d);
        _minHeight = minHeight(d);
        
        anchor.y = start;
        if (isEnough) {
          start = start + _maxHeight;
          d.module.width(width).height(_maxHeight);
        } else {
          // No enough
          if (_availableHeight < _minHeight) {
            d.module.width(0).height(0);
            return anchor;
          } else if (_availableHeight > _maxHeight) {
            start = start + _maxHeight;
            d.module.width(width).height(_maxHeight);
            _availableHeight = _availableHeight - _maxHeight;
          } else {
            start = start + _availableHeight;
            d.module.width(width).height(_availableHeight);
            _availableHeight = 0;
          }
        }

        if (align === 'right' && (w = maxWidth(d)) < width) {
          anchor.x = width - w;
        }

        /* if ( align === 'center' ) {  TODO add support  }*/

        result[d.module.alias] = anchor;
      });

      return result;
//      var data = arguments[0].slice().sort(stack_sortDefault),
//          align = arguments[1],
//          heights = [],
//          result = {},
//          spring = 0, // spring volume for each component to shrink/enlarge
//          maxY = height,
//          isEnough = false;
//      
//      data.forEach(function (d) { heights.push(maxHeight(d)); });
//      
//      var heightSum = d3.sum(heights), _minHeight, _maxHeight;
//      if ( heightSum > height ) {
//        spring = heightSum - height;
//        
//        data.forEach(function (d) {
//          _minHeight = minHeight(d);
//          _maxHeight = maxHeight(d);
//          
//          if(height < _minHeight){
//            //this element with whole height can't be layout.
//            d.module.width(0).height(0);
//            heightSum = heightSum - _maxHeight;
//            spring = heightSum - height;
//          }else{
//            if(heightSum > _maxHeight && _maxHeight - spring < _minHeight){
//              //multiple legends
//              d.module.width(0).height(0);
//              heightSum = heightSum - _maxHeight;
//            }
//          }
//        });
//      }else if ( gravity < 0 && heightSum <= height ) {
//        maxY = heightSum;
//        isEnough = true;
//      }
//      
//      data.forEach(function (d) {
//        var anchor = { x : 0, y : 0 }, 
//            w = 0; // preferred size
//        
//        // terminate
//        if ((!isEnough) && (d.module.width() === 0) && (d.module.height() === 0)) {
////          d.module.width(0).height(0);
//          return anchor;
//        } else {
//        // width is irrelevant
//          var moduleHeight = maxHeight(d);
//          if(spring > 0){
//            moduleHeight = (maxHeight(d) - spring < minHeight(d)) ? (maxHeight(d) - spring) : minHeight(d);
//          }
//          d.module.width(width).height(moduleHeight);
//          
//          anchor.y = maxY - d.module.height();
//          maxY = anchor.y; // push stack
//          
//          if ( align === 'right' && (w = maxWidth(d)) < width ) {
//            anchor.x = width - w;
//          }
//          
//          /* if ( align === 'center' ) {  TODO add support  }*/
//          
//          result[d.module.alias] = anchor;
//        }
//      });
//      
//      return result;
      
    }
    
    stack.sort = function (x) {
      if ( !arguments.length ) { return sort; }
      sort = x;
      return stack;
    };
    
    stack.size = function (x) {
      if ( !arguments.length ) { return size; }
      size = x;
      return stack;
    };
    
    stack.gravity = function (x) {
      if ( !arguments.length ) { return gravity; }
      gravity = x;
      return stack;
    };
    
    stack.order = function (x) {
      if ( !arguments.length ) { return order; }
      order = x;
      return stack;
    };
    
    stack.width = function (x) {
      if ( !arguments.length ) { return width; }
      width = x;
      return stack;
    };
    
    stack.height = function (x) {
      if ( !arguments.length ) { return height; }
      height = x;
      return stack;
    };
    
    stack.data = function () { return stack; };
    stack.properties = function () { return stack; };
    
    return stack;
  };
  
  return _;
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.layout.Stack',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.layout.stack',
  version : '4.0.2'
}
],
function Setup ( Manifest, Constants, fn ) {
  var module = {
    id : "sap.viz.modules.layout.stack",
    type : Constants.Module.Type.Scientific.Layout,
    name : "stack",
    description : "The stack layout algorithm",
    properties : {},
    configure : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.mbcLegendArea',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(TextRuler, langManager,FormatManager,TypeUtils, UADetector) {
  var mbcLegendArea = function(ctx){
    
    var width = 400, height = 200, valueLabelFont = {
        'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
        'fontsize' : '12px',
        'fontweight' : 'normal',
        'color' : '#333333'
      }, chartData, colors = [], markerSize = {width: 18, height : 20}, paddingBottom = 1,
        selectedItem = [], selectionMode = 'selectionMode', posInfo = {
        markerPaddingRight : 0.5,
        paddingTop : 1,
        maxValueSpace : 1.6,
        minValueSpace : 0.5,
        minMarkerHeight : 10,  //10pixel
        space : 0
      }, nullLabelIndex = -1, textHeight = 20, minimized = false, noValueString = langManager.get('IDS_ISNOVALUE'), options;
    var effectManager = null;
    var style = {};
        
    var chart = function(selection){
      selection.each(function(){
        getThemeStyleDef();
        
        //Calculate marker size.
        _calMarkerSize(height);
        
        var labelsData = chartData, textElements, y = 0, visible = 'visible', j, jlen, valuePaddingLeft = posInfo.markerPaddingRight * textHeight;
        var wrap = d3.select(this);
        
        var indicatedRectElement = wrap.selectAll('rect.v-indicatedRect');
        if(indicatedRectElement.empty()){
          indicatedRectElement = wrap.append('rect').attr('class', 'v-indicatedRect v-hovershadow');
        }
        indicatedRectElement.attr('visibility', 'hidden')
          .attr('width', markerSize.width + 8).attr('height', markerSize.height+2);
        
        var gWrap = wrap.selectAll('g.v-row').data(labelsData, function(d, i){
          return d.val;
        });
        
        gWrap.exit().remove();
        var gEnterWrap = gWrap.enter().append('g').attr('class', 'v-row');
        gEnterWrap.append('rect').attr('class', function(d, i){
          return 'v-marker ID_' + i;
        });
        gEnterWrap.append('text');

        var rectElements = gWrap.selectAll('rect.v-marker').attr('width', markerSize.width).attr('height', markerSize.height);
        var parameter, fillID;
        for(j = 0, jlen = rectElements.length; j < jlen; j++){
          y = (markerSize.height + paddingBottom) * ((nullLabelIndex !== -1) ? (j-1) : j);
          if(labelsData[j].val === 'N/A'){
            y = (markerSize.height + paddingBottom)*(jlen > 1 ? jlen : 0);
          }
          rectElements[j][0].setAttribute('y', y);
          
          parameter = {
            drawingEffect : 'normal',
            fillColor : colors[labelsData.length - j - 1]
          };
          fillID = effectManager.register(parameter);
          rectElements[j][0].setAttribute('fill', fillID);
        }

        textElements = gWrap.selectAll('text').text(function(d, i){
          var txt = d.val;
          if(txt === 'N/A'){
            txt = noValueString;
          }
          if(TypeUtils.isExist(options.formatString)){
              txt = FormatManager.format(txt , options.formatString );
          }
          return txt;
        }).attr('x', markerSize.width + valuePaddingLeft);
        y = 0;
        for(j = 0, jlen = textElements.length; j < jlen; j++){
          y = markerSize.height*((nullLabelIndex !== -1) ? j : (j+1)) + textHeight/2;
          if(labelsData[j].val === 'N/A'){
            y = (markerSize.height + paddingBottom)*(jlen > 1 ? jlen : 0) + textHeight/2 + markerSize.height/2;
          }
          if(minimized && j !== jlen-1 && (labelsData[j].val !== 'N/A')){
            visible = 'hidden';
          }else {
            visible = 'visible';
          }
          
          textElements[j][0].setAttribute('y', y);
          textElements[j][0].setAttribute('visibility', visible);
        }
        
        
        if(labelsData.length > 1){
          //Add top text
          var topTextElements = wrap.selectAll('text.v-topText');
          if(topTextElements.empty()){
            topTextElements = wrap.append('text').attr('class', 'v-topText');
          }
          var topTextLabel;
          if(nullLabelIndex !== -1){
            topTextLabel = labelsData[1].ctx.ranges.endValue;
          }else{
            topTextLabel = labelsData[0].ctx.ranges.endValue;
          }
          if(TypeUtils.isExist(options.formatString)){
            topTextLabel = FormatManager.format(topTextLabel, options.formatString);
          }
          topTextElements.text(topTextLabel).attr('x', markerSize.width + valuePaddingLeft).attr('y', textHeight/2);
        }else if(labelsData.length === 1){
          textElements[0][0].setAttribute('y', textHeight/2 + markerSize.height/2);
        }
        
        var defaultValueLabelStyle = ctx.styleManager.queryDefault('v-label');
        wrap.attr('font-family', defaultValueLabelStyle['font-family']).attr('font-size', defaultValueLabelStyle['font-size']).attr('font-weight', defaultValueLabelStyle['font-weight']).attr('fill', defaultValueLabelStyle.color);
        if (UADetector.isMobile()) {
            wrap.on('touchstart', itemClicked).on('touchend.color', blurHandler);
        } else {
            wrap.on('mouseover', hoverHandler).on('mouseout', blurHandler)
              .on('mousedown', itemClicked).on('mouseup', hoverHandler);
        }
      });
    };

    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }

    var hoverHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      var item = d3.select(getCurrentEvent().target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        var x = item.attr('x'), y = item.attr('y');
        
      var indicatedItem = d3.selectAll('.v-indicatedRect');
      indicatedItem.attr('class', 'v-indicatedRect v-hovershadow').attr('visibility', 'visible')
        .attr('fill', style.hovershadow.fill).attr('x', x - 4).attr('y', y- 1);
    };
    
    var blurHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      var item = d3.select(getCurrentEvent().target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        
      var indicatedItem = d3.selectAll('.v-indicatedRect');
      indicatedItem.attr('visibility', 'hidden');
    };
    
    var itemClicked = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }
      var item = d3.select(getCurrentEvent().target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1){
          return;
        }
        var x = item.attr('x'), y = item.attr('y');
        
      var indicatedItem = d3.selectAll('.v-indicatedRect');
      indicatedItem.attr('class', 'v-indicatedRect v-hovershadow-mousedown').attr('visibility', 'visible').attr('fill', '#808080').attr('x', x - 4).attr('y', y- 1);
    };
    
    chart.clickHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        return;
      }

      var isSelected = false,
          target = getCurrentEvent().target;
      
      if(_contains(selectedItem, target)){
        //has been selected.
        isSelected = true;
      }else{
        //New selected item
        selectedItem.push(target);
      }
      return isSelected;
    };
    
    chart.width = function(_) {
      if(!arguments.length){
        return width;
      }
      width = _;
      return chart;
    };

    
    chart.height = function(_) {
      if(!arguments.length){
        return height;
      }
      height = _;
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length){
        return options;
      }
      //TODO use extends...
      options = properties;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length){
        return chartData;
      }
      chartData = _;
      return chart;
    };
    
    chart.setSelectionMode = function(_){
      selectionMode = _;
    };
    chart.hasData = function(){
      if( chartData){
        return true;
      }else {
        return false;
      }
    };
    chart.getPreferredSize = function() {
      var maxWidth = 0, maxHeight = 0, minHeight = 0, minWidth = 0, data = chartData;
      if(data){
        //reset N/A flag
        nullLabelIndex = -1;
        
        getThemeStyleDef();
        var textInfos = _calTextSize();
        var len = data.length, maxValueWidth = textInfos.maxValueWidth, valueSize = textInfos.textSize;
//        var maxValueWidth = -1, valueSize = [], labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
//        var len = data.length;
//        for ( var i = 0; i < len; i++) {
//          if(data[i].val === 'N/A'){
//            valueSize[i] = TextRuler.measure(noValueString, labelFont);
//            nullLabelIndex = i;
//          }else{
//            var value = data[i].val;
//            if(TypeUtils.isExist(options.formatString)){
//                value = FormatManager.format(value , options.formatString );
//              }
//            valueSize[i] = TextRuler.measure(value, labelFont);
//            
//          }
//          if ((valueSize[i] === undefined) || (valueSize[i].width > maxValueWidth)) {
//            maxValueWidth = valueSize[i].width;
//          }
//        }
        
        textHeight = parseInt(valueLabelFont.fontsize, 10); //1em
        var h = (posInfo.maxValueSpace + 1) * textHeight;
        
        maxWidth = markerSize.width + posInfo.markerPaddingRight * textHeight + maxValueWidth;
        minWidth = markerSize.width + posInfo.markerPaddingRight * textHeight + (valueSize[0].width > valueSize[len - 1].width ? valueSize[0].width : valueSize[len - 1].width);
        if(nullLabelIndex !== -1){
          maxHeight = (h + paddingBottom) * (len+1) + textHeight;
          minHeight = (posInfo.minMarkerHeight + paddingBottom) * (len+1) + textHeight;
        }else{
          maxHeight = (h + paddingBottom) * len + textHeight;
          minHeight = (posInfo.minMarkerHeight + paddingBottom) * len + textHeight;
        }
        
//        if(((posInfo.minMarkerHeight + paddingBottom) * len) < textHeight * 2){
//          //Hide MBC legend if label font size is very bigger.
//          minHeight = maxHeight;
//          minWidth = maxWidth;
//        }
      }
      return {
        minHeight: minHeight,
        minWidth: minWidth,
        width: maxWidth,
        height: maxHeight
      };
    };
    
    chart.doLayout = function(size){
      // Calculate marker size.
      _calMarkerSize(size.height);
      var textInfos = _calTextSize();
      
      var actualWidth = 0, actualHeight = 0, textWidth = 0, len = textInfos.textSize.length;
      if(minimized === true){
        textWidth = (textInfos.textSize[0].width > textInfos.textSize[len-1].width) ? textInfos.textSize[0].width : textInfos.textSize[len-1].width;
      }else{
        textWidth = textInfos.maxValueWidth;
      }
        
      actualWidth = markerSize.width + posInfo.markerPaddingRight * textHeight + textWidth;
      if(nullLabelIndex !== -1){
        actualHeight = (markerSize.height + paddingBottom) * (len+1) + textHeight;
      }else{
        actualHeight = (markerSize.height + paddingBottom) * len + textHeight;
      }
      return {
        width : actualWidth,
        height : actualHeight
      };
    };
    
    chart.color = function(_) {
      if(!arguments.length){
        return colors;
      }
      colors = _;  
      return chart;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length){
        return effectManager;
      }
      effectManager = _;

      return chart;
    };
    
    var _calTextSize = function(){
      var maxValueWidth = -1, valueSize = [], data = chartData, labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
      var len = data.length;
      for ( var i = 0; i < len; i++) {
        if(data[i].val === 'N/A'){
          valueSize[i] = TextRuler.measure(noValueString, labelFont);
          nullLabelIndex = i;
        }else{
          var value = data[i].val;
          if(TypeUtils.isExist(options.formatString)){
              value = FormatManager.format(value , options.formatString );
            }
          valueSize[i] = TextRuler.measure(value, labelFont);
          
        }
        if ((valueSize[i] === undefined) || (valueSize[i].width > maxValueWidth)) {
          maxValueWidth = valueSize[i].width;
        }
      }
      return {
        maxValueWidth : maxValueWidth,
        textSize : valueSize
      };
    };
    
    var _calMarkerSize = function(areaHeight){
      var len = chartData.length, h = 0, space = 0;
      minimized = false;
      if(nullLabelIndex !== -1){
        space = (areaHeight - (len + 2) * textHeight)/(len+1);
      }else{
        space = (areaHeight - (len + 1) * textHeight)/len;
      }
      h = space + textHeight;
      
      var maxValueSpace = posInfo.maxValueSpace * textHeight;
      if(space > maxValueSpace){
        space = maxValueSpace;
        h = space + textHeight;
      }else {
        var minValueSpace = posInfo.minValueSpace * textHeight;
        if(space < minValueSpace){
          h = posInfo.minMarkerHeight;
          space = 0;
          minimized = true;
        }
      }
      posInfo.space = space;
      markerSize.height = h;
    };
    
    //Utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = ctx.styleManager.query('v-label');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };

    function getCSSStyle() {
        style.hovershadow = ctx.styleManager.queryDefault('v-hovershadow');
    }
    getCSSStyle();
    return chart;
  };
  return mbcLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.sizeLegendArea',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
}
],
function Setup(TextRuler, langManager,FormatManager,TypeUtils) {
  var colorLegendArea = function(ctx){
    
    var width = 400, height = 200, valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '14px',
      'fontweight' : 'normal',
      'color' : '#333333'
    }, chartData=[0, 0, 0], scale, colors, shapes, guildeLineWidth = 10, valuePaddingLeft = 15, valueLabelHeight = 0, options;
    
    var effectManager  = null;
    
    var chart = function(selection){
      selection.each(function(){
        if(scale === undefined){
          return;
        }
        
        getThemeStyleDef();
        
        //Smart value label management.
        var textHeight = parseInt(valueLabelFont.fontsize, 10); //1em
        var visibleData = [], labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        if(valueLabelHeight === 0){
          valueLabelHeight = TextRuler.measure('M', labelFont).height;
        }
        var visibleCount = Math.floor((scale(chartData[0]) + textHeight) / valueLabelHeight);
        switch(visibleCount){
        case 0:
        case 1:
          visibleData.push(chartData[0]);
          break;
        case 2:
          visibleData.push(chartData[0]);
          if(chartData.length > 1){
            visibleData.push(chartData[chartData.length -1]);
          }
          break;
        default :
          visibleData = chartData;
        }

        var bubbleSizeArr = [], maxWidth = -1, dataWidth, value;
        for(var i = 0, len = visibleData.length; i < len; i++){
          bubbleSizeArr.push(scale(visibleData[i])/2);
          value = _isNullValue(visibleData[i]);
          if(TypeUtils.isExist(options.formatString)){
              value = FormatManager.format(value , options.formatString );
            }
          dataWidth = TextRuler.measure(value, labelFont).width;
          if(dataWidth > maxWidth){
            maxWidth = dataWidth;
          }
        }
        var maxBubbleSize = bubbleSizeArr[0];
        var wrap = d3.select(this);
        var circlesWrap = wrap.selectAll('g.v-circles');
        if(circlesWrap.empty()){
          circlesWrap = wrap.append('g').attr('class', 'v-circles').data([bubbleSizeArr]);
        }
        circlesWrap.attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize+textHeight)+ ')');
        
        var parameter = {
          drawingEffect : options.drawingEffect,
          graphType : 'circle',
          fillColor : '#748CB2'
        };
        var fillID = effectManager.register(parameter);
        var circleElements = circlesWrap.selectAll('circle').data(bubbleSizeArr, function(d, i){
          return d;
        });
        circleElements.exit().remove();
        circleElements.enter().append('circle').attr('stroke', 'white').attr('stroke-width', 1).attr('fill', fillID).attr('opacity', '0.85');
        circleElements.attr('r', function(d, i){ return d;})
          .attr('cx', function(d, i){
            return 0;
          }).attr('cy', function(d, i){
            return maxBubbleSize-d;
          });
        
        var labelsWrap = wrap.selectAll('g.v-valueLabels');
        if(labelsWrap.empty()){
          labelsWrap = wrap.append('g').attr('class', 'v-valueLabels').data([visibleData]);
        }
        var labelX = (maxBubbleSize*2+valuePaddingLeft+guildeLineWidth+maxWidth) > width ? width : (maxBubbleSize*2+valuePaddingLeft+guildeLineWidth+maxWidth);
        labelsWrap.attr('transform', 'translate('+ labelX +', '+(maxBubbleSize+textHeight*3/2)+')');
        var valueElements = labelsWrap.selectAll('text').data(visibleData, function(d, i){
          return d;
        });
        valueElements.exit().remove();
        valueElements.enter().append('text').attr('text-anchor', 'end');
        valueElements.text(function(d, i){
            var value = _isNullValue(d);
            if(TypeUtils.isExist(options.formatString)){
              value = FormatManager.format(value , options.formatString );
            }
            return value;
          }).attr('dx', 0).attr('dy', function(d, i){
            var dy = (i-1)*maxBubbleSize - 2;
            if(visibleData.length === 2 && i === 1){
              dy = maxBubbleSize - 2;
            }
            return dy;
          });
        
        var guidelineWrap = wrap.selectAll('g.v-guideLines');
        if(!guidelineWrap.empty()){
          //Empty
          guidelineWrap.remove();
        }
        guidelineWrap = wrap.append('g').attr('class', 'v-guideLines').attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize+textHeight)+ ')');
        if(visibleData.length > 0){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ -maxBubbleSize +' L '+(maxBubbleSize+guildeLineWidth)+" "+ -maxBubbleSize);
        }
        if(visibleData.length > 1){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ maxBubbleSize +'L'+(maxBubbleSize+guildeLineWidth)+" "+ maxBubbleSize);
        }
        if(visibleData.length > 2){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ (maxBubbleSize - bubbleSizeArr[1]) +' L '+maxBubbleSize+" 0"+  ' M '+ maxBubbleSize + " 0 " + " L "+ (maxBubbleSize + guildeLineWidth) +" 0");
        }
        
        var defaultValueLabelStyle = ctx.styleManager.queryDefault('v-label');
        wrap.attr('font-family', defaultValueLabelStyle['font-family']).attr('font-size', defaultValueLabelStyle['font-size']).attr('font-weight', defaultValueLabelStyle['font-weight']).attr('fill', defaultValueLabelStyle.color);
      });
        
    };
    
    chart.width = function(_) {
      if(!arguments.length){
        return width;
      }
      width = _;
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length){
        return height;
      }
      height = _;
      return chart;
    };
    
    chart.color = function(_) {
      if(!arguments.length){
        return colors;
      }
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length){
        return shapes;
      }
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length){
        return options;
      }
      //TODO use extends...
      options = properties;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length){
        return chartData;
      }
      chartData = _;
      return chart;
    };
    
    chart.scale = function(_){
      if(!arguments.length){
        return scale;
      }
      scale = _;
      return chart;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length){
        return effectManager;
      }

      effectManager = _;
      return chart;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = ctx.styleManager.query('v-label');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    chart.hasData = function(){
      if(scale){
         return true;
      }else {
        return false;
      }
    };
    chart.getPreferredSize = function(){

      getThemeStyleDef();
      var maxWidth = 0, maxHeight = 0, minWidth = 0, minHeight = 0;
      var maxValueWidth = -1, maxBubbleSize, valueSize = [], value = null, space, i, len,
        data = chartData, labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;

        /*** start new layout algorithm ***/
        if(scale){
          for(i = 0, len = data.length; i < len; i++){
            value = _isNullValue(data[i]);
            if(TypeUtils.isExist(options.formatString)){
                value = FormatManager.format(value , options.formatString );
              }
            valueSize[i] = TextRuler.measure(value, labelFont);
            if((valueSize[i] === undefined) || (valueSize[i].width > maxValueWidth)) {
              maxValueWidth = valueSize[i].width;
            }
          }
          space =  maxValueWidth + valuePaddingLeft + guildeLineWidth;
          maxBubbleSize = scale(data[0]);
          
          maxHeight = maxBubbleSize + valueSize[len - 1].height * 2;
          maxWidth = maxBubbleSize + space;
          minWidth = maxBubbleSize + valuePaddingLeft + guildeLineWidth + valueSize[0].width;
          minHeight = maxHeight;
        }
//      }else{
//        /*** start old layout algorithm ***/
//      if(scale && layoutSpace){
//        valueLabelHeight = 0;
//        
//        for(i = 0, len = data.length; i < len; i++){
//          value = _isNullValue(data[i]);
//          if(TypeUtils.isExist(options.formatString)){
//              value = FormatManager.format(value , options.formatString );
//            }
//          valueSize[i] = TextRuler.measure(value, labelFont);
//          if((valueSize[i] === undefined) || (valueSize[i].width > maxValueWidth)) {
//            maxValueWidth = valueSize[i].width;
//          }
//        }
//        
//        space =  maxValueWidth + valuePaddingLeft + guildeLineWidth;
//        maxBubbleSize = chartSize ? (chartSize.width - layoutSpace - legendSpace - space - containerInfo.space - containerInfo.number * bubbleSpace) / (1 + (1 / bubbleScale) * containerInfo.number) : scale(data[0]);
//          valueLabelHeight = valueSize[len - 1].height;
//        
//
//        if (!hasHeightFeed && containerInfo.plotHeight) {
//          maxBubbleSize = Math.min((containerInfo.plotHeight - bubbleSpace) * bubbleScale, maxBubbleSize);
//        }
//        
//        maxHeight = maxBubbleSize + valueSize[len - 1].height * 2;
//        maxWidth = maxBubbleSize + space;
//        minWidth = maxWidth;
//        minHeight = maxHeight;
//      }
//      }
      return {
        minHeight: minHeight,
        minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
    };
    
    chart.doLayout = function(size){
      return size;
    };
    
    return chart;
  };
    
  var _isNullValue = function(value){
    return (value === null) ? langManager.get('IDS_ISNOVALUE') : value;
  };
  
  return colorLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.2'},
[

],

function Setup() {

  var DrawUtil = {

  };

  /**
   *  props = {
   *    type: 
   *    rx:
   *    ry:
   *  }
   *  @return path "d" for D3 
   */
  DrawUtil.createMarkerData = function (props){
    // TODO Maybe we can use hashmap to cache here
    //if(symbolMap[props]) return symbolMap[props];
    var result;
    var temp = props.borderWidth / 2;
    switch(props.type)
    {
    case "circle" :
      result = "M" + (-props.rx - temp)  + ",0 A" + (props.rx + temp) + "," + (props.ry + temp) + " 0 1,0 " + (props.rx + temp) + ",0 A";
      result += (props.rx + temp) + "," + (props.ry + temp) + " 0 1,0 " + (-props.rx -temp) + ",0z";
      break;
    case "cross" :
      result = "M" + (-props.rx - temp) + "," + (-props.ry/3 - temp) + "H" + (-props.rx/3  - temp) + "V" + (-props.ry - temp)+ "H" + (props.rx/3 +temp);
      result += "V" + (-props.ry/3 - temp) + "H" + (props.rx + temp) + "V" + (props.ry/3 + temp) + "H" + (props.rx/3 + temp);
      result += "V" + (props.ry +temp) + "H" + (-props.rx/3 - temp) + "V" + (props.ry/3 + temp) + "H" + (-props.rx -temp) + "Z";
      break;
    case "diamond" :
      result = "M0," + (-props.ry -temp)  + "L" + (props.rx + temp) + ",0" + " 0," + (props.ry + temp) + " " + (-props.rx -temp) + ",0" + "Z";
      break;
    case "square" :
      result = "M" + (-props.rx - temp) + "," + (-props.ry - temp) + "L" + (props.rx + temp) + ",";
      result += (-props.ry - temp) + "L" + (props.rx + temp) + "," + (props.ry + temp) + "L" + (-props.rx - temp) + "," + (props.ry + temp) + "Z";
      break;
    case "triangle-down" ://TODO: remove duplicate
    case "triangleDown" :
      result = "M0," + (props.ry + temp) + "L" + (props.rx + temp) + "," + -(props.ry + temp) + " " + -(props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "triangle-up" ://TODO: remove duplicate
    case "triangleUp" : 
      result =  "M0," + -(props.ry + temp) + "L" + (props.rx + temp) + "," + (props.ry + temp) + " " + -(props.rx + temp) + "," + (props.ry + temp) + "Z";
      break;
    case "triangle-left" ://TODO: remove duplicate
    case "triangleLeft" :
      result = "M" + -(props.rx + temp) + ",0L" + (props.rx + temp) + "," + (props.ry + temp) + " " + (props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "triangle-right" ://TODO: remove duplicate
    case "triangleRight" :
      result = "M" + (props.rx + temp) + ",0L" + -(props.rx + temp) + "," + (props.ry + temp) + " " + -(props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "intersection" :
      result = "M" + (props.rx + temp) + "," + (props.ry + temp) + "L" +  (props.rx/3 + temp) + ",0L" + (props.rx + temp) + "," + -(props.ry +temp) + "L";
      result += (props.rx / 2 - temp) + "," + -(props.ry + temp) + "L0," + (-props.ry/3 - temp) + "L" + (-props.rx / 2 + temp) + "," + -(props.ry + temp) + "L";
      result += -(props.rx + temp) + "," + -(props.ry +temp) + "L" + -(props.rx/3 + temp) + ",0L" + -(props.rx + temp) + "," + (props.ry + temp) + "L";
      result += (-props.rx/2 + temp) + "," + (props.ry + temp) + "L0," + (props.ry/3 + temp) + "L" + (props.rx/2 - temp) + "," + (props.ry + temp) + "Z";
      break;
    case 'squareWithRadius' : 
      var r = props.rx;
      var radius = r - 3;
      result = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r;
      result += "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
      break;
    }
    //symbolMap[props] = result;
    return result;

  };

  function getAnimationInitData(props)
  {
    var result;
    switch(props.type)
    {
    case "circle" :
      result = "M0,0A0,0 0 1,0 0,0A0,0 0 1,0 0,0z"; 
      break;
    case "cross" :
      result = "M0,0H0V0H0V0H0V0H0V0H0V0H0Z";
      break;
    case "diamond" :
      result = "M0,0L0,0 0,0 0,0Z";
      break;

    case "triangle-down" ://TODO: remove duplicate
    case "triangle-up" ://TODO: remove duplicate
    case "triangle-left" ://TODO: remove duplicate
    case "triangle-right" :  //TODO: remove duplicate
    case "triangleDown" :
    case "triangleUp" :
    case "triangleLeft" :
    case "triangleRight" :        
      result = "M0,0L0,0 0,0Z";
      break;
    case "intersection" :
      result = "M0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0Z";
      break;
    case 'squareWithRadius' : 
      result = "M0,0L0,0Q0,0 0,0L0,0Q0,0 0,0L0,0Q0,0 0,0L0,0Q0,0 0,0Z";
      break;  
    case "square" :
      result = "M0,0L0,0L0,0L0,0Z";
      break;
    default:
      result = "M0,0L0,0L0,0L0,0Z";
      break;
    }
    return result;
  }
  
  DrawUtil.createElements = function(d3Enter, props)
  {
    return d3Enter.append("path").attr("class", props.className);
  };
  
  DrawUtil.createElement = function(d3Parent, props, effectManager)
  {
    var d3Element = d3Parent.append("path").attr("class", props.className);
    props.node = d3Element;
    DrawUtil.drawGraph(props, effectManager);
    return d3Element;
  };

  /**
   * props = {
   *   node: current d3 svg element,
   *  graphType : marker type
   *  drawingEffect: drawingEffect
   *  direction : direction
   *   rx : size
   *  ry: size
   *  fillColor: color
   *  borderWidth:
   *  borderColor,
   *  visibility: "visible" or "hidden"
   *  animateTime: total time for animation in ms 
   *  strokeOpacity: opacity for border line
   *  endFunc: callback function, when animation complete, it will be called
   * }
   *  effectManager: current effectManager
   */
  DrawUtil.drawGraph =  function (props, effectManager)
  {
    var para = {
        type: props.graphType,
        rx:Math.round(props.rx),
        ry:Math.round(props.ry),
        borderWidth: props.borderWidth ? Math.round(props.borderWidth) : 0
    };
    var data = DrawUtil.createMarkerData(para);

    var tempOpacity;
    if (props.visibility === 'hidden') {
        tempOpacity = 0;
    } else {
        tempOpacity = 1;
    }
    var fillId = effectManager.register(props);
    props.node.attr("fill", fillId).attr("stroke-width", props.borderWidth).attr("stroke", props.borderColor)
       .attr("opacity", tempOpacity).attr("stroke-opacity", props.strokeOpacity);
    if(props.animateTime && props.animateTime > 0) {
      props.node.attr("d", getAnimationInitData(para));
      props.node.transition().duration(props.animateTime).attr("d", data).each('end', props.endFunc);
    } else {
      props.node.attr("d", data);
    }
    return  props.node;
  };
  
  return DrawUtil;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.colorLegendArea',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(TextRuler, dispatch, DrawUtil, ObjectUtils, UADetector) {
  var colorLegendArea = function(ctx){
    var width = 400, height = 200, valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '12px',
      'fontweight' : 'normal',
      'color' : '#333333'
    }, options = {
      isHierarchy : undefined,
      position : 'right',
      legendType : 'ColorLegend'
    }, colorLabelSize = 1, shapes = [], colors = [], colorFeedLength = 0, shapeFeedLength = 0, wrap,
    textHeight = 20,  selectedItem = [], isStyleChanged = true, selectionMode = 'multiple',
    markerMargin = {
        right : 0.5,
        bottom : 0.6,
        left : 1,
        top : 0
    }, pagingBtnInfo = {
        height : 1.6,
        markerHeight : 0.5,
        padding: 0.5,
        hasNext : true,
        hasPre : false
    }, relayout  = true;
    
    var style = {};
    var effectManager = null;

    var imageInfo =
    {
        imageMode: false,
        imagePalette: [],
        radio: 1
    };
    
    //alex su
    //These are two cursors to depict legend rows to be shown.
    var randomSuffix = ObjectUtils.guid();
    var startRow = 0, lastStartRow = 0;
    var endRow = Infinity;
    
    //Each row's position [{x: 10, y: 10}, {...}...]
    var rowPosArr = [], chartData = {}, isItemsOverflow, endItemNum, startItemNum = 0;
	var firstOverFlowPos;
    
    var chart = function(selection){
      selection.each(function(){
        getThemeStyleDef();
        
        //relayout for new smart layout
        var labelsData;
        if(relayout){
          isItemsOverflow =  false;
          _calculateRowPosition({width: width, height: height});
          labelsData = getLabelData();
        }else{
          labelsData = getLabelData();
          isItemsOverflow =  false;
          if(labelsData.length > 0 && labelsData.length < chartData.length){
            isItemsOverflow = true;
          }
          if(isItemsOverflow === true){
            _calculateRowPosition({width: width, height: height});
            labelsData = getLabelData(); 
          }
        }
        
        wrap = d3.select(this);
        
        //indicated item while hovering or clicking
        var indicatedItems = wrap.selectAll('rect.v-indicatedRect');
        if(indicatedItems.empty()){
          indicatedItems = wrap.append('rect').attr('class', 'v-indicatedRect v-hovershadow').attr('visibility', 'hidden');
        }
        var rectMargin = markerMargin.bottom * textHeight;
        indicatedItems.attr('width', width+10).attr('height', textHeight + rectMargin).attr('x', -5).attr('y', -rectMargin/2);
        
        var defaultValueLabelStyle = ctx.styleManager.queryDefault('v-label');
        wrap.attr('font-family', defaultValueLabelStyle['font-family']).attr('font-size', defaultValueLabelStyle['font-size']).attr('font-weight', defaultValueLabelStyle['font-weight']).attr('fill', defaultValueLabelStyle['fill']);
        //Create each row
        var gEnterRow = wrap.selectAll('g.v-row').data(labelsData, function(d, i){
          return d.val;
        });
        gEnterRow.exit().remove();
        
        var rectEnterRow = gEnterRow.enter().append('g');
        gEnterRow.attr('class', function(d, i) {
          return randomSuffix+' v-row ID_' + i;
        });  
        
        var i, j, len, jLen, rowWrap;
        if((options.legendType !== 'BubbleColorLegend') && options.isHierarchy && (!(options.position === 'top' || options.position === 'bottom'))) {
          //Legend with hierarchy
          var labelItem, rowItems, lastRowLabel = [], itemXPos = 0, itemYPos = 0;

          for(i = 0, len = labelsData.length; i < len; i++) {
            itemXPos = 0, itemYPos = 0;
            
            //'China / 2001 / Car - Profit' TO ['China', '2001', 'Car', 'Profit']
            labelItem = labelsData[i].val;
            labelItem = labelItem.replace('-', '/');
            rowItems = labelItem.split(' / ');
            rowWrap = d3.select(this).select("g.v-row.ID_" + i);
            //Create each row's sub elements.
            var isShowWholeItem = false;
            for(j = 0, jLen = rowItems.length - 1; j < jLen; j++) {
              if(lastRowLabel[j] !== rowItems[j]) {
                //Only with last label and color label
                isShowWholeItem = true;
                break;
              }
            }
            
            var t = rowWrap.selectAll('g').data(rowItems);
            t.enter().append('g').attr('class', function(d, i) {
              return randomSuffix+' v-label ID_' + i;
            });

            for(j = 0, jLen = rowItems.length; j < jLen; j++) {
              var gWrap;
              if(j === jLen - 1) {
                //With legend marker
                gWrap = createRowWithColorLabel(rowWrap.select('g.v-label.ID_'+j), i, true, rowItems[j]);
                gWrap.attr('transform', function(d, index) {
                  itemXPos = 10 * j;
                  if(isShowWholeItem){
                    itemYPos = textHeight + itemYPos + markerMargin.bottom * textHeight;                    
                  }
                  return 'translate(' + itemXPos + ',' + itemYPos + ')';
                });
              } else {
                if(isShowWholeItem) {
                  //No legend marker
                  gWrap = createRowWithColorLabel(rowWrap.select('g.v-label.ID_'+j), i, false, rowItems[j]);
                  gWrap.attr('transform', function(d, index) {
                    itemXPos = 10 * j;
                    if(j > 0){
                      itemYPos = textHeight + itemYPos + markerMargin.bottom * textHeight;
                    }
                    return 'translate(' + itemXPos + ',' + itemYPos + ')';
                  });
                }
              }
              if(gWrap){
                gWrap.attr('visibility', function(d, index){
                  var visible = 'visible';
                  if((rowPosArr[i] === undefined) || (rowPosArr[i].y + itemYPos > height - 2 * textHeight)){
                    visible = 'hidden';
                    isItemsOverflow = true;
                    if(firstOverFlowPos === undefined){
                      if(rowPosArr[i]!== undefined){
                        firstOverFlowPos = rowPosArr[i].y + itemYPos + textHeight;
                      }else{
                        firstOverFlowPos = rowPosArr[rowPosArr.length - 1].y + itemYPos + 2 * textHeight;
                      }
                    }
                  }
                  return visible;
                });
              }
              lastRowLabel[j] = rowItems[j];
            }
          }
          
          gEnterRow.attr('transform', function(d, i){
            if(rowPosArr[i]){
              return 'translate('+ rowPosArr[i].x + ',' + rowPosArr[i].y + ')';
            }
          });
        } else {
          //Create each row
          for(i = 0, len = labelsData.length; i < len; i++) {
            rowWrap = d3.select(this).selectAll("g.v-row.ID_" + i);
            createRowWithColorLabel(rowWrap, i + startItemNum, true, labelsData[i].val);
          }

          //Each row position
          gEnterRow.attr('transform', function(d, i) {
            if(d.pos){
              return 'translate(' + d.pos.x + ',' + d.pos.y + ')';
            }
          });
        }
        
        //Add 'rect' element to handle click event.
        rectEnterRow.append('rect').attr('class', 'v-eventRect');
        gEnterRow.each(function(d, i){
          d3.select(this).selectAll('rect.v-eventRect').attr('class', function(){
            return randomSuffix + ' v-eventRect ID_' +i;
          });
        });
        var eventItems = wrap.selectAll('rect.v-eventRect').data(labelsData, function(d, i){
          return d.val;
        });
        eventItems.attr('height', textHeight).attr('fill', 'rgba(255, 255, 255, 0)');
        if(options.position === 'top' || options.position === 'bottom') {
          //markerSize = Color_Marker_Size + Right_Margin + Left_Margin
          var markerSize = (colorLabelSize + markerMargin.right) * textHeight + markerMargin.left * textHeight / 2;
          eventItems.attr('width', function(d){
            return (d.size === undefined) ? width : (d.size.width + markerSize);
          });          
        }else{
          eventItems.attr('width', width);
        }
        
        d3.select(this).selectAll('text.v-itemsEllipsis').attr('visibility', 'hidden');
        var btnWrapper;
        if(isItemsOverflow && labelsData.length > 0){
          if((!options.isHierarchy) && (options.position === 'left' || options.position === 'right')){
          //Add pre/next button
            var pagingBtnHeight = pagingBtnInfo.height * textHeight; 
            var pagingMarkerHeight = pagingBtnInfo.markerHeight * textHeight;
            var preWrapper, nextWrapper, nextPosY;
            btnWrapper = d3.select(this).selectAll('g.v-pagination-buttons');
            if(btnWrapper.empty()){
              btnWrapper = d3.select(this).append('g').attr('class', 'v-pagination-buttons');
              
              //Pre Button Group
              preWrapper = btnWrapper.append('g').attr('class', 'v-preWrapper');
              preWrapper.append('rect').attr('class', 'v-preBtn').attr('width', width + 10).attr('height', pagingBtnHeight).attr('x', -5).attr('y', 0).attr('fill','rgba(0,0,0,0)');
              
              preWrapper.append('text').attr('class', 'v-preText').attr('text-anchor', 'end');
              preWrapper.append('path').attr('class', 'v-prePath');
              
              //Next Button Group
              nextWrapper = btnWrapper.append('g').attr('class', 'v-nextWrapper');
              nextWrapper.append('rect').attr('class', 'v-nextBtn').attr('width', width + 10).attr('height', pagingBtnHeight).attr('x', -5).attr('fill','rgba(0,0,0,0)');
              
              nextWrapper.append('text').attr('class', 'v-nextText').attr('text-anchor', 'end');
              nextWrapper.append('path').attr('class', 'v-nextPath');
            }
            
            //Update pre/next status
            btnWrapper.selectAll('g.v-preWrapper').attr('visibility', function(){
              return (pagingBtnInfo.hasPre === true) ? 'visible' : 'hidden';
            });
            nextPosY = labelsData[labelsData.length - 1].pos.y + textHeight + pagingBtnInfo.padding * textHeight;
            btnWrapper.selectAll('g.v-nextWrapper').attr('transform', 'translate( '+ 0 + ', '+ nextPosY +')').attr('visibility', function(){
              return (pagingBtnInfo.hasNext === true) ? 'visible' : 'hidden';
            });
            btnWrapper.selectAll('text.v-preText').attr('x', width/2 - textHeight).attr('y', (pagingBtnHeight + textHeight)/2 - 2).text(function(){
              return "(" + startItemNum+") ";
            });
            btnWrapper.selectAll('text.v-nextText').attr('x', width/2 - textHeight).attr('y', (pagingBtnHeight + textHeight)/2 - 2).text(function(){
              return "(" + (chartData.length - endItemNum) + ") ";
            });
            btnWrapper.selectAll('path.v-prePath').attr('d', function(){
              return _generatePagingBtnPath(width / 2, pagingBtnHeight  / 2, pagingMarkerHeight, 'triangleUp');
            }).attr('fill', valueLabelFont['fill']);
            btnWrapper.selectAll('path.v-nextPath').attr('d', function(){
              return _generatePagingBtnPath(width / 2, pagingBtnHeight  / 2, pagingMarkerHeight, 'triangleDown');
            }).attr('fill', valueLabelFont['fill']);
          }else{
            btnWrapper = d3.select(this).selectAll('g.v-pagination-buttons');
            if(!btnWrapper.empty()){
              btnWrapper.remove();
            }
            //Much items ellipsis
            var itemsEllipsis = d3.select(this).selectAll('text.v-itemsEllipsis');
            if(itemsEllipsis.empty()){
              itemsEllipsis = d3.select(this).append('text').attr('class', 'v-itemsEllipsis').text('...')
                .attr('text-anchor', 'middle');
            }
            itemsEllipsis.attr('visibility', function(){
              var visible = 'hidden';
              if(isItemsOverflow){
                visible = 'visible';
              }
              return visible;
            });
            if (options.position === 'top' || options.position === 'bottom') {
              itemsEllipsis.attr('dy', height/2).attr('dx', function(){
                return (firstOverFlowPos === undefined) ? width : firstOverFlowPos;
              });
            }else{
              itemsEllipsis.attr('dx', width/2).attr('dy', function(){
                return (firstOverFlowPos === undefined) ? height : firstOverFlowPos;
              });
            }
          }
        }else{
          var btnsWrapper = d3.select(this).selectAll('g.v-pagination-buttons');
          if(!btnsWrapper.empty()){
            btnsWrapper.remove();
          }
        }
//        if (options.position === 'top' || options.position === 'bottom') {
//          d3.select('g.v-groups.v-label').attr('transform',function() {
//            return 'translate(' + (width - (firstOverFlowPos === undefined ? 0 : firstOverFlowPos)) / 2 + ',0)';
//          });
//        }
        if (UADetector.isMobile()) {
            d3.select(this).on('touchstart', itemClicked).on('touchend.color', blurHandler);
        } else {
        d3.select(this).on('mouseover', hoverHandler).on('mouseout', blurHandler)
          .on('mousedown', itemClicked).on('mouseup', hoverHandler);
        }
        
        relayout = false;
      });
    };
    
    chart.width = function(_) {
      if(!arguments.length){
        return width;
      }
      width = _;
      relayout = true;
      isItemsOverflow = false;
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length){
        return height;
      }
      height = _;
      relayout = true;
      isItemsOverflow = false;
      return chart;
    };
    
    chart.color = function(_) {
      if(!arguments.length){
        return colors;
      }
      colors = _;  
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length){
        return shapes;
      }
      shapes = _;
      return chart;
    };
    
    chart.colorFeedLength = function(_){
      colorFeedLength = _;
      return chart;
    };
    
    chart.shapeFeedLength = function(_){
      shapeFeedLength = _;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length){
        return chartData;
      }
      chartData = _;
      return chart;
    };

    chart.imageInfo = function(_) {
      if(!arguments.length){
        return imageInfo;
      }
      imageInfo = _;
      relayout = true;
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length){
        return options;
      }
      //TODO use extends...
      options = properties;
      return chart;
    };
    chart.hasData = function(){
     if( chartData && chartData.length > 0){
       return true;
     }else {
       return false;
       }
    };
    chart.getPreferredSize = function() {
      getThemeStyleDef();
      //TODO reset itemsCount which is used in overflow legend items
      startItemNum = 0;
      return _calculateRowPosition({width: width, height: height});
    };
    
    chart.doLayout = function(size){
      return size;
    };
    
    chart.setSelectionMode = function(_){
      selectionMode = _;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length){
        return effectManager;
      }
      effectManager = _;

      return chart;
    };

    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }

    var getLabelData = function(){
      var labelsData = [], start = startItemNum, len = endItemNum;
      if(chartData.length > 0){
        //Split items
        labelsData = chartData.slice(start, len);
        startRow = 0;
        endRow = len;
      }
      return labelsData;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = ctx.styleManager.query('v-label');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          if(valueLabelFont.fontsize !== valueLabelStyle['font-size']){
            isStyleChanged = true;
          }
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          if(valueLabelFont.fontweight !== valueLabelStyle['font-weight']){
            isStyleChanged = true;
          }
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    var hoverHandler = function(){
      var target = getCurrentEvent().target;
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');
      if(_isPagingEvent(target)){
        if(clickedItemClass.search('v-pre') === -1){
          d3.selectAll('.v-nextBtn').attr('class', 'v-nextBtn v-hovershadow').attr('fill', style.hovershadow.fill);
        }else{
          d3.selectAll('.v-preBtn').attr('class', 'v-preBtn v-hovershadow').attr('fill', style.hovershadow.fill);
        }
      }else{
        if(!_validateEvent(target)){
          return;
        }
      
        var indicatedItem = wrap.selectAll('.v-indicatedRect');
        var indicatedItemPos = _getIndicatedItemPosition(item);
        indicatedItem.attr('class', 'v-indicatedRect v-hovershadow').attr('fill', style.hovershadow.fill)
          .attr('y', indicatedItemPos.y).attr('visibility', 'visible');
        if(options.position === 'top' || options.position === 'bottom') {
          indicatedItem.attr('x', indicatedItemPos.x).attr('width', indicatedItemPos.width);
        }
      }
    };
    
    var blurHandler = function(){
      var target = getCurrentEvent().target;
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');
      if(_isPagingEvent(target)){
        if(clickedItemClass.search('v-pre') === -1){
          d3.selectAll('.v-nextBtn').attr('class', 'v-nextBtn').attr('fill', 'rgba(0, 0, 0 ,0)');
        }else{
          d3.selectAll('.v-preBtn').attr('class', 'v-preBtn').attr('fill', 'rgba(0, 0, 0 ,0)');
        }
      }else{
        if(!_validateEvent(target)){
          return;
        }
      
        var indicatedItem = wrap.selectAll('.v-indicatedRect');
        indicatedItem.attr('visibility', 'hidden');
      }
    };
    
    var itemClicked = function(){
      var target = getCurrentEvent().target;
      
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');

      if(!clickedItemClass){
        return;
      }
      
      if(clickedItemClass.search('v-pre') === -1 && clickedItemClass.search('v-next') === -1){
        var isValid = _validateEvent(target);
        if(isValid === false){
          return;
        }
        
        var indicatedItem = wrap.selectAll('.v-indicatedRect');
        var indicatedItemPos = _getIndicatedItemPosition(item);
        indicatedItem.attr('class', 'v-indicatedRect v-hovershadow-mousedown').attr('visibility', 'visible').attr('fill', '#808080').attr('y', indicatedItemPos.y);
        if(options.position === 'top' || options.position === 'bottom') {
          indicatedItem.attr('x', indicatedItemPos.x).attr('width', indicatedItemPos.width);
        }
      }else{
        //click on preBtn or nextBtn
        var paging = false;
        if(clickedItemClass.search('v-pre') === -1){
          //Next page
          //Current page's last item always be shown as the first item of next page.
          if(pagingBtnInfo.hasNext){
            lastStartRow = startItemNum;
            startItemNum = endItemNum;
            paging = true;
          }
          d3.selectAll('.v-nextBtn').attr('class', 'v-nextBtn v-hovershadow-mousedown').attr('fill', '#808080');
        }else{
          //Pre page
          if(pagingBtnInfo.hasPre){
            var eachRowHeight = textHeight + textHeight * markerMargin.bottom;
            var itemsCount = _calItemsCount(height-pagingBtnInfo.height*textHeight*2 , eachRowHeight);
            if(itemsCount === 0) {
              itemsCount = 1;
            }
            startItemNum = startItemNum - itemsCount;
//              startItemNum = lastStartRow;
            paging = true;
          }
          d3.selectAll('.v-preBtn').attr('class', 'v-preBtn v-hovershadow-mousedown').attr('fill', '#808080');
        }
        
        if(paging){
          startItemNum  = (startItemNum < 0) ? 0 : startItemNum;
          _calculateRowPosition({width: width, height: height});
          chart(d3.select(this));
        }
      }
    };
    
    chart.clickHandler = function(){
      var target = getCurrentEvent().target;
      var isValid = _validateEvent(target);
      if(isValid === false){
        return;
      }
   
      var isSelected = false;
      
      if(_contains(selectedItem, target)){
        //has been selected.
        isSelected = true;
      }else{
        //New selected item
        selectedItem.push(target);
      }
      return isSelected;
    };
    
    chart.deselectByCtx = function(deselectedData){
      if(!deselectedData){
        //deslected All items. Remove all selected legend items.
        selectedItem = [];
//        d3.selectAll('.indicatedRect').attr('fill', 'rgba(0,0,0,0)');
      }else{
        var itemData, isSame = true;
        for(var i = 0, len = selectedItem.length; i < len; i++){
          isSame = true;
          itemData = selectedItem[i].__data__.ctx.path;
          if(!itemData){
            itemData = selectedItem[i].__data__.ctx.ranges;
            if(itemData !== deselectedData.ctx.ranges){
              isSame = false;
            }
          }else{
            for(var k in itemData){
              if(deselectedData.ctx.path[k] !== undefined){
                if(deselectedData.ctx.path[k].length > 0){
                  if(deselectedData.ctx.path[k] !== itemData[k]){
                    isSame = false;
                  }
                }else{
                  if(deselectedData.ctx.path[k] !== itemData[k]){
                    isSame = false;
                  }
                }
              }
            }
          }
          
          if(isSame === true){
            //remove the deselected item.
            selectedItem.splice(i, 1);
            break;
          }
        }
      }
    };
    
    var _calItemsCount = function(size, itemSize){
      return Math.floor(size/itemSize);
    };
    
    var _validateEvent = function(target){
      var isValid = true;
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy){
        isValid = false;
      }
      
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');
      if(!clickedItemClass || clickedItemClass.search('eventRect') === -1){
        isValid = false;
      }
      
      return isValid;
    };
    
    var _isPagingEvent = function(target){
      var isValid = false;
      
      var item = d3.select(target);
      var clickedItemClass = item.attr('class');
      if(clickedItemClass && (clickedItemClass.search('v-pre') !== -1 || clickedItemClass.search('v-next') !== -1)){
        isValid = true;
      }
      return isValid;
    };
    
    var _getIndicatedItemPosition = function(item){
      var data = item.datum(); 
      var markerSize = (colorLabelSize + markerMargin.right) * textHeight + markerMargin.left * textHeight / 2;
      return {
        x : data.pos.x - 4,
        y : data.pos.y - markerMargin.bottom * textHeight / 2,
        width : data.size.width + markerSize
      };
    };
    
    //Utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    };
    
    /*
     * Calculate legend row position and return legend max size. 
     * return max and min size.
     */
    var _calculateRowPosition = function(wholeSize) {
      var maxHeight = 0, maxWidth = 0, minWidth = 0, minHeight = 0,
        maxRowTextSize = {'width':0, 'height':0}, 
        labelsData = chartData,
        maxRowWidth = 0;
      if(labelsData && labelsData.length > 0){
        var labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        textHeight = parseInt(valueLabelFont.fontsize, 10); //1em
        
        //markerSize = Color_Marker_Size + Right_Margin
        var markerSize = (colorLabelSize + markerMargin.right) * textHeight;
        
        var rowLabelSize = [], xPos = 0, yPos = 0; //each row text width
        
        rowPosArr = [];
        
        var i, j, len, jLen;
        //Measure labels size
        //If colors feed don't have MND, can't show legend in hierarchy.
        if((options.legendType !== 'BubbleColorLegend') && options.isHierarchy && (!(options.position === 'top' || options.position === 'bottom'))){
          //Measure hierarchy legend
          var labelItem, rowItems, rowItemSize, maxRowItemSize = {'width' : 0, 'height': 0}, lastRowLabel = [];
          for(i = 0, len = labelsData.length; i < len; i++) {
            //'China / 2001 / Car - Profit' TO ['China', '2001', 'Car', 'Profit']
            labelItem = labelsData[i].val;
            labelItem = labelItem.replace('-', '/');
            rowItems = labelItem.split(' / ');
            
            //Create each row's sub elements.
            var isShowWholeItem = false;
            for(j = 0, jLen = rowItems.length - 1; j < jLen; j++) {
              if(lastRowLabel[j] !== rowItems[j]) {
                //Only with last label and color label
                isShowWholeItem = true;
                break;
              }
            }
            
            //Calculate each row's max item size
            var itemHeight = 0;
            for(j = 0, jLen = rowItems.length; j < jLen; j++) {
              rowItemSize = TextRuler.measure(rowItems[j], labelFont);
              if(j === jLen - 1){
                rowItemSize.width = rowItemSize.width + markerSize;
                itemHeight = itemHeight + (markerMargin.bottom+1) * textHeight;
              }else if(isShowWholeItem){
                itemHeight = itemHeight + (markerMargin.bottom+1) * textHeight;
              }
              rowItemSize.width = rowItemSize.width + 10*j;
              if(rowItemSize.width > maxRowItemSize.width){
                maxRowItemSize = rowItemSize; 
              }
              lastRowLabel[j] = rowItems[j];
            }
            if(maxRowItemSize.width > maxRowWidth){
              maxRowWidth = maxRowItemSize.width;
            }
            rowLabelSize.push(itemHeight);
            
            //Calculate each row's position
            // if(options.position === 'left' || options.position === 'right') {
              if(i > 0){
                yPos = yPos + rowLabelSize[i-1];              
              }
              if(yPos + textHeight > wholeSize.height){
                isItemsOverflow = true;
                break;
              }
            // }else{
  //             
            // }
            rowPosArr.push({x: xPos, y: yPos});
            labelsData[i].pos = {x: xPos, y: yPos};
          }
          maxWidth = xPos + maxRowWidth;
          //maxHeight = yPos + rowLabelSize[rowLabelSize.length - 1];
          maxHeight = Infinity;
          
          minWidth = TextRuler.measure('M...', labelFont).width;
          minHeight = 2 * textHeight;
        }else{
          //No isHierarchy. Calculate each row's position
          if(options.position === 'top' || options.position === 'bottom'){
            //Horizontal Layout
            var nextXPos = xPos;
            endItemNum = labelsData.length;
            for(i = 0, len = labelsData.length; i < len; i++){             
              //Set X-Position
              if(i > 0){
                xPos = nextXPos;              
              }
              
              //Measure label text size.
              if((labelsData[i].size === undefined) || (isStyleChanged !== false)){
                labelsData[i].size = TextRuler.measure(labelsData[i].val, labelFont);
              }
              
              nextXPos = xPos + markerSize + labelsData[i].size.width + markerMargin.left * textHeight;
              if(nextXPos > wholeSize.width){
                endItemNum = i;
                isItemsOverflow = true;
                firstOverFlowPos = xPos;
                break;
              }
              labelsData[i].pos = {x: xPos, y: yPos};
//              rowPosArr.push({x: xPos, y: yPos});
            }
            
            if(isItemsOverflow){
              maxWidth =firstOverFlowPos+ TextRuler.measure('M...', labelFont).width;
			}else{
              maxWidth = xPos + markerSize + labelsData[endItemNum -1].size.width;
			}           
            maxHeight = yPos + textHeight;
            maxRowWidth = wholeSize.width;
          }else{
            //Vertical Layout
            var eachRowHeight = textHeight + textHeight * markerMargin.bottom, contentHeight = wholeSize.height;
            var pagingBtnHeight = (pagingBtnInfo.height + pagingBtnInfo.padding)* textHeight;
            endItemNum = labelsData.length;
            if(isItemsOverflow === true ){
//              yPos = yPos + pagingBtnInfo.height;
//              contentHeight = wholeSize.height - pagingBtnInfo.height;
              if(pagingBtnInfo.hasPre === true){
                //Add PRE button's height
                yPos = yPos + pagingBtnHeight;
//                contentHeight = contentHeight - pagingBtnHeight;
              }
//              if(pagingBtnInfo.hasNext === true){
//                contentHeight = contentHeight - pagingBtnHeight; 
//              }
            }
            for(i = startItemNum, len = labelsData.length; i < len; i++){
              // Initialize the maxRowTextSize
              if(maxRowTextSize.width === 0 && maxRowTextSize.height === 0){
                 maxRowTextSize= TextRuler.measure(labelsData[i].val, labelFont);
              }

              //Set Y-Position
              if(i > startItemNum){
                yPos = yPos + eachRowHeight;
              }
              if((yPos + textHeight > contentHeight) && (i < len)){
                endItemNum = i; //This index's label can't be shown.
                isItemsOverflow = true;
                
                pagingBtnInfo.hasNext = true;
                pagingBtnInfo.hasPre = true;
                
                if(yPos + pagingBtnHeight > contentHeight){
                  endItemNum = endItemNum - 1;
                }
                
                break;
              }
              //Measure label text size.
              if((labelsData[i].size === undefined) || (isStyleChanged !== false)){
                labelsData[i].size = TextRuler.measure(labelsData[i].val, labelFont);
              }
              labelsData[i].pos = {x: xPos, y: yPos};
//              rowPosArr.push({x: xPos, y: yPos});
              
              //Set max text length
              if(labelsData[i].size.width > maxRowTextSize.width){
                maxRowTextSize = labelsData[i].size;
              }
            }
            
            //Update hasNext and hasPre status
            if(yPos + eachRowHeight <= contentHeight || endItemNum === len){
              pagingBtnInfo.hasNext = false;
              pagingBtnInfo.hasPre = true;
            }
            if(startItemNum === 0){
              pagingBtnInfo.hasPre = false;
            }
            

            maxRowWidth = markerSize + maxRowTextSize.width;
            maxWidth = xPos + maxRowWidth;
            maxHeight = eachRowHeight * len;
            minHeight = pagingBtnHeight * 2 + textHeight;
            if(minHeight > maxHeight){
              minHeight = maxHeight;
            }
          }
          
          //Calculation final row text size.
          minWidth = xPos + markerSize + TextRuler.measure('M...', labelFont).width; 
        }
      }
      if(minWidth > maxWidth){
        minWidth = maxWidth;
      }
      if(isStyleChanged === true){
        isStyleChanged = false;
      }
      return {
        minHeight : minHeight,
        minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
    };
    
    var getImageURL = function(index)
    {
        var imageURL = "";

        var imageURLNumber = imageInfo.imagePalette.length;
        if(imageURLNumber > 0)
        {
            imageURL = imageInfo.imagePalette[index%imageURLNumber];
        }

        return imageURL;
    };
    
    var createRowWithColorLabel = function(wrap, index, isShowColorLabel, labelText) {
      var dx = 0, colorLabelType;
      var markerSize = colorLabelSize * textHeight;

      if(isShowColorLabel) {
        if(shapeFeedLength > 0){
          var shapeIndex = index % shapeFeedLength;
          if(shapes.length < shapeFeedLength){
            //less shape to be used
            shapeIndex = shapeIndex % shapes.length;
          }
          colorLabelType = shapes[shapeIndex];
        }else{
          if(options.legendType === 'BubbleColorLegend'){
            colorLabelType = (shapes[0] === undefined) ? 'square' : shapes[0];
          }else{
            var tmpShape = shapes[index % shapes.length];
            colorLabelType = (tmpShape === undefined) ? 'square' : tmpShape;
            if(colorLabelType === 'square'){
              colorLabelType = "squareWithRadius";
            }
          }
        }
        
        if(!imageInfo.imageMode)
        {
            var centerPos = textHeight / 2; 
            var path = wrap.selectAll('path').data([labelText]);
            DrawUtil.createElements(path.enter(),{shape: colorLabelType, className: null} );
            path.attr("transform", function(d,i)
            {
              var color;
              if(shapeFeedLength > 0) {
                i = Math.floor(index / shapeFeedLength);
                var t = colors.length > colorFeedLength ? colorFeedLength : colors.length;
                if(t > 0){
                  color = colors[i % t];
                }else{
                  color = colors[0];
                }
              } else {
                color = colors[index % (colors.length > colorFeedLength ? colorFeedLength : colors.length)];
              }
              var parameter = {
                  drawingEffect:options.drawingEffect,
                  graphType:colorLabelType,
                  fillColor : color,
                  direction : 'vertical',
                  rx: markerSize / 2,
                  ry: markerSize / 2,
                  borderWidth: 0,
                  borderColor: "transparent",
                  node:d3.select(this)
    //              visibility: "visible"
              };
              DrawUtil.drawGraph(parameter, effectManager);
              return 'translate(' + centerPos + ',' + centerPos + ')';
          
            });
        }
        else
        {
            var imageObjs = wrap.select("image");
            if(imageObjs.empty())
            {
                imageObjs = wrap.append("image");
            }

            imageObjs.attr("xlink:xlink:href", getImageURL(index))
                .attr("width",markerSize)
                .attr("height",markerSize);
        }
        
        dx = markerSize + markerMargin.right * textHeight;
      }
      // item text label
      var text = wrap.selectAll('text').data([labelText]);
      text.enter().append('text');
      text.attr('x', dx).attr('y', textHeight).text(function(d) {
          return d;
        });
      
      var labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
      text.each(function(d) {
        TextRuler.ellipsis(d, this, width-dx, labelFont);
      });
      return wrap;
    };

    var _generatePagingBtnPath = function(x, y, height, type){
      var w = (7*height) / 8;
      var h = height / 2;
      var path = "";
      if(type === 'triangleUp'){
        path = 'M ' + x + " " + (y - h) + " L " + (x + w) + " " + (y + h) + " L " + (x - w) + " "+ (y + h);
      }else{
        path = 'M ' + (x - w) + " " + (y - h) + " L " + (x + w) + " " + (y - h) + " L " + x + " " + (y + h);
      }
      return path;
    };
    
    function getCSSStyle() {
        style.hovershadow = ctx.styleManager.queryDefault('v-hovershadow');
    }
    getCSSStyle();
    return chart;
  };
    
  return colorLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.common',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.legend.colorLegendArea',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.legend.sizeLegendArea',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.legend.mbcLegendArea',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.TapGestureDetector',
  version : '4.0.2'
}
],
function Setup(Manifest, TextRuler, TypeUtils, dispatch, ObjectUtils,
               ColorLegendArea, SizeLegendArea, MBCLegendArea, langManager,Objects,
               BoundUtil, UADetector, TapGestureDetector) 
{
  var legend = function(manifest, ctx) {
    var imageInfo =
    {
        imageMode: false,
        imagePalette: [],
        radio: 1
    };

    var width = 0, 
        height = 0, 
        preferenceSize = { width : 0, height : 0}, 
        position = 'right', 
        titleFont = {
          fontfamily : "'Open Sans', Arial, Helvetica, sans-serif",
          fontsize : '14px',
          fontweight : 'bold',
          color : '#333333'
        }, valueLabelFont = {
        'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '12px',
      'fontweight' : 'normal',
      'color' : '#333333'
    },options = {}, isVisible = true, isHidden = false, shapes = [], colors = [], textHeight = 20, 
    margin = {
      top : 0,
      right : 0,
      bottom : 0,
      left : 0
    }, titleMarginBottom = 0.5, legendAreaPos = {x:0, y:0}, sizeScale, sizeBubbleScale, sizeBubbleSpace, sizeBubbleHasHeightFeed, colorScale, hideTitle = false;
    
    //Each row's position [{x: 10, y: 10}, {...}...]
    var chartData = {title:'', labels:''}, bubleSizeData = [], data = null, shapeFeeds = [], colorFeeds = [], colorFeedLength = 0, shapeFeedLength = 0, relayout = true;
    var legendArea = ColorLegendArea(ctx);
    var eDispatch = new dispatch('highlightedByLegend');
    var effectManager = ctx.effectManager;
    var eventManager = ctx.eventManager;
    var properties;
    var isHierarchicalChanged = false;
    var oTapGestureDetector;
    var gEnterCol;
    
    var chart = function ( selection ) {
      BoundUtil.drawBound(selection, width, height);
      
      selection.each(function() {
        if ( isColorLegend() || isBubbleColorLegend() ) {
          if ( chartData.labels.length === 0 ) {
            isVisible = false;
          }
        }
        
        if ( isVisible && !isHidden && _isSizeAcceptable()) {
          getThemeStyleDef();
          
          if ( relayout ) {
            _calculateRowPosition({'width': width, 'height' : height});
          }

          var xPos = margin.left * textHeight, yPos = margin.top * textHeight;
          
          var wrap = d3.select(this).selectAll('g.v-content').data([chartData]);
          wrap.enter().append('g').attr('class', 'v-content');//.attr('clip-path', 'url(#legend-edge-clip)');
          if ( isHierarchicalChanged ) {
            isHierarchicalChanged = false;
            wrap.selectAll('.v-row').remove();
          }
          //Legend Title
          if ( options.isShowTitle && !hideTitle ) {
            var titleTextHeight = parseInt(titleFont.fontsize, 10);
            var titleStyle = 'font-weight: ' + titleFont.fontweight +'; fill:' + titleFont.color + '; font-family: ' + titleFont.fontfamily + '; font-size: '+titleFont.fontsize+";";
            var titleLabel = (options.titleText===undefined || options.titleText === null) ? chartData.title : options.titleText;
            
            var labelTitleElement = wrap.selectAll('text.v-title');
            if ( labelTitleElement.empty() ) {
              labelTitleElement = wrap.append('text').attr('class', 'v-title viz-legend-title');
            }
            var defalutTitleFont = ctx.styleManager.queryDefault('v-title');
            labelTitleElement.text(titleLabel).attr('dx', xPos).attr('dy', yPos + titleTextHeight).attr('visibility', 'visible')
              .attr('font-weight', defalutTitleFont['font-weight']).attr('fill', defalutTitleFont['fill']).attr('font-family', defalutTitleFont['font-family']).attr('font-size', defalutTitleFont['font-size']);
            
            //Show ... in title 
            labelTitleElement.each(function(d) {
              TextRuler.ellipsis(titleLabel, this, width-xPos, titleStyle);
            });
          } else {
            wrap.selectAll('text.v-title').attr('visibility', 'hidden');
            if ( hideTitle ) {
                hideTitle = false;
            } 
          }
  
          var labelsData = chartData.labels;
          // Create Legend Groups
          gEnterCol = wrap.selectAll('g.v-groups').data([labelsData]);
          gEnterCol.enter().append('g').attr('class', 'v-groups v-label viz-legend-valueLabel');
          gEnterCol.attr('transform', 'translate('+legendAreaPos.x+','+legendAreaPos.y+')');
  
          var tmpWidth = ( !width ? preferenceSize.width : width) - xPos;
          var tmpHeight = ( !height ? preferenceSize.height : height) - yPos;
          
          //TODO Need to handle legend in the top/bottom side.
          legendArea.properties(options).width(tmpWidth).height(tmpHeight-legendAreaPos.y).effectManager(effectManager);
          if ( isSizeLegend() ) {
            legendArea.data(bubleSizeData).scale(sizeScale);
          } else if ( isMeasureBasedColoringLegend() ) {
            legendArea.data(labelsData).color(colorScale.range());
          } else {
            legendArea.imageInfo(imageInfo);
            legendArea.data(labelsData).color(colors).colorFeedLength(colorFeedLength).shapeFeedLength(shapeFeedLength);
          }
          var temp = gEnterCol.call(legendArea);
          //Bind click handler in legend labels
          if (UADetector.isMobile()) {
            if(oTapGestureDetector === undefined){
                oTapGestureDetector = new TapGestureDetector();
                oTapGestureDetector.addGestureAction(mobileClickHandler);
                oTapGestureDetector.enable(true);

                eventManager.addGestureDetector(oTapGestureDetector);
            }
          } else {
            temp.on('click', clickHandler);
          }
          
          //Vertical align to center
          if ( options.position === 'left' || options.position === 'right' ) {
            switch(options.alignment){
              case 'end':
                wrap.attr('transform', 'translate(0, '+(((height-preferenceSize.height) > 0) ? ((height-preferenceSize.height)) : 0)+')');
                break;
              case 'middle':
                wrap.attr('transform', 'translate(0, '+(((height-preferenceSize.height)/2 > 0) ? ((height-preferenceSize.height)/2) : 0)+')');
                break;
            }
          } else {
            d3.select(this).selectAll('g.v-content').attr('transform','translate('+(width-preferenceSize.width)/2+','+'0)');
          }
        } else {
          //Handle visible is false.
          var elements = d3.select(this).selectAll('g.v-content');
          if (!elements.empty()) {
              elements.remove();
          }
//          var clipPathWrap = d3.select(this).select('#legend-edge-clip');
//          if(!clipPathWrap.empty()){
//            clipPathWrap.remove();
//          }
        }
        isHidden = false;
      });
    };

    function getCurrentEvent() {
      if ( d3.event ) {
        return d3.event;
      } else {
        return window.event;
      }
    }
    function mobileClickHandler(data) {
        if (!isValid(getCurrentEvent())) {
            return;
        }
        return clickHandler(data);
    }

    function clickHandler (data) {
      if(options.isHierarchy) {
        return;
      }
      var target = getCurrentEvent().target;
      var className = d3.select(target).attr('class');
      //TODO Use class name to check clicked item. Color legend and mbc legend use the same class name.
      if(className && className.search('v-preBtn') === -1 && className.search('v-nextBtn') === -1){
        var isSelected = legendArea.clickHandler();
        var selectedData = d3.select(target).data()[0];
        if(selectedData !== undefined){
          eDispatch.highlightedByLegend(selectedData, isSelected);
        }
//        var index = parseInt(d3.select(d3.event.target).attr('class').split('ID_')[1], 10);
//        if(chartData.labels[index] !== undefined){
//          eDispatch.highlightedByLegend(chartData.labels[index], isSelected);
//        }
      }
    }

    function isInLegendContent(node) {
        var result = false;
        if(node.tagName === 'svg'){
            return false;
        }else{
            if(node === gEnterCol.node()){
                return true;
            }
            result = isInLegendContent(node.parentNode);
        }
        return result;
    }

    function isValid (event) {
        return isInLegendContent(event.target);
    }
    chart.deselectLegend = function(deselectedData){
      //TODO MBC support legend interaction.
      if(!(isMeasureBasedColoringLegend() || isSizeLegend())){
        legendArea.deselectByCtx(deselectedData);
      }
    };
    
    chart.width = function(_) {
      if(!arguments.length){
        return width;
      }
      width = _;
      legendArea.width(_);
      relayout = true;
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length){
        return height;
      }
      height = _;
      legendArea.height(_);
      relayout = true;
      return chart;
    };

    chart.imageInfo = function(_) {
      if(!arguments.length){
        return imageInfo;
      }
      imageInfo = _;
      relayout = true;
      return chart;
    };

    chart.position = function(_) {
      if(!arguments.length){
        return position;
      }
      position = _;
      return chart;
    };

    chart.colorPalette = function(_) {
      if(!arguments.length){
        return colors;
      }
      colors = _;  
      legendArea.color(_);
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length){
        return shapes;
      }
      shapes = _;
      legendArea.shapes(_);
      return chart;
    };

    chart.properties = function(props) {
      if(!arguments.length){
        return properties;
      }
      //TODO use extends...
      if (properties && props && properties.isHierarchical !== props.isHierarchical){
        isHierarchicalChanged = true;
      }
      Objects.extend(true, properties, props);
      options.visible = properties.visible;
      isVisible = options.visible;
      options.isShowTitle = properties.title.visible;
      options.titleText = properties.title.text;
      options.isHierarchy = properties.isHierarchical;
      options.position = properties.position;
     
      options.formatString = properties.formatString;
      
      if(options.legendType !== properties.type){
        options.legendType = properties.type;
        if(data && chartData.labels){
          parseFeedsData(data);
          legendArea.data(chartData.labels);
        }
      }
      options.alignment = properties.alignment;
      options.drawingEffect = properties.drawingEffect;
      
      if(isSizeLegend()){
        legendArea = SizeLegendArea(ctx);
        
      }else if (isMeasureBasedColoringLegend()){
        legendArea = MBCLegendArea(ctx);
      }
      legendArea.properties(options);
      return chart;
    };

    chart.getPreferredSize = function () {
      getThemeStyleDef();
      return _calculateRowPosition();
    };
    
    chart.data = function(_) {
      if(!arguments.length){
        return data;
      }
      data = _;
      parseFeedsData(_);
      legendArea.data(chartData.labels);
      return chart;
    };
    
    chart.sizeLegendInfo = function(_){
      if(!arguments.length){
        return sizeScale;
      }
      //Size scale
      sizeScale = _.scale;
      legendArea.scale(sizeScale);
      
      sizeBubbleScale = _.bubbleScale;
      
      sizeBubbleSpace = _.space;
      
      sizeBubbleHasHeightFeed = _.hasHeightFeed;
      
      //Size data
      if(_.data.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
        bubleSizeData = _.data;
        legendArea.data(bubleSizeData);
      }
      
      //Size legend title
      chartData.title = handleNull(_.title);
      
      return chart;
    };
    
    chart.hideTitle = function() {
        hideTitle = true;
        return hideTitle;
    },
    
    chart.hide = function(_) {
        isHidden = _;
        return chart;
    },
    
    /*
     * Measure based coloring
     */
    chart.mbcLegendInfo = function(_){
      if(!arguments.length){
        return colorScale;
      }
      if(_.colorScale === undefined){
        isVisible = false;
      }else{
        isVisible = options.visible;
        colorScale = _.colorScale;
        //Legend title
        chartData.title = handleNull(_.title);
        _parseMeasureBasedColoringLegend();
        legendArea.data(chartData.labels);
      }
      return chart;
    };
    
    chart.setSelectionMode = function(_){
      if(!(isMeasureBasedColoringLegend() || isSizeLegend())){
        legendArea.setSelectionMode(_);
      }
    };
    
    /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return chart;
      };
    
      //alex su
      chart.isVisible = function(){
        return isVisible;
      };
      
    var getThemeStyleDef = function(){
      var titleStyle = ctx.styleManager.query('v-title');
      if(titleStyle){
        if(titleStyle['fill']){
          titleFont.color = titleStyle['fill'];
        }
        if(titleStyle['font-family']){
          titleFont.fontfamily = titleStyle['font-family'];
        }
        if(titleStyle['font-size']){
          titleFont.fontsize = titleStyle['font-size'];
        }
        if(titleStyle['font-weight']){
          titleFont.fontweight = titleStyle['font-weight'];
        }
      }
      
      var valueLabelStyle = ctx.styleManager.query('v-label');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    var buildColorShapeFeeds = function(feed){
      if(isColorFeeds(feed.key)) {
        colorFeeds = feed.values;
      } else {
        if(isShapeFeeds(feed.key)) {
          shapeFeeds = feed.values;
        }
      }
    };
    
    var parseFeedsData = function(data) {
      if(!data){
        return;
      }
      colorFeeds = [];
      shapeFeeds = [];
      var aa = data.getAnalysisAxisDataByIdx(0);
      if(aa){ 
        colorFeeds = aa.values;
      }
      
      aa = data.getAnalysisAxisDataByIdx(1);
      if(aa){
        shapeFeeds = aa.values;
      }
      
      if(isBubbleColorLegend()){
        _parseBubbleColorLegendFeeds();
      }else if(!(isSizeLegend())){
        _parseColorLegendFeeds();
      }
    };
    
    var _parseMeasureBasedColoringLegend = function(){
      var labels = [], item = {
        'val' : undefined,
        'ctx' : {}
      };
      var mbcDomains = colorScale.domain();
      for(var len = mbcDomains.length, i = 0, j = len-1; i < len; i++){
        if(mbcDomains[i].length > 0){
//          item.val = '[ ' + mbcDomains[i][0] + ' ; ' + mbcDomains[i][1] + ( i===len-1 ? ' ]' : ' [');
          item.val = mbcDomains[i][0];
          item.ctx.ranges = {
            startValue : mbcDomains[i][0],
            endValue : mbcDomains[i][1],
            isRightOpen : true,
            isLeftOpen : false
          };
        }else{
          item.val = 'N/A';
          item.ctx.ranges = {};
          if(labels[j+1] !== undefined){
            labels[j+1].ctx.ranges.isRightOpen = false;
          }
        }
        if(j === 0){
          item.ctx.ranges.isRightOpen = false;
        }
        labels[j] = {};
        ObjectUtils.extend(true, labels[j--], item);
      }
      
      chartData.labels = labels;
    };
    
    var _parseBubbleColorLegendFeeds = function(){
      var labels = [], title ='', tmpVal = '', i, j = 0, len, tmpLabel={
        'val' : undefined,
        'ctx' : {
          'path' : {}
        }
      }, dii;
      colorFeedLength = 0, shapeFeedLength = 0;
      
      if(colorFeeds && colorFeeds.length > 0 && colorFeeds[0].rows.length > 0){
        var firstColorFeed = colorFeeds[0];
        title = handleNull(firstColorFeed.col.val);
        
        dii = 'dii_a'+(firstColorFeed.rows[0].ctx.path.aa+1);
        tmpLabel = {
          'val' : firstColorFeed.rows[0].val,
          'ctx' : {
            'path' : { }
          },
          'info' : firstColorFeed.rows[0].info
        };
        tmpLabel.ctx.path[dii] = [firstColorFeed.rows[0].ctx.path.dii];
        
        for(i = 1, len = firstColorFeed.rows.length; i < len; i++){
          tmpVal = firstColorFeed.rows[i].val;
          if(tmpVal === tmpLabel.val || _containsVal(labels, tmpVal)){
            tmpLabel.ctx.path[dii].push(firstColorFeed.rows[i].ctx.path.dii);
          }else{
            labels[j] = {};
            tmpLabel.val = resolveCustomLabel(tmpLabel);
            ObjectUtils.extend(true, labels[j++], tmpLabel);
            //New color label. Add it to uniqueColorLabel and assign its new color
            tmpLabel.val = tmpVal;
            tmpLabel.ctx = {
              path : { }
            };
            tmpLabel.ctx.path[dii] = [firstColorFeed.rows[i].ctx.path.dii];
          }
        }
        //Add the last one
        labels[j] = {};
        tmpLabel.val = resolveCustomLabel(tmpLabel);
        ObjectUtils.extend(true, labels[j], tmpLabel);
        
        colorFeedLength = labels.length;
      }
      
      if(shapeFeeds && shapeFeeds.length > 0) {
        var firstShapeFeed = shapeFeeds[0], shapeLabels=[];
        title = (title === '') ? handleNull(firstShapeFeed.col.val) : title + " / " + handleNull(firstShapeFeed.col.val);
        
        dii = 'dii_a'+(firstShapeFeed.rows[0].ctx.path.aa+1);
        tmpLabel = {
          'val' : firstShapeFeed.rows[0].val,
          'ctx' : {
            'path' : {}
          },
          'info' : firstShapeFeed.rows[0].info
        }, j = 0;
        tmpLabel.ctx.path[dii] = [firstShapeFeed.rows[0].ctx.path.dii];
        
        for(i = 1, len = firstShapeFeed.rows.length; i < len; i++){
          tmpVal = firstShapeFeed.rows[i].val;
          if(tmpVal === tmpLabel.val || _containsVal(shapeLabels, tmpVal)){
            tmpLabel.ctx.path[dii].push(firstShapeFeed.rows[i].ctx.path.dii);
          }else{
            shapeLabels[j] = {};
            tmpLabel.val = resolveCustomLabel(tmpLabel);
            ObjectUtils.extend(true, shapeLabels[j++], tmpLabel);
            //New shape label. Add it to uniqueColorLabel and assign its new color
            tmpLabel.val = tmpVal;
            tmpLabel.ctx = {
              path : {}
            };
            tmpLabel.ctx.path[dii] = [firstShapeFeed.rows[i].ctx.path.dii];
          }
        }
        //Add the last one
        shapeLabels[j] = {};
        tmpLabel.val = resolveCustomLabel(tmpLabel);
        ObjectUtils.extend(true, shapeLabels[j], tmpLabel);

        shapeFeedLength = shapeLabels.length;
        if(labels.length > 0){
          labels = getCartesian([labels, shapeLabels], ' / ');
        }else{
          labels = shapeLabels;
        }
      }
      
      if(labels.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
      }
       
      chartData = {
        'title' : title,
        'labels' : labels
      };
    };
    
    var _parseColorLegendFeeds = function(){
      var title, labels = [];
      var colorData = _parseLegendFeed(title, colorFeeds, colorFeedLength);
      colorFeedLength = colorData.feedsLength;
      var shapeData = _parseLegendFeed(title, shapeFeeds, shapeFeedLength);
      shapeFeedLength = shapeData.feedsLength;
      
      //Color and Shape Cartesian
      if(shapeData.labels.length > 0){
        if(colorData.labels.length > 0){
          if(colorData.MNDInfo.MNDIndex === undefined && shapeData.MNDInfo.MNDIndex === undefined){
            //Has color and shape feed and no MND. So use '/'
            labels = getCartesian([colorData.labels, shapeData.labels], ' / ');
            title = colorData.title + " / " + shapeData.title;
          }else {
            if((colorData.MNDInfo.MNDIndex !== undefined && !colorData.MNDInfo.hasOnlyMND) || (shapeData.MNDInfo.MNDIndex !== undefined && !shapeData.MNDInfo.hasOnlyMND)){
              labels = getCartesian([colorData.labels, shapeData.labels], ' - ');
              title = colorData.title + " - " + shapeData.title;
            } else if (colorData.MNDInfo.MNDIndex !== undefined && colorData.MNDInfo.hasOnlyMND){
              labels = shapeData.labels;
              title = shapeData.title;
            } else {
              labels = colorData.labels;
              title = colorData.title;
            }
              
          } 
        }else{
          labels = shapeData.labels;
          title = shapeData.title;
        }
      }else{
        labels = colorData.labels;
        title = colorData.title;
      }

      if(labels.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
      }
      chartData = {
        'title' : title,
        'labels' : labels
      };
    };
    
    var _parseLegendFeed = function(title, feeds, feedsLength){
      var labels = [], rows = [], dimensionTag = ' / ', measureTag = ' - ';
      var MNDIndex, hasOnlyMND = false, i, j, len;
      //Handle colors feeds
      if(feeds && feeds.length > 0){
        for(i = 0, len = feeds.length; i < len; i++) {
          if(feeds[i].type !== 'MND') {
            if(title === undefined) {
              title = handleNull(feeds[i].col.val);
            } else {
              title = title + dimensionTag + handleNull(feeds[i].col.val);
            }
            
            rows = feeds[i].rows;
            for(j = 0; j < rows.length; j++) {
              if(labels[j] === undefined) {
                labels[j] = {};
                labels[j].val = resolveCustomLabel(rows[j]);
                if (rows[j].dataTransformInfo && rows[j].dataTransformInfo.autoBinning) {
                  labels[j].val += ('(' + rows[j].dataTransformInfo.autoBinning.othersNum + ')');
                }
                labels[j].ctx = {
                  path : _setPathByaa(rows[j].ctx.path)
                };
              } else {
                if (rows[j].val !== '') {
                  labels[j].val = labels[j].val + dimensionTag + resolveCustomLabel(rows[j]);
                }
              }
            }
          } else {
            MNDIndex = i;
          }
        }
        feedsLength = labels.length;
      }
      
      //Handle Colors with MND
      if(MNDIndex !== undefined) {
        //Save color feed with MND status.
        if(labels.length > 0){
          if(feeds[MNDIndex].rows.length > 1){
            if(MNDIndex === 0) {
              title = langManager.get('IDS_DEFAULTMND') + measureTag + title; 
              //MND is the first feed type. Legend label should be 'MND - A/B/C'
              labels = getCartesian([handleNullInArray(feeds[MNDIndex].rows), labels], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } else if(MNDIndex === feeds.length - 1) {
              title = title + measureTag + langManager.get('IDS_DEFAULTMND');
              //MND is the last feed type. Legend label should be 'A/B/C - MND'
              labels = getCartesian([labels, handleNullInArray(feeds[MNDIndex].rows)], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } 
          }
        }else{
          title = langManager.get('IDS_DEFAULTMND');
          rows = feeds[MNDIndex].rows;
          for(j = 0; j < rows.length; j++) {
            labels[j] = {};
            labels[j].val = resolveCustomLabel(rows[j]);
            labels[j].ctx = rows[j].ctx;
          }
          feedsLength = rows.length;
          if(rows.length === 1){
            hasOnlyMND = true;
          }
        }
      }
      
      return {
        'title' : title,
        'labels' : labels,
        'feedsLength' : feedsLength,
        'MNDInfo' : {
          'MNDIndex' : MNDIndex,
          'hasOnlyMND': hasOnlyMND //Only has MND, no cartesian
        }
      };
    };
    
    var _setPathByaa = function(path){
      var pathObj = {};
      switch(path.aa){
        case 0:
          pathObj.dii_a1 = path.dii;
          break;
        case 1:
          pathObj.dii_a2 = path.dii;
          break;
        case 2:
          pathObj.dii_a3 = path.dii;
          break;
      }
      return pathObj;
    };
    
    // Calculate legend row position and return legend max size.
    var _calculateRowPosition = function () {
      var maxHeight = 0, 
          maxWidth = 0, 
          minWidth = 0, 
          minHeight = 0, 
          titleSize = { width : 0, height : 0 }, 
          legendAreaSize = {};
          
      var labelFont, xPos, yPos;

      if ( isVisible && legendArea.hasData()) {
        labelFont = "font-size:" + titleFont.fontsize + 
                  "; font-weight:" + titleFont.fontweight + 
                  "; font-family:" + titleFont.fontfamily;
                  
        textHeight = parseInt(valueLabelFont.fontsize, 10); //1em
        xPos = margin.left * textHeight, yPos = margin.top * textHeight;
        var startYPos = yPos;
        
        // Measure title size
        if ( options.isShowTitle && 
           ( ( typeof options.titleText !== 'undefined' && options.titleText !== null) || 
             (typeof chartData.title !== 'undefined' && chartData.title !== null ))) 
        {
          titleSize = TextRuler.measure( 
            typeof options.titleText === 'undefined' || options.titleText === null ? 
            chartData.title : options.titleText, labelFont);
            
//          if ( !hideTitle ) {
            yPos = yPos + titleSize.height + titleMarginBottom * textHeight;
//          }
        }
        
        // Legend Area Position
        legendAreaPos = { x : xPos, y: yPos};
        
        // TODO [Christy | 2013/2/26] change return value's name. width,height to maxWidth,maxHeight
        legendAreaSize = legendArea.getPreferredSize();
        
        // Calculate legend's max and min size with title
        if ( options.position === 'top' || options.position === 'bottom' ) {
          maxWidth = xPos + legendAreaSize.width;
          maxHeight = titleSize.height + titleMarginBottom * textHeight + legendAreaSize.height;
          
          minWidth = xPos + legendAreaSize.minWidth;
          minHeight = startYPos + legendAreaSize.minHeight;
        }else{
          maxWidth = xPos + ((titleSize.width > legendAreaSize.width) ? titleSize.width : legendAreaSize.width);
          maxHeight = yPos + legendAreaSize.height;
          
          minWidth = xPos + legendAreaSize.minWidth;
          minHeight = startYPos + legendAreaSize.minHeight;
        }
        
        //Smart layout legend title 
        if(options.isShowTitle){
          var relLegendAreaSize = {
              width : width - xPos,
              height : height - yPos
          };
          if (relLegendAreaSize.height < legendAreaSize.minHeight) {
            // Hide legend title if it's shown.
            hideTitle = true;
            legendAreaPos = { x : xPos, y: startYPos};
          }else{
            hideTitle = false;
          }
        }
        /*
        if ( width === 0 || height === 0 ) {
          // initial status
          // TODO Not be sure about this statements.
          preferenceSize = {
              width : maxWidth,
              height : maxHeight
          };
        } else if ( width < minWidth || height < minHeight ) {
          // TODO Too small. 
          preferenceSize = {
              width : 0,
              height : 0
          };
        } else if ( width > maxWidth && height > maxHeight){
          // Enough
          preferenceSize = {
              width : maxWidth,
              height : maxHeight
          };
        } else {
          var relLegendAreaSize = {
              width : width - xPos,
              height : height - yPos
          };
          var tmpWidth, tmpHeight;
          if ( (relLegendAreaSize.height < legendAreaSize.minHeight) && options.isShowTitle ) {
            // Hide legend title if it's shown.
            hideTitle = true;
            yPos = startYPos;
            titleSize = {width: 0, height: 0};
            relLegendAreaSize.height = height - startYPos;
            relayout = true;
          }
          var actualSize = legendArea.doLayout(relLegendAreaSize);
          if ( options.position === 'top' || options.position === 'bottom' ) {
            tmpWidth = xPos + actualSize.width;
            tmpHeight = titleSize.height + titleMarginBottom * textHeight + actualSize.height;
          } else {
            tmpWidth = xPos + ((titleSize.width > actualSize.width) ? titleSize.width : actualSize.width);
            tmpHeight = yPos + actualSize.height;
          }
          // TODO not good
          if ( tmpWidth > maxWidth ) {
            tmpWidth = maxWidth;
          }
          if ( tmpHeight > maxHeight ) {
            tmpHeight = maxHeight;
          }
          
          preferenceSize = {
            width : tmpWidth,
            height : tmpHeight
          };
        }*/
      }

      preferenceSize = {
          width : maxWidth,
          height : maxHeight,
          maxWidth : maxWidth,
          maxHeight : maxHeight,
          minWidth : minWidth,
          minHeight : minHeight
      };
      return preferenceSize;
    };
    
    var _containsVal = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i].val === obj) {
                return true;
            }
        }
        return false;
    };
    
    var getCartesian = function(arrays, symbol) {
      var result = arrays[0];
      var fff = function(arr) {
        var ar = result;
        result = [];
        for(var i = 0; i < ar.length; i++) {
          for(var j = 0; j < arr.length; j++) {
            var t1 = (ar[i].val === undefined) ? ar[i].val : ar[i].val, t2 = (arr[j].val === undefined) ? arr[j].val : arr[j].val;
            var ctx = {
              path : {}
            };
            ObjectUtils.extend(ctx.path, ar[i].ctx.path, arr[j].ctx.path);
            result.push({
              'val': t1 + symbol + t2, 
              'ctx': ctx
            });
          }
        }
      };
      for(var i = 1; i < arrays.length; i++) {
        fff(arrays[i]);
      }

      return result;
    };
    
    var isColorFeeds = function(feedName){
      var result = false;
//      if(Manifest.feeds[feedName].semantic === 'COLOR'){
//        result = true;
//      }
      if(feedName.search('color') !== -1){
        result = true;
      }
      return result;
    };
    
    var isShapeFeeds = function(feedName){
      var result = false;
//      if(Manifest.feeds[feedName].semantic === 'SHAPE'){
//        result = true;
//      }
      if(feedName.search('shape') !== -1){
        result = true;
      }
      return result;
    };
    
    var isColorLegend = function(){
      var result = false;
      if(options.legendType === 'ColorLegend'){
        result = true;
      }
      return result;  
    };
    
    var isSizeLegend = function(){
      var result = false;
      if(options.legendType === 'SizeLegend'){
        result = true;
      }
      return result;  
    };
    
    var isBubbleColorLegend = function(){
      var result = false;
      if(options.legendType === 'BubbleColorLegend'){
        result = true;
      }
      return result;  
    };
    
    var isMeasureBasedColoringLegend = function(){
      var result = false;
      if(options.legendType === 'MeasureBasedColoringLegend'){
        result = true;
      }
      return result;  
    };
    
    var _isSizeAcceptable = function(){
      return (width > 0 && height > 0);
    };
    
    //alex su
    var handleNull = function(_){
      var defaultString = langManager.get('IDS_ISNOVALUE');
      if (_ === null || _ === undefined){
        return defaultString;
      }
      else{ 
        return _;
      }
    };
    
    var resolveCustomLabel = function(rawObj){
      var ret;
      if(rawObj.info){
        var clobj = rawObj.info.customlabel;
        if(clobj){
          if(clobj.type === 'url'){
            //Jimmy/12/27/2012 do we still need the orginal value in legend here?
            ret = rawObj.val;
          }else if(clobj.type === 'string'){
            ret = clobj.val;
          }
        }else{
          ret = rawObj.val;
        }
      }else{
        ret = rawObj.val;
      }
      ret = handleNull(ret);
      return ret;  
    };
    
    var handleNullInArray = function(array){
      for (var i = 0; i < array.length; ++i){
        array[i].val = handleNull(array[i].val);
      }
      return array;
    };
    
//    var handleNullInArray = function(array){
//      var newArray = cloneObject(array);
//      for (var i = 0; i < newArray.length; ++i)
//        newArray[i].val = handleNull(newArray[i].val);
//      return newArray;
//    };
//    
//    var cloneObject = function(object){
//
//          if(typeof(object)!='object') return object;
//          if(object==null) return object;
//          
//          var o=Object.prototype.toString.call(object)==='[object Array]'?[]:{};
//
//          for(var i in object){
//                  if(typeof object[i] === 'object'  ){
//                          o[i]=cloneObject(object[i]);
//                  }else o[i]=object[i];
//          }
//          
//          return o;
//    };
    
    properties = manifest.props(null);
    chart.properties(null);
    return chart;
  };
  return legend;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.legend.Common',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.legend.common',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.legend.common',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'common legend',
    'description': 'The legend is a box containing a symbol and name for each series item or point item in the chart.',
    'properties' : {
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of legend.'
      },
      'title' : {
        'name' : 'title',
      'description' : 'Settings for legend title.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set visibility of legend title.'
           }, 
          'text':{
            'name' : 'text',
            'supportedValueType' : 'String',
            'defaultValue' : null,
            'description' : 'Set text of legend title.'
           }
        }
      },
      'formatString': {
        'name' : 'formatString',
        'supportedValueType': 'String',
        'defaultValue' : null,
        'description' : 'Set format string of legend.',
        'isExported': false
      },
      'isHierarchical' : {
        'name' : 'isHierarchical',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set hierarchy legend. Supported only when legend is located in the right of chart.',
        'isExported': true
      },
      'position' : {
        'name' : 'position',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'right', 'left'],
        'defaultValue' : 'right',
        'description' : 'Set legend position. Only support legend is located in the right side.',
        'isExported' : true
      },
      'type' : {
        'name' : 'type',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'ColorLegend', 'BubbleColorLegend', 'SizeLegend', 'MeasureBasedColoringLegend' ],
        'defaultValue' : 'ColorLegend',
        'description' : 'Set legend type of Bubble chart. Non-bubble chart is not supported.',
        'isExported' : false
      },
      'alignment' : {
        'name' : 'alignment',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'start', 'middle', 'end' ],
          'defaultValue' : 'start',
          'description' : 'Set alignment of legend.',
          'isExported' : false
      },
      'drawingEffect':{
        'name' : 'drawingEffect',
         'supportedValueType' : 'List',
          'supportedValues' : [ 'normal', 'glossy' ],
          'defaultValue' : 'normal',
          'description' : 'Set drawing effect of legend.',
          'isExported' : true
      }
    },
    'css' : {
      '.viz-legend-title.v-title' : {
        'description' : 'Define style for the legend title.',
        'value' : {
          'fill' : '#000000',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'bold'
        }
      },
      '.viz-legend-valueLabel.v-label' : {
        'description' : 'Define style for the legend label.',
        'value' : {
          'fill' : '#000000',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      },
        '.v-hovershadow' : {
            'description' : 'Define style for hovershadow in legend.',
              'value' : {
                'fill' : '#cccccc'
              }
        }
    },
    'configure' : null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.layout.Dock',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.layout.dock',
  version : '4.0.2'
}
],
function Setup ( Manifest, Constants, fn ) {
  var module = {
    id : "sap.viz.modules.layout.dock",
    type : Constants.Module.Type.Scientific.Layout,
    name : "dock",
    description : "The dock layout algorithm",
    properties : {},
    configure : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.datalabel',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
}
],
function Setup(TextUtils, TypeUtils, formatManager, Manifest,Objects, Dispatch){
    var dataLabel = function(manifest, ctx){
      var fontSize = '12px', fontColor = '#333333', fontFamily = '"Open Sans" Arial, Helvetica, sans-serif', fontWeight = 'normal';
      var properties = manifest.props(null);
      var dataLabel,                      // labels of each datashapesgroup
          dataLabels,                     // all labels, it must be two-dimension array
          originalLabels;                 // used for smartLayout, it must be one-dimension array
      var gPlot, parentNodeBBox;
      var labelStyle;
      var _SVGRoot;
      var _dispatch = new Dispatch("initialized");
      
      /*
       * Properties that needed for different charts.
       * Data label is designed as a general module, but different charts do have different requirements. Most of these properties are used for this reason.
       */
      var labelOrientation = 'horizontal',  // label can be horizontal or vertical
          orientation,                      // chart orientation, it is used during smart layout. if it is vertical, the move is from middle to top or bottom; if it is horizontal, the move is from middle to left or right.
          paintingMode,                     // the kind of coordinate system
          visible,                          // show or hide data label
          position,                         // data label can be inside or outside
          automaticInOutside,               // if the data label is longer than its owner element, move label out of it.
          formatString, isPercentMode, isStackMode, showZero, outsideVisible, outsidePosition, positionPreference,
          isGeoChart,     
          type;                             // label type, for now, two types, 1, value 2 label and value
      var isDonut = false;
      var heatMapLabelFontColor = '#ffffff', isHeatMap = false, isOneCategoryHeatmap = false, padding = 2, isTreeMap = false, treeMapLabelFontColor = '#ffffff';

      function label (){}
      
      label.removeLabel = function(){
        if(TypeUtils.isExist( gPlot.parent())){
          gPlot.parent().selectAll('g.v-m-datalabel').remove();
        }
      };
      
      /**
       * [08-Jan-2012 Nick]
       */
      label.showLabel = function(){
        if(visible && gPlot.parent()){
          getCSSSetting();
          gPlot.parent().selectAll('g.v-m-datalabel').remove();
          if (!isGeoChart) {
            parentNodeBBox = gPlot.parent().select('.v-bound')[0][0].getBoundingClientRect();//gPlot.parent().node().getBoundingClientRect();
          } else {
            parentNodeBBox = gPlot.parent().node().getBoundingClientRect();
          }
          prepareLabel();
          if(dataLabel.length === 0){
            _dispatch.initialized();
            return;
          }

          labelStyle = 'fill:' + fontColor + '; font-family: ' + fontFamily + '; font-weight: ' + fontWeight +'; font-size: '+ fontSize +"; text-anchor:start";
          var datashapesgroups = gPlot.parent().selectAll('.v-datashapesgroup');
              datashapesgroups.each(function(d,i){
                var labelGroup = d3.select(this).selectAll('g.v-m-datalabel').data([dataLabels[i]]);
                    labelGroup = labelGroup.enter().append('g').attr('class','v-m-datalabel').append('g').attr('class','v-datalabel');
                    ctx.styleManager.query('v-datalabel').toAttrs(labelGroup);
					if (isHeatMap) {
                      labelGroup.attr('fill',heatMapLabelFontColor);
                    } else if (isTreeMap) {
                      labelGroup.attr('fill',treeMapLabelFontColor);
                    }
                  
                    labelGroup.each(function(labels, index){
                      var dLabel = d3.select(this).selectAll('text').data(labels);
                      var text = dLabel.enter().append('g')
                                   .attr('transform',function(label){
                                       return label.transformString;
                                   });
                      text.each(function(d, i){
                        //we can also find main shape through data
                        var currd = gPlot.parent().selectAll('.v-datapoint').data()[i];
                        //register decoration to main shape
                        if(TypeUtils.isExist(currd.decoras)){
                          currd.decoras.push(this);
                        }
                      });
                      text = text.append('text');
                      text.text(function(d) {
                        return d.value;
                      });
                      text.attr('visibility', 'hidden');
                      
                      text.attr('x', function(d){
                            return d.x;
                          })
                          .attr('y', function (d) {
                            return d.y;
                          });
                   
                      if(labelOrientation === 'vertical'){
                        text.attr('transform',function(d){
                          return 'rotate(270 '+d.centerX + ',' + d.centerY + ')';
                        });
                      }
                      
                    });
              });
              smartLayout();
        }
        _dispatch.initialized();
      };
      
      function smartLayout() {
        var gElements = gPlot.parent().selectAll('.v-datalabel text')[0];//gPlot.parent().selectAll('rect.viz-event-sub-layer')[0][0].getBoundingClientRect();
        var labels = [], label, plotArea = {};
        var i;
        for (i = 0; i < gElements.length; i++) {
          label = {};
          var elementBBox = gElements[i].getBoundingClientRect();
          label.top = elementBBox.top; 
          label.left = elementBBox.left; 
          label.right = elementBBox.right; 
          label.bottom = elementBBox.bottom; 
          label.visible = true;
          label.needMove = false;
          label.x = 0;
          label.y = 0;
          labels.push(label);
        }
        
        plotArea.top = parentNodeBBox.top;
        plotArea.left = parentNodeBBox.left;
        plotArea.right = parentNodeBBox.right;
        plotArea.bottom = parentNodeBBox.bottom;
        
        automaticLayout(originalLabels, labels, plotArea);
        removeUnqualifiedLabels(labels, plotArea);
        
        for (i = 0; i < labels.length; i++) {
          if (labels[i].visible) {
            if (labels[i].needMove) {
              gElements[i].setAttribute('x', labels[i].x);
              gElements[i].setAttribute('y', labels[i].y);
            }
            gElements[i].setAttribute('visibility', 'visible');
          } else {
            gElements[i].parentNode.parentNode.removeChild(gElements[i].parentNode);
          }
        }
      }
      
      function getCSSSetting() {
        var dataLabelStyle = ctx.styleManager.query('v-datalabel');
        if(dataLabelStyle){
          if(dataLabelStyle['fill']){
            fontColor = dataLabelStyle['fill'];
          }
          if(dataLabelStyle['font-family']){
            fontFamily = dataLabelStyle['font-family'];
          }
          if(dataLabelStyle['font-size']){
            fontSize = dataLabelStyle['font-size'];
          }
          if(dataLabelStyle['font-weight']){
            fontWeight = dataLabelStyle['font-weight'];
          }
//          labelStyle = 'fill:' + fontColor + '; font-family: ' + fontFamily + '; font-size: '+ fontSize +";";
        }
      }
      
      function formatDataLabel(value,dataPoint){
        if(TypeUtils.isExist(formatString)){
          var formatedValue, iFormatString, indexOfiFS, indexOfctx;
          //for bubble ,val is an array , datalebel will display y .so just format the y value.
          if(TypeUtils.isArray(dataPoint.__data__.val)){
            indexOfctx = isGeoChart ?  0 : 1;
            iFormatString = formatString[0];
            indexOfiFS = dataPoint.__data__.ctx[indexOfctx].path.mg >= iFormatString.length ? iFormatString.length -1 : dataPoint.__data__.ctx[indexOfctx].path.mg;
            formatedValue = formatManager.format(value, iFormatString[indexOfiFS]);
          }else{
            iFormatString = formatString[dataPoint.__data__.ctx.path.mg];
            //if this array is null of undefined, we will use default value
            if(TypeUtils.isExist(iFormatString)){
              indexOfiFS = dataPoint.__data__.ctx.path.mi >= iFormatString.length ? iFormatString.length -1 : dataPoint.__data__.ctx.path.mi;
              formatedValue = formatManager.format(value, iFormatString[indexOfiFS]);
            }else{
              formatedValue = value;
            }
          }
          return formatedValue;
        }
        return value;
      }

      
      
      var automaticLayout = function(srcLabels, desLabels, plotArea) {
        
        if (srcLabels !== null && desLabels !== null) {
          for (var i = 0; i < srcLabels.length; i++) {
            if (i < desLabels.length) {
              if (!isStackMode && !isPercentMode && automaticInOutside  && orientation === 'horizontal') {
                if (showZero && srcLabels[i].value === 0 && !isGeoChart) {
                  var bbox1 = srcLabels[i].datapointRect;
                  desLabels[i].needMove = true;
                  desLabels[i].x = srcLabels[i].outsideX;
                  desLabels[i].y = srcLabels[i].outsideY;
                  desLabels[i].left = bbox1.right;
                  desLabels[i].right = bbox1.right + srcLabels[i].width;
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    desLabels[i].visible = false;
                  }
                } else if (position === 'inside') {
                  if (srcLabels[i].width > srcLabels[i].ownerWidth || isCrossBorder(desLabels[i], plotArea)) {
                    desLabels[i].needMove = true;
                    desLabels[i].x = srcLabels[i].outsideX;
                    desLabels[i].y = srcLabels[i].outsideY;
                    var boundingBox1 = srcLabels[i].datapointRect; 
                    if (srcLabels[i].value > 0) {
                      desLabels[i].left = boundingBox1.left + srcLabels[i].ownerWidth;
                      desLabels[i].right = boundingBox1.right + srcLabels[i].width;
                    } else {
                      desLabels[i].left =  boundingBox1.left - srcLabels[i].width;
                      desLabels[i].right = boundingBox1.right - srcLabels[i].ownerWidth;
                    }
                  }
                  
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    desLabels[i].visible = false;
                  }
                } else if (position === 'outside') {
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    if (srcLabels[i].width <= srcLabels[i].ownerWidth) {
                      desLabels[i].needMove = true;
                      desLabels[i].x = srcLabels[i].insideX;
                      desLabels[i].y = srcLabels[i].insideY;
                      var boundingBox2 = srcLabels[i].datapointRect;
                      if (srcLabels[i].value > 0) {
                        desLabels[i].left = boundingBox2.left + (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                        desLabels[i].right = boundingBox2.right - (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;                      
                      } else {
                        desLabels[i].left = boundingBox2.left + (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                        desLabels[i].right = boundingBox2.right - (srcLabels[i].ownerWidth - srcLabels[i].width) / 2;
                      }
                      
                      if (isCrossBorder(desLabels[i], plotArea)) {
                        desLabels[i].visible = false;
                      }
                    } else {
                      desLabels[i].visible = false;
                    }
                  }
                }
              } else if (!isStackMode && !isPercentMode && automaticInOutside && orientation === 'vertical') {
                if (showZero && srcLabels[i].value === 0 && !isGeoChart) {
                  desLabels[i].needMove = true;
                  desLabels[i].x = srcLabels[i].outsideX;
                  desLabels[i].y = srcLabels[i].outsideY;  
                  var bbox2 = srcLabels[i].datapointRect;
                  desLabels[i].top = bbox2.top + srcLabels[i].height;
                  desLabels[i].bottom = bbox2.top;
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    desLabels[i].visible = false;
                  }
                } else if (position === 'inside') {
                  if (srcLabels[i].height > srcLabels[i].ownerHeight || isCrossBorder(desLabels[i], plotArea)) {
                    desLabels[i].needMove = true;
                    desLabels[i].x = srcLabels[i].outsideX;
                    desLabels[i].y = srcLabels[i].outsideY;
                    var boundingBox3 = srcLabels[i].datapointRect;
                    if (srcLabels[i].value >= 0) {
                      desLabels[i].top =  boundingBox3.top - srcLabels[i].height;
                      desLabels[i].bottom =  boundingBox3.bottom - srcLabels[i].ownerHeight;   
                    } else {
                      desLabels[i].top = boundingBox3.top + srcLabels[i].ownerHeight;
                      desLabels[i].bottom = boundingBox3.bottom + srcLabels[i].height;               
                    }
                  }
                  
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    desLabels[i].visible = false;
                  }
                } else if (position === 'outside') {
                  if (isCrossBorder(desLabels[i], plotArea)) {
                    if (srcLabels[i].height <= srcLabels[i].ownerHeight) {
                      desLabels[i].needMove = true;
                      desLabels[i].x = srcLabels[i].insideX;
                      desLabels[i].y = srcLabels[i].insideY;   
                      var boundingBox4 = srcLabels[i].datapointRect;
                      if (srcLabels[i].value > 0) {
                        desLabels[i].top = boundingBox4.top + (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;
                        desLabels[i].bottom =  boundingBox4.bottom - (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;                      
                      } else {
                        desLabels[i].top = boundingBox4.top + (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;
                        desLabels[i].bottom =  boundingBox4.bottom - (srcLabels[i].ownerHeight - srcLabels[i].height) / 2;                     
                      }               
                      if (isCrossBorder(desLabels[i], plotArea)) {
                        desLabels[i].visible = false;
                      }
                    } else {
                      desLabels[i].visible = false;
                    }
                  }
                }
              } else if (!isStackMode && !isPercentMode && !automaticInOutside) {
                if (orientation === 'horizontal') {
                  if (showZero && srcLabels[i].value === 0 && !isGeoChart && srcLabels[i].width === 0) {
                    var bbox3 = srcLabels[i].datapointRect;
                    desLabels[i].left = bbox3.right;
                    desLabels[i].right = bbox3.right + srcLabels[i].width;
                  } else if (!outsideVisible && srcLabels[i].width > srcLabels[i].ownerWidth) {
                    desLabels[i].visible = false;
                  }
                  
                } else if (orientation === 'vertical') {
                  if (showZero && srcLabels[i].value === 0 && !isGeoChart && srcLabels[i].height === 0) {
                    var bbox4 = srcLabels[i].datapointRect;
                    desLabels[i].top = bbox4.top + srcLabels[i].height;
                    desLabels[i].bottom = bbox4.top;
                  } else if (!outsideVisible) {
                    if (isHeatMap || isTreeMap) {
                      if (isOneCategoryHeatmap || isTreeMap) {
                        if (srcLabels[i].height > srcLabels[i].ownerHeight/2) {
                          desLabels[i].visible = false;
                        }
                      } else {
                        if (srcLabels[i].height > srcLabels[i].ownerHeight) {
                          desLabels[i].visible = false;
                        }
                      }
                      
                      if (srcLabels[i].width > srcLabels[i].ownerWidth) {
                        desLabels[i].visible = false;
                      }
                    } else if (srcLabels[i].height > srcLabels[i].ownerHeight) {
                      desLabels[i].visible = false;
                    }
                  }
                }
                
                if (showZero && srcLabels[i].value === 0 && position === 'inside' && !isGeoChart) {
                  desLabels[i].needMove = true;
                  desLabels[i].x = srcLabels[i].outsideX;
                  desLabels[i].y = srcLabels[i].outsideY;
                } else if (!showZero && srcLabels[i].value === 0) {
                  desLabels[i].visible = false;
                }
 
                if (isCrossBorder(desLabels[i], plotArea)) {
                  desLabels[i].visible = false;
                }
                
              } else if (isStackMode) {
                if (orientation === 'horizontal') {
                  if (isCrossBorder(desLabels[i], plotArea) || (srcLabels[i].width > srcLabels[i].ownerWidth)) {
                    desLabels[i].visible = false;
                  }
                } else if (orientation === 'vertical') {
                  if (isCrossBorder(desLabels[i], plotArea) || (srcLabels[i].height > srcLabels[i].ownerHeight)) {
                    desLabels[i].visible = false;
                  }
                }
                if (!isPercentMode && srcLabels[i].value === 0) {
                  desLabels[i].visible = false;
                }
              } else if (isPercentMode) {
                if (isCrossBorder(desLabels[i], plotArea)) {
                  desLabels[i].visible = false;
                }
              }
            }
          }
          resetFlags();
        }
      };

      var resetFlags = function() {
        isHeatMap = false;
        isOneCategoryHeatmap = false;
        isTreeMap = false;
      };
      
      var parseOptions = function(props){
        orientation = TypeUtils.isExist(props.orientation) ? props.orientation : orientation;
        paintingMode = TypeUtils.isExist(props.paintingMode) ? props.paintingMode : paintingMode;
        visible = TypeUtils.isExist(props.visible) ? props.visible : visible;
        position = TypeUtils.isExist(props.position) ? props.position : position;
        automaticInOutside = TypeUtils.isExist(props.automaticInOutside) ? props.automaticInOutside : automaticInOutside;
        formatString = TypeUtils.isExist(props.formatString) ? props.formatString : formatString;
        isPercentMode = TypeUtils.isExist(props.isPercentMode) ? props.isPercentMode : isPercentMode;
        isStackMode = TypeUtils.isExist(props.isStackMode) ? props.isStackMode : isStackMode;
        isDonut = TypeUtils.isExist(props.isDonut) ? props.isDonut : isDonut;
        showZero = TypeUtils.isExist(props.showZero) ? props.showZero : showZero;
        outsideVisible = TypeUtils.isExist(props.outsideVisible) ? props.outsideVisible : outsideVisible;
        outsidePosition = TypeUtils.isExist(props.outsidePosition) ? props.outsidePosition : outsidePosition;
        isGeoChart = TypeUtils.isExist(props.isGeoChart) ? props.isGeoChart : isGeoChart;
        positionPreference = TypeUtils.isExist(props.positionPreference) ? props.positionPreference : positionPreference;
        type = TypeUtils.isExist(props.type) ? props.type : type;
      };
      
      //get customlabel text from from the rawObj, if the type is url, return the original text
      var getCustomlabelText = function(rawObj){
        var ret;
        if(rawObj.info){
          var clobj = rawObj.info.customlabel;
          if(clobj){
            if(clobj.type === 'url'){
              ret = rawObj.val;
            }else if(clobj.type === 'string'){
              ret = clobj.val;
            }
          }else{
            ret = rawObj.val;
          }
        }else{
          ret = rawObj.val;
        }
        return ret;
      };
      
      var prepareLabel = function(){
        _SVGRoot = gPlot.parent()[0][0].ownerSVGElement;
        dataLabel = [], dataLabels = [], originalLabels = [];
        if( _SVGRoot !== null && _SVGRoot.getBBox().width === 0){
          return;
        }
        var i = 0, j = 0, label, plotOffset, tempElement;
        var datashapeOffset, labelSize, percentageValue;
        
        var boundarySelection = gPlot.parent().selectAll('.v-datashapesgroup');
        if(boundarySelection[0].length === 0){
          boundarySelection = gPlot.parent();
        }
        var gElements = boundarySelection.selectAll('.v-datapoint');
        
        if(paintingMode === 'polarCoordinate'){
          for( i = 0 ; i < boundarySelection[0].length; i++){
            var polarBoundaryBox = boundarySelection[0][i].getBBox();
            if (polarBoundaryBox.width === 0 || polarBoundaryBox.height === 0) {
              break;
            }
            plotOffset = boundarySelection[0][i].getTransformToElement(_SVGRoot);
            dataLabel = [];
            for( j = 0 ; j < gElements[i].length; j++){
              label = {};
              tempElement = gElements[i][j];
              datashapeOffset = tempElement.getTransformToElement(_SVGRoot);
              /**
               *  [07-Jan-2012 Nick] 
               *  FIX FOR IE, in some cases, datashapesOffset is null here.
               *  So if it is null, the logic should jump out of here.
               */
              if(!TypeUtils.isExist(datashapeOffset)){
                  break;
              }
              label.dataShape = tempElement;
              var dimensions = '';
              percentageValue = (tempElement.__data__.endAngle - tempElement.__data__.startAngle) / ( 2 * Math.PI);
              percentageValue = formatDataLabel(percentageValue, tempElement);
              /*
               * [18-Dec-2012 Nick] Combine measures and dimensions into one label. (for pie only)
               */
              if(type === 'label and value'){
                var dimensionObjects = tempElement.__data__.dimValueObjects;
                for(var k=0; k < dimensionObjects.length; k++){
                  var subText = getCustomlabelText(dimensionObjects[k]);
                  dimensions += (subText === null? 'No value' : subText);
                  if (dimensionObjects[k].dataTransformInfo && dimensionObjects[k].dataTransformInfo.autoBinning) {
                    break;
                  }
                  if(k !== (dimensionObjects.length - 1)){
                    dimensions += '/';
                  }
                }  
              }
              label.value = dimensions + ' (' + percentageValue + ')';
              
              label.transformString = ('translate(' + (datashapeOffset.e - plotOffset.e) + ',' + (datashapeOffset.f - plotOffset.f) + ')' );

              labelSize = TextUtils.fastMeasure(label.value, fontSize, fontWeight, fontFamily);
              var r = tempElement.__data__.r;           
              var mAngle = (tempElement.__data__.endAngle + tempElement.__data__.startAngle)/ 2;        
              var sinLabelAngle = Math.sin(mAngle);
              var cosLabelAngle = Math.cos(mAngle);
            
              var labelCenterX, labelCenterY;
            
              if(isDonut){
                labelCenterX = 0.65 * r * sinLabelAngle;
                labelCenterY = 0.65 * r * cosLabelAngle;
              }else{
                labelCenterX = 0.5 * r * sinLabelAngle;
                labelCenterY = 0.5 * r * cosLabelAngle;
              }
            
              label.x = 0 + labelCenterX * datashapeOffset.a - labelSize.width/2;
              label.y = 0 - labelCenterY * datashapeOffset.d + labelSize.height/2;
              label.centerX = labelCenterX;
              label.centerY = labelCenterY;
              label.datapointRect = tempElement.getBoundingClientRect();
            
              dataLabel.push(label);
              originalLabels.push(label);
            }
            dataLabels.push(dataLabel);
          }
        }else if(paintingMode === 'rectCoordinate'){
          for( i = 0; i < boundarySelection[0].length; i++){
            var rectBoundaryBox = boundarySelection[0][i].getBBox();
            if (rectBoundaryBox.width === 0 || rectBoundaryBox.height === 0) {
              break;
            }
            plotOffset = boundarySelection[0][i].getTransformToElement(_SVGRoot);
            dataLabel = [];
            for( j = 0 ; j < gElements[i].length; j++){
              label = {};
              tempElement = gElements[i][j];
              datashapeOffset = tempElement.getTransformToElement(_SVGRoot);
              
              /**
               *  [07-Jan-2012 Nick] 
               *  FIX FOR IE, in some cases, datashapesOffset is null here,
               *  so if it is null, the logic should jump out of here.
               */
              if(!TypeUtils.isExist(datashapeOffset)){
                  break;
              }
              label.dataShape = tempElement;
              var bbox = tempElement.getBBox();        
              /*
               * [18-Dec-2012 Nick] 
               * For different charts, the requirements of showing label are different.
               * 1. Geo bubble/chorolopeth chart, it has an array of values in __data__.val, but the array only has one object
               * 2. Bubble and scatter has more than one object in __data__.val, but only y member is displayed.
               * 3. for the other charts, show val directly.
               */
              var originalValue;
              if(TypeUtils.isArray(tempElement.__data__.val)){
                if(isGeoChart){
                  originalValue = tempElement.__data__.val[0];
                }else{
                  originalValue = tempElement.__data__.y;
                }
              }else{
                if(isPercentMode && type === 'value'){
                  originalValue = tempElement.__data__.value;
                }else{
                  originalValue = tempElement.__data__.val;
                }
              }
              if(type !== 'value' && tempElement.__data__.isNegative){
                originalValue = '-' + originalValue;
              }
              var heatMapLabelWidth = 0, heatMapLabelHeight = 0;
              if (tempElement.__data__.isOnlyOneCategory !== undefined) {
                isHeatMap = true;
                if (tempElement.__data__.isOnlyOneCategory) {
                  isOneCategoryHeatmap = true;
                  var heatMapLabel = gPlot.parent().selectAll('text.v-heatmapdatalabel')[0][0];
                  if (heatMapLabel) {
                    var heatmapLabelBBox = heatMapLabel.getBBox();
                    heatMapLabelWidth = heatmapLabelBBox.width;
                    heatMapLabelHeight = heatmapLabelBBox.height;
                  }
                }
              }
              
              var treeMapLabelWidth = 0, treeMapLabelHeight = 0;
              if (tempElement.__data__.isTreeMap !== undefined) {
                isTreeMap = true;
                var treeMapLabel = gPlot.parent().selectAll('text.v-treemapdatalabel')[0][0];
                if (treeMapLabel) {
                  var treeMapLabelBBox = treeMapLabel.getBBox();
                  treeMapLabelWidth = treeMapLabelBBox.width;
                  treeMapLabelHeight = treeMapLabelBBox.height;
                }
              }
        
              label.value =  formatDataLabel(originalValue, tempElement);
              if(type === 'label and value'){
                label.value = tempElement.__data__.label + ' (' + (label.value === null? 'No value' : label.value) + ')';
              }
              var x = bbox.x * datashapeOffset.a, y = bbox.y * datashapeOffset.d, width = bbox.width* datashapeOffset.a, height = bbox.height* datashapeOffset.d;    
              /**
               *  [18-Dec-2012 Nick] 
               *  plotOffset means the offset between g.datashapesgroup and svg root element
               *  datashapeOffset means the offset between element.datapoint and svg root element
               *  so the difference between them means the offset between element.datapoint and g.datashapesgroup
               */
              label.transformString = ('translate(' + (datashapeOffset.e - plotOffset.e) + ',' + (datashapeOffset.f - plotOffset.f) + ')' );
              var insideCenterX = 0, insideCenterY = 0, outsideUpCenterX = 0, outsideUpCenterY = 0, outsideDownCenterX = 0, outsideDownCenterY = 0, outsideLeftCenterX = 0, outsideRightCenterX = 0, outsideLeftCenterY = 0, outsideRightCenterY = 0;
              if (isHeatMap || isTreeMap) {
                var labelValue = label.value;
                if (TypeUtils.isNumber(labelValue)){
                  labelValue = labelValue.toString();
                }
                var dataLabeFontColor = null;
                if (isHeatMap) {
                  dataLabeFontColor = heatMapLabelFontColor;
                } else if (isTreeMap) {
                  dataLabeFontColor = treeMapLabelFontColor;
                }
                label.value = TextUtils.ellipsis(labelValue, null, width - 3,  "fill:" + dataLabeFontColor + ";font-family:" + fontFamily + ";font-size:" + fontSize);
              }
              labelSize = TextUtils.fastMeasure(label.value, fontSize, fontWeight, fontFamily);
 
              if(orientation === 'horizontal'){
                label.centerX = x + width/2;
                label.centerY = y + height/2;
                /**
                 * [07-Jan-2012 Nick]
                 * if the label value is negative, set outsidePosition to left, so make sure it is listed on the left sideof data shape element
                 */
                if (positionPreference && position === 'outside') {
                  if (outsidePosition === 'right'){
                    label.centerX = label.centerX  + width/2 + labelSize.width/2;
                  }
                } else {
                  if(position === 'outside'){
                    if( outsidePosition === 'left' || (!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)){
                      label.centerX = label.centerX - (width/2 + labelSize.width/2);
                    }else if (outsidePosition === 'right'){
                      label.centerX = label.centerX  + width/2 + labelSize.width/2;
                    }
                  }
                }
                insideCenterX = x + width/2;
                insideCenterY = y + height/2;

                if (!isStackMode) {
                  if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                    outsideRightCenterX = label.centerX  + width/2 + labelSize.width/2;
                    outsideRightCenterY = y + height/2;
                  } else {
                    outsideLeftCenterX = label.centerX - (width/2 + labelSize.width/2);
                    outsideLeftCenterY = y + height/2;
                  }
                }

              }else{
                label.centerX = x + width/2;
                label.centerY = y + height/2;
                /**
                 * [07-Jan-2012 Nick]
                 * if the label value is negative, set outsidePosition to down, so make sure it is listed below the data shape element
                 */
                if(tempElement.__data__.isNegative){
                  outsidePosition = 'down';
                }   
                if (isHeatMap && isOneCategoryHeatmap) {
                  label.centerY += labelSize.height/2;
                } else if (isTreeMap) {
                  label.centerY += (treeMapLabelHeight/2 + labelSize.height/2);
                }
                
                if (positionPreference && position === 'outside') {
                  if (outsidePosition === 'up'){
                    label.centerY = label.centerY - height/2 - labelSize.height/2;
                  }
                } else {
                  if(position === 'outside'){
                    if( outsidePosition === 'down' || (!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)){
                      label.centerY = label.centerY + height/2 + labelSize.height/2;
                    }else if (outsidePosition === 'up'){
                      label.centerY = label.centerY - height/2 - labelSize.height/2;
                    } 
                  }
                }
	
                insideCenterY = y + height/2;
                insideCenterX = x + width/2;
                
                if (!isStackMode) {
                  if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                    outsideUpCenterY = label.centerY - height/2 - labelSize.height/2;
                    outsideUpCenterX = x + width/2;
                  } else {
                    outsideDownCenterY = label.centerY + height/2 + labelSize.height/2;
                    outsideDownCenterX = x + width/2;
                  }
                }
              }
              label.x = label.centerX - labelSize.width/2;
              label.y = label.centerY - labelSize.y/2;
              label.width = labelSize.width;
              label.height = labelSize.height;
              label.ownerWidth = width;
              label.ownerHeight = height;
              label.datapointRect = tempElement.getBoundingClientRect();
              label.insideX = insideCenterX - labelSize.width/2;
              label.insideY = insideCenterY - labelSize.y/2;
              if (!isStackMode) {
                if (orientation === 'horizontal') {
                  if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                    label.outsideX = outsideRightCenterX - labelSize.width/2;
                    label.outsideY = outsideRightCenterY - labelSize.y/2;
                  } else {
                    label.outsideX = outsideLeftCenterX - labelSize.width/2;
                    label.outsideY = outsideLeftCenterY - labelSize.y/2;
                  }
                } else if (orientation === 'vertical') {
                  if (!(!TypeUtils.isExist(tempElement.__data__.isNegative) && originalValue < 0)) {
                    label.outsideX = outsideUpCenterX - labelSize.width/2;
                    label.outsideY = outsideUpCenterY - labelSize.y/2;
                  } else {
                    label.outsideX = outsideDownCenterX - labelSize.width/2;
                    label.outsideY = outsideDownCenterY - labelSize.y/2;
                  }
                }
              }
              dataLabel.push(label);
              originalLabels.push(label);
            }
            dataLabels.push(dataLabel);
          }
        }
      };
      
      var isOverlappedWith = function(srcLabel, desLabel) {
  
        var left1 = srcLabel.left, top1 = srcLabel.top, right1 = srcLabel.right, bottom1 = srcLabel.bottom;
        var left2 = desLabel.left, top2 = desLabel.top, right2 = desLabel.right, bottom2 = desLabel.bottom;
        
        if (!((left1 >= right2) || (top1 >= bottom2) || (right1 <= left2) || (bottom1 <= top2))) {
          return true;
        }
        return false;        
      };
      
      var removeUnqualifiedLabels = function(labels, plotArea) {

        if (labels === null || plotArea === null) {
          return;
         }
            
         for (var i = 0; i < labels.length; i++) {
           
           var srcLabel = labels[i];
           
//           if (isCrossBorder(srcLabel, plotArea)) {
//             srcLabel.visible = false;
//             continue;
//           }
           if (!srcLabel.visible) {
             continue;
           }
           for (var j = i + 1; j < labels.length; j++) {
             var desLabel = labels[j];
             if (!desLabel.visible) {
               continue;
             }
             if (isOverlappedWith(srcLabel, desLabel)) {
               desLabel.visible = false;
             }
           }
         }
         
      };
      
      var isCrossBorder = function(label, plotArea) {
        
        if (label.top < plotArea.top || label.left < plotArea.left || label.right > plotArea.right || label.bottom > plotArea.bottom) {
          return true;
        }
        
        return false;
      };
      /**
     * get/set your event dispatch if you support event
     */
     label.dispatch = function(_){
       if(!arguments.length){
         return _dispatch;
       }
       _dispatch = _;
       return label;
     };
     
      label.plot = function(_){
        if(!arguments.length){
          return gPlot;
        }
        gPlot = _;
      };

      label.parent = function(){};
      
      label.properties = function(_){
        if(!arguments.length){
          return properties;
        }        
        Objects.extend(true,properties, _);
        parseOptions(properties);
      };
      
      return label;
    };
    return dataLabel; 
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.datalabel',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.datalabel',
    'name' : 'datalabel',
    'type' : Constants.Module.Type.Supplementary,
    'properties' : {  
      'visible': {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether data label is visible.',
     },
     'isDonut': {
       'name' : 'isDonut',
       'supportedValueType' : 'Boolean',
       'defaultValue' : false,
       'description' : 'Set for donut chart only.',
       'isExported': false
    },
    'type' : {
      'name' : 'type',
      'supportedValueType' : 'String',
      'defaultValue' : 'value',
      'description' : 'Set the type of label',
      'isExported': false
    },
    'automaticInOutside': {
      'name' : 'automaticInOutside',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'if it is true, the data label will be automatically placed outside when data label postion property is inside and vice versa.',
      'isExported': false    
    },
    'showZero': {
      'name' : 'showZero',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'if it is true, the value zero will be shown in data label.',
      'isExported': false    
    },
    'isGeoChart': {
      'name' : 'isGeoChart',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'if it is true, it is a geo chart.',
      'isExported': false    
    },
    'isStackMode': {
      'name' : 'isStackMode',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'Set for stack chart only.',
      'isExported': false    
    },
    'isPercentMode': {
      'name' : 'isPercentMode',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'Set for percent chart only.',
      'isExported': false    
    },
    'positionPreference': {
      'name' : 'positionPreference',
      'supportedValueType' : 'Boolean',
      'defaultValue' : false,
      'description' : 'If it is true, the data label position is defined by property outsidePosition no matter whether data label value is negative.',
      'isExported': false    
    },
    'outsideVisible': {
      'name' : 'outsideVisible',
      'supportedValueType' : 'Boolean',
      'defaultValue' : true,
      'description' : 'when data label is oustide, it can control whether it is visible or not.',
      'isExported': false    
    },
    'outsidePosition': {
      'name' : 'outsidePosition',
      'supportedValueType' : 'List',
      'supportedValues': ['up','down', 'left', 'right'],
      'defaultValue' : 'up',
      'description' : 'when data label is oustide, its position is above the element.',
      'isExported': false    
    },
        'paintingMode': {
           'name' : 'paintingMode',
           'supportedValueType' : 'List',
           'supportedValues': ['rectCoordinate','polarCoordinate'],
           'defaultValue' : 'rectCoordinate',
           'description' : 'Set painting mode of data labels.',
           'isExported' : false
        },
        'position': {
           'name' : 'position',
           'supportedValueType' : 'List',
           'supportedValues' : ['inside','outside'],
           'defaultValue' : 'inside',
           'description' : 'Set position of data labels.'
        },
        'orientation': {
           'name' : 'orientation',
           'supportedValueType' : 'List',
           'supportedValues' : ['horizontal', 'vertical'],
           'defaultValue' : 'vertical',
           'description' : 'Set orientation of data labels.',
           'isExported' : false
        },
        'formatString': {
        	'name' : 'formatString',
        	'supportedValueType': 'Two-Dimensions-Array',
          'defaultValue' : null,
        	'description' : 'Set format string of datalabel.As we may have dual axis with serveral measures,the first array is applied to primary axis and the second one is applied to the second axis.'
        		+'If the length of format string list is less than the length of data series, the last format string in the list will be applied to exceeded data series.' 
        	}
      },
      'css' : {
        '.v-datalabel' : {
          'description' : 'Define style for the data label',
          'value' : {
            'fill' : '#333333',
            'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
            'font-size' : '12px',
            'font-weight' : 'normal'
          }
        }
      },
      configure: null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ignite',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.append',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.layout.stack',
  version : '4.0.2'
}
],
function Setup ( registry, category, ignite, append, objects, evts, stack ) {
  
  var _ = function ( manifest, context ) {
    var width = 0,
        height = 0,
        properties = {},
        data = {},
        config = {},
        parentNode = null,
        children = {},
        selections = {},
        dispatch = evts('relayout', 'initialized'),
        charger = {},
        initComplete = false;
    
    // TODO redundant logic to be abstracted out
    function init ( data, attrs, conf ) {
      var children = {};
      
      $.each(conf.modules, function ( key, value ) {
        if ( value === null ) { return; }
        var dataset = value.data ? data.createDataAdapterForModule(value.data) : data,
            type = category.get(value.id).type;
        
        children[key] = ignite(value.id, context, 'v-m-' + key);
        children[key].alias = key;
        
        if ( key !== 'layout' ) {
          selections[key] = append.apply(parentNode, [ 'g', { 'class' : 'v-m-' + key } ]);
        }
        
        if ( type !== registry.Type.Container ) {
          children[key].data(dataset)
            .properties(objects.extend(
              true, 
              {}, 
              value.configure ? value.configure.properties : {}, 
              value.configure ? attrs[value.configure.propertyCategory] : {}));
          
          if ( children[key].parent ) { children[key].parent(selections[key]); }
        }
      });
      
      initComplete = true; 
      return children;
    }
    
    function layout () {
      var algorithm = children.layout, 
          components = [],
          props = properties.legendGroup ? 
                  properties.legendGroup.layout : manifest.props().layout,
          alignment = 'left', // alignment for legend stack always at left
          result = {};
      
      algorithm
        .width(width)
        .height(height)
        .gravity(-1)
        .size(function (d) { return d.module.getPreferredSize(); })
        .sort(function (a, b) { return a.priority - b.priority; });
      
      $.each(config.modules, function ( key, value ) {
        if ( value === null ) { return; }
        if ( !value.configure || !value.configure.properties || !value.configure.properties.layout ) { 
          return;
        }
        
        if ( value.configure.properties.layout ) {
          components.push({
            module : children[key],
            order : value.configure.properties.layout.order
          });
        }
      });
      
      result = algorithm(components, alignment);

      $.each(result, function ( key, value ) {
        selections[key].attr('transform', 
          'translate(' + value.x + ',' + value.y + ')');
      });
    }
    
    function chart ( selection ) {
      selection.each(function (d) {
        layout();
        $.each(children, function ( key, value ) {
          if ( key !== 'layout' ) { selections[key].call(value); }
        });
      });
      
      dispatch.initialized();
    }
    
    chart.width = function (x) {
      if ( !arguments.length ) { return width; }
      width = x;
      return chart;
    };
    
    chart.height = function (x) {
      if ( !arguments.length ) { return height; }
      height = x;
      return chart;
    };
    
    chart.size = function (xs) {
      if ( !arguments.length ) { return { width : width, height : height }; }
      width = xs.width;
      height = xs.height;
      return chart;
    };
    
    chart.properties = function (xs) {
      if ( !arguments.length ) { return properties; }
      properties = $.extend(true, {}, properties, xs);
      
      $.each(children, function ( key, value ) {
        if ( config.modules[key].configure ) {
          value.properties(properties[config.modules[key].configure.propertyCategory]);
        }
      });
      
      if ( !$.isEmptyObject(config) && !$.isEmptyObject(data) && !initComplete ) {
        children = init(data, properties, config);
      }
      
      return chart;
    };
    
    chart.config = function (xs) {
      if ( !arguments.length ) { return config; }
      config = xs;
      
      if ( !$.isEmptyObject(properties) && !$.isEmptyObject(data) && !initComplete ) {
        children = init(data, properties, config);
      }
      
      return chart;
    };
    
    chart.dispatch = function (x) {
      if ( !arguments.length ) { return dispatch; }
      dispatch = x;
      return chart;
    };
    
    chart.data = function (xs) {
      if ( !arguments.length ) { return data; }
      data = xs;
      
      $.each(children, function ( key, value ) {
        if ( config.modules[key].data ) {
          value.data(data.createDataAdapterForModule(config.modules[key].data));
        } else {
          value.data(data);
        }
      });
      
      if ( !$.isEmptyObject(config) && !$.isEmptyObject(properties) && !initComplete ) {
        children = init(data, properties, config);
      }
      
      return chart;
    };
    
    chart.parent = function (x) {
      if ( !arguments.length ) { return parentNode; }
      parentNode = x;
      return chart;
    };
    
    // Means of wiring up module dependencies
    chart.recharge = function (x) {
      if ( !arguments.length ) { return charger; }
      charger = x;
      return chart;
    };
    
    chart.modules = function (xs) {
      if ( !arguments.length ) { return children; }
      children = xs;
      return chart;
    };
    
    chart.getPreferredSize = function () {
      var minWidths = [], maxWidths = [], minHeights = [], maxHeights = [];
      
      $.each(children, function ( key, value ) {
        if ( key === 'layout' ) { return; }
        var size = value.getPreferredSize();
        minWidths.push(size.minWidth);
        minHeights.push(size.minHeight);
        maxWidths.push(size.maxWidth);
        maxHeights.push(size.maxHeight);
      });
      
      return {
        minWidth : d3.min(minWidths),
        maxWidth : d3.max(maxWidths),
        minHeight : d3.min(minHeights),
        maxHeight : d3.max(maxHeights)
      };
    };
    
    return chart;
  };
  
  return _;
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.legend',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    id : 'sap.viz.modules.legend',
    type : Constants.Module.Type.Container,
    name : 'legend',
    description: 'The legend is a box containing a symbol and name for each series item or point item in the chart.',
    properties : {
		'layout' : {
        'name' : 'layout',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'position' : {
            'name' : 'position',
            'supportedValueType' : 'String',
            'defaultValue' : 'right',
            'description' : 'Set the position of the legend area.',
          },
          'priority' : {
            'name' : 'priority',
            'supportedValueType' : 'Int',
            'defaultValue' : 1,
            'description' : 'Set the priority of the position for the legend area.',
			'isExported' : false
          },           
        },
        'description' : 'Settings for layout of legend area.'
      },
    },
    css : {
      
    },
    configure : null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.title',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
}
],
function Setup ( TextUtils, langManager, Objects, boundings ) {
  var title = function ( manifest, ctx ) {
    var width = 0, height = 0; 
    var titleStyle = null;
    
    var options = {}, 
        size = { width : 500, height : 100 }, 
        titleText = '';
    
    var chart = function ( selection ) {
      if ( options.visible ) {
        boundings.drawBound(selection, width, height);
        updateTitleStyle();
        
        var wrapper = this.selectAll('text.v-title').data([titleText]);
        wrapper.exit().remove();
        wrapper
          .enter()
          .append('text')
          .attr('class', 'v-title viz-title-label');
          
        ctx.styleManager
          .queryDefault('v-title')
          .toAttrs(wrapper);
          
        wrapper.attr('text-anchor', function () {
          if ( options.alignment === 'right' ) return 'end';
          else if ( options.alignment === 'left' ) return 'start';
          else return 'middle';   
        })
        .attr('x', function () {
          if ( options.alignment === 'right' ) return width;
          else if (options.alignment === 'left') return 0;
          else return width / 2; //"center" anyway
        })
        .attr('y', height / 2)
        .attr('dominant-baseline', 'central');
        
        TextUtils.ellipsis(titleText, wrapper.node(), width, titleStyle);
      }
      else
      {
        selection.selectAll('text.v-title').remove();
      }
    };

    chart.width = function ( value ) {
      if ( !arguments.length ) return width;
      width = value;
      return chart;
    };

    chart.height = function ( value ) {
      if ( !arguments.length ) return height;
      height = value;
      return chart;
    };
    
    chart.size = function ( value ) {
      if ( !arguments.length ) return size;
      size = value;
      return chart;
    };

    chart.properties = function ( properties ) {
      if ( !arguments.length ) return options;
      Objects.extend(true, options, properties);

      if ( options.text === '' || options.text === null) {
        titleText = langManager.get('IDS_DEFAULTCHARTTITLE');
      } else {
        titleText = options.text;
      }

      return chart;
    };
    
    chart.getPreferredSize = function () {
      if ( options.visible ) {
        updateTitleStyle();
        var titleSize = TextUtils.measure(titleText, titleStyle);
        var minSize = TextUtils.measure('M...', titleStyle);
        return {
          hideOversize : true,
          maxSizeConstant : 1 / 3,
          'width' : titleSize.width,
          'height' : titleSize.height,
          minWidth : minSize.width,
          minHeight : minSize.height,
          maxWidth : titleSize.width,
          maxHeight : titleSize.height
        };
      }
      
      return { maxWidth : 0, maxHeight : 0, minWidth : 0, minHeight : 0, 'width' : 0, 'height' : 0 };      
    };
    
    function updateTitleStyle () {
      titleStyle = ctx.styleManager.query('v-title').toString();
    }
    
    options = manifest.props(null);
    return chart;
  };
  
  return title;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.title',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.title',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'title',
    'description': "Settings for the chart's main title.",
    'properties' : {
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set visibility of chart title.'
      },
      'text' : {
        'name' : 'text',
        'supportedValueType' : 'String',
        'defaultValue' : null,
        'description' : 'Set chart title text.'
      },
      'alignment' : {
        'name' : 'alignment',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'left', 'center', 'right' ],
        'defaultValue' : 'center',
        'description' : 'Set chart title alignment.'
      },
      'layout' : {
        'name' : 'layout',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'position' : {
            'name' : 'position',
            'supportedValueType' : 'String',
            'defaultValue' : 'right',
            'description' : 'Set the position of the title.',
          },
          'priority' : {
            'name' : 'priority',
            'supportedValueType' : 'Int',
            'defaultValue' : 0,
            'description' : 'Set the priority of the position for the title.',
            'isExported' : false
          },           
        },
        'description' : 'Settings for layout of title.',
        'isExported' : false
       },
    },
    'css' : {
      '.viz-title-label.v-title' : {
        'description' : 'Define style for the title label.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '16px',
          'font-weight' : 'bold',
          'fill' : '#333333'
        }
      }
    },
    'configure' : null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
}
],
function Setup(manifest, ObjectUtils, langManager) {
  /**
   * This is a instantce , which already have been registered into {@link sap.viz.manifest.feeds}.</br>
   * </br>
   * Now, once an item is loaded from {@link sap.viz.manifest.feeds}, it will automatically provide some APIs .</br>
   * </br>
   * @see sap.viz.manifest.feeds#get
   * @class Built-in_Manifest_Objects.feedsManifest
   * @example
   * var pieFeed = manifest.feeds.get(pieId);
   */
  return manifest.registerCategory("feeds", function(obj) {

    var feeds = {};
    obj.feeds.forEach(function(o) {
      feeds[o.id] = o;
      var na = o.name;
      delete o.name;
      Object.defineProperty(o, 'name', {
        get : function() {
          var res = langManager.get(na);
          if (res) {
            return res;
          }
          return na;
        },
        enumerable : true
      });
    });
    /**
     * This is a instantce , which already have been registered into {@link sap.viz.manifest.feeds}.</br>
     * </br>
     * Now, once an item is loaded from {@link sap.viz.manifest.feeds}, it will automatically provide some APIs .</br>
     * </br>
     * @see sap.viz.manifest.feeds#get
     * @class Built-in_Manifest_Objects.feedsManifest
     * @example
     * var pieFeed = manifest.feeds.get(pieId);
     * @ignore
     */
    Object.defineProperty(obj, "feedsMap", {
      value : feeds,
      writable : false,
      enumerable : false,
      configurable : false
    });

    return obj;
  });
});sap.riv.module(
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
}
],
function Setup(manifest, feedsManifest, ObjectUtils, TypeUtils, Objects, constants, module,
    langManager) {
  function getModuleByType(modules, type) {
    for ( var i = 0; i < modules.length; ++i) {
      if (modules[i].module.type === type) {
        return modules[i];
      }
      if (modules[i].subModules) {
        var r = getModuleByType(modules[i].subModules, type);
        if (r) {
            return r;    
        }
          
      }
    }
    return null;
  }
  function overrideProperties (target, overProps){
    if(!overProps){
      return;
    }
    var tempPropName, tempPropObj;
    for(tempPropName in target){
      if(target.hasOwnProperty(tempPropName) && overProps.hasOwnProperty(tempPropName)){
        tempPropObj = target[tempPropName];
        if(tempPropObj.supportedValueType === 'Object'){
          overrideProperties(tempPropObj.supportedValues, overProps[tempPropName]);
        }else{
          tempPropObj.defaultValue = overProps[tempPropName];
        }
      }
    }
  }
  function filterProperties (target, filterInfo){
    var tempPropName, tempPropObj;
    for(tempPropName in target){
      if(target.hasOwnProperty(tempPropName)){
        if (target[tempPropName] === null){
          delete target[tempPropName];
          continue;
        }
        tempPropObj = target[tempPropName];
        /*[Jimmy/11/15/2012]what if we override supportedValueType in the propertyOverride?
         currently we don't know how to deal with it.
         * */
        if(filterInfo){
          Objects.extend(true, tempPropObj, filterInfo[tempPropName]);
        }
        if(tempPropObj.isExported === false){
          delete target[tempPropName];
        }else{
          if(tempPropObj.supportedValueType === 'Object'){
            filterProperties(tempPropObj.supportedValues, filterInfo ? filterInfo[tempPropName] : null);
            //if its type is object and with no children, we just delete it
            if(TypeUtils.isEmptyObject(tempPropObj.supportedValues)){
              delete target[tempPropName];
            } 
          } 
        }
      }
    }
  }
  function loadProperties(allProperties, modules) {
    if(modules){
      //3 properties we need take care of
      //propertyCategory, properties and propertiesOverride
      var mProps/*original module properties*/, 
          mcProps/*properties defined in chart manifest, aka module reference*/,
          moProps/*properties definition override in chart manifest, aka propertiesOverride*/,
          propCate/*property category*/,
          mRef/*module reference name in chart config*/;
      modules.forEach(function(o){//@Alex Su: configure module if module has one.
        if (o.config.configure){
          mRef = o.moduleRef;
          mProps = o.module.properties;
          mcProps = o.config.configure.properties;
          propCate = o.config.configure.propertyCategory;
          moProps = o.config.configure.propertiesOverride;
          allProperties[propCate] = Objects.extend(true, null, mProps);
          //we add a new meta data info here to indicate the reference path in chart configure of each property category        
          Object.defineProperties(allProperties[propCate], { 
            'moduleRefPath':{            
              get : (function(_refName) {
                return function() {
                  return _refName;
                };
              }(mRef)),
              enumerable : false
            }  
          });
          //filter out isExported=false, it can come from moProps or mProps
          filterProperties(allProperties[propCate], moProps);
          //override default values which come from mcProps
          overrideProperties(allProperties[propCate], mcProps);
        }
        loadProperties(allProperties, o.subModules);
      });
    }
  }

  function loadFeeds(allFeeds, modules, aaIndexOffset, mndProOffset) {
    if (modules) {
      modules.forEach(function(o) {
        var feeds = o.module.feeds;
        var newAAIndexOffset = aaIndexOffset;
        var newMNDProOffset = mndProOffset;
        if (feeds) {
          var moduleFeeds;
          var feedsId = feeds.id;
          if (feedsId !== undefined) {
            var feedsConfigure = feeds.configure;
            moduleFeeds = feedsManifest.get(feedsId).feedsMap;
            if (feedsConfigure) { 
              moduleFeeds = ObjectUtils.extend(true, null, moduleFeeds,
                  feedsConfigure);
              }
          } else {
            moduleFeeds = {};
            feeds.forEach(function(feed) {
              moduleFeeds[feed.id] = feed;
            });
          }
     
          var i;
          for (i in moduleFeeds) {
            if(moduleFeeds.hasOwnProperty(i)){
              var feed = moduleFeeds[i];
              if (feed) {
                feed = ObjectUtils.extend(true, null, feed);
                allFeeds[i] = feed;
                if (feed.type === constants.Feed.Type.Dimension) {
                  var aaIndex = feed.aaIndex;
                  aaIndex += aaIndexOffset;
                  if (newAAIndexOffset < aaIndex) {
                      newAAIndexOffset = aaIndex;
                  }
                   
                  feed.aaIndex = aaIndex;
  
                  var mndPro = feed.acceptMND;
                  if (mndPro >= 0) {
                    if (mndProOffset > 0) {
                      mndPro += mndProOffset;  
                    }
                      
  
                    if (newMNDProOffset < mndPro) {
                      newMNDProOffset = mndPro;
                      }
  
                    feed.acceptMND = mndPro;
                  }
                }
              }
            }
          }
          if (newMNDProOffset >= 0) {
              newMNDProOffset += 1;
          }
            

        }
        loadFeeds(allFeeds, o.subModules, newAAIndexOffset, newMNDProOffset);
      });
    }
  }
  /**
     * This is a instantce , which already have been registered into {@link sap.viz.manifest.viz}.</br>
     * </br>
     * Now, once an item is loaded from {@link sap.viz.manifest.viz}, it will automatically provide some APIs .</br>
     * </br>
     * @example
     * 
     * var allFeedOfBar = manifest.viz.get(barType).allFeeds();
     *
     * @see sap.viz.manifest.viz#get
     * @class Built-in_Manifest_Objects.vizManifest
     */
  return manifest
      .registerCategory(
          "viz",
          function(obj) {
            var modules =[];
            var configModules = obj.modules;
            for ( var moduleRefName in configModules) {
              if(configModules.hasOwnProperty(moduleRefName)){
                var moduleRef = configModules[moduleRefName];
                if (moduleRef !== null) {
                  manifest.module.loadModule(modules, moduleRef, moduleRefName);
                }
              }
            }

            var feedsConfigure = obj.feeds;
            var allFeeds, allRequiredFeeds, vizname = obj.name;
            var allProperties;
            delete obj.name;
            Object
                .defineProperties(
                    obj,
                    {
                      /**
                         * get the feeds definition of an item in {@link sap.viz.manifest.viz}
                         * @method Built-in_Manifest_Objects.vizManifest#allFeeds
                         * @return {[Object] allFeeds} all feeds definition of an item
                         * @example
                         * 
                         * var allFeedOfBar = sap.viz.manifest.viz.get('viz/bar').allFeeds();
                         *
                         */
                      allFeeds : {
                        value : function() {
                          if (!allFeeds) {
                            allFeeds = {};
                            loadFeeds(allFeeds, modules, 0, -1);
                            ObjectUtils.extend(true, allFeeds, feedsConfigure);
                            allFeeds = d3.values(allFeeds).filter(function(o) {
                              return o;
                            });
                          }

                          //Data Handler needs to know full feed definition including useless feed for data dispatching
                          var includeUselessFeed = !arguments.length || arguments[0] === false ? false : true;
                          if (includeUselessFeed === false){
                              if (!allRequiredFeeds){
                                  allRequiredFeeds = d3.values(allFeeds).filter(function(o) {
                                  if (o.min === 0 && o.max === 0){
                                      return false;
                                  }else {
                                      return true;
                                  }
                                  
                                  });
                              }
                              return allRequiredFeeds;
                          }else{
                              return allFeeds;
                          }
       
                        }
                      },
                      /**
                         * get all properties definition of an item in {@link sap.viz.manifest.viz}
                         * @method Built-in_Manifest_Objects.vizManifest#allProperties
                         * @return {[Object] allProperties} all properties definition of an item
                         * @example
                         * 
                         * var allPropertiesOfBarChart = sap.viz.manifest.viz.get('viz/bar').allProperties();
                         *
                         */
                      allProperties : {
                        /*we will go through all modules and merge their property definitions with properties override in chart manifest,
                         and return. note all the properties with isExport=false will be filtered out*/
                        value : function() {
                          if(!allProperties) {
                            allProperties = {};
                            loadProperties(allProperties, modules);
                          }
                          return allProperties;
                        }  
                      },
                      getChartPropCate : {
                        value : function() {
                          return getModuleByType(modules, 'CHART').config.configure.propertyCategory;
                        }
                      },
                      /**
                       * get the name of the visualization
                       * @property {String}  Built-in_Manifest_Objects.vizManifest#name
                       * @example
                       * var name = sap.viz.manifest.viz.get('viz/bar').name
                       */
                      name : {
                        get : function() {
                          var res = langManager.get(vizname);
                          if (res) {
                              return res;
                          }
                           
                          return vizname;
                        },
                        enumerable : true
                      }
                    });
            return obj;
          });
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.layout.Dock',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.legend.Common',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.layout.Stack',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'riv/base',
    name : 'IDS_BASECHART',
    'abstract' : true,
    modules : {
      root : {
        id : 'sap.viz.modules.rootContainer',
        configure : {
          propertyCategory : 'general'
        },
        modules : {
          title : {
            id : 'sap.viz.modules.title',
            configure : {
              propertyCategory : 'title',
              properties : {
                layout : {
                  position : 'top',
                  priority : 0
                }
              }
            }
          },
          
          layout : {
            id : 'sap.viz.modules.layout.dock'
          },
          
          legends : {
            id : 'sap.viz.modules.legend',
            configure : {
              propertyCategory : 'legendGroup',
              properties : {
                layout : {
                  position : 'right',
                  priority : 1,
                  alignment : 'right'
                }
              }
            },
            modules : {
              layout : {
                id : 'sap.viz.modules.layout.stack'
              },
              legend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  propertyCategory : 'legend',
                  properties : {
                    layout : { order : 0 }
                  }
                }
              } 
            }
          }
        }
      }
      
    },
    dependencies : {}
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiChart = {
    id : 'riv/base/multiple',
    name : 'IDS_BASEMULTIPLECHART',
    base : 'riv/base',
    'abstract' : true,
    modules : {
      root : {
        id : 'sap.viz.modules.rootContainer',
        configure : { propertyCategory : 'general' },
        modules : {
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart']
              }
            }
          },        
          main : {
            id : 'sap.viz.modules.tablecontainer',
            configure : {
              propertyCategory : 'multiLayout',
              properties : {
                layout : {
                  position : 'center',
                  priority : 10
                }
              }
            },
            modules: {
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                'description': 'Settings for the column axis of multiple charts.',
                  propertyCategory : 'columnAxis',
                  properties : {
                    title : { visible : false },
                    gridline : { visible : true },
                    color : '#d8d8d8',
                    type : 'category',
                    position : 'top'
                  },
                  propertiesOverride : {    
                    label : { isExported : false },
                    axisline : { isExported : false },
                    gridline:{ 
                      isExported : false,
                      color: { isExported : false },
                      size: { isExported:false }
                    }
                  }
                }
              },
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  description : 'Settings for the row axis of multiple charts.',
                  propertyCategory : 'rowAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    title : { visible : false },
                    color : '#d8d8d8',
                    gridline : { visible : true }
                  },
                  propertiesOverride : {          
                    label : { isExported : false },
                    axisline : { isExported : false },
                    gridline:{
                      isExported : false,
                      color: { isExported : false },
                      size: { isExported:false }
                    }
                  }
                }
              },
              plot : { id : 'sap.viz.modules.xycontainer' }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiXYChart = {
    id : 'riv/base/multiple/xy',
    name : 'IDS_BASEMULTIPLEXYCHART',
    base : 'riv/base/multiple',
    'abstract' : true,
    modules : {
      root : {
        id : 'sap.viz.modules.rootContainer',
        configure : { propertyCategory : 'general' },
        modules : {
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : { propertyCategory : 'tooltip' }
          },
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot: {
                    configure: {
                      propertiesOverride:{
                        primaryValuesColorPalette:{ isExported: false },
                        secondaryValuesColorPalette: { isExported: false }
                      }
                    }
                  },
                  background : {
                    id : 'sap.viz.modules.background',
                    configure : {
                      propertyCategory : 'background',
                      properties : { direction : 'vertical' }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        paintingMode : 'rectCoordinate',
                        visible : false,
                        position : 'inside',
                        automaticInOutside : true,
                        showZero : true,
                        isStackMode : false,
                        isPercentMode : false,
                        outsideVisible : true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiXYChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.XY',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var colorFeed = {
    'id' : 'regionColor',
    'name' : 'IDS_REGIONCOLOR',
    'type' : constants.Type.Dimension,
    'min' : 0,
    'max' : 2,
    'aaIndex' : 2,
    'acceptMND' : 1
  };

  var valueAxis1 = {
    'id' : 'primaryValues',
    'name' : 'IDS_PRIMARYVALUES',
    'type' : constants.Type.Measure,
    'min' : 1,
    'max' : constants.Constraints.INF,
    'mgIndex' : 1
  };

  var valueAxis2 = {
    'id' : 'secondaryValues',
    'name' : 'IDS_SECONDARYVALUES',
    'type' : constants.Type.Measure,
    'min' : 0,
    'max' : constants.Constraints.INF,
    'mgIndex' : 2
  };

  var dimension = {
    'id' : 'axisLabels',
    'name' : 'IDS_AXISLABELS',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 2,
    'acceptMND' : 0,
    'aaIndex' : 1
  };

  var feeds = {
    id : "xy",
    feeds : [ colorFeed, dimension, valueAxis1, valueAxis2 ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.XY',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.xy.base',
    'abstract' : true,
    'type' : Constants.Module.Type.Chart,
    'name' : 'xy base module',
    'datastructure' : 'DATA STRUCTURE DOC',
    'properties' : {  
    'colorPalette':
      {
         'name' : 'colorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColor,
          'description' : 'Set color palette for non-dual chart. Or dual chart\'s color palette when MND is not fed on legend color.'
      },
        'primaryValuesColorPalette' : {
          'name' : 'primaryValuesColorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColorDualAxis1,
          'description' : 'Set axis 1 color palette for dual chart.',
            'isExported' : true
        },  
        'secondaryValuesColorPalette' : {
          'name' : 'secondaryValuesColorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColorDualAxis2,
          'description' : 'Set axis 2 color palette for dual chart.',
            'isExported' : true
        },
        'drawingEffect':{
          'name' : 'drawingEffect',
           'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Set drawing effect of XY.',
            'isExported' : true
        },
    },
    'events' : {
      'initialized': Constants.Module.Event.Initialized.desc,
      'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc,
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "xy"
    },
    'css' : null,
    'configure' : null
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'},
[

],
function Setup() 
{
  var defaultSelectionUtil = {

  };
  
  defaultSelectionUtil.clearSelectionInfo = function(plot, isSelected, elems){
    var i, len;
        if(elems instanceof Array){
          for(i = 0, len = elems.length; i < len; i++){
            InfoProcessor(elems[i], isSelected);
          }
        }else{
          InfoProcessor(elems, isSelected);
        } 
  };
  
  function InfoProcessor(elems, isSelected){
    var j, info;
    if(elems.__data__){
      info = elems.__data__.info;
    }else{
      return;
    }
   
    if(info instanceof Array){
      for(j = 0; j < info.length; j++){
        if(info && info.defaultSelection){
          info.defaultSelection.isSelected = isSelected;
        }
      }
    }else{
      info.defaultSelection.isSelected = isSelected;
    }
  }
  
  return defaultSelectionUtil;
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
}
],
function Setup(feeder, langManager, Constants) {
  var tooltipDataHandler = function() {
    var _buffer = [];

    var my = {};

    var defaultString = langManager.get('IDS_ISNOVALUE');

    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };

    /**
     * 
     * @param data
     * @param seriesData
     * @param aai1
     * @param colorPalette
     * @param shapePalette
     * @param postProcess
     *          {Function} you can round the data or other thing.
     * @returns TOOD: add desc
     */
    my.generateTooltipData = function(data, seriesData, aai1, colorPalette,
        shapePalette, postProcess) {

      var parseFeedsData = function(data) {
        var barGroupValue;
        var isStacked = false;
        if (seriesData[aai1][0] !== undefined && seriesData[aai1][0].length > 0) {
          barGroupValue = d3.merge([ seriesData[aai1][0], seriesData[aai1][1] ]);
          isStacked = true;
        } else {
          barGroupValue = seriesData[aai1];
        }

        var tooltipData = {
          'body' : [],
          'footer' : []
        };
        var valueLength = barGroupValue.length;
        var isDual = false;
        var division = 0;
        var mvgData = [data.getMeasureValuesGroupDataByIdx(0), data.getMeasureValuesGroupDataByIdx(1)];
        var aaData = [data.getAnalysisAxisDataByIdx(0), data.getAnalysisAxisDataByIdx(1)];
        var MNDHandler = mndHandler(aaData);
        
        if (mvgData[0] && mvgData[1]) {
          isDual = true;
          division = mvgData[0].values.length;
        }
        var isMNDbeforeCate = false;
        var MNDLength;
        var i = 0, j = 0, k = 0,len;
        var measureIndex;
        var body;
        var valueIndex;
        var itemLabel;
        var item;
        var footer;

        if (!MNDHandler.hasMNDonCate && !MNDHandler.hasMNDonColor) {
          // MND does not feed on either category or color

          if (aaData[1]) {
            measureIndex = 0;
            if (mvgData[0]) {
              for ( i = 0; i < mvgData[0].values.length; ++i) {
                body = {
                  'name' : handleNull(mvgData[0].values[i].col),
                  'val' : []
                };
                for ( j = 0, len = mvgData[0].values[i].rows.length; j < len; ++j) {
                  valueIndex = measureIndex * len + j;
                  itemLabel = [];
                  for ( k = 0; k < aaData[1].values.length; ++k) {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                  item = {
                    'shape' : shapePalette[valueIndex % shapePalette.length],
                    'color' : colorPalette[valueIndex % colorPalette.length],
                    'label' : itemLabel,
                    'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                        : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                            : postProcess(barGroupValue[valueIndex].val),
                     'valueAxis' : 0
                  };
                  body.val.push(item);
                }
                tooltipData.body.push(body);
                ++measureIndex;
              }
            }
            // for dual chart
            if (mvgData[1]) {
              for ( i = 0; i < mvgData[1].values.length; ++i) {
                body = {
                  'name' : handleNull(mvgData[1].values[i].col),
                  'val' : []
                };
                for ( j = 0, len = mvgData[1].values[i].rows.length; j < len; ++j) {
                  valueIndex = measureIndex * len + j;
                  itemLabel = [];
                  for ( k = 0; k < aaData[1].values.length; ++k) {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                  item = {
                    'shape' : shapePalette[valueIndex % shapePalette.length],
                    'color' : colorPalette[valueIndex % colorPalette.length],
                    'label' : itemLabel,
                    'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                        : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                            : postProcess(barGroupValue[valueIndex].val),
                     'valueAxis' : 1
                  };
                  body.val.push(item);
                }
                tooltipData.body.push(body);
                ++measureIndex;
              }
            }
          } else {
            body = {
              'name' : handleNull(mvgData[0].values[0].col),
              'val' : []
            };
            item = {
              'shape' : shapePalette[0 % shapePalette.length],
              'color' : colorPalette[0 % colorPalette.length],
              'label' : null,
              'value' : barGroupValue[0].val === ' ' ? defaultString
                  : postProcess === undefined ? handleNull(barGroupValue[0].val)
                      : postProcess(barGroupValue[0].val),
               'valueAxis' : 0
            };
            body.val.push(item);
            tooltipData.body.push(body);
          }
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            footer = {
              'label' : aaData[0].values[i].col,
              'value' : aaData[0].values[i].rows[aai1]
            };
            tooltipData.footer.unshift(footer);
          }

        } else if (MNDHandler.hasMNDonColor) {
          // MND feeds on color
          for (i = 0; i < aaData[1].values.length; ++i) {
            if (aaData[1].values[i].type === 'MND') {
              MNDLength = aaData[1].values[i].rows.length;
              if (i === 0) {
                isMNDbeforeCate = true;
              }
              break;
            }
          }

          measureIndex = 0;
          var colorIndex;
          if (mvgData[0]) {
            for (i = 0; i < mvgData[0].values.length; ++i) {
              body = {
                'name' : handleNull(mvgData[0].values[i].col),
                'val' : []
              };
              for (j = 0, len = mvgData[0].values[i].rows.length; j < len; ++j) {
                colorIndex = undefined;
                if (isMNDbeforeCate){
                  valueIndex = measureIndex * len + j;
                }
                else if (!isStacked || !isDual){
                  valueIndex = j * MNDLength + measureIndex;
                }
                else {
                  valueIndex = j * division + measureIndex;
                  colorIndex = j * MNDLength + measureIndex;
                }
                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  if (aaData[1].values[k].type !== 'MND') {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                }
                item = {
                  'shape' : colorIndex !== undefined ? shapePalette[colorIndex  % shapePalette.length] 
                : shapePalette[valueIndex % shapePalette.length],
                  'color' : colorIndex !== undefined ? colorPalette[colorIndex % colorPalette.length] 
                  : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 0
                };
                body.val.push(item);
              }
              tooltipData.body.push(body);
              ++measureIndex;
            }
          }
          // for dual chart
          if (mvgData[1]) {
            for (i = 0; i < mvgData[1].values.length; ++i) {
              body = {
                'name' : handleNull(mvgData[1].values[i].col),
                'val' : []
              };
              for (j = 0, len = mvgData[1].values[i].rows.length; j < len; ++j) {
                colorIndex = undefined;
                if (isMNDbeforeCate){
                  valueIndex = measureIndex * len + j;
                }
                else if (!isStacked || !isDual){
                  valueIndex = j * MNDLength + measureIndex;
                }
                else {
                  valueIndex = j * (MNDLength - division) + measureIndex - division + parseInt(valueLength * division / MNDLength, 10);
                  colorIndex = j * MNDLength + measureIndex;
                }

                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  if (aaData[1].values[k].type !== 'MND') {
                    itemLabel.push(aaData[1].values[k].rows[j]);
                  }
                }
                item = {
                  'shape' : colorIndex !== undefined ? shapePalette[colorIndex % shapePalette.length] 
                : shapePalette[valueIndex  % shapePalette.length],
                  'color' : colorIndex !== undefined ? colorPalette[colorIndex % colorPalette.length] 
                  : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 1
                };
                body.val.push(item);
              }
              tooltipData.body.push(body);
              ++measureIndex;
            }
          }
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            footer = {
              'label' : aaData[0].values[i].col,
              'value' : aaData[0].values[i].rows[aai1]
            };
            tooltipData.footer.unshift(footer);
          }

        } else {
          // MND feeds on category axis
          var bodyName = null;
          var categoryLength;
          for (i = 0; i < aaData[0].values.length; ++i) {
            if (aaData[0].values[i].type === 'MND') {
              MNDLength = aaData[0].values[i].rows.length;
              var groupCount = 0;
              if (seriesData.length !== undefined) {
                groupCount = seriesData.length;
              } else {
                for (j in seriesData) {
                  if (seriesData.hasOwnProperty(j)){
                    ++groupCount;
                  }
                }
              }

              categoryLength = groupCount / MNDLength;
              if (i === 0) {
                isMNDbeforeCate = true;
                bodyName = aaData[0].values[i].rows[parseInt(aai1 / categoryLength, 10)];
              } else {
                // isMNDbeforeCate = false;
                bodyName = aaData[0].values[i].rows[aai1 % MNDLength];
              }
              break;
            }
          }
          body = {
            'name' : bodyName,
            'val' : []
          };

          if (aaData[1]) {
            // there exists color feeds.
            // var measureIndex = 0;
            if (mvgData[0]) {
              for (j = 0, len = mvgData[0].values[0].rows.length; j < len; ++j) {
                valueIndex = j;
                itemLabel = [];
                for (k = 0; k < aaData[1].values.length; ++k) {
                  itemLabel.push(aaData[1].values[k].rows[j]);
                }
                item = {
                  'shape' : shapePalette[valueIndex % shapePalette.length],
                  'color' : colorPalette[valueIndex % colorPalette.length],
                  'label' : itemLabel,
                  'value' : barGroupValue[valueIndex].val === ' ' ? defaultString
                      : postProcess === undefined ? handleNull(barGroupValue[valueIndex].val)
                          : postProcess(barGroupValue[valueIndex].val),
                   'valueAxis' : 0
                };
                body.val.push(item);
              }
            }
          } else {
            // otherwise...
            item = {
              'shape' : shapePalette[0 % shapePalette.length],
              'color' : colorPalette[0 % colorPalette.length],
              'label' : null,
              'value' : barGroupValue[0].val === ' ' ? defaultString
                  : postProcess === undefined ? handleNull(barGroupValue[0].val)
                      : postProcess(barGroupValue[0].val),
               'valueAxis' : 0
            };
            body.val.push(item);
          }
          tooltipData.body.push(body);
          for (i = 0, len = aaData[0].values.length; i < len; ++i) {
            if (aaData[0].values[i].type !== 'MND') {
              footer = {
                'label' : aaData[0].values[i].col,
                'value' : null
              };
              if (isMNDbeforeCate) {
                footer.value = aaData[0].values[i].rows[aai1  % categoryLength];
              } else {
                footer.value = aaData[0].values[i].rows[parseInt(aai1 / MNDLength, 10)];
              }
              tooltipData.footer.unshift(footer);
            }
          }

        }
        return tooltipData;
      };

      var help = function(index) {
        if (_buffer[index] === undefined) {
          _buffer[index] = parseFeedsData(data);
        }
        return _buffer[index];
      };

      return help(aai1);
    };
    return my;
  };

  function mndHandler(aaData) {
    var hasMNDonCate = false;
    var j, len;
    if (aaData[0]){
      for (j = 0, len = aaData[0].values.length; j < len; ++j){
        if (aaData[0].values[j].type && aaData[0].values[j].type === 'MND'){
          hasMNDonCate = true;
        }
      }
    }
     var hasMNDonColor = false;
    if (!hasMNDonCate) {
      if (aaData[1]){
        for (j = 0, len = aaData[1].values.length; j < len; ++j){
          if (aaData[1].values[j].type && aaData[1].values[j].type === 'MND'){
            hasMNDonColor = true;
          }
        }
      }
    }
    return {
      hasMNDonCate : hasMNDonCate,
      hasMNDonColor : hasMNDonColor
    };
  }

  tooltipDataHandler.formatTooltipData = function(data) {
    var tooltipEventData = {
      name : Constants.Module.Event.TooltipShow.name,
      data : data
    };
    return tooltipEventData;
  };

  tooltipDataHandler.dataTransform = function(obj) {
    var data1 = obj['MG1'];
    var data2 = obj['MG2'];

    var transferredDataSet = [];
    var i, j;
    if (obj.hasMND && obj.MNDOnColor && obj.MNDInner) {
      var mg1mnum = 0, mg2mnum = 0, colorAxisDataNum = 0;
      if (obj['MG1Number']) {
        mg1mnum = obj['MG1Number'];
        colorAxisDataNum = data1.length / mg1mnum;
      }
      if (obj['MG2Number']) {
        mg2mnum = obj['MG2Number'];
        colorAxisDataNum = data2.length / mg2mnum;
      }

      for (i = 0; i < colorAxisDataNum; i++) {
        for (j = 0; j < mg1mnum; j++) {
          transferredDataSet.push(data1[i * mg1mnum + j]);
        }
        for (j = 0; j < mg2mnum; j++) {
          transferredDataSet.push(data2[i * mg2mnum + j]);
        }
      }
    } else {
      if (data1) {
        for (i = 0; i < data1.length; i++) {
          transferredDataSet.push(data1[i]);
        }
      }
      if (data2) {
        for (i = 0; i < data2.length; i++) {
          transferredDataSet.push(data2[i]);
        }
      }
    }

    var stackedBarGroup = [];
    // the number of bar in each group
    var barGroupNumber;
    if (data1.length !== 0) {
      barGroupNumber = data1[0].length;
    } else {
      barGroupNumber = data2[0].length;
    }
    for ( j = 0; j < barGroupNumber; j++) {
      var ds = [];
      for (i = 0; i < transferredDataSet.length; i++) {
        ds.push(transferredDataSet[i][j]);
      }
      stackedBarGroup.push(ds);
    }

    return stackedBarGroup;
  };

  return tooltipDataHandler;
});sap.riv.module(
{
  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.2'
}
],
function Setup(constants) {
    var ColorSeriesGenerator = {
      /**
       * return d3 ordinal scale of sap standard color palette 
       */
      sap32 : function(){
      return d3.scale.ordinal().range(constants.SAPColorSingleAxis);
      },
      sap32dualaxis1 : function(){
            return d3.scale.ordinal().range(constants.SAPColorDualAxis1);
        },
        sap32dualaxis2 : function(){
            return d3.scale.ordinal().range(constants.SAPColorDualAxis2);
        }      
    };

    return ColorSeriesGenerator;
});sap.riv.module(
{
  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'},
[

],

function Setup() {
    
    var Scaler = {


        getRoughTickNum : function (_scale, _roughTickNum) 
        {
            var const_minTickNum = 2;
            var roughTickNum = -1;

            if(!_roughTickNum || _roughTickNum < const_minTickNum) {
                var rangeArray = _scale.range();
                var rangeLen = Math.abs(rangeArray[0] - rangeArray[rangeArray.length-1]);
                if(rangeLen > 10) {
                    roughTickNum = const_minTickNum + Math.round(rangeLen/100);
                } else {
                    roughTickNum = const_minTickNum;
                }
            } else {
                roughTickNum = _roughTickNum;
            }
            _scale.tickHint = roughTickNum;
            return roughTickNum;
        },
		
        toFixedNumber : function(item)
        {
            if((typeof item) === "object" && item.length)
            {
                for(var i = 0; i <= (item.length - 1); i++)
                {
                    if((typeof item[i]) === "number")
                    {
                        item[i] = parseFloat(item[i].toFixed(8));
                    }
                }
            }
            else if((typeof item) === "number")
            {
                item = parseFloat(item.toFixed(8));
            }
            return item;
        },		
        
        /**
         * @param _scale
         *        d3 quantitative scale
         *                
         * @param _roughTickNum
         *        rough tick number
         *                
         * @param _accurateTickNum
         *        accurate tick number
         *
         * @returns d3 quantitative scale which can be divided by ticks perfectly
         */
        perfect : function(_scale, _roughTickNum, _accurateTickNum)
        {
            var qScale = _scale.nice();

            //the function may change the domain, but never change the range.
            var const_minTickNum = 2;
            var const_extendNum = 100;

            var domainArray = _scale.domain();
            domainArray = this.toFixedNumber(domainArray);

            var originalDomainBegin = domainArray[0];
            var originalDomainEnd = domainArray[domainArray.length-1];

            //if the domain is [0,0], we change it to [0,100]
            //if the domain is [-x,-x], we change it to [-x,0]
            //if the domain is [x,x], we change it to [x,0]
            //we do this in modules
            var roughTickNum = -1;
            var accurateTickNum = -1;

            if(!_accurateTickNum || _accurateTickNum < const_minTickNum) {
                roughTickNum = this.getRoughTickNum(_scale, _roughTickNum);
            } else {
                accurateTickNum = _accurateTickNum;
            }

            if(accurateTickNum < 0)
            {
                var ticks = qScale.ticks(roughTickNum);
                ticks = this.toFixedNumber(ticks);

                var adjustDomain = true;
                var distance;
                if(ticks.length === 0)
                {
                    adjustDomain = false;
                }
                else if(ticks.length > 1)
                {
                    distance = ticks[1] - ticks[0];//>0
                }
                else//ticks.length==1
                {
                    var beginDis = Math.abs(domainArray[0] - ticks[0]);//>0
                    var endDis = Math.abs(domainArray[domainArray.length - 1] - ticks[0]);//>0
                    if(beginDis > endDis)
                    {
                        distance = beginDis;
                    }
                    else
                    {
                        distance = endDis;
                    }
                }
                
                var realTickNum = const_minTickNum;
                if(adjustDomain)
                {
                    realTickNum = ticks.length;
                    if(domainArray[0] < domainArray[1])
                    {
                        if(ticks[0] != domainArray[0])
                        {
                            domainArray[0] = ticks[0] - distance;
                            realTickNum++;
                        }

                        if(ticks[ticks.length -1] != domainArray[domainArray.length - 1])
                        {
                            domainArray[domainArray.length - 1] = ticks[ticks.length - 1] + distance;
                            realTickNum++;
                        }
                    }
                    else
                    {
                        if(ticks[0] != domainArray[domainArray.length - 1])
                        {
                            domainArray[domainArray.length - 1] = ticks[0] - distance;
                            realTickNum++;
                        }

                        if(ticks[ticks.length -1] != domainArray[0])
                        {
                            domainArray[0] = ticks[ticks.length - 1] + distance;
                            realTickNum++;
                        }
                    }
                }

                qScale.tickNum = realTickNum;
                qScale.distance = distance;
                qScale.tickHint = realTickNum - 1;

                //to nice the domainArray, avoid the domain contains 0.00060000001
                domainArray[0] = this.toFixedNumber(domainArray[0]);
                domainArray[domainArray.length - 1] = this.toFixedNumber(domainArray[domainArray.length - 1]);
                qScale.domain(domainArray);
                
            }
            else
            {
                //accurateTickNum:
                //1. use it as roughTickNum. 
                //2. adjust the ticNum or not
                this.perfect(qScale, accurateTickNum);
                if(qScale.tickNum > accurateTickNum)
                {
                    //try to make sure qScale.tickNum < accurateTickNum
                    var tempNum = accurateTickNum;
                    for(;tempNum >= const_minTickNum;)
                    {
                        tempNum--;
                        this.perfect(qScale, tempNum);
                        if(qScale.tickNum <= accurateTickNum)
                        {
                            break;
                        }
                    }
                }
                
                //adjust the domain
                if(qScale.tickNum < accurateTickNum)
                {
                    var tickNumToAdd = (accurateTickNum - qScale.tickNum);
                    var domainArray = qScale.domain();
                    //var originalDomainBegin 
                    //var originalDomainEnd

                    for(;tickNumToAdd > 0;)
                    {
                        if(domainArray[0] < domainArray[1])
                        {
                            if(Math.abs(domainArray[1] - originalDomainEnd) > Math.abs(originalDomainBegin - domainArray[0]))
                            {
                                domainArray[0] -= qScale.distance;
                            }
                            else
                            {
                                domainArray[1] += qScale.distance;
                            }
                            tickNumToAdd--;
                            qScale.tickNum++;
                        }
                        else
                        {
                            if(Math.abs(domainArray[1] - originalDomainEnd) > Math.abs(originalDomainBegin - domainArray[0]))
                            {
                                domainArray[0] += qScale.distance;
                            }
                            else
                            {
                                domainArray[1] -= qScale.distance;
                            }
                            tickNumToAdd--;
                            qScale.tickNum++;
                        }
                    }
                    
                    qScale.tickHint = qScale.tickNum - 1;
                    //to nice the domainArray, avoid the domain contains 0.00060000001
                    domainArray[0] = parseFloat(domainArray[0].toFixed(8));
                    domainArray[domainArray.length - 1] = parseFloat(domainArray[domainArray.length - 1].toFixed(8));
                    qScale.domain(domainArray);
                    
                }
            }

            return qScale;
        },
        
        /**
         * @param _scaleA
         *        d3 linear scale
         *                
         * @param _scaleB
         *        d3 linear scale
         */
        perfectDual : function(_scaleA, _scaleB) {

            this.perfect(_scaleA);
            this.perfect(_scaleB);
            
            var domainArrayA = _scaleA.domain();
            var domainArrayB = _scaleB.domain();

            var rangeArrayA = _scaleA.range();
            var rangeArrayB = _scaleB.range();

            if( (domainArrayA[0] > domainArrayA[domainArrayA.length-1]
                && domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                ||
                (domainArrayA[0] < domainArrayA[domainArrayA.length-1]
                && domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                ||
                (domainArrayA[0] < 0
                && domainArrayA[domainArrayA.length-1] < 0)
                ||
                (domainArrayB[0] < 0
                && domainArrayB[domainArrayB.length-1] < 0)
                ||
                (domainArrayA[0] > 0
                && domainArrayA[domainArrayA.length-1] > 0)
                ||
                (domainArrayB[0] > 0
                && domainArrayB[domainArrayB.length-1] > 0)
                || 
                ( Math.abs(rangeArrayA[0] - rangeArrayA[rangeArrayA.length-1])
                != Math.abs(rangeArrayB[0] - rangeArrayB[rangeArrayB.length-1]) )
              )
            {
                //we do not need to do anythings to support this "dual"
                return;
            }

            //now make sure 
            //1. same tickNum before 0
            //2. same tickNum after 0
            var positiveTickNumA = 0;
            var negativeTickNumA = 0;

            var positiveTickNumB = 0;
            var negativeTickNumB = 0;

            var tickNumA = _scaleA.tickNum; //tickNumA >= const_minTickNum
            var tickNumB = _scaleB.tickNum; //tickNumB >= const_minTickNum

            var intervalA = (domainArrayA[domainArrayA.length-1] - domainArrayA[0])/(tickNumA-1);
            intervalA = parseFloat(intervalA.toFixed(8));

            for(var i = 0; i < tickNumA; i++)
            {
                var tickValue = domainArrayA[0] + i * intervalA;
                if(tickValue > 0)
                {
                    positiveTickNumA++;
                }
                else if(tickValue < 0)
                {
                    negativeTickNumA++;
                }
            }

            var intervalB = (domainArrayB[domainArrayB.length-1] - domainArrayB[0])/(tickNumB-1);
            intervalB = parseFloat(intervalB.toFixed(8));

            for(var i = 0; i < tickNumB; i++)
            {
                var tickValue = domainArrayB[0] + i * intervalB;
                if(tickValue > 0)
                {
                    positiveTickNumB++;
                }
                else if(tickValue < 0)
                {
                    negativeTickNumB++;
                }
            }

            if(positiveTickNumA > positiveTickNumB)
            {
                var moreInterNum = positiveTickNumA - positiveTickNumB;
                if(domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[domainArrayB.length-1] += (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
                else if(domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[0] += (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
            }
            else if(positiveTickNumA < positiveTickNumB)
            {
                var moreInterNum = positiveTickNumB - positiveTickNumA;
                if(domainArrayA[0] < domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[domainArrayA.length-1] += (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
                else if(domainArrayA[0] > domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[0] += (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
            }

            //negative values
            if(negativeTickNumA > negativeTickNumB)
            {
                var moreInterNum = negativeTickNumA - negativeTickNumB;
                if(domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[0] -= (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
                else if(domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[domainArrayB.length-1] -= (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
            }
            else if(negativeTickNumA < negativeTickNumB)
            {
                var moreInterNum = negativeTickNumB - negativeTickNumA;
                if(domainArrayA[0] < domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[0] -= (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
                else if(domainArrayA[0] > domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[domainArrayA.length-1] -= (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
            }

            //to nice the domainArray, avoid the domain contains 0.00060000001
            domainArrayA[0] = parseFloat(domainArrayA[0].toFixed(8));
            domainArrayA[1] = parseFloat(domainArrayA[1].toFixed(8));
            domainArrayB[0] = parseFloat(domainArrayB[0].toFixed(8));
            domainArrayB[1] = parseFloat(domainArrayB[1].toFixed(8));
            
            _scaleA.domain(domainArrayA);
            _scaleB.domain(domainArrayB);

            _scaleA.tickHint = _scaleA.tickNum -1;
            _scaleB.tickHint = _scaleB.tickNum -1;
        }
    };
    
    return Scaler;
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'},
[

],
function Setup() 
{

  return function(data) 
  {
    var dataset1;
    var dataset2;
    var hasMND = false;
    var bMNDOnColor = true;
    var bMNDInner = false; 
    var bDualAxis = false;
    var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
    var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
    var regionColorFeed = data.getAnalysisAxisDataByIdx(1);
    var categoryFeed = data.getAnalysisAxisDataByIdx(0);

    if((measureFeed2 && measureFeed2.values && measureFeed2.values.length > 0))
    {
      bDualAxis = true;
    }
    if(categoryFeed && categoryFeed.values && categoryFeed.values.length > 0)
    {
      if (categoryFeed.values[0].type === 'MND')
      {
        hasMND = true;
        bMNDOnColor = false;
        bMNDInner = false;
      }else if(categoryFeed.values[categoryFeed.values.length - 1].type === 'MND')
      {
        hasMND = true;
        bMNDOnColor = false;
        bMNDInner = true;
      }
    }

    if(regionColorFeed && regionColorFeed.values && regionColorFeed.values.length > 0)
    {
      if(regionColorFeed.values[0].type === 'MND')
      {
        hasMND = true;
        bMNDInner = false;
      }else if(regionColorFeed.values[regionColorFeed.values.length - 1].type === 'MND')
      {
        hasMND = true;
        bMNDInner = true;
      }
    }

    // MND on axis label
    function processOneAxisValue(feed)
    {
      var dataset = [];
      var i, j, k;
      var measureData;
      if (feed.values.length <= 0){
        return dataset;
      }
      if (hasMND && !bMNDOnColor)
      {
        for(j = 0; j < feed.values[0].rows.length; ++j)
        {    
          measureData = new Array(feed.values.length * feed.values[0].rows[0].length);
          for(k = 0; k < feed.values[0].rows[0].length; ++k)
          {
            for(i = 0 ; i < feed.values.length; ++i)
            {
              var dataPoint = {};
              dataPoint.val = feed.values[i].rows[j][k].val;
              dataPoint.ctx = feed.values[i].rows[j][k].ctx;
              dataPoint.info = feed.values[i].rows[j][k].info;
              if(bMNDInner){
                measureData[k * feed.values.length + i] = dataPoint;
              } else {
                measureData[i * feed.values[0].rows[0].length + k] = dataPoint; 
              }
            }
          }
          dataset.push(measureData);
        }  
      }
      else // MND on Region color or no MND
      {
        dataset = new Array(feed.values.length * feed.values[0].rows.length);

        for(i = 0 ; i < feed.values.length; ++i)
        {
          for(j = 0; j < feed.values[0].rows.length; ++j)
          {    
            measureData = feed.values[i].rows[j];
            if(!hasMND || !bMNDInner){
              dataset[i * feed.values[0].rows.length + j] = measureData;
            } else {
              dataset[j * feed.values.length + i] = measureData;
            }
          }
        }
      }

      return dataset;
    }

    function addOneMeasure(dataset, measure)
    {
      for(var i = 0; i < measure.length; ++i)
      {
        dataset[i] = dataset[i].concat(measure[i]);
      }
    }

    function mergeTwoAxis(result)
    {
      var colors = [];
      var measure1Num = measureFeed1.values.length;
      var measure2Num = measureFeed2.values.length;
      var columnNum  = measureFeed1.values[0].rows[0].length;
      var dataset = new Array(measureFeed1.values[0].rows.length); 
      var curColumn = 0;
      var i,j,k;
      for(i = 0; i < dataset.length; ++i){
        dataset[i] = [];
      }
      if(bMNDInner){
        var rowNum = measureFeed1.values[0].rows.length;
        for(i = 0; i < columnNum; ++i)
        {

          for(j = 0; j < measure1Num; ++j)
          {
            for(k = 0; k < rowNum; ++k){
              dataset[k][curColumn] = measureFeed1.values[j].rows[k][i];
            }
            colors[curColumn] = 0;
            ++curColumn;
          }
          for(j = 0; j < measure2Num; ++j)
          {
            for(k = 0; k < rowNum; ++k){
              dataset[k][curColumn] = measureFeed2.values[j].rows[k][i];
            }
            colors[curColumn] = 1;
            ++curColumn;
          }
        }
      }else{
        for(i = 0; i < measure1Num; ++i)
        {
          for(j = 0; j < columnNum; ++j)
          {
            colors[curColumn++] = 0; 
          }
          addOneMeasure(dataset, measureFeed1.values[i].rows);
        }
        for(i = 0; i < measure2Num; ++i)
        {
          for(j = 0; j < columnNum; ++j)
          {
            colors[curColumn++] = 1; 
          }
          addOneMeasure(dataset, measureFeed2.values[i].rows);
        }
      }
      result['MG1'] = dataset;
      result["MG1Number"] = measureFeed1.values.length;
      result['color'] = colors;
    }

    var result = {};

    if(bDualAxis && !bMNDOnColor)
    {
      mergeTwoAxis(result);
    }else{
      dataset1 = processOneAxisValue(measureFeed1);
      result["MG1Number"] = measureFeed1.values.length;
      if(bDualAxis){
        dataset2 = processOneAxisValue(measureFeed2);
        result["MG2Number"] = measureFeed2.values.length;
      }
      result["MG1"] = dataset1;
      result["MG2"] = dataset2;
    }
    result["hasMND"] = hasMND;
    result["MNDOnColor"] = bMNDOnColor;
    result['MNDInner'] = bMNDInner;
    return result;

  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.area',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(dataUtil, dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, ObjectUtils, Objects,UADetector, BoundUtil, defaultSelUtil) 
{
  return function(manifest, ctx) 
  {
    var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint";

    var width, height;
    var data_ = null, props;
    //alistar zhu
    var randomSuffix = ObjectUtils.guid();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";

    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgAreasGroup, svgAreaBgGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        areas:[],
        bottomValue: null,
        topValue:null,
        drawData:null
    };
    var areaShapeLine = null;
  
    var colorPalette = [];
    var bAnimationComplete = false;
 
    var selectedMarkerNum = 0;
    var gSelection = null;

    // clip defs for enimation

    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false, hasDefaultSelection = false;
    
    var clipRect;
    
    var OPACITY = 0.4;
    
    var bDataUpdated = false;
    
    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(isDataLoading){
        hasAnmation = props.animation.dataLoading;
      }else if(isDatasetChanged){
        hasAnmation = props.animation.dataUpdating;
      }else if(isSizeChanged){
        hasAnmation = props.animation.resizing;
      }
      return hasAnmation;
    }

    function area(selection) {
      //selection.each(generate);
      BoundUtil.drawBound(selection, width, height);
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return area;
    }

   // For normal stacked area chart, currently we only use globally stacked 
//    function calculateStackedMinMax(axisValue, minMax)
//    {
//    
//      var accuPositiveValues = new Array(axisValue.data[0].length);
//      var accuNegativeValues = new Array(axisValue.data[0].length);
//      var i;
//      for(i = 0; i < accuPositiveValues.length; ++i)
//      {
//        accuPositiveValues[i] = 0;
//        accuNegativeValues[i] = 0;
//      }
//      for(i = 0; i < axisValue.data.length; ++i)
//      {
//        for(var j = 0; j < axisValue.data[i].length; ++j)
//        {
//          if(!NumberUtils.isNoValue(axisValue.data[i][j].val))
//          {
//            if(axisValue.data[i][j].val >= 0)
//            {
//              accuPositiveValues[j] += axisValue.data[i][j].val ;
//            } else {
//              accuNegativeValues[j] += axisValue.data[i][j].val ;
//            }
//          }
//        }
//      }
//      minMax.max = d3.max(accuPositiveValues);
//      minMax.min = d3.min(accuNegativeValues);
//    }
    
    function calculateGloballyStackedMinMax(axisValue, minMax)
    {
    
      var accuValues = new Array(axisValue.data[0].length);
      var i;
      for(i = 0; i < accuValues.length; ++i)
      {
        accuValues[i] = 0;
      }
      for(i = 0; i < axisValue.data.length; ++i)
      {
        for(var j = 0; j < axisValue.data[i].length; ++j)
        {
          if(!NumberUtils.isNoValue(axisValue.data[i][j].val))
          {
              accuValues[j] += axisValue.data[i][j].val;
              if(minMax.min === null)
              {
                minMax.min = accuValues[j];
                minMax.max = accuValues[j];
              }else{
                minMax.min = minMax.min > accuValues[j] ? accuValues[j] : minMax.min;
                minMax.max = minMax.max > accuValues[j] ? minMax.max : accuValues[j];
              }
          }
        }
      }
    }


    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return minMax;}
      if(props.mode === "percentage"){
        minMax.min = 0;
        minMax.max = 1;
        return minMax;
      }
      /*  for normal stacked chart and non-stacked chart
     if(props.bStacked){
        calculateStackedMinMax(axisValue, minMax);
      }else{
        minMax.max = Number(d3.max(axisValue.data, function(d){
          return d3.max(d, function(_){ return _.val;});
        }));
        minMax.min = Number(d3.min(axisValue.data, function(d){
          return d3.min(d, function(_){ return _.val;});
        }));
      }
      */
      calculateGloballyStackedMinMax(axisValue, minMax);
      if(NumberUtils.isNoValue(minMax.max )) { return null;}
      
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / (props.orientation === "vertical" ? height :width) ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ (props.orientation === "vertical" ? height :width);
      }else{
        var temp = (minMax.max - minMax.min) * 5 / (props.orientation === "vertical" ? height :width);
        minMax.min -= temp;
        minMax.max += temp;
      }
      if(minMax.min === 0 && minMax.max === 0){
        minMax.max = 1;
      }
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      valueAxis1Data.colorPalette = props.colorPalette;
      for(i = 0; i < valueAxis1Data.data.length; ++i)
      {
      colorPalette.push(valueAxis1Data.colorPalette[i% valueAxis1Data.colorPalette.length]);
      }
    }

    function calculateScale(axisValue)
    {
       var range = (props.orientation === "vertical" ? [height, 0] : [0,width])
      if(axisValue.data && axisValue.data.length > 0)
      { 
        if(axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          if(!minMax) {
            axisValue.scale.domain([0, 1]).range (range);
          }
          else  {
            axisValue.scale.domain([minMax.min, minMax.max]).range(range);
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range(range);
        }
        if (!axisValue.manualRange) {
            Scaler.perfect(axisValue.scale);
        } else {
            Scaler.getRoughTickNum(axisValue.scale);
        }
      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      if(!(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)))
      {
        return;
      }
      var domain = [];
      var categoryNum = valueAxis1Data.data[0].length;
     
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands(props.orientation === "vertical" ? [0, width] :[height, 0]);
      calculateScale(valueAxis1Data);
    }

    function changeGroupMarker(groupIndex, visible, className)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }
      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis1Data);
        }
      }
    }
    
    function changeOneArea(seriesIndex, xIndex, valueAxis, visible)
    {
      if(!valueAxis.areas[seriesIndex])
      {
        valueAxis.areas[seriesIndex] = [];  
      }
      if(!valueAxis.areas[seriesIndex][xIndex] && visible === "visible")
      {
        valueAxis.areas[seriesIndex][xIndex] = svgAreasGroup.append("svg:path")
        .attr("d", areaShapeline(valueAxis.drawData.data[seriesIndex][xIndex])).attr("stroke", function (){
           var para = { graphType:"line", 
             fillColor:valueAxis.colorPalette[seriesIndex %  valueAxis.colorPalette.length]};
             return effectManager.register(para);
           }).attr("stroke-width", 1).attr("fill",  function (){
           var para = { 
                drawingEffect:props.drawingEffect,
                graphType:"rectangle", 
                direction : props.orientation,
                fillColor:valueAxis.colorPalette[seriesIndex %  valueAxis.colorPalette.length]};
                return effectManager.register(para);
           });
      }
      if(valueAxis.areas[seriesIndex][xIndex])
      {
        valueAxis.areas[seriesIndex][xIndex].attr("visibility", visible);
      }
    }
    
    function changeOneMarker(seriesIndex, xIndex, className, valueAxis)
    {
      var stroke, tempOpacity;

      if (className === CLASSMARKERSELECTED) {
        stroke = selectedColor;
        tempOpacity = 1;
        changeOneArea(seriesIndex, xIndex, valueAxis, "visible");
        valueAxis.selectedMarkers[seriesIndex][xIndex] = true;
      } else {
        changeOneArea(seriesIndex, xIndex, valueAxis, "hidden");
        valueAxis.selectedMarkers[seriesIndex][xIndex] = false;
        if(selectedMarkerNum > 0) {
            tempOpacity = OPACITY;
        } else {
            tempOpacity = 1;
        }
        
        if (className === CLASSMARKERHOVER) {
            stroke = bgColor;
        } else {
            stroke = "transparent";
            if (props.marker.visible === false) {
                tempOpacity = 0;
        }
        }
      }
  
      d3.select(valueAxis.markers[seriesIndex][xIndex])
        .attr("class", CLASSDATAPOINT + ' ' + className).attr("stroke", stroke).attr("opacity", tempOpacity);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      categoryNum = valueAxis1Data.data[0].length;
      if(index > categoryNum - 1) {index = categoryNum - 1;}
      if(index < 0) { index = 0;}
      return (props.orientation === "vertical" ? index : categoryNum - 1 - index);
    }

    function processOneAxisSelect(valueAxis, marker) {
      svgAreaBgGroup.selectAll(".v_areabg").attr("opacity", OPACITY).attr("stroke-opacity", OPACITY);

      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }
      ++selectedMarkerNum;
      changeOneMarker(yi, xi, CLASSMARKERSELECTED, valueAxis);
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, CLASSMARKERHOVER, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, "", valueAxis);
      }
    }
    
//    function processNullValue(axisValue)
//    {
//      var result = {
//          data:[],
//          color:[]
//      };
//      var arr = [];
//      var k;
//      var obj = {};
//      for(var i = 0; i < axisValue.length; ++i)
//      {
//        var preIndex = 0;
//        for(var j = 0; j < axisValue[i].length; ++j)
//        {
//          if(NumberUtils.isNoValue(axisValue[i][j].val))
//          {
//            if(j > preIndex)
//            {
//              arr = [];
//              arr.push({x:preIndex, y:0});
//              for(k = preIndex; k < j; k++)
//              {
//                obj = {};
//                obj.y = axisValue[i][k].val;
//                obj.x = k;  
//                arr.push(obj);
//              }
//              arr.push({x:k-1, y:0});
//              result.data.push(arr);
//              result.color.push(i);
//             }
//             preIndex = j + 1;
//           }
//        }
//        
//        if(preIndex < axisValue[i].length)
//        {
//          arr = [];
//          arr.push({x:preIndex, y:0});
//          for(k = preIndex; k <  axisValue[i].length; k++)
//          {
//            obj = {};
//            obj.y = axisValue[i][k].val;
//            obj.x = k;
//            arr.push(obj);
//          }
//          arr.push({x:k-1, y:0});
//          result.data.push(arr);
//          result.color.push(i);
//        }
//      }
//      return result;
//    }
//    
//    // for normal stacked area chart, currently not used
//    function generateAreaData(axisValue)
//    {
//      var result = {
//          data:[],
//          color:[],
//          accuPositiveVal:[],
//          accuNegativeVal:[]
//      };
//      var arr = [];
//      var i;
//      var topAreaData = [];
//      var bottomAreaData = [];
//      //generate area for all series
//      for(i = 0; i < axisValue.length; ++i)
//      {
//        result.accuPositiveVal[i] = new Array(axisValue[i].length);
//        result.accuNegativeVal[i] = new Array(axisValue[i].length);
//        for(var j = 0; j < axisValue[i].length; ++j)
//        {
//          result.accuPositiveVal[i][j] = (i > 0 ? result.accuPositiveVal[i-1][j] : 0);
//          result.accuNegativeVal[i][j] =  (i > 0 ? result.accuNegativeVal[i-1][j] : 0);
//          if(!NumberUtils.isNoValue(axisValue[i][j].val))
//          {
//            if(axisValue[i][j].val >= 0)
//            {
//              bottomAreaData.push({x:j, y:result.accuPositiveVal[i][j]});
//              result.accuPositiveVal[i][j] += axisValue[i][j].val ;
//              topAreaData.push({x:j, y: result.accuPositiveVal[i][j]});
//              
//            } else if(axisValue[i][j].val < 0){
//              topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              result.accuNegativeVal[i][j] += axisValue[i][j].val ;
//              bottomAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//            } 
//            
//            } else {
//            if(j > 0 && !NumberUtils.isNoValue(axisValue[i][j-1].val) )
//            {
//              if(axisValue[i][j - 1].val >= 0)
//              {
//                topAreaData.push({x:j, y: result.accuPositiveVal[i][j]});
//              } else {
//                topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              }
//              topAreaData = topAreaData.concat(bottomAreaData.reverse());
//              result.data.push(topAreaData);
//              result.color.push(i);
//              topAreaData = [];
//              bottomAreaData = [];
//            }
//            
//            if( j < axisValue[i].length - 1 &&  !NumberUtils.isNoValue(axisValue[i][j+1].val))
//            {
//              if(axisValue[i][j+1].val >= 0)
//              {
//                topAreaData.push({x:j, y:result.accuPositiveVal[i][j]});
//              }else{
//                topAreaData.push({x:j, y:result.accuNegativeVal[i][j]});
//              }
//            }
//          }
//        }
//        
//        if(topAreaData.length > 0)
//        {
//          topAreaData = topAreaData.concat(bottomAreaData.reverse());
//          result.data.push(topAreaData);
//          result.color.push(i);
//          topAreaData = [];
//          bottomAreaData = [];
//        }
//      }
//      return result;
//    }

    function generateGloballyStackedAreaData(axisValue)
    {
      var data = axisValue.data;
      var result = {
          data:[],   // store data for each point which use to highlight one area 
          bgAreaData:[], // draw area background region
          accuVal:[]  // accumulated values for stacked area
      };
      var i , j;
      var topAreaData = [];
      var bottomAreaData = [];
   
      // speical process for percentage chart, divide regions for zero values
      var groupValueNumbers = new Array(data[0].length);
      if(props.mode === "percentage" && bDataUpdated)
      {
        turnToPercentage(data);
        bDataUpdated = false;
      }
      
      for( i = 0; i < groupValueNumbers.length; ++i)
      {
        groupValueNumbers[i] = 0;
      }
      result.bgAreaData = new Array(data.length);
      for(i = 0; i < data.length; ++i)
      {     
        result.bgAreaData[i] = [];
        result.accuVal[i] = new Array(data[i].length);
        for( j = 0; j < data[i].length; ++j)
        {
          result.accuVal[i][j] = (i > 0 ? result.accuVal[i-1][j] : 0);
          if(!NumberUtils.isNoValue(data[i][j].val))
          {
            groupValueNumbers[j] ++;
            result.accuVal[i][j] += (props.mode === "percentage" ? Math.abs(data[i][j].val) : data[i][j].val);
          }
        }
      }
      
      // generate background area shape
      for(i = 0; i < data.length; ++i)
      {
        for(j = 0; j < data[i].length; ++j)
        {      
          if(!NumberUtils.isNoValue(data[i][j].val))
          {
            // there are 0 values in group and group contain 0 and null value only 
              bottomAreaData.push({x:j, y: ( i > 0 ? result.accuVal[i - 1][j] : 0)});
              topAreaData.push({x:j, y: result.accuVal[i][j]});
          } else {
            if(groupValueNumbers[j] > 0)
            {
              if(j > 0 && !NumberUtils.isNoValue(data[i][j-1].val) )
              {
                topAreaData.push({x:j, y: result.accuVal[i][j]}); 
                topAreaData = topAreaData.concat(bottomAreaData.reverse());
                result.bgAreaData[i].push(topAreaData);
                topAreaData = [];
                bottomAreaData = [];
              }

              if( j < data[i].length - 1 &&  !NumberUtils.isNoValue(data[i][j+1].val))
              {
                topAreaData.push({x:j, y:result.accuVal[i][j]});
              }
            }else if(topAreaData.length > 0)
            {
              topAreaData = topAreaData.concat(bottomAreaData.reverse());
              result.bgAreaData[i].push(topAreaData);
              topAreaData = [];
              bottomAreaData = [];
            }
          }         
        }

        if(topAreaData.length > 0)
        {
          topAreaData = topAreaData.concat(bottomAreaData.reverse());
          result.bgAreaData[i].push(topAreaData);
          topAreaData = [];
          bottomAreaData = [];
        }
      }
      
      
      // generate path for every point's area
      var element = {};
      for(i = 0; i < data.length; ++i)
      {
        result.data[i] = [];
        for(j = 0; j < data[i].length; ++j)
        {  
            if( j > 0 )
            {
               if( groupValueNumbers[j - 1] > 0)
               {
                 topAreaData.push({x: j - 0.5, y : (result.accuVal[i][j - 1] + result.accuVal[i][j]) / 2});
                 bottomAreaData.push({x : j - 0.5, y: (i > 0 ? ((result.accuVal[i - 1][j - 1] + result.accuVal[i - 1][j]) / 2) : 0)});
               }
            }
            topAreaData.push({x: j, y : result.accuVal[i][j]});
            bottomAreaData.push({x :j, y: ( i > 0 ? result.accuVal[i - 1][j] : 0)});
            if(j < data[0].length - 1)
            {
              if( groupValueNumbers[j + 1] > 0)
              {
                topAreaData.push({x: j + 0.5, y : (result.accuVal[i][j] + result.accuVal[i][j + 1]) / 2});
                bottomAreaData.push({x : j + 0.5, y: (i > 0 ? ((result.accuVal[i - 1][j] + result.accuVal[i - 1][j + 1]) / 2) : 0)});
              }
            }
            topAreaData = topAreaData.concat(bottomAreaData.reverse());
            result.data[i].push(topAreaData);
            topAreaData = [];
            bottomAreaData = [];
            
        }
      }
      axisValue.drawData = result;
      return result;
    }
    
    
    function processOneAxis(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var result = generateGloballyStackedAreaData(axisValue);
      // for normal stacked and non-stacked
//      if(props.bStacked){
//        result = generateAreaData(axisValue.data);
//      } else {
//        result = processNullValue(axisValue.data);
//      }


      var areas = svgAreaBgGroup.selectAll("." + "v-areagroup").data(result.bgAreaData);
      areas.enter().append("svg:g").attr("class", "v-areagroup");
      areas.exit().remove();
      // draw area chart
      var line = (props.orientation === "vertical" ?  d3.svg.line().x(function(d,i) { return xScale(d.x) + xScale.rangeBand(
) / 2; }).
      y(function(d) {  return axisValue.scale(d.y); }) :
      d3.svg.line().y(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).
      x(function(d) {  return axisValue.scale(d.y); }));
      areas.attr("transform", 
          function(d, i) {
            var areaShapes = d3.select(this).selectAll(".v-areabg").data(d);
            areaShapes.enter().append("svg:path").attr("stroke-linejoin", "round").attr("class", "v-areabg").attr("opacity", 1).attr("stroke-opacity", 1);
            areaShapes.exit().remove();
            areaShapes.attr("transform", function(areapath, index)
            {
            d3.select(this).attr("d", line(areapath)).attr("stroke", function (){
              var para = { graphType:"line", 
                  fillColor:axisValue.colorPalette[i %  axisValue.colorPalette.length]};
                  return effectManager.register(para);
                  })
            .attr("stroke-width", 1)
            .attr("fill",  function (){
                var para = { 
                  drawingEffect:props.drawingEffect,
                  graphType:"rectangle", 
                  direction : props.orientation,
                  fillColor:axisValue.colorPalette[i %  axisValue.colorPalette.length]};
                  return effectManager.register(para);
                });
            });
      });
      
      areaShapeline = ( props.orientation === "vertical" ? d3.svg.line().x(function(d,i) { return (d.x + 0.5) * xScale.rangeBand();})
      .y(function(d) {  return axisValue.scale(d.y); }) :
      d3.svg.line().y(function(d,i) { return height - (d.x + 0.5) * xScale.rangeBand();}).
      x(function(d) {  return axisValue.scale(d.y); }));
      axisValue.areas = [];
      svgAreasGroup.selectAll(".v-areashape").remove();
      
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
 
      var groups = svgMarkersGroup.selectAll("g.v-marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "v-marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible){
        visible  = "visible";
      }
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".v-datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','v-datashape');
        DrawUtil.createElements(datashape,{shape: props.marker.shape, className: CLASSDATAPOINT} );
        seriesMarkers.exit().remove();
        markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(d3.select(this).selectAll('path').node());
        
          var parameter = {
              drawingEffect:props.drawingEffect,
              graphType: props.marker.shape,
              fillColor : axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction : 'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              strokeOpacity: 0.3,
              node:d3.select(this).select('path'),
              visibility: visible
          };

          DrawUtil.drawGraph(parameter, effectManager);
 
          return   props.orientation === "vertical"
           ? "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(result.accuVal[i][index]) + ")"
           :  "translate(" + axisValue.scale(result.accuVal[i][index]) + "," + (xScale(index) + xScale.rangeBand() / 2) + ")";
          
//         for non-stacked and normal stacked case
 //         if(props.bStacked)
 //         {
 //           return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val >= 0 ? result.accuPositiveVal[i][index] : result.accuNegativeVal[i][index]) + ")"; 
 //         } else {
 //            return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val) + ")";  
 //         }
        });

        axisValue.markers.push(markerArr); 
      });
    }

    function processOneAxisDeselectAll(valueAxis, xIndex)
    {
      if(!valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }

      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}

          (valueAxis.areas[seriesIndex][groupIndex]).attr("visibility", "hidden");
 
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERHOVER, valueAxis);
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, "", valueAxis);
          }
        }
      }
    }
    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }
    function deselectedAllHandler()
    {
      var event = getCurrentEvent();
      var xpoint =   props.orientation === "vertical" ? (event ? event.clientX : 0) - g.node().getBoundingClientRect().left 
      :(event ? event.clientY : 0) - g.node().getBoundingClientRect().top;
      var xIndex = getCategoryIndex(xpoint);
      selectedMarkerNum = 0;
      processOneAxisDeselectAll(valueAxis1Data, xIndex);
    }

    
    function renderChart(selection)
    {
      gSelection = selection;
      getCSSStyle();
      eDispatch.startToInit();
      if(!g){ g = selection.append("svg:g");}
      if(!svgMarkersGroup)
      {
        svgAreaBgGroup = g.append("svg:g").attr("class", "v-areasbg");
        svgAreasGroup = g.append("svg:g").attr("class", "v-areas");
        if(!mouseMoveLine) {mouseMoveLine = g.append("svg:line").attr("stroke", hoverColor).attr("class", "v-hoverline viz-plot-hoverline");}
        svgMarkersGroup = g.append("svg:g").attr("class", "v-markers v-datashapesgroup");
      }    
      if( props.orientation === "vertical" )
      {
        mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", height)
       .attr("stroke-width", 1)
       .attr("visibility", "hidden").attr("stroke-linejoin", "round");
      }else {
        mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", width).attr("y2", 0)
        .attr("stroke-width", 1).attr("stroke", hoverColor)
        .attr("visibility", "hidden").attr("shape-rendering", "crispEdges");
      }
      selectedMarkerNum = 0;
      lightAll();
      

      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
      if( props.orientation === "vertical" )
      {
        clipRect.attr("x", 0).attr("y", 0).attr("height", height).attr("width", 0 );
      }else{
        clipRect.attr("x", 0).attr("y",  height).attr("height", 0).attr("width", width);
      }

      svgAreaBgGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      
      //[21-Jan-2013 Nick] FIX BUG. Draw chart before 'initialized' event is fired out.
      processOneAxis(valueAxis1Data);
      if(enableAnimation()){
        if( props.orientation === "vertical" ){
        clipRect
          .attr("x", 0).attr("y", 0).attr("height", height).attr("width", 0).transition().duration(1000).attr("width", width
).each("end", function(){
          eDispatch.initialized();});
        } else
          {
          clipRect
          .attr("x", 0).attr("y", height).attr("height", 0).attr("width", width).transition().duration(1000)
          .attr("height", height).attr("y", 0).each("end", function(){
          eDispatch.initialized();});
          }
         
        }else{
          clipRect
          .attr("x", 0).attr("y", 0).attr("height", height).attr("width", width);

          svgMarkersGroup.attr("clip-path", null);
          svgAreaBgGroup.attr("clip-path", null);
          eDispatch.initialized();
         }

    }
    
    // turn to percentage for value axis
    function turnToPercentage(data)
    {
      
      if(data === null || data === undefined  || data[0].length === 0)
        return;
      
      var i = 0, j = 0;
      var groupSums = new Array(data[0].length);
      var zeroNumbers = new Array(data[0].length);
      for( i = 0; i < groupSums.length; ++i)
      {
        groupSums[i] = 0;
        zeroNumbers[i] = 0;
      }
      for(i = 0; i < data.length; ++i)
      {
        for(j = 0; j < data[i].length; ++j)
        {
          if(!NumberUtils.isNoValue(data[i][j].val))
          {
            groupSums[j] += Math.abs(data[i][j].val);
            if(data[i][j].val === 0)
            {
              ++zeroNumbers[j];
            }
          }
        }
      }
      
      for(i = 0; i < data.length; ++i)
      {
        for(j = 0; j < data[i].length; ++j)
        {
           data[i][j].value = data[i][j].val;
          if(!NumberUtils.isNoValue(data[i][j].val))
              {
                if(groupSums[j] > 0){
                  data[i][j].value = data[i][j].val;
                  data[i][j].val = data[i][j].val / groupSums[j];
                }else if(zeroNumbers[j] > 0){
                  data[i][j].val = 1 / zeroNumbers[j];
                }
              } 
        }
      }

    }
  

    function lightAll() {
      svgAreaBgGroup.selectAll(".v-areabg").attr("opacity", 1).attr("stroke-opacity", 1);
      svgAreasGroup.selectAll(".v-areashape").attr("visibility", "hidden");
      if (props.marker.visible === true) {
        tempopacity = 1;
      } else {
        tempopacity = 0;
      }      
      svgMarkersGroup.selectAll('.'+ CLASSMARKERSELECTED).attr("opacity", tempopacity).attr("class", CLASSDATAPOINT);
    }

    function grayAll() {
      svgAreaBgGroup.selectAll(".v-areabg").attr("opacity", OPACITY).attr("stroke-opacity", OPACITY);
      svgAreasGroup.selectAll(".v-areashape").attr("visibility", "hidden");
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = OPACITY;
      } else {
        tempopacity = 0;
      }
      svgMarkersGroup.selectAll('.'+ CLASSMARKERSELECTED).attr("class", CLASSDATAPOINT).attr("opacity", tempopacity);
    }
    
    function getCSSStyle() {
      if (!props.style){
        props.style = {};
      } 
      var cssDef;

      if (!props.style.marker){
        props.style.marker = {};
      }
      props.style.marker.stroke = "transparent";
     
      cssDef = ctx.styleManager.queryDefault('v-hoverline');
      if(cssDef)
      {
        if (cssDef['stroke']){
          hoverColor = cssDef['stroke'];
        }
      }
    }
    function resetDataRange(){
      valueAxis1Data.topValue = null;
      valueAxis1Data.bottomValue = null;
    }
    area.width = function(value) {
      if (!arguments.length){
        return width;
      }
      isSizeChanged = (!isSizeChanged && (value === width)) ? false : true;
      width = value;
      computeScales();
     
      return area;
    };
    
    area.height = function(value) {
      if (!arguments.length){
        return height;
      }
      isSizeChanged = (!isSizeChanged && (value === height)) ? false : true;
      height = value;
      computeScales();
      return area;
    };
    
    area.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    /*
     * get/set properties
     */
    area.properties = function(_) {
      if (!arguments.length){
        return props;
      } 
      Objects.extend(true, props, _);
      computeScales();
     // if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
     // if(props.width < 1 || props.width > 7) { props.width = 2; }
      props.marker.size = 4;
      props.marker.shape = "circle";

      createColorPalette();
      return area;
    };
    
    area.primaryAxisColor = function(){
          return null;
    };
        
        
    /**
     * get/set your event dispatch if you support event
     */
    area.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;}
      eDispatch = _;
      return area;
    };
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    area.data = function(value){
      if (!arguments.length){
        return data_;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(data_, value)){
        isDataSchemaChanged = true;
      }
      allDataIsNaN = true;
      bDataUpdated = true;
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      
      //[04-Mar-2013 Nick] Testify whether defaultselection
      var dataInfo = (valueAxis1Data.data.length === 0 ? valueAxis2Data.data[0][0] : valueAxis1Data.data[0][0]);
      if(dataInfo.info &&  dataInfo.info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      resetDataRange();
      
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      computeScales();
      createColorPalette();
      return area;        
    };
    
    area.dataLabel = function(_){};
      
      area.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined) {
                  title.push(titles.values[i].col);
                } else {
                  title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
     
    /**
     * get color palette
     */
    area.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };

    area.shapePalette = function(){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return area;
    };

    area.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return area;
    };

    area.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return area;

    };

    area.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis1Data.scale.domain()[0],
          max: valueAxis1Data.scale.domain()[1]
        };
      }
      if (range !== null) {
          valueAxis1Data.topValue = range.max;
          valueAxis1Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis1Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
            calculateScale(valueAxis1Data);
          }
      }
      return area;
    };

    area.parent = function() { 
      return gSelection;
    };

    /**
     * get/set size
     */
    area.size = function(w, h) {
      if (arguments.length === 0){
        return {
          width : area.width(),
          height : area.height()
        };
      }
      area.width(w).height(h);
      return area;
    };
    
    area.clear = function (gray) {
      deselectedAllHandler();
      var markers = [];
      if (gray === null || gray === undefined || gray === false){
        lightAll();
        markers.push(svgMarkersGroup.selectAll("g.v-marker").selectAll("."+CLASSDATAPOINT));
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gSelection, false, markers);
        }
      } else {
        grayAll();
      }
    };

    area.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        processOneAxisSelect(valueAxis1Data, marker );
      }
      
      svgMarkersGroup.selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, true, elementArray);
      }
    };

    area.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      selectedMarkerNum -= elementArray.length;
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        processOneAxisDeselect(valueAxis1Data, marker);
      }
      if(selectedMarkerNum === 0)
      {
        svgMarkersGroup.selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
      }
   
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, false, elementArray);
      }
    };
    
    area.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if (props.orientation === "vertical" ){
        if(point0 < 0 || point0 > width){
          return;
        }
      } else {
        if(point1 < 0 || point1 > height){
          return;
        }
      }

      var xIndex = getCategoryIndex(props.orientation === "vertical" ? point0 : point1);
      if(preHighLightIndex === xIndex) { return; }
      var xCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", "");
      changeGroupMarker(xIndex, "visible", CLASSMARKERHOVER);  

      preHighLightIndex = xIndex;


      if (props.hoverline.visible) {
        mouseMoveLine.attr( props.orientation === "vertical" ? "x1" : "y1", xCoord).attr(props.orientation === "vertical" ? "x2" : "y2", xCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }

      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        if(props.orientation === "vertical")
        {
          pt.x = xScale(xIndex) + xScale.rangeBand() / 2 + matrix.e;
          pt.y = height / 4 + matrix.f;
        } else {
          pt.x = width * 3 / 4 + matrix.e;
          pt.y = xCoord + matrix.f;
        }
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
          x : matrix.e,
          y : matrix.f,
          width : width,
          height : height
        };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }

    };

    area.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", "");
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    area.dataLabel = function(_){};
    
    props = manifest.props(null);
    return area;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.area',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.area',
    'name' : 'area',
     base : 'sap.viz.modules.xy.base',
    'properties' : {
    'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'mode' : {
        'name' : 'mode',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'comparison', 'percentage' ],
        'defaultValue' : 'comparison',
        'description' : 'Set dispaly mode of area chart.',
         'isExported' : false
      },
      'orientation' : {
        'name' : 'orientation',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'vertical', 'horizontal' ],
        'defaultValue' : 'vertical',
        'description' : 'vertical or horizontal area chart.',
        'isExported' : false
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for tooltip related properties.'
     },
      'hoverline' : {
          'name' : 'hoverline',
          'supportedValueType' : 'Object',
          'description' : 'Settings for hoverline properties.',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set to enabled/disabled hoverline or not.'
            }
          }
      },
      'marker' : {
        'name' : 'marker',
      'description': 'Settings for marker/data point graphics',
        'supportedValueType' : 'Object',
        'isExported' :false,
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set show marker or not.',
            'isExported' :false
          },
          'shape' : {
            'name' : 'shape',
            'supportedValueType' : 'List',
            'supportedValues' : ['circle', 'diamond', 'triangleUp', 'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection'],
            'defaultValue' : 'circle',
            'description' : 'Set marker shapes for chart.'
          },
          'size' : {
            'name' : 'size',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : "4",
            'min' : '4',
            'max' : '32',
            'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 4.'
          }
        }
      }
    },
    'css' : {
     
        '.viz-plot-hoverline.v-hoverline': {
          'description' : 'Define style for hoverline in line.',
          'value' : {
            'stroke' : '#cccccc'
           }
        }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiAreaChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_area',
    name : 'IDS_MULTIAREACHART',
    base : 'riv/base/multiple/xy',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 3 ] }
              }
            }
          },
          
          tooltip : {
            configure : {
              properties : { chartType : 'line', orientation : 'left' }
            }
          },
        
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : { clientID : 'main', propertyCategory : 'interaction' }
          },
          
          main : {
            configure : {
              properties : { 'mergeDataRange' : ['primary'] }
            },
            
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    data : { aa : [ 1 ] },
                    configure : {
                      description : 'Settings for the category axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        title : { visible : false },
                        gridline : { visible : false },
                        type : 'category',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false }
                      }
                    }
                  },
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      description : 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        type : 'value',
                        position : 'left'
                      },
                      propertiesOverride : {
                        title : { isExported : false }
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        position : 'outside',
                        orientation : 'vertical',
                        automaticInOutside : false,
                        outsidePosition : 'down'
                      },
                      propertiesOverride:{
                        position : { isExported : false }
                      }
                    }
                  },
                  plot : {
                    id : 'sap.viz.modules.area',
                    configure : {
                      description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds:{
      multiplier : { max:1 },
      secondaryValues: null,
      axisLabels : { max:1 }
    },
    
    dependencies : {
      attributes : [
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'xCategoryScale'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'yCategoryScale'
        },
        {
          targetModule : 'root.main',
          target : 'primaryDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main',
          source : 'primaryDataRange'
        },
        {
          targetModule : 'root.main.plot.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'categoryScale'
        }, {
          targetModule : 'root.main.plot.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.plot.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryAxisTitle'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot.plot',
          source : 'getColorPalette'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot.plot',
          source : 'shapePalette'
        }, {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
        }
      ],
      events : [
        {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main',
          type : 'showTooltip'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main',
          type : 'hideTooltip'
        }, 
        {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        },
        {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        },
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'initialized.datalabel'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'startToInit.datalabel'
        }
      ]
    }
  };

  Manifest.register(multiAreaChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiHorizontalAreaChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiAreaChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_horizontal_area',
    name : 'IDS_MULTIHORIZONTALAREACHART',
    base : 'viz/multi_area',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left'
              }
            }
          },  
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  background : {
                    configure : {
                      properties : {
                        direction : 'horizontal'
                      }
                    }
                  },
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    data : null,
                    configure : {
                      'description':'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        gridline : {
                          visible : true
                        },
                        type : 'value',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : true },
                        label : { isExported : true },
                        axisline : { isExported : true }
                      }
                    }
                  },
    
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    data : { aa : [ 1 ] }, 
                    configure : {
                      'description':'Settings for the catetory axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        gridline : { visible : false },
                        type : 'category',
                        position : 'left'
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false }
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        position : 'outside',
                        orientation : 'horizontal',
                        automaticInOutside : false,
                        outsidePosition : 'left'
                      },
                      propertiesOverride:{
                        position : { isExported : false }
                      }
                    }
                  },             
                  plot : {
                    id : 'sap.viz.modules.area',
                    configure : {
                    'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                       properties : {
                       orientation: 'horizontal'
                      }
                    }
                  }
                }
                
              }
            }
            }
        }
      }
    },
   
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }
      ],
      events : [  {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main',
            type : 'showTooltip'
        }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main',
            type : 'hideTooltip'
        } , {
          targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
          targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }]
    }
  };

  Manifest.register(multiAreaChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageHorizontalAreaChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiHorizontalAreaChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiAreaChart = {
    id : 'viz/multi_100_horizontal_area',
    name : 'IDS_MULTIPERCENTAGEHORIZONTALAREACHART',
    base : 'viz/multi_horizontal_area',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left',
                formatString: [["0.00%"],["0.00%"]]
              }
            }
          },  
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
    
                   xAxis : {
                     id : 'sap.viz.modules.axis',
                     configure : {
                       properties : {
                           isPercentMode : true
                       }
                     }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode: true
                      }
                    }
                  },
    
                  plot : {
                    id : 'sap.viz.modules.area',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : {
                        mode:'percentage'
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }   
  };

  Manifest.register(multiAreaChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageAreaChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiAreaChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_area',
    name : 'IDS_MULTIPERCENTAGEAREACHART',
    base : 'viz/multi_area',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'line',
                orientation : 'left',
                formatString: [["0.00%"],["0.00%"]]
              }
            }
          },
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      properties : {
                        isPercentMode : true
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.area',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties: {
                      mode : "percentage"
                     }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var module = {
    'id' : 'sap.viz.modules.xy.bar.base',
    'name' : 'bar',
    base : "sap.viz.modules.xy.base",
    'abstract' : true,
    'properties' : {
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'isRoundCorner' : {
        'name' : 'isRoundCorner',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set enable/disable round corner of bar.'
      },
      'animation' : {
        'name' : 'animation',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'dataLoading' : {
            'name' : 'dataLoading',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data loading animation of plot area.'
          },
          'dataUpdating' : {
            'name' : 'dataUpdating',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data updating animation of plot area.'
          },
          'resizing' : {
            'name' : 'resizing',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable resizing animation of plot area.'
          }
        },
        'description' : 'Settings for animation of plot area.'
      }
    },
    css : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
              'value' : {
                'fill' : '#cccccc'
              }
        }
    }
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.2'},
[

],
function Setup() 
{
  return function(){
    var layerPos = {},//point on svg xy-coordinate
      clientPos = {},  //point on client position
      svgBoundingBox = null; //to improve performance, save all the bound of selected shape
    var lassoHelper, //div holder 
      lassoStart, lassoMove, lassoFinish, //lasso handler 
      start = false, 
      gWrapper = null, 
      gSelection = null, hitTestRect = {}, elementFilter, selectees,
      decorativeRect = null;
    //selection should be a svg element, as some function as svg native function. 
    var lassoSelection = function(selection, options){
      
      lassoHelper = $('<div id="lasso-selection-help" style="position:absolute;pointer-events:none;background:#cccccc;"></div>');
      elementFilter = options && options.filter ? options.filter:'.v-datapoint';
      gSelection = d3.select(selection).select('.main').length > 0  ? d3.select(selection).select('.main')[0][0] :  selection;
      gWrapper = d3.select(gSelection);
      var bbox = gSelection.getBBox();
      //as SVG limitation, you can not get the event info if you click where there is no shape.
      decorativeRect = gWrapper.insert('rect', 'g').attr('width', bbox.width).attr('height', bbox.height).attr('x', 0).attr('y', 0).attr('fill-opacity', 0);
      lassoStart = options.lassoStart ?options.lassoStart: function(){}, 
      lassoMove = options.lassoMove ? options.lassoMove: function(){}, 
      lassoEnd = options.lassoEnd ? options.lassoEnd: function(){};
      //register event on svg element
      gWrapper.on('mousedown', lassoSelection.start);
      gWrapper.on('mousemove', lassoSelection.move);
      gWrapper.on('mouseup', lassoSelection.end);
      return lassoSelection;
    };
    //intersect two rectangle
    function intersect(a, b) {
        return (a.x <= (b.x + b.width) &&
                b.x <= (a.x + a.width) &&
                a.y <= (b.y + b.height) &&
                b.y <= (a.y + a.height));
    };
    
    //filter the selectees to see whether the shape intersect with hitTestRect. 
    var filter = function(point, size){
      
      hitTestRect.x = point.x;
      hitTestRect.y = point.y;
      hitTestRect.height = size.height;
      hitTestRect.width = size.width;
      
      var res = [];
      //to reduce the time to get the bounding value, restore them into variable.
      if(selectees == null){
        selectees = gWrapper.selectAll(elementFilter);;
      }
      
      selectees.filter(function(d, m){
        var bounding = this.getBoundingClientRect();
        var rect = {
          x : bounding.left,
          y : bounding.top,
          width : bounding.width,
          height : bounding.height
        };
        if(intersect(rect , hitTestRect)){
          res.push(this);
        }
      });

      return res;
    };
    
    lassoSelection.start = function(){
      //as the layerX's issue in IE, so use the other way to calculate the x/y point on svg element.
      //layerX = pageX - svgBounding.left
      //layerY = pageY - svgBounding.top
      svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
      clientPos.x = d3.event.clientX, clientPos.y = d3.event.clientY;
      layerPos.x = clientPos.x - svgBoundingBox.left, layerPos.y = clientPos.y - svgBoundingBox.top;
      
      lassoHelper.css({
        "left": layerPos.x,
        "top": layerPos.y,
        "width": 0,
        "height": 0
      });
      
      //insert the background before the svg element in order to draw the background the behind svg
      lassoHelper.insertBefore(gSelection.ownerSVGElement.parentNode);
      
      var candidates = filter({x:clientPos.x, y:clientPos.y}, {width:0, height:0});
      
      lassoStart(candidates);
      
      start = true;
    };
    
    /**
     * when mouse move, only show the background
     */
    lassoSelection.move = function(){
      if(start){
        svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
        var x1 = layerPos.x, y1 = layerPos.y, x2 = d3.event.clientX - svgBoundingBox.left, y2 = d3.event.clientY - svgBoundingBox.top;
        if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
        if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
        lassoHelper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
      }
    };
    
    lassoSelection.end = function(){
      lassoHelper.css({
        width:0,
        height:0
      });
      lassoHelper.remove();
      svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
      var x1 = layerPos.x, y1 = layerPos.y, x2 = d3.event.clientX - svgBoundingBox.left, y2 = d3.event.clientY - svgBoundingBox.top;
      var cx1 = clientPos.x, cy1 = clientPos.y , cx2 = d3.event.clientX, cy2 = d3.event.clientY;
      if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; tmp = cx2; cx2 = cx1; cx1 = tmp;}
      if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; tmp = cy2; cy2 = cy1; cy1 = tmp; }
      //lassoHelper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
      
      if(x1 === x2 && y1 === y2){
        start = false;
      }else{
        var candidates = filter({x:cx1, y:cy1}, {width: x2-x1, height: y2-y1});
        lassoEnd(candidates);
        start = false;
      }
    };
    
    return lassoSelection;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.bar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.datalabel',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, tooltipDataHandler, NumberUtils, lassoSelection, Scaler, ObjectUtils, dataLabel, Objects, langManager, BoundUtil, defaultSelUtil, UADetector) {
  var bar = function(manifest, ctx) {
	var  CLASSMARKERSELECTED = "v-datapoint-selected",
         CLASSMARKERHOVER = "v-datapoint-hover";
         CLASSDATAPOINT = "v-datapoint";
    var  tooltipDataHandlerObj;
    var  data1,                 // data1 for value axis 1
         data2,                 // data2 for value axis 2
         data,                  // data from measure feed
         seriesData = [],             // seriesData is used to draw chart, it is transferred from data
         primaryAxisTopBoundary = 0,       // max value for value axis 1
         primaryAxisBottomBoundary = 0,
         primaryAxisManualRange = false,
         secondaryAxisManualRange = false,
         secondaryAxisTopBoundary = 0,
         secondaryAxisBottomBoundary = 0,      // max value for value axis 2
         gWrapper = null;
    
    var  width,          // chart width
         height,          // chart height
         isDualAxis = false,
         hasMNDonCategoryAxis = false,
         id = Math.floor(Math.random() * 10000),
         colorPalette = [],
         axis1ColorPalette,
         axis2ColorPalette,
         MNDInnerOnColor = false,
         measureOnAxis1 = 0,
         measureOnAxis2 = 0,
         shapePalette = ['squareWithRadius'],      // shape palette for legend
         properties,          // poreperteis that is used to control chart
         eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip','initialized','startToInit');
        
    
    
    var effectManager = ctx.effectManager;
    
    var valueScales = [],
        yScale = d3.scale.ordinal(),    // category scale
        xScale = d3.scale.linear(),      // scale for value axis 1
        xScale2 = d3.scale.linear();    // scale for value axis 2
      
      //variable for event
    var decorativeShape = null,           // the shape to show the effect of mouse move
        lastSelected = [],           // the variable to hold all selected shapes
        lastHovered = null,         // last hovered dimention item index
        tooltipVisible = true,  
        isLasso = false;
      
    var indexforSecondaryAxis = 0,        // if data index of seriesData is bigger than it, which means those data should be scaled by xScale2    
        barNumber,              // the number of bar in each group    
        barGroupNumber,            // the number of bar groups 
        barWidth = [],            // array to store all bars' widths.
        barHeight;              // barHeight is fixed and all bars have the same height.
    
    var enableDataLoadingAnimation = true,   // control initialization animation  
        enableDataUpdatingAnimation = true, // control data updating animation
        enableResizingAnimation = true, // control resizing animation
        enableRoundCorner = false,      // enable/disable round corner bar
        clipEdge = true,          // if it is false, the chart can be drawn out of the plot area.
        totalIntervalTime = 1000,      // animation time limited. all animation must be completed within it.
        hasDefaultSelection = false,
        isOnlyInitAnimation = false;    // for now, only init animation is supported
    
    var defsEnter = null, 
        roundCornerDefs = null,
        suffix = ObjectUtils.guid();
    
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;

    var dataLabel;
    
    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(!isOnlyInitAnimation){
        hasAnmation = enableDataLoadingAnimation;
      }else if(dataStructureChange || dataValueChange){
        hasAnmation = enableDataUpdatingAnimation;
      }else if(sizeChange){
        hasAnmation = enableResizingAnimation;
      }
      return hasAnmation;
    }
    
    /**
     * Parse options
     */
    var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
        enableResizingAnimation = properties.animation.resizing;

        tooltipVisible = properties.tooltip.enabled;
          
        if(isDualAxis && !hasMNDonCategoryAxis){
          axis1ColorPalette = properties.primaryValuesColorPalette;   
          axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
          axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
        drawingEffect = properties.drawingEffect; 
        
        var colorIndexes = 0;
        if(!hasMNDonCategoryAxis){
          indexforSecondaryAxis = data1.length;
          colorIndexes = seriesData[0].length;   
        }else{
          colorIndexes = seriesData.length * seriesData[0].length;
        }
        colorPalette = [];
        var i = 0;
        if(MNDInnerOnColor){
          var flag = 0, flag2 = 0, j = 0;
          for(i = 0 ; i < indexforSecondaryAxis; i++){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            flag++;
            if(flag === measureOnAxis1){
              flag2 = 0;
              for(; j <=(colorIndexes-indexforSecondaryAxis); j++){
                if(flag2 >= measureOnAxis2){
                  flag = 0;
                  break;
                }
              colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              flag2++;
            }
          }
        }
      }else{
        for(i = 0; i < colorIndexes; i++){
          if(i < indexforSecondaryAxis){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
          }else if(isDualAxis && !hasMNDonCategoryAxis){
            colorPalette.push(axis2ColorPalette[(i-indexforSecondaryAxis) % axis2ColorPalette.length]);  
          }
        }
      }
    };

    var getImageURL = function(index)
    {
        var imageURL = "";

        var imageURLNumber = properties.imagePalette.length;
        if(imageURLNumber > 0)
        {
            imageURL = properties.imagePalette[index%imageURLNumber];
        }

        return imageURL;
    };
      
    /**
     * Create chart
     */
    function chart(selection){
        BoundUtil.drawBound(selection, width, height);
      
        var countMagnitude = function(number)
        {
            var res = 0;
            //0.0234: 0.01
            //0.234: 0.1
            //2.34: 1
            //23.4: 10
            //234:100
            //234:100
            if(number >= 1)
            {
                res = 1;
                for(;;)
                {
                    if((number / 10) < 1)
                    {
                        break;
                    }
                    else
                    {
                        number /= 10;
                        res *= 10;
                    }
                }
            }
            else if(number < 1)
            {
                res = 0.1;
                for(;;)
                {
                    if((number * 10) >= 1)
                    {
                        break;
                    }
                    else
                    {
                        number *= 10;
                        res /= 10;
                    }
                }
            }
            return res;
        }

        var bestImageNumberRatio = function(seriesData, valueScale, barHeight)
        {
            var res = 1;
            var imageRatioObjs = [];
            for(var i = 0; i < seriesData.length; i++)
            {
                for(var j = 0; j < seriesData[i].length; j++)
                {
                    var ratioItem = {};
                    ratioItem.rectWidth = valueScale(seriesData[i][j].val);
                    ratioItem.rectHeight = barHeight;

                    ratioItem.imageWidth = barHeight;
                    ratioItem.val = seriesData[i][j].val;

                    imageRatioObjs.push(ratioItem);
                }
            }
            //var points = [40,100,1,5,25,10];
            imageRatioObjs.sort(function(a,b){return b.rectWidth-a.rectWidth});
            if(imageRatioObjs.length != 0)
            {
                var bestImageNum = imageRatioObjs[0].rectWidth/imageRatioObjs[0].imageWidth;
                var theVal = imageRatioObjs[0].val;

                var baseMagnitude = countMagnitude(bestImageNum/theVal);
                
                var imageNumTest = [];
                
                imageNumTest.push ({"base":1, "gap": Math.abs(baseMagnitude * theVal - bestImageNum)});
                imageNumTest.push ({"base":2, "gap": Math.abs(baseMagnitude * 2 * theVal - bestImageNum)});
                imageNumTest.push ({"base":5, "gap": Math.abs(baseMagnitude * 5 * theVal - bestImageNum)});
                imageNumTest.push ({"base":10, "gap": Math.abs(baseMagnitude * 10 * theVal - bestImageNum)});
                
                var compare = function (a, b)
                {
                    return a.gap - b.gap;
                }     
                imageNumTest.sort(compare);           
                
                //&& (baseMagnitude * theVal * imageRatioObjs[0].imageWidth) >= imageRatioObjs[0].rectWidth*0.2)
                res = baseMagnitude * imageNumTest[0].base;
            }

            return res;
        }

        var imageFill = function(barShape, bar, i, barHeight)
        {

            var defIDFun = function(d, itemIndex) {
                    return suffix + "-defID-" + i + itemIndex;//i is group index
                };

            var urlIDFun = function(d, itemIndex) {
                    return "url(#" + defIDFun(d, itemIndex) + ")";//i is group index
                };

            var rectWidthFun = function(d) {
                    var valueScale = valueScales[d.valueAxis];
                    return valueScale(d.val);
                };

            var rectWidthFunForPattern = function(d) {
                    return rectWidthFun(d) + 2;
                };

            var imageNumber = function(perDefData)
            {

                var val = perDefData.val;
                if(perDefData.val < 0)
                {
                    val = -val;
                }

                var res = {number:0, interval:barHeight};
                res.number = val*imageNumRatio;

                //to count the interval
                var intNum = Math.floor(res.number);
                var decimalNum = res.number - intNum;

                var rectWidth = rectWidthFun(perDefData);
                var imageWidth = barHeight;
                var lastImageWidth = imageWidth * decimalNum;

                //   imageWidth + (intNum-1)*interval + (interval-imageWidth) + lastImageWidth == rectWidth   //interval >= imageWidth           
                //or imageWidth + (intNum-1)*interval + (lastImageWidth - (imageWidth - interval)) == rectWidth //interval < imageWidth && (lastImageWidth > ( imageWidth - interval) )
                //or imageWidth + (intNum-1)*interval == rectWidth //interval < imageWidth && (lastImageWidth <= ( imageWidth - interval) )
                var intervalTest1;
                if(intNum == 0)
                {
                    intervalTest1 = 0;
                }
                else
                {
                    if(rectWidth > lastImageWidth)
                    {
                        intervalTest1 = (rectWidth - lastImageWidth)/intNum; 
                    }
                    else
                    {
                        intervalTest1 = 0;
                    }
                }
                
                var intervalTest2;
                if(intNum <= 1)
                {
                    intervalTest2 = rectWidth/2;
                }
                else
                {
                    if(rectWidth > imageWidth)
                    {
                        intervalTest2  = (rectWidth - lastImageWidth)/(intNum);
                    }
                    else
                    {
                        intervalTest2 = rectWidth/(intNum + 1);
                    }
                }

                var intervalTest3;
                if(intNum === 0)
                {
                    intervalTest3 = 0;
                }
                else if (intNum === 1)
                {
                    intervalTest3 = rectWidth - lastImageWidth;
                }
                else if(rectWidth > imageWidth)//imageWidth > lastImageWidth
                {
                    intervalTest3  = (rectWidth - imageWidth)/(intNum - 1);
                }
                else
                {
                    intervalTest3 = rectWidth/(intNum + 1);
                }


                if(intervalTest1 >= imageWidth)
                {
                    res.interval = intervalTest1;
                }
                else if (intervalTest2 < imageWidth && (lastImageWidth > (imageWidth-intervalTest2)) )
                {
                    res.interval = intervalTest2;
                }
                else
                {
                    res.interval = intervalTest3;
                }

                return res;
            }

            var imageRatioObjs = [];
            

            var imagesFun = function (perDefData,k)
            {
                var pathIDFun = function(d, itemIndex) {
                        return suffix + "-pathID-" + i + k + itemIndex;
                    };

                var urlPathIDFun = function(d, itemIndex) {
                        return "url(#" + pathIDFun(d, itemIndex) + ")";
                    };

                var lastRectIDFun = function(d, itemIndex) {
                        return "L-" + pathIDFun(d, itemIndex);
                    };

                var urlLastRectIDFun = function(d, itemIndex) {
                        return "url(#" + lastRectIDFun(d, itemIndex) + ")";
                    };

                var thisObj = d3.select(this);

                var rectWidth = rectWidthFun(perDefData);
                var rectHeight = barHeight;

                var imageNum = imageNumber(perDefData);

                var intNum = Math.floor(imageNum.number);
                var decimalNum = imageNum.number - intNum;

                thisObj.selectAll("*").remove();

                var iImage = 0;
                for(; iImage < intNum; iImage++)
                {
                    thisObj.append("image")
                        .attr("xlink:xlink:href", getImageURL(k))
                        .attr("width",rectHeight)
                        .attr("height",rectHeight)
                        .attr("x",iImage*imageNum.interval);
                }

                if(decimalNum)
                {
                    //we cannot use clip-path, becuase clip-path will change the X of the image. 
                    var startX = iImage*imageNum.interval;
                    var lastImage = thisObj.append("g").attr('transform',"translate(" + startX + ",0)");

                     lastImage.append("defs").append("pattern")
                    .attr("id", lastRectIDFun)
                    .attr("patternUnits","userSpaceOnUse")
                    .attr("width",rectHeight + 2)
                    .attr("height",rectHeight + 2)
                    .append("image")
                    .attr("xlink:xlink:href", getImageURL(k))
                    .attr("width",rectHeight)
                    .attr("height",rectHeight);

                     lastImage.append("rect")
                    .attr("width",rectHeight*decimalNum)
                    .attr("height",rectHeight)
                    .attr("fill",urlLastRectIDFun);

                    //<g transform="translate(497.48177999999984,0)">
                    //<defs>
                    //    <pattern id="img5" patternUnits="userSpaceOnUse" width="100" height="100">
                    //        <image xlink:href="user.png" width="45.6" height="45.6" />
                    //    </pattern>
                    //</defs>
                    //<rect width="22.8" height="45.6" fill="url(#img5)"></rect>
                    //</g>
                }
                
            };

            //start of the function
            barShape.selectAll("defs").remove();
            var imageDef = barShape.append("defs").append("pattern")
                .attr("id", defIDFun)
                .attr("patternUnits","userSpaceOnUse")
                //.attr("width",20)//plot width
                //.attr("height",20);//plot height
                .attr("width",rectWidthFunForPattern)
                .attr("height",barHeight + 2);

            //we use "each" to access data and index
            //to make the imageNumRatio
            var imageNumRatio = 1;
            imageDef.each( function(d)
            {
                var valueScale = valueScales[d.valueAxis];
                imageNumRatio = bestImageNumberRatio(seriesData, valueScale, barHeight);
            }
            );

            imageDef.each(imagesFun);
            bar.attr('fill',urlIDFun);
            
            var debugMode = false;
            if(debugMode)
            {
                bar.attr("stroke", "#555555");
                bar.attr("stroke-width", "1");
            }
        };


      tooltipDataHandlerObj = tooltipDataHandler();
      
      // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
      if(valueScales.length === 0){ 
        return;
      }
      eDispatch.startToInit();
      
      selection.each(function(){
        barNumber = seriesData[0].length;
        barGroupNumber =  seriesData.length;      
        barHeight = 8 * (yScale.rangeBand()) / (9*barNumber +7 );
        
        var svg = (gWrapper = d3.select(this));
 
        //append decorativeShape bar
        if(decorativeShape === null){
          decorativeShape = d3.select(this).append('rect').attr('visibility', 'hidden').attr('width', width).attr('height',  yScale.rangeBand() - barHeight/2).attr(
              'fill', ctx.styleManager.queryDefault('v-hovershadow').fill).attr('class', 'v-hovershadow');
        }else{
          decorativeShape.attr('width', width).attr('height',  yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden');
        }
        
        if(defsEnter === null){
          defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
        }else{
          defsEnter.attr('width', width).attr('height', height);
        }    
          
        if(roundCornerDefs === null){      
          roundCornerDefs = svg.append('defs');
        }else{
          if( dataStructureChange || sizeChange || dataValueChange || !enableRoundCorner){
            roundCornerDefs.selectAll(".v-clippath").remove();
          }
        }
          
        var r = Math.log(barHeight)/Math.log(2);
        if( r < 0 ){
          enableRoundCorner = false;
        }
        var valueScale;
        var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
        if(!TypeUtils.isExist(datashapesgroup[0][0])){
          datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup');
        }
        var barGroup = datashapesgroup.selectAll('g.v-bar').data(seriesData), lastBarGroupIndex = seriesData.length -1;
           barGroup.enter().append('g');
           barGroup.attr('class','v-bar').each( function (perBarGroup,i) {
                var barTransition, yArray = [];
                // wrap a datashape g for each rect
                var barShape = d3.select(this).selectAll('g.v-datashape').data(perBarGroup);
                    barShape.enter().append('g').attr('class','v-datashape').append('rect').attr('class', 'v-datapoint');
                    barShape.exit().remove();
                    barShape.attr('transform',function(perRectData, m){
                        var x;                   
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val < 0){
                          x =  valueScale(perRectData.val) ;
                        }else{
                          x = valueScale(0);
                        }
                        var y = yScale(i) + barHeight * (barNumber - m - 1);
                            y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                            
                        yArray.push(y);
                        return 'translate('+x+','+y+')';         
                    });
                var bar = barShape.select('rect.v-datapoint'), 
                    lastBarIndex = seriesData[0].length -1;
                

                bar.attr('fill',function(perRectData,i){
                      perRectData.fillColor = colorPalette [ i % colorPalette.length];
                      var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : perRectData.fillColor,
                          direction : 'vertical'
                      };
                      return effectManager.register(parameter);
                    })
                    .attr('shape-rendering','crispEdges').attr('fill-opacity', 1).attr('stroke','none');

                 var adjustBarWithoutAnimation = function()
                 {
                    bar.attr('width', function(perRectData){
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val !== ' ' && perRectData.val !== 0){
                          var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                          // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                          return width;
                        }else{
                          return 0;
                        }
                      })
                      .attr('x', 0).attr('height', barHeight).attr('y', 0);
                    if(enableRoundCorner){
                    var rcFunction =  function(){ bar.attr('clip-path', function(perRectData, m){
                        var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                        roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                          .append('rect').attr('rx', r).attr('ry', r)
                          .attr('width', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val !== 0){
                              var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              return (width + r);
                            }else{
                              return 0;
                            }
                          })
                          .attr('height', barHeight)
                          .attr('y', 0)
                          .attr('x', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val < 0){
                              return  0;
                            }else{
                              return 0 - r;
                            }
                          });
                          return 'url(#' + id + ')';
                      });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                    }
                 }
                 
                 var adjustBarWithDataStructureChangeAnimation = function()
                 {
                      bar.attr('y', function(perRectData, m){
                            var y = yScale(i) - yArray[m] + barHeight * (barNumber - m  - 1);
                            y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                            return  y;
                          })
                          .attr('x', function(perRectData){
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val  > 0){
                              return 0;
                            }else{
                              return valueScale(0) - valueScale(perRectData.val);
                            }
                           })
                           .attr('height', barHeight).attr('width', 0)
                           .attr('class', function(d, m){
                             return 'v-datapoint series-'+m;
                           });
                      
                      if(enableRoundCorner){
                         var rcFunction = function(){bar.attr('clip-path', function(perRectData, m){
                          var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                          var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                          roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                              .append('rect').attr('rx', r).attr('ry', r)
                              .attr('width', w + r).attr('height', barHeight).attr('y', 0).attr('x',x)
                              .transition().delay(function(d,m){return (m + barNumber * i) * interval;})
                              .attr('x', function(){
                                valueScale = valueScales[perRectData.valueAxis];
                                if(perRectData.val < 0){
                                  return 0;
                                }else{
                                  return 0 - r;
                                }
                              })
                              .attr('width',  function(){
                                valueScale = valueScales[perRectData.valueAxis];
                                // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                // the space is reserved
                                if(perRectData.val !== ' ' && perRectData.val !== 0){
                                  var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                  // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                  return  width + r;
                                }else{
                                  return 0;
                                }
                              });
                        return 'url(#' + id + ')'; });};
                        if(UADetector.isSafari() && UADetector.os === "Windows"){
                           window.setTimeout(rcFunction, 0);
                        } else{
                          rcFunction();
                        }
                      }
                  
                      var interval = totalIntervalTime / (barNumber * barGroupNumber);
                      barTransition = bar.transition();
                      barTransition.delay(function(d,m){return (m + barNumber * i) * interval;})
                        .attr('x', 0).attr('y', 0)
                        .attr('width',  function(perRectData){
                          valueScale = valueScales[perRectData.valueAxis];
                          // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                          // the space is reserved
                          if(perRectData.val !== ' ' && perRectData.val !== 0 ){
                            var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                            // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                            return  width;
                          }else{
                            return 0;
                          }
                        })
                        .each('end', function(d, m){
                          if(m === lastBarIndex && i === lastBarGroupIndex){
                            completeAnimation();
                          }
                        });
                 }               

                  if(enableAnimation()){
                    // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                    // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                    if(dataStructureChange){
                        adjustBarWithDataStructureChangeAnimation();
                    }
                    // [04 - Sep - 2012 Nick] if the size of plot area is changed, re-scale chart
                    else if(sizeChange){
                        if(!imageFillEnabled())
                        {
                            if(enableRoundCorner){
                            var rcFunction = function() { bar.attr('clip-path', function(perRectData, m){
                              var w = parseFloat(this.getAttribute('width')), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                              var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                              roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                .append('rect').attr('rx', r).attr('ry', r)
                                .attr('width', w + r).attr('height', h).attr('y', y).attr('x',x)
                                .transition().duration(totalIntervalTime)
                                .attr('x', function(){
                                  if(perRectData.val < 0){
                                    return  0;
                                  }else{
                                    return 0 - r;
                                  }
                                })
                                .attr('width',  function(){
                                  valueScale = valueScales[perRectData.valueAxis];
                                  // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                  // the space is reserved
                                  if(perRectData.val !== ' ' && perRectData.val !== 0){
                                    var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                    // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                    return width + r;
                                  }else{
                                    return 0;
                                  }
                                })
                                .attr('height', barHeight)
                                .attr('y', 0);
                              return 'url(#' + id + ')'; });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                             window.setTimeout(rcFunction, 0);
                            } else{
                             rcFunction();
                            }
                            }

                            barTransition = bar.transition();
                            barTransition.duration(totalIntervalTime)
                            .attr('x', 0).attr('y', 0)
                            .attr('width',  function(perRectData, m){
                              valueScale = valueScales[perRectData.valueAxis];
                              if(perRectData.val !== ' ' && perRectData.val !== 0){
                                var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                return width;
                              }else{
                                return 0;
                              }
                            })
                            .attr('height', barHeight)
                            .each('end', function(d, m){
                              if(m === lastBarIndex && i === lastBarGroupIndex){
                                completeAnimation();
                              }
                            });
                        }
                        else
                        {
                            var resizeTime = 500;
                            adjustBarWithoutAnimation();
                            var barG = barGroup.attr("opacity", 0.3);
                            barG = barG.transition();
                            barG = barG.delay(0)
                                .duration(resizeTime)
                                .attr('opacity', 1)
                                .each('end',completeAnimation);
                        }
                    }
                    else if(dataValueChange){
                        if(!imageFillEnabled())
                        {
                          if(enableRoundCorner){
                          var rcFunction = function(){ bar.attr('clip-path', function(perRectData, m){
                              var w = parseFloat(this.getAttribute('width')), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                              var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                              roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                    .append('rect').attr('rx', r).attr('ry', r)
                                    .attr('x',  - r).attr('width', w + r).attr('height', h).attr('y', y)
                                    .transition().duration(totalIntervalTime)
                                    .attr('width',  function(){
                                        valueScale = valueScales[perRectData.valueAxis];
                                      // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                      // the space is reserved
                                        if(perRectData.val !== ' ' && perRectData.val !== 0){
                                        var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                        // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                        return (width + r);
                                      }else{
                                        return 0;
                                      }
                                     })
                                    .attr('height', barHeight)
                                    .attr('y', 0);
                              return 'url(#' + id + ')'; });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                          }
                          
                          //To seperate dataValueChange, as in size change, we calculate more than data value change.
                          //in value change, only change the width, in size, there are height width, y
                          barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime)
                          .attr('width',  function(perRectData){
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val !== ' ' && perRectData.val !== 0){
                              var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              return width;
                            }else{
                              return 0;
                            }
                          })
                          .attr('x', 0).attr('y', 0)
                          .each('end', function(d, m){
                            if(m === lastBarIndex && i === lastBarGroupIndex){
                              completeAnimation();
                            }
                          });
                        }
                        else
                        {
                            var anniTime = 500;
                            adjustBarWithoutAnimation();
                            var barG = barGroup.attr("opacity", 0.3);
                            barG = barG.transition();
                            barG = barG.delay(0)
                                .duration(anniTime)
                                .attr('opacity', 1)
                                .each('end',completeAnimation);
                        }
                    }                      
                    else if(enableRoundCorner){
                     var rcFunction = function(){ bar.attr('clip-path', function(perRectData, m){
                        var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                        roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                          .append('rect').attr('rx', r).attr('ry', r)
                          .attr('width', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val !== 0){
                              var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              return (width + r);
                            }else{
                              return 0;
                            }
                          })
                          .attr('height', barHeight)
                          .attr('y', 0)
                          .attr('x', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val < 0){
                              return  0;
                            }else{
                              return 0 - r;
                            }
                          });
                          return 'url(#' + id + ')';
                          if(m === lastBarIndex && i === lastBarGroupIndex){
                            completeAnimation();
                          }
                      });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                    }
                  }
                  // [04 - Sep - 2012 Nick] if the animation is disabled
                  else{
                    adjustBarWithoutAnimation();
                 }

//----------------call image fill functions-----------------------------------------------------
                //barItem: the datashape which has one rect and one defs
                //bar: the bar rect in the barItem
                //i: is group index
                //barHeight: the height of the bar

                if(imageFillEnabled())
                {
                    imageFill(barShape, bar, i, barHeight);
                }
//----------------------------------------------------------------------------------------------
                 // bar.exit().remove();
              });

          barGroup.exit().remove();
        
        //reset status
        });
      if (! enableAnimation()){
        completeAnimation();
      }  
      sizeChange = false, dataStructureChange = false, dataValueChange = false;
      isOnlyInitAnimation = true;
       
        return chart;
      }
    
    function completeAnimation(){
        eDispatch.initialized();  
    }

    var imageFillEnabled = function()
    {
        return (properties.imageFill && !isDualAxis);
    }
    
    chart.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };

    chart.imageInfo = function(){
        var imageInfo =
        {
            imageMode: properties.imageFill,
            imagePalette: properties.imagePalette,
            radio: 1
        };
        return imageInfo;
    };
    
    
    chart.dataLabel = function(label){
      if(!arguments.length){
        return label;
      }
      dataLabel = label;
    };
    /**
     * Mouse over 
     */
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1) || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }

      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + barHeight/4).attr(
          'visibility', 'visible');

      if(i !== lastHovered){
        if (tooltipVisible) {      
          lastHovered = i;
          //this.parentNode.parentNode.parentNode point to the main container
          var transform = gWrapper[0][0].getTransformToElement(gWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          
          var tData = tooltipDataHandlerObj.generateTooltipData(data, seriesData, barGroupNumber-1-i, colorPalette, shapePalette);
          tData.point = {
              x: point.x,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tData.plotArea = {
            x : transform.e,
            y : transform.f,
            width : width,
            height : height
          };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
      };

      chart.parent = function(){
        return gWrapper;
      };

      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
        	elems[i].setAttribute('fill-opacity', 1);
            if(!enableRoundCorner){
                elems[i].setAttribute('stroke', '#333333');
            }
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
          elems.setAttribute('fill-opacity', 1);          
          if(!enableRoundCorner){
                elems.setAttribute('stroke', '#333333');
           }
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gWrapper, true, elems);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
        	elems[i].setAttribute('class',CLASSDATAPOINT);
            elems[i].setAttribute('fill-opacity', 0.4);
            elems[i].setAttribute('stroke','none');
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINT);
          elems.setAttribute('fill-opacity', 0.4);
          elems.setAttribute('stroke','none');
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gWrapper, false, elems);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null || gray == false){
          var rects = gWrapper.selectAll('.v-datapoint');
              rects.attr('fill-opacity', 1).attr('stroke','none').attr('class',CLASSDATAPOINT);
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(gWrapper, false, rects);
          }
        }else{
          gWrapper.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke','none').attr('class',CLASSDATAPOINT);
        }
      };
      
      /**
       * TODO: add desc
       */
      chart.blurOut = function(){
        lastHovered = null;
        decorativeShape.attr('visibility', 'hidden');
      if (tooltipVisible) {      
        eDispatch.hideTooltip();
      }
      };
      
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
      chart.data = function(value){
        if (!arguments.length){
          return data;
         }
        data = value;
        var obj = MNDHandler(data);
        
        data1 = obj["MG1"];
        data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        
        if( data1[0] && data1[0][0].info && data1[0][0].info.defaultSelection){
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        }
        
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
        }else{
          hasMNDonCategoryAxis = false;
          if(TypeUtils.isExist(data2)){
                isDualAxis = true;
            }else{
                isDualAxis = false;
            }
        }
        
        var _seriesData = dataTransform(data1, data2, obj.color);
        //judge what changed in dataset
        if(seriesData.length !== _seriesData.length || _seriesData[0].length !== seriesData[0].length){
          dataStructureChange = true;
        }else {
          dataValueChange = true;
        }
        seriesData = _seriesData;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      parseOptions();
         return chart;        
      };

      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return properties;
         }
         Objects.extend(true, properties, props);
            parseOptions();
            
         return chart;        
      };
      
      /**
       * TODO: add desc
       */
      var makeScales = function(){
      var domain = [];
      valueScales = [];
      for (var i=0; i < seriesData.length; i++){
           domain.push(i);
        }
        yScale.domain(domain).rangeBands([height, 0]);
        //when data is all 0 or null, we make the xScale.domain(0,1)
        if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
          xScale.domain([0,1]).range([0, width]);
        }else{
          xScale.domain([primaryAxisBottomBoundary, primaryAxisTopBoundary]).range([0, width]);
        }
        if(TypeUtils.isExist(data2) || isDualAxis){
        //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

          if(secondaryAxisTopBoundary === 0 && secondaryAxisBottomBoundary === 0){
            xScale2.domain(xScale.domain()).range(xScale.range());
          }else{
            xScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([0, width])
            //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
            if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
              xScale.domain(xScale2.domain()).range(xScale2.range());
            }
          }
          if (!secondaryAxisManualRange && !primaryAxisManualRange)
          {
              Scaler.perfectDual(xScale, xScale2);
          }
          else if(!secondaryAxisManualRange && primaryAxisManualRange)
          {
              Scaler.perfect(xScale2);
              Scaler.getRoughTickNum(xScale);
          }
          else if (secondaryAxisManualRange && !primaryAxisManualRange)
          {
              Scaler.perfect(xScale);
              Scaler.getRoughTickNum(xScale2);
          }
          else
          {
            Scaler.getRoughTickNum(xScale);
            Scaler.getRoughTickNum(xScale2);
          }
        } else { 
          if (!primaryAxisManualRange) {
            Scaler.perfect(xScale);
          } else {
            Scaler.getRoughTickNum(xScale);
          }
          xScale2.range([0, 0]);
        }
        valueScales.push(xScale);
        valueScales.push(xScale2);
      };
      
      /**
       * TODO: add desc. please don't leave empty otherwise jsdoc will complain.
       */
      chart.categoryScale = function(scale){
        if (!arguments.length){
          return yScale;
         }
        yScale = scale;
         return chart;
      };
     
      chart.primaryScale = function(scale){
        if (!arguments.length){
          return xScale;
         }
        xScale = scale;
        valueScales[0] = xScale;
         return chart;
      };
      
      chart.secondScale = function(scale){
        if (!arguments.length){
          return xScale2;
         }
        xScale2 = scale;
        valueScales[1] = xScale2;
         return chart;
      };
      
      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(!hasMNDonCategoryAxis){
          return colorPalette[seriesData[0].length - 1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };     
      
      chart.primaryDataRange = function(range){
        if (!arguments.length){
          return {
            min: primaryAxisBottomBoundary,
            max: primaryAxisTopBoundary
          };
        }
        if (range !== null) {
            primaryAxisTopBoundary = range.max;
            primaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                primaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          return {
            min: secondaryAxisBottomBoundary,
            max: secondaryAxisTopBoundary
          };
        }
        if (range !== null) {
            secondaryAxisTopBoundary = range.max;
            secondaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                secondaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };      
      
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return this;
      };
      
      /**
      * get/set your color palette if you support color palette
      */
      chart.colorPalette = function(_){
        if(!arguments.length){
          return colorPalette;
        }
        colorPalette = _;
        return this;
      };        
        // chart.primaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis1ColorPalette;
            // }  
            // axis1ColorPalette = _;
            // return this;
        // };
// 
        // chart.secondaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis2ColorPalette;
            // }  
            // axis2ColorPalette = _;
            // return this;
        // };        

      /**
      * get/set your shape Palette if you support shape Palette
      */
      chart.shapePalette = function(_){
        if(!arguments.length){
          return shapePalette;
        }
        shapePalette = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
//      var dataTransform = function(data1,data2){
//        var barGroups = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;
//      var barGroup = [];
//      for(var i=0; i<data1.length; i++){
//        var temp = d3.max(data1[i], function(m){return m.val;});
//        var temp2 = d3.min(data1[i], function(m){return m.val;});
//        if(primaryAxisTopBoundary <temp){
//          primaryAxisTopBoundary = temp;
//        }
//        if(primaryAxisBottomBoundary > temp2){
//            primaryAxisBottomBoundary = temp2;
//        }
//          barGroup.push(data1[i]);
//        }
//      if(data2 != undefined){
//      
//        for(i=0; i<data2.length; i++){
//          var temp = d3.max(data2[i], function(m){return m.val;});
//          var temp2 = d3.min(data2[i], function(m){return m.val;});
//          if(secondaryAxisTopBoundary < temp){
//            secondaryAxisTopBoundary = temp;
//          }
//          if(secondaryAxisBottomBoundary > temp2){
//              secondaryAxisBottomBoundary = temp2;
//          }
//          barGroup.push(data2[i]);
//        }
//      }
//       
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        for(i=0; i< barGroup.length; i++){
//          ds.push(barGroup[i][j]);
//        }
//        barGroups.push(ds);
//      }
//     
//        return barGroups;
//      };
      
      var dataTransform = function(valueAxis1,valueAxis2, colorIndexArray){
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        var barGroups = [];
      // the number of bar in each group
        var barGroupNumber = 0;
        
        if (valueAxis1[0] && valueAxis1[0].length) {
            barGroupNumber =  valueAxis1[0].length;
        } else if (valueAxis2[0] && valueAxis2[0].length){
            barGroupNumber =  valueAxis2[0].length;
        }
      var barGroup = [];
      var temp = 0, temp2 = 0;
      var i = 0, j = 0;
      for(i=0; i < valueAxis1.length; i++){
        if(hasMNDonCategoryAxis){
          for(j = 0;  j< valueAxis1[i].length; j++){
            if(colorIndexArray[j] === 0){
              temp = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 0;
              
              if(primaryAxisTopBoundary <temp){
                primaryAxisTopBoundary = temp;
              }
              if(primaryAxisBottomBoundary > temp){
                primaryAxisBottomBoundary = temp;
              }
              indexforSecondaryAxis++;
            }else{
              temp2 = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 1;
              
              if(secondaryAxisTopBoundary < temp2){
                secondaryAxisTopBoundary = temp2;
              }
              if(secondaryAxisBottomBoundary > temp2){
                  secondaryAxisBottomBoundary = temp2;
              }
            }
          }
        }else{
          temp = d3.max(valueAxis1[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis1[i], function(m){return m.val;});
          
          if(primaryAxisTopBoundary <temp){
            primaryAxisTopBoundary = temp;
          }
          if(primaryAxisBottomBoundary > temp2){
            primaryAxisBottomBoundary = temp2;
          }
        }
        barGroup.push(valueAxis1[i]);
          
        }
      if(valueAxis2 !== undefined){
        for(i=0; i<valueAxis2.length; i++){
          temp = d3.max(valueAxis2[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis2[i], function(m){return m.val;});
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
              secondaryAxisBottomBoundary = temp2;
          }
          barGroup.push(valueAxis2[i]);
        }
      }
      
      for(j=0; j < barGroupNumber; j++){
        var ds = [];
        for(i=0; i< barGroup.length; i++){
          if(!hasMNDonCategoryAxis){
            if( i < valueAxis1.length){
              barGroup[i][j].valueAxis = 0;
            }else{
              barGroup[i][j].valueAxis = 1;
            }
          }
          if(NumberUtils.isNoValue(barGroup[i][j].val)){
            barGroup[i][j].val = ' ';
          }
          ds.push(barGroup[i][j]);
        }
        if(MNDInnerOnColor){
          var dSet = [], flag1=0, flag2=0;
          var n=0;
          for(var m=0; m < valueAxis1.length; m++){
            dSet.push(ds[m]);
            flag1++;
            if(flag1 === measureOnAxis1 && valueAxis2 !== undefined){
              flag2 = 0;
              for(; n<valueAxis2.length; n++){
                if(flag2 >= measureOnAxis2){
                  flag1 = 0;
                  break;
                }
                dSet.push(ds[valueAxis1.length+n]);
                flag2++;
              }
            }
          }
          barGroups.push(dSet);
        }else{
          barGroups.push(ds);
        }
      }
     
        return barGroups;
      };      
    properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.bar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.bar',
    'name' : 'bar',
    base : "sap.viz.modules.xy.bar.base",
    'properties' : {
      'imageFill' : {
        'name' : 'imageFill',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'isExported' : false,
        'description' : 'Set enabled/disabled image fill.'
      },
      'imagePalette' : {
        'name' : 'imagePalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : [ 'http://www.sap.com/global/ui/images/global/sap-logo.png' ],
        'isExported' : false,
        'description' : 'images to fill the bar',
      } 
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_bar',
    name : 'IDS_MULTIBARCHART',
    base : 'riv/base/multiple/xy',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 3 ] }
              }
            }
          },
          
          tooltip : {
            configure : {
              properties : { chartType : 'bar', orientation : 'left' }
            }
          },
          
          main : {   
            configure : {
              properties : {
                'mergeDataRange' : ['primary']
              }
            },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  background : {
                    configure : { properties : { direction : 'horizontal' } }
                  },
                  
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        orientation : 'horizontal',
                        outsidePosition : 'right'
                      }
                    }
                  },
                  
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      description :'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        title : { visible : false },
                        type : 'value',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  },

                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    data : { aa : [ 1 ] },
                    configure : {
                      description : 'Settings for the category axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        type : 'category',
                        position : 'left',
                        gridline : { visible : false }
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false }
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.bar',
                    configure : {
                      description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'xCategoryScale'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'yCategoryScale'
        },
        {
          targetModule : 'root.main',
          target : 'primaryDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main',
          source : 'primaryDataRange'
        },
        {
          /**
           * [jimmy/8/8/2012]each node in the path may have several entities
           * like main.plot, we may create several main.plots
           * (here the xycontainer), by using 'main.plot.xAxis'
           * here we actually means for xAxis in each main.plot
           * 
           * in the future, we may need support more complicated dependency resolving
           * like 'the 3rd xycontainer's xAxis', can be described
           * as main.plot[2].xAxis
           */
          targetModule : 'root.main.plot.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryScale'
        }, 
        { 
          targetModule : 'root.main.plot.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot.plot',
          source : 'primaryAxisTitle'
        },
        {
          targetModule : 'root.main.plot.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'categoryScale'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot.plot',
          source : 'colorPalette'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main',
          type : 'showTooltip'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main',
          type : 'hideTooltip'
        },
        {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, 
        {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'initialized.datalabel'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'startToInit.datalabel'
        }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.verticalbar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, ObjectUtils, NumberUtils, Objects, langManager, boundUtil, defaultSelUtil, UADetector) {
  var vBar = function(manifest, ctx) {
	var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint";
    var tooltipDataHandlerObj;
    var data1, 
        data2, 
        data, 
        seriesData = [], 
        primaryAxisTopBoundary = 0, 
        primaryAxisBottomBoundary = 0,
        primaryAxisManualRange = false,
        secondaryAxisManualRange = false,
        secondaryAxisTopBoundary = 0,
        secondaryAxisBottomBoundary = 0,
        sWrapper = null;
    
    var width = undefined, 
        height = undefined,
        id = Math.floor(Math.random() * 10000),
        x = 0, 
        y = 0,
        isDualAxis = false,
        colorPalette = [],
        axis1ColorPalette,
        axis2ColorPalette,
        MNDInnerOnColor = false,
        measureOnAxis1 = 0,
        measureOnAxis2 = 0,
        shapePalette = ['squareWithRadius'],
        properties,
        eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
      
    var effectManager = ctx.effectManager;
    
    var valueScales = [],
        xScale = d3.scale.ordinal(),
        yScale = d3.scale.linear(),
        yScale2 = d3.scale.linear();


    var decorativeShape, 
        eventLayerShape, 
        lastSelected = [], 
        tooltipVisible = true,
        lastHovered = null;

      
    var indexforSecondaryAxis = 0,
        barNumber,
        barGroupNumber,
        barWidth,
        yPositions = [];
        
    var enableDataLoadingAnimation = true,
        enableDataUpdatingAnimation = true,
        enableResizingAnimation = true, // control resizing animation
        enableRoundCorner = false,
        clipEdge = true,
        hasDefaultSelection = false,
        totalIntervalTime = 1000,
        afterAttachToDOM = false,
        isOnlyInitAnimation = false;
    
    var defsEnter, 
        roundCornerDefs,
        suffix = ObjectUtils.guid();
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;

    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(!isOnlyInitAnimation){
        hasAnmation = enableDataLoadingAnimation;
      }else if(dataStructureChange || dataValueChange){
        hasAnmation = enableDataUpdatingAnimation;
      }else if(sizeChange){
        hasAnmation = enableResizingAnimation;
      }
      return hasAnmation;
    }
    
    chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
        // find the closet dimension
        var i = -1;
        while (i < seriesData.length) {
          if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
            break;
          }
          i++;
        }
        
        if (i > (seriesData.length - 1)) i = seriesData.length - 1;
        if (i < 0) i = 0;

        //if (i > (seriesData.length - 1)|| i < 0) {
        //  decorativeShape.attr('visibility', 'hidden');
        //  return;
        //}
      
        decorativeShape.attr('x',xScale.rangeBand() * i + barWidth/4)
                       .attr('visibility', 'visible');
              
        if(lastHovered !== i){
          if (tooltipVisible) {
            lastHovered = i;
            //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
            var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
            var xoffset = transform.e;
            
            var tData = tooltipDataHandlerObj.generateTooltipData(data, seriesData, i, colorPalette, shapePalette);
            tData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: point.y
            };
            tData.plotArea = {
              x : transform.e,
              y : transform.f,
              width : width,
              height : height
            };
            eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
          }
        }
      };
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
        	elems[i].setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
            elems[i].setAttribute('fill-opacity', 1);
            if(!enableRoundCorner){
                elems[i].setAttribute('stroke', '#333333');
           }
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
          elems.setAttribute('fill-opacity', 1);
          if(!enableRoundCorner){
              elems.setAttribute('stroke', '#333333');
          }
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, true, elems);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
        	elems[i].setAttribute('class',CLASSDATAPOINT);
            elems[i].setAttribute('fill-opacity', 0.4);
            elems[i].setAttribute('stroke','none');
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINT);
          elems.setAttribute('fill-opacity', 0.4);
	      elems.setAttribute('stroke','none');
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, false, elems);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null || gray == false){
          var rects = sWrapper.selectAll('.v-datapoint');
              rects.attr('fill-opacity', 1).attr('stroke','none').attr('class',CLASSDATAPOINT);
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(sWrapper, false, rects);
          }
        }else{
          sWrapper.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke','none').attr('class',CLASSDATAPOINT);
        }
      };
      

      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
        enableResizingAnimation = properties.animation.resizing;
        tooltipVisible = properties.tooltip.enabled;
        drawingEffect = properties.drawingEffect;
      
        if(isDualAxis && !hasMNDonCategoryAxis){
          axis1ColorPalette = properties.primaryValuesColorPalette;   
          axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
          axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
        var colorIndexes = 0;
        if(!hasMNDonCategoryAxis){
          indexforSecondaryAxis = data1.length;
          colorIndexes = seriesData[0].length;   
        }else{
          colorIndexes = seriesData.length * seriesData[0].length;
        }
        colorPalette = [];
        if(MNDInnerOnColor){
          var flag = 0, flag2 = 0, j = 0;
          for(var i=0 ; i < indexforSecondaryAxis; i++){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            flag++;
            if(flag == measureOnAxis1){
              flag2 = 0;
              for(; j <=(colorIndexes-indexforSecondaryAxis); j++){
                if(flag2 >= measureOnAxis2){
                  flag = 0;
                  break;
                }
                colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
                flag2++;
              }
            }
          }
        }else{
          for(var i=0 ; i < colorIndexes; i++){
            if(i < indexforSecondaryAxis){
              colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            }else if(isDualAxis && !hasMNDonCategoryAxis){
              colorPalette.push(axis2ColorPalette[(i-indexforSecondaryAxis) % axis2ColorPalette.length]);  
            }
          }  
        }
      };
      
      /**
       * Create chart
       */

      function chart(selection){
        
        boundUtil.drawBound(selection, width, height);

        tooltipDataHandlerObj = tooltipDataHandler();
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(valueScales.length == 0) return;
        
        eDispatch.startToInit();
        
        selection.each(function(){
              barNumber = seriesData[0].length;
              barGroupNumber =  seriesData.length;
              barWidth = 8 * (xScale.rangeBand()) / (9*barNumber +7 );
              
              var svg = sWrapper = d3.select(this);

              if(decorativeShape == null){
                  decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() - barWidth/2).attr('height',height).attr('visibility', 'hidden')
                    .attr('fill', ctx.styleManager.queryDefault('v-hovershadow').fill).attr('class', 'v-hovershadow');
                }else{
                  decorativeShape.attr('width', xScale.rangeBand() - barWidth/2).attr('height',height).attr('visibility', 'hidden');
                }
    
              //vertical bar
              if(defsEnter == null){
                defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
              }else{
                defsEnter.attr('width', width).attr('height', height);
              }    
              
              if(roundCornerDefs == null){      
                roundCornerDefs = svg.append('defs');
              }else{
                if( dataStructureChange || sizeChange || dataValueChange || !enableRoundCorner){
                  roundCornerDefs.selectAll(".v-clippath").remove();
                }
              }
            
              var r = Math.log(barWidth)/Math.log(2);
              if( r < 0 ){
                enableRoundCorner = false;
              }
              var valueScale;
              var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
              if(!TypeUtils.isExist(datashapesgroup[0][0])){
                datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup');
              }
              
              var barGroup = datashapesgroup.selectAll('g.v-column').data(seriesData), lastBarGroupIndex = seriesData.length -1, lastBarIndex = seriesData[0].length - 1;    
                  barGroup.enter().append('g');
                  barGroup.attr('class','v-column').each( function (perBarGroup, i) {
                      var xArray=[], yArray=[];
                      var barShape = d3.select(this).selectAll('g.v-datashape').data(perBarGroup);
                      barShape.enter().append('g').attr('class','v-datashape').append('rect').attr('class', 'v-datapoint');

                      barShape.exit().remove();
                      // [21-Nov-2012 Nick] Keep the original x-position for each g.datashape, it is used when data value changes.
                      if(afterAttachToDOM){
                        barShape.each(function(){
                          yArray.push(this.getTransformToElement(this.parentNode).f);
                        });
                      }
                      barShape.attr('transform', function(perRectData,m){
                          var y;
                          valueScale = valueScales[perRectData.valueAxis];
                          if(perRectData.val >= 0){
                            y = valueScale(perRectData.val);
                          }else{
                           y = valueScale(0) ;
                          }
                          var x = xScale(i) + barWidth * m;
                          x = x + barWidth/8 *(m) + barWidth/2;
                          xArray.push(x);
                          return 'translate('+x+','+y+')';
                      });
                      var bar = barShape.select('rect.v-datapoint');
                        bar.attr('fill', function(d,i){ 
                                  d.fillColor = colorPalette[i % colorPalette.length]; 
                                  var parameter = {
                                      drawingEffect:drawingEffect,
                                      fillColor : d.fillColor,
                                      direction : 'horizontal'
                                  };
                                  return effectManager.register(parameter);
                            })
                            .attr('shape-rendering','crispEdges').attr('fill-opacity', 1).attr('stroke','none');
                      
                        if(enableAnimation()){
                      // [05 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                      // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                      if(dataStructureChange){
                        bar.attr('width', barWidth).attr('height', 0)
                           .attr('x', function (perRectData, m) {
                             var x = xScale(i) - xArray[m] + barWidth * m;
                             x = x + barWidth/8 *(m) + barWidth/2;
                             return x;
                           })
                          .attr('y', function(perRectData){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0 && perRectData.val > 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              return height;
                            }else{
                              return 0;
                            }
                          });
 
                        
                        if(enableRoundCorner){
                         var rcFunction = function(){ bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;
                            roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                .append('rect').attr('rx', r).attr('ry', r)
                                .attr('x', 0).attr('width', barWidth)
                                .attr('y', h)
                                .transition().delay(function(d,m){return (m + barNumber * i) * interval})
                                .attr('height', function(){
                                  valueScale = valueScales[perRectData.valueAxis];
                                  // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                  // the space is reserved
                                  if(perRectData.val !== ' ' && perRectData.val != 0){
                                    var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                    // [10 - Sep - 2012 Nick] if the height of one bar is less than 1px, use 1px.
                                    return (height + r); 
                                  }else{
                                    return 0;
                                  }
                                })
                                .attr('y', function(){
                                  if(perRectData.val > 0){
                                    return  0;
                                  }else{
                                    return 0 - r;
                                  }
                                });
                            return 'url(#' + id + ')'; });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                        }
                        
                        var interval = totalIntervalTime / (barNumber * barGroupNumber);
                        bar.transition().delay(function(d,m){return (m + barNumber * i) * interval})
                          .attr('height', function(perRectData,m){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              return height;
                            }else{
                              return 0;
                            }
                          })
                          .attr('y', 0).attr('x',0)
                          .each('end', function(perRectData, m){
                            if(m === lastBarIndex && i === lastBarGroupIndex){
                              completeAnimation();
                            }
                          });
                      }else if(sizeChange){
                        if(enableRoundCorner){
                         var rcFunction = function(){ bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                            roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                              .append('rect').attr('rx', r).attr('ry', r)
                                  .attr('width', w).attr('x', x).attr('height', h)
                                  .attr('y', function(){
                                      if(perRectData.val > 0){
                                        return 0;
                                      }else{
                                        return 0 - r;
                                      }
                                  })
                                  .transition().duration(totalIntervalTime).attr('width',barWidth)
                                  .attr('height', function(){
                                    valueScale = valueScales[perRectData.valueAxis];
                                    // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                    // the space is reserved
                                    if(perRectData.val !== ' ' && perRectData.val != 0){
                                      var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                      // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                      return  (height + r); 
                                    }else{
                                      return 0;
                                    }
                                  })
                            return 'url(#' + id + ')'; });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                        }
                        //bar.transition().delay(function(d,m){return (m + barNumber * i) * interval}).attr('width',  function(d, m){
                        bar.transition().duration(totalIntervalTime).attr('width', barWidth)
                           .attr('height', function(perRectData){
                              valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                              if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              return  height; 
                            }else{
                              return 0;
                            }
                           })
                           .attr('y', 0).attr('x', 0)
                           .each('end', function(d, m){
                             if(m === lastBarIndex && i === lastBarGroupIndex){
                               completeAnimation();
                             }
                           });
                      }else if(dataValueChange){
                        var barYP = [];
                        bar.attr('y',function(d,k){
                          var pos = yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                          barYP.push(pos);
                          return pos;
                        })
                        if(enableRoundCorner){
                         var rcFunction = function(){ bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;  
                            roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                .append('rect').attr('rx', r).attr('ry', r)
                                  .attr('x', x).attr('width', barWidth)
                                  .attr('height', function(){
                                    valueScale = valueScales[perRectData.valueAxis];
                                    var newHeight = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                    if(parseFloat(h) > newHeight){
                                      return h;
                                    }else{
                                      return newHeight;
                                    }
                                  }) 
                                  .attr('y', function(){
                                    return barYP[m];
                                  })
                                  .transition().duration(totalIntervalTime)
                                  .attr('height', function(){
                                      valueScale = valueScales[perRectData.valueAxis];
                                    // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                    // the space is reserved
                                      if(perRectData.val !== ' ' && perRectData.val != 0){
                                      var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                      // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                      return (height + r); 
                                    }else{
                                      return 0;
                                    }
                                  }).attr('y', function () {
                                      valueScale = valueScales[perRectData.valueAxis];
                                    if(perRectData.val >= 0){
                                      return 0;
                                    }else{
                                      return 0 - r;
                                    }
                                  });
                            return 'url(#' + id + ')'; });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                        }
                        
                        //To seperate dataValueChange, as in size change, we calculate more than data value change.
                        //in value change, only change the width, in size, there are height width, y
                        bar.transition().duration(totalIntervalTime)
                          .attr('height', function(perRectData,m){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              perRectData.height = height;
                              return height; 
                            }else{
                              return 0;
                            }
                          })
                          .attr('y', 0).attr('x',0)
                          .each('end', function(d, m){
                            if(m === lastBarIndex && i === lastBarGroupIndex){
                              completeAnimation();
                            }
                          });
                      }
                      else if(enableRoundCorner){
                      var rcFunction = function(){ bar.attr('clip-path', function(perRectData, m){
                          var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                        roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                          .append('rect').attr('rx', r).attr('ry', r)
                          .attr('width', barWidth)
                          .attr('height', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              return  (height + r); 
                            }else{
                              return 0;
                            }
                          })
                          .attr('y', function () {
                               valueScale = valueScales[perRectData.valueAxis];
                               if(perRectData.val >= 0){
                                 return 0;
                               }else{
                                 return 0 - r;
                               }
                          })
                          .attr('x', 0);
                          return 'url(#' + id + ')'; 
                          if(m === lastBarIndex && i === lastBarGroupIndex){
                            completeAnimation();
                          }
                        });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                        }  
                    }
                      // [05-Sep-2012 Nick] When animation is disabled, the chart is drawed here.
                      else{
                       bar.attr('width', barWidth)
                         .attr('height', function(perRectData){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                          // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                            var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                            // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                            perRectData.height = height;
                            return height; 
                          }else{
                            return 0;
                          }
                         })
                         .attr('y', 0).attr('x', 0);
                      
                      if(enableRoundCorner){
                        var rcFunction = function(){ bar.attr('clip-path', function(perRectData, m){
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                          roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                            .append('rect').attr('rx', r).attr('ry', r)
                            .attr('width', barWidth)
                            .attr('height', function(){
                              valueScale = valueScales[perRectData.valueAxis];
                              // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                              // the space is reserved
                              if(perRectData.val !== ' ' && perRectData.val != 0){
                                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                return  (height + r); 
                              }else{
                                return 0;
                              }
                            })
                            .attr('y', function () {
                                 valueScale = valueScales[perRectData.valueAxis];
                                 if(perRectData.val >= 0){
                                   return 0;
                                 }else{
                                   return 0 - r;
                                 }
                            })
                            .attr('x', 0);
                          return 'url(#' + id + ')'; });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                        }
                      }
                     // bar.exit().remove();
                });

                barGroup.exit().remove();
        });

        if (! enableAnimation()){
          completeAnimation();
        }  
        sizeChange = false, dataValueChange = false, dataStructureChange = false;
        isOnlyInitAnimation = true;
        return chart;
      }
      

      function completeAnimation(){
          eDispatch.initialized();
          afterAttachToDOM = true;
      }
      
      chart.afterUIComponentAppear = function(){
        eDispatch.initialized(); 
      };
      
      
    function changeYPosition(d,m){
      var i = d3.interpolate(height,  (m >= indexforSecondaryAxis) ? yScale2(d.val) : yScale(d.val));
        return function(t){ 
          return   i(t);
        }
    };
    
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange =  (width === value)&&!sizeChange ? false:true;
          width = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange ? false:true;
        height = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
    chart.data = function(value){
      if (!arguments.length){
          return data;
      }
        data = value;
        
        var obj = MNDHandler(data);

        data1 = obj["MG1"];
        data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;

        if ( data1[0] && data1[0][0].info && data1[0][0].info.defaultSelection ) {
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        }
        
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
        }else{
          hasMNDonCategoryAxis = false;
          if(TypeUtils.isExist(data2)){
                isDualAxis = true;
            }else{
                isDualAxis = false;
            }
        }
        
        var _seriesData = dataTransform(data1,data2, obj.color);
        //judge what changed in dataset
        if(seriesData.length !== _seriesData.length || _seriesData[0].length !== seriesData[0].length){
          dataStructureChange = true;
        }else {
          dataValueChange = true;
        }
        seriesData = _seriesData;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
       return chart;        
    };


      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return properties;
         }
            Objects.extend(true, properties, props);  
            parseOptions();

         return chart;        
      };
     
      /**
       * TODO: add desc
       */
      var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
           domain.push(i);
        }
      
      valueScales = [];
        //when all data is 0 or null, we make yscale.domain from 0 to 1
        xScale.domain(domain).rangeBands([0, width]);
        if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
          yScale.domain([0, 1]).range([height, 0]);

        }else{
          yScale.domain([primaryAxisBottomBoundary, primaryAxisTopBoundary]).range([height, 0]);

        }

        if(TypeUtils.isExist(data2) || isDualAxis){
        //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

          if(secondaryAxisTopBoundary === 0 && secondaryAxisBottomBoundary === 0){
            yScale2.domain(yScale.domain()).range(yScale.range());
          }else{
            yScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([height, 0])
            //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
            if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
              yScale.domain(yScale2.domain()).range(yScale2.range());
            }
          }
          if (!secondaryAxisManualRange && !primaryAxisManualRange)
          {
              Scaler.perfectDual(yScale, yScale2);
          }
          else if(!secondaryAxisManualRange && primaryAxisManualRange)
          {
              Scaler.getRoughTickNum(yScale);
              Scaler.perfect(yScale2);
          }
          else if (secondaryAxisManualRange && !primaryAxisManualRange)
          {
              Scaler.perfect(yScale);
              Scaler.getRoughTickNum(yScale2);
          }
          else
          {
              Scaler.getRoughTickNum(yScale);
              Scaler.getRoughTickNum(yScale2);
          }
        }else{
          if (!primaryAxisManualRange) {
            Scaler.perfect(yScale);
          } else {
            Scaler.getRoughTickNum(yScale);
          }
          yScale2.range([0, 0]);
        }
            valueScales.push(yScale);
            valueScales.push(yScale2);
      };
      
      /**
       * TODO: please fill your comments here, or jsdoc will complain.
       */
      chart.categoryScale = function(scale){
        if (!arguments.length){
          return xScale;
         }
        xScale = scale;
         return chart;
      };
     
      chart.primaryScale = function(scale){
        if (!arguments.length){
          return yScale;
         }
        yScale = scale;
        valueScales[0] = yScale;
         return chart;
      };
      
      chart.secondScale = function(scale){
        if (!arguments.length){
          return yScale2;
         }
        yScale2 = scale;
        valueScales[1] = yScale2;
         return chart;
      };

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(!hasMNDonCategoryAxis){
          return colorPalette[seriesData[0].length - 1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };          
      
      chart.primaryDataRange = function(range){
        if (!arguments.length){
          return {
            min: primaryAxisBottomBoundary,
            max: primaryAxisTopBoundary
          };
        }
        if (range !== null) {
            primaryAxisTopBoundary = range.max;
            primaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                primaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          return {
            min: secondaryAxisBottomBoundary,
            max: secondaryAxisTopBoundary
          };
        }
        if (range !== null) {
            secondaryAxisTopBoundary = range.max;
            secondaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                secondaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };    

      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length)
          return y;
        y = _;
        return this;
      };

      chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
    chart.dataLabel = function(_){};
    
    chart.eventTarget = function (evt) {
      if (evt.type == 'mousemove') {
        return chart.hoverOnPoint;
      } else if (evt.type == 'mouseout') {
        return blurOut;
      }
    };
      
      /**
      * get/set your color palette if you support color palette
      */
      chart.colorPalette = function(_){
        if(!arguments.length){
          return colorPalette;
        }
        colorPalette = _;
        return this;
      };

                
        // chart.primaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis1ColorPalette;
            // }  
            // axis1ColorPalette = _;
            // return this;
        // };
// 
        // chart.secondaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis2ColorPalette;
            // }  
            // axis2ColorPalette = _;
            // return this;
        // };        

      /**
      * get/set your shape Palette if you support shape Palette
      */
      chart.shapePalette = function(_){
        if(!arguments.length){
          return shapePalette;
        }
        shapePalette = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
//      var dataTransform = function(data1,data2){
//        var stackedBarGroup = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;
//      var transferredDataSet = [];
//      for(var i=0; i<data1.length; i++){
//                var temp = d3.max(data1[i], function(m){return m.val;});
//                var temp2 = d3.min(data1[i], function(m){return m.val;});
//                if(primaryAxisTopBoundary <temp){
//                    primaryAxisTopBoundary = temp;
//                }
//                if(primaryAxisBottomBoundary > temp2){
//                    primaryAxisBottomBoundary = temp2;
//                }
//          transferredDataSet.push(data1[i]);
//        }
//      if(data2 != undefined){
//        for(i=0; i<data2.length; i++){
//                    var temp = d3.max(data2[i], function(m){return m.val;});
//                    var temp2 = d3.min(data2[i], function(m){return m.val;});
//                    if(secondaryAxisTopBoundary < temp){
//                        secondaryAxisTopBoundary = temp;
//                    }
//                    if(secondaryAxisBottomBoundary > temp2){
//                        secondaryAxisBottomBoundary = temp2;
//                    }
//          transferredDataSet.push(data2[i]);
//        }
//      }
//       
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        for(i=0; i< transferredDataSet.length; i++){
//          ds.push(transferredDataSet[i][j]);
//        }
//        stackedBarGroup.push(ds);
//      }
//     
//        return stackedBarGroup;
//      };
      
      var dataTransform = function(valueAxis1,valueAxis2, colorIndexArray){
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        var barGroups = [];
      // the number of bar in each group
      var barGroupNumber = 0;
      
      if (valueAxis1[0] && valueAxis1[0].length) {
            barGroupNumber = valueAxis1[0].length;
      } else if (valueAxis2[0] && valueAxis2[0].length) {
            barGroupNumber = valueAxis2[0].length;
      }
      var barGroup = [];
      var temp = temp2 = 0;
      for(var i=0; i < valueAxis1.length; i++){
        if(hasMNDonCategoryAxis){
          for(var j = 0;  j< valueAxis1[i].length; j++){
            if(colorIndexArray[j] == 0){
              temp = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 0;
              
              if(primaryAxisTopBoundary <temp){
                primaryAxisTopBoundary = temp;
              }
              if(primaryAxisBottomBoundary > temp){
                primaryAxisBottomBoundary = temp;
              }
              indexforSecondaryAxis++;
            }else{
              temp2 = valueAxis1[i][j].val;
              
              valueAxis1[i][j].valueAxis = 1;
              if(secondaryAxisTopBoundary < temp2){
                secondaryAxisTopBoundary = temp2;
              }
              if(secondaryAxisBottomBoundary > temp2){
                  secondaryAxisBottomBoundary = temp2;
              }
            }
          }
        }else{
          temp = d3.max(valueAxis1[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis1[i], function(m){return m.val;});
          
          if(primaryAxisTopBoundary <temp){
            primaryAxisTopBoundary = temp;
          }
          if(primaryAxisBottomBoundary > temp2){
            primaryAxisBottomBoundary = temp2;
          }
        }
        barGroup.push(valueAxis1[i]);
          
        }
      if(valueAxis2 != undefined){
      
        for(i=0; i<valueAxis2.length; i++){
          var temp = d3.max(valueAxis2[i], function(m){return m.val;});
          var temp2 = d3.min(valueAxis2[i], function(m){return m.val;});
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
              secondaryAxisBottomBoundary = temp2;
          }
          barGroup.push(valueAxis2[i]);
        }
      }
      
      
       
      for(var j=0; j < barGroupNumber; j++){
        var ds = [];
        for(i=0; i< barGroup.length; i++){
          if(!hasMNDonCategoryAxis){
            if( i < valueAxis1.length){
              barGroup[i][j].valueAxis = 0;
            }else{
              barGroup[i][j].valueAxis = 1;
            }
          }
          if(NumberUtils.isNoValue(barGroup[i][j].val)){
            barGroup[i][j].val = ' ';
          }
          ds.push(barGroup[i][j]);
        }
        if(MNDInnerOnColor){
          var dSet = [], flag1=0, flag2=0;
          var n=0;
          for(var m=0; m < valueAxis1.length; m++){
            dSet.push(ds[m]);
            flag1++;
            if(flag1 == measureOnAxis1 && valueAxis2 != undefined){
              flag2 = 0;
              for(; n<valueAxis2.length; n++){
                if(flag2 >= measureOnAxis2){
                  flag1 = 0;
                  break;
                }
                dSet.push(ds[valueAxis1.length+n]);
                flag2++;
              }
            }
          }
          barGroups.push(dSet);
        }else{
          barGroups.push(ds);
        }
      }
        return barGroups;
      };
    
      properties = manifest.props(null);
      return chart;
  };
  return vBar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.verticalbar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.verticalbar',
    'name' : 'vertical bar',
    base : "sap.viz.modules.xy.bar.base",
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_column',
    name : 'IDS_MULTIVERTICALBARCHART',
    base : 'viz/multi_bar',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'verticalbar',
                orientation : 'left'
              }
            }
          },
          main : {
            modules: {
              plot : {
                modules : {
                  background : {
                    configure : {
                      properties : {
                        direction : 'vertical'
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        orientation : 'vertical',
                        outsidePosition : 'up'
                      }
                    }
                  },
                  xAxis : {
                    data : {
                      aa : [ 1 ]
                    },
                    configure : {
                      'description':'Settings for the category axis of an XY chart.',
                      properties : {
                        type : 'category',
                        gridline : {
                          visible : false
                        }
                      },
                      propertiesOverride : {                   
                        gridline : {
                  isExported : false
                  },
                  label : {
                        isExported : false
                        },
                        axisline : {
                        isExported : false
                       }
                      }
                    }
                  },
                  /**
                   * 'xAxis2' : { },
                   */
        
                  yAxis : {
                    data : null,
                    configure : {
                      'description':'Settings for the value axis of an XY chart.',
                      properties : {
                        type : 'value',
                        gridline : {
                          visible : true
                        }
                      },
                      propertiesOverride : {                   
                        gridline : {
                  isExported : true
                  },
                  label : {
                        isExported : true
                        },
                        axisline : {
                        isExported : true
                       }
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.verticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{  
        multiplier:{
        max:1
      },
        axisLabels:{
        max:1
      },
      secondaryValues: null
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, { targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var multiVBarChart = {
    id : 'viz/multi_dual_column',
    name : 'IDS_MULTIDUALVERTICALBARCHART',
    base : 'viz/multi_column',
    modules : {
      root : {
        modules : {
          main : {
            configure : { properties : { 'mergeDataRange' : ['primary', 'second'] } },
            modules: {
              plot : {
                modules : {
                  plot: {
                    configure: {
                      propertiesOverride:{
                        primaryValuesColorPalette:{ isExported: true },
                        secondaryValuesColorPalette: { isExported: true }
                      }
                    }
                  },
                  yAxis:{
                    id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                  },
                  yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                      propertyCategory : 'yAxis2',
                      properties : {
                        title : { visible : false },
                        type : 'value',
                        position : 'right'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  }
                }
              }
            }
          }
      }
    }
    
    },
    feeds:{
      multiplier : { max:1 },
      secondaryValues : { min : 1, max : Number.POSITIVE_INFINITY  },
      axisLabels:{ max:1 }
    },
    
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.main.plot.yAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'secondScale'
      }, {
        targetModule : 'root.main.plot.yAxis2',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'root.main.plot.yAxis2',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.stackedverticalbar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(TypeUtils, ObjectUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, NumberUtils, Objects, langManager, boundUtil, defaultSelUtil, UADetector) {
  var bar = function(manifest, ctx) {
        var CLASSMARKERSELECTED = "v-datapoint-selected",
          CLASSMARKERHOVER = "v-datapoint-hover",
          CLASSDATAPOINT = "v-datapoint";
      var tooltipDataHandlerObj;
      var data, 
          data1 = [[]],
          data2 = [[]],
          seriesData = [], tooltipData = [],
          primaryAxisTopBoundary = 0,
          primaryAxisBottomBoundary = 0,
          primaryAxisManualRange = false,
          secondaryAxisManualRange = false,
          secondaryAxisTopBoundary = 0,
          secondaryAxisBottomBoundary = 0,
          gWrapper = null;
    
      var width,
          height,
          x = 0, y = 0,
          isDualAxis = false,
          hasMNDonCategoryAxis = false,
          colorPalette = [],
          axis1ColorPalette,
          axis2ColorPalette,
          MNDInnerOnColor = false,
          measureOnAxis1 = 0,
          measureOnAxis2 = 0,
          shapePalette = ['squareWithRadius'],
          properties,
          eDispatch = dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized','startToInit');
    
      var effectManager = ctx.effectManager;
    
      var valueScales = new Array(2),
          xScale = d3.scale.ordinal(),
          yScale = d3.scale.linear(),
          yScale2 = d3.scale.linear();
      
      var decorativeShape, 
          lastSelected = [], 
          tooltipVisible = true,      
          lastHovered = null;
      
      var barNumber,
          barGroupNumber,
          barNumberinGroup,
          yPositions = [],
          positiveIndexes = [], 
          negativeIndexes = [],
          barWidth;
    
      var defsEnter, 
          roundCornerDefs,
          suffix = ObjectUtils.guid();

      var enableDataLoadingAnimation = true,
          enableDataUpdatingAnimation = true,
          enableResizingAnimation = true, // control resizing animation
          enableRoundCorner = false,
          clipEdge = true,
          hasDefaultSelection = false,
          isOnlyInitAnimation = false,
          afterAttachToDOM = false,
          totalIntervalTime = 800;

      var mode = 'comparison'; //bar display mode
      var drawingEffect = 'normal';
    
      var sizeChange = false, dataStructureChange = false, dataValueChange = false;
    
      var totalAnimationCount, currentAnimationCount;
      //@Alex Su, judge whether we should enable animation
      
      function enableAnimation(){
        var hasAnmation = false;
        if(!isOnlyInitAnimation){
          hasAnmation = enableDataLoadingAnimation;
        }else if(dataStructureChange || dataValueChange){
          hasAnmation = enableDataUpdatingAnimation;
        }else if(sizeChange){
          hasAnmation = enableResizingAnimation;
        }
        return hasAnmation;
      }
      
   
      
      function turnToPercentage(){
        for(var i=0, len = seriesData.length; i < len; i++){
            for(var j=0 , rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++){
              var sum = 0, avaCount = 0, k;
              for(k=0; k < rowSeriesData[j].length; k++){
                sum += Math.abs(rowSeriesData[j][k].val);
                if(!rowSeriesData[j][k].isNaN) {avaCount++;}
              }
              if(sum === 0){
                for(k=0; k < rowSeriesData[j].length; k++){
                        rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                        rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                        }
                }
              }else{
                for( k=0; k < rowSeriesData[j].length; k++){
                      if(rowSeriesData[j][k].val < 0){
                        rowSeriesData[j][k].isNegative = true;
                      }
                      rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                      rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
                      if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                        rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
                      }
                }
              }
              
            }
          }
        }
      
       
      
      
      var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        mode = properties.mode === 'percentage'? 'percentage': 'comparison';
        enableDataLoadingAnimation = properties.animation.dataLoading; 
        enableDataUpdatingAnimation = properties.animation.dataUpdating; 
        enableResizingAnimation = properties.animation.resizing;
        tooltipVisible = properties.tooltip.enabled;    
        if(isDualAxis && !hasMNDonCategoryAxis){
          axis1ColorPalette = properties.primaryValuesColorPalette;   
          axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
          axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
      
        drawingEffect = properties.drawingEffect;
        colorPalette = [];
        
        var flag = 0, flag2 = 0, j = 0, i = 0;
        if(MNDInnerOnColor){
          for(i=0 ; i < seriesData[0][0].length; i++){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            flag++;
            if(flag === measureOnAxis1 && isDualAxis && TypeUtils.isExist(seriesData[0][1])){
              flag2 = 0;
              for(; j <= seriesData[0][1].length; j++){
                if(flag2 >= measureOnAxis2){
                  flag = 0;
                  break;
                }
                colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
                flag2++;
              }
            }
          }
        }else{
          for(i=0 ; i < seriesData[0].length; i++){
            for(j=0; j < seriesData[0][0].length; j++){
               colorPalette.push(axis1ColorPalette[j % axis1ColorPalette.length]);
            }
            if(isDualAxis && TypeUtils.isExist(seriesData[0][1])){
                for(j=0; j < seriesData[0][1].length; j++){
                   colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
                }
            }
          }  
        }       
      };
      
      function chart(selection){
        
        boundUtil.drawBound(selection, width, height);
        
        tooltipDataHandlerObj = tooltipDataHandler();
        
        //deal with percentage mode
        if(mode === 'percentage'){
          turnToPercentage();
        }
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(!TypeUtils.isExist(yScale) && !TypeUtils.isExist(yScale2)){
          return;
        }
        
        currentAnimationCount = 0;
        totalAnimationCount = 0;
        
        eDispatch.startToInit();
        
        selection.each(function(){
          var indexForAxis2 = data1.length;
              barNumberinGroup = seriesData[0][0].length + ((TypeUtils.isExist(seriesData[0][1])) ? seriesData[0][1].length : 0);
          var barWidthInitial = 8 * (xScale.rangeBand()) / (9*barNumberinGroup +7 );
              barNumber = (TypeUtils.isExist(data2)) ? 2 : 1;
              barWidth = 8 * (xScale.rangeBand()) / (9*barNumber +7 );
        
          totalAnimationCount = seriesData.length * barNumberinGroup;
          
          gWrapper = d3.select(this);
          
          var svg =  gWrapper;
          
          if(decorativeShape === undefined){
            decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() -barWidth/2).attr('height',
                height).attr('visibility', 'hidden').attr(
                'fill', ctx.styleManager.queryDefault('v-hovershadow').fill).attr('class', 'v-hovershadow');
          }else{
            decorativeShape.attr('width', xScale.rangeBand() -barWidth/2).attr('height',height).attr('visibility', 'hidden');
          }

          if(defsEnter === undefined){
            defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
          }else{
            defsEnter.attr('width', width).attr('height', height);
          }  
          
          if(roundCornerDefs === undefined){      
            roundCornerDefs = svg.append('defs');
          }else{
            if( dataStructureChange || sizeChange || dataValueChange || !enableRoundCorner ){
              roundCornerDefs.selectAll(".v-clippath").remove();
            }
          }
           
          var r = Math.log(barWidth)/Math.log(2);
          if( r < 0 ){
            enableRoundCorner = false;
          }
        
          var valueScale, tempPos = 0, tempNeg = 0, negativeIndex = 0, postiveIndex = 0;
          var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
          if(!TypeUtils.isExist(datashapesgroup[0][0])){
            datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup');
          }
          var barGroup = datashapesgroup.selectAll('g.v-stackedcolumn').data(seriesData);          
          barGroup.enter().append('g');
          barGroup.attr('class','v-stackedcolumn').each(function (perGroupData, i) {
                var axisGroup = d3.select(this).selectAll('g.v-axisGroup').data(perGroupData);     
                axisGroup.enter().append('g');
                axisGroup.attr('class','v-axisGroup').each( function (perAxisData,j) {  
                  // This is for dual axis
                  var valueScale = (j === 0) ? yScale : yScale2;
                  var startPoint = (j === 0) ? barWidth /2 : (barWidth /2 + barWidth + barWidth/8);
                  var initStartPoint = (j === 0) ? xScale(i) : (xScale(i) + barWidth / 2 + barWidth) ;
                  var fillingColor =  (j === 0) ? axis1ColorPalette : axis2ColorPalette;
                  
                  // This is for pos/neg values.
                  var positiveY = 0, negativeY = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                  var yArray = [], xArray=[];
                  
                  // wrap a datashape g for each rect
                  var barShape = d3.select(this).selectAll('g.v-datashape').data(perAxisData);
                      barShape.enter().append('g').attr('class','v-datashape').append('rect').attr('class', 'v-datapoint');
                      barShape.exit().remove();
                      
                      // [21-Nov-2012 Nick] Keep the original x-position for each g.datashape, it is used when data value changes.
                      if(afterAttachToDOM){
                        barShape.each(function(){
                          yArray.push(this.getTransformToElement(this.parentNode).f);
                        });
                      }
                      
                      // [20-Nov-2012 Nick] As g.datashape is considered as a 'shape' concept, all positioning behavior is applied to this element
                      barShape.attr('transform', function (perRectData, m) {
                          var y ;
                          if(perRectData.val >=0 ){
                            positiveStackedValue += perAxisData[m].val;
                            positiveY = valueScale(positiveStackedValue);                          
                            y= positiveY;
                          }else{
                            negativeY = valueScale(negativeStackedValue);
                            negativeStackedValue += perAxisData[m].val;
                            y= negativeY;
                          }
                          var x = xScale(i) + startPoint;
                          xArray.push(x);
                          return 'translate('+x+','+y+')';
                      });
                      
                  var bar = barShape.select('rect.v-datapoint');
                      bar.attr('fill', function(d,colorIndex){  
                      d.fillColor = fillingColor[colorIndex % fillingColor.length];
                      var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : d.fillColor,
                          direction : 'horizontal'
                      };
                      return effectManager.register(parameter);
                    }).attr('shape-rendering','crispEdges').attr('fill-opacity', 1).attr('stroke','none');
                    
                      if(enableAnimation()){
                    // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                    // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                    if(dataStructureChange){
                      bar.attr('x', function(perRectData, m){
                            var x = initStartPoint - xArray[m] + barWidthInitial * m;
                            x = x + barWidthInitial/8 *(m) + barWidthInitial/2;
                            return x;
                        })
                        .attr('width', barWidthInitial) .attr('height', 0)
                        .attr('y', function (perRectData) {
                          if(perRectData.val > 0){
                            return Math.abs(valueScale(perRectData.val) - valueScale(0));
                          }else{
                            return 0;
                          }
                        });
                      // [04 - Sep - 2012 Nick] Round corner enabled. Do the same transition as the bars do.
                      if(enableRoundCorner){
                       var rcFunction = function(){ bar.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                        .append('rect').attr('class', 'v-roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  Math.abs(valueScale(perRectData.val) - valueScale(0)) + r)
                                        .attr('height',r).attr('width', barWidthInitial)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                        .attr('x',0)
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                      }
                      bar.transition().duration(totalIntervalTime/2)
                         .attr('height', function(perRectData){
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                         })
                         .attr('y', 0).each('end', function(perRectData, m){
                             this.setAttribute('y', 0);
                             this.setAttribute('height', Math.abs(valueScale(perRectData.val) - valueScale(0)));
                             
                             d3.select(this).transition().duration(totalIntervalTime/2)
                             .attr('width', barWidth).attr('x',0)
                             .each('end', function(){
                                this.setAttribute('x', 0);
                                this.setAttribute('width', barWidth);
                              // Fire out event to tell the animation is done.
                                completeAnimation();
                           });
                         });
                      
                    }else if(sizeChange){
                      bar.attr('y',function(d,k){
                          return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                        })
                        .attr('height', function(perRectData,k){
                          var newHeight = Math.abs(valueScale(perRectData.val) - valueScale(0));
                          if(parseFloat(this.height.baseVal.value) > newHeight){
                            return this.height.baseVal.value;
                          }else{
                            return newHeight;
                          }
                        });
                      var sizeChangeTransition = bar.transition();
                      sizeChangeTransition.duration(totalIntervalTime/2)
                        .attr('width', barWidth)
                        .attr('x', 0)
                        .attr('height', function(perRectData){
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                        })
                        .attr('y',0)
                        .each('end', function(d, m){
                            this.setAttribute('width', barWidth);
                            this.setAttribute('x', 0);
                            this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                            this.setAttribute('y', 0);
                           // Fire out event to tell the animation is done.
                             completeAnimation();
                        });
                      if(enableRoundCorner){
                     var rcFunction = function(){
                         sizeChangeTransition.attr('clip-path', function(perRectData, indexinGroup){
                             if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var  y = parseFloat(this.y.baseVal.value);
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                        .append('rect').attr('class', 'v-roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)
                                        .attr('y',  function(){
                                          return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                        })
                                        .attr('height',this.height.baseVal.value + r).attr('width', this.width.baseVal.value)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        .attr('x',0)
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                      }
  
                    }else if(dataValueChange){
                      bar.attr('y',function(d,k){
                        return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                      });
                      var dataValueChangeTransition = bar.transition();
                      dataValueChangeTransition.duration(totalIntervalTime/2)
                         .attr('height', function(perRectData){
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                         })
                         .attr('y', 0)
                         .each('end', function(d, m){
                             this.setAttribute('y', 0);
                             this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                           // Fire out event to tell the animation is done.
                             completeAnimation();
                        });
                      if(enableRoundCorner){
                     var rcFunction = function(){  dataValueChangeTransition.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var  y = parseFloat(this.y.baseVal.value);
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                        .append('rect').attr('class', 'v-roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)
                                        .attr('y',  function(){
                                          return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                        })
                                        .attr('height',this.height.baseVal.value + r).attr('width', this.width.baseVal.value)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('x', 0)
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        });
                            return 'url(#' + id + ')' ;
                          }
                           
                        });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                      }
                    }
                    else if (enableRoundCorner){
                       var rcFunction = function(){bar.attr('clip-path', function(perRectData, indexinGroup){
                        if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                            var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                            var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                      .append('rect').attr('class', 'v-roundCorner-clip')
                                      .attr('rx', r).attr('ry', r)      
                                      .attr('y', function () {
                                        if(indexinGroup === negativeIndexes[j][i]){
                                          return 0 - r;
                                        }else{
                                          return 0;
                                        }
                                      })
                                      .attr('height',function(){
                                         return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                      })
                                      
                                      .attr('x',0)
                                      .attr('width', barWidth);
                          return 'url(#' + id + ')' ;
                        }
                      completeAnimation();
                     });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }

                    }
                  }else{
                    bar.attr('y', 0).attr('x', 0)
                       .attr('width', barWidth)
                       .attr('height', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                       });
                    if(enableRoundCorner){
                       var rcFunction = function(){ bar.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                        .append('rect').attr('class', 'v-roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)      
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0 - r;
                                          }else{
                                            return 0;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        
                                        .attr('x',0)
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                       });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                     }

                   }
                });       
              });
          barGroup.exit().remove();
        });
        if (! enableAnimation()){
          eDispatch.initialized();
        }  
        sizeChange = false, dataValueChange = false, dataStructureChange = false;
        isOnlyInitAnimation = true;
        return chart;
      }
      
      function completeAnimation(){
          if( ++currentAnimationCount ===  totalAnimationCount){
              eDispatch.initialized();
              afterAttachToDOM = true;
          }
        }
      
        chart.afterUIComponentAppear = function(){
          eDispatch.initialized(); 
        };
        
    
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }  
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }  
         return chart;        
      };

      chart.data = function(value){
      if (!arguments.length){
          return data;
      }
      
      data = value;
      var obj = MNDHandler(data);

        var _data1 = obj["MG1"];
        var _data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        tooltipData = [];
        
        var i = 0;
        
      if( _data1[0] && _data1[0][0].info && _data1[0][0].info.defaultSelection){
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        }   
        
      if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
          var tempData1 = [], tempData2 = [];
          var tempStackedData1 = [], tempStackedData2 = [];
          for(i=0; i<_data1.length; i++){
            tempData1 = [];
            tempData2 = [];
            for(var j=0; j<_data1[i].length; j++){
              if(obj.color[j] === 0){
                tempData1.push(_data1[i][j]);
                tempData2.push({
                val:null,
                hasMNDonCategoryAxis : true
              });
              }else{

                tempData1.push({
                val:null,
                hasMNDonCategoryAxis : true
              });
                tempData2.push(_data1[i][j]);
              }
            }
            tempStackedData1.push(tempData1);
            tempStackedData2.push(tempData2);
          }
          _data1 = tempStackedData1;
          _data2 = tempStackedData2;

      }else{
        hasMNDonCategoryAxis = false;
        if(TypeUtils.isExist(_data2)){
          if(! dataStructureChange && (data2.length !== _data2.length || data2[0].length !== _data2[0].length)){
                  dataStructureChange = true;
               }
          isDualAxis = true;
           }else{
              isDualAxis = false;
            }
        }
      
      if(data1.length !== _data1.length || data1[0].length !== _data1[0].length){
            dataStructureChange = true;
          }
      
      var _seriesData = dataHandler(_data1, _data2);
      seriesData = _seriesData;
        data1 = _data1;
        data2 = _data2;
      
        //judge what changed in dataset
        if(!dataStructureChange){
          dataValueChange = true;
        }
        
        if(hasMNDonCategoryAxis){
          for( i=0; i< seriesData.length; i++){
            var temp = seriesData[i];
            if(temp[0][0].hasMNDonCategoryAxis){
              tooltipData.push(temp[1]);
            }else{
              tooltipData.push(temp[0]);
            }
          }
        }else{
          tooltipData = ObjectUtils.extend(true, {}, seriesData); 
        }
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
      
      return chart;        
    };


    /**
     * set/get properties
    */
    chart.properties = function(props){
      if (!arguments.length){
          return properties;
       }
      Objects.extend(true, properties, props);
            parseOptions();
        
        return chart;        
    };
       

    var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
          domain.push(i);
        }
        xScale.domain(domain).rangeBands([0, width]);

        if(mode === 'percentage'){
          yScale.domain([0,1]).range([height, 0]);
          yScale2.domain([0,1]).range([height, 0]);
          Scaler.perfect(yScale);
          Scaler.perfect(yScale2);
        }else{
          //when all data is 0 or null, we make the domain from 0 to 1
          if( primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0 ){
            yScale.domain([0,1]).range([height, 0]);
          }else{
            yScale.domain([primaryAxisBottomBoundary,primaryAxisTopBoundary]).range([height, 0]);
          }

          if(TypeUtils.isExist(data2) || isDualAxis){
          //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

            if(secondaryAxisTopBoundary === 0 && secondaryAxisBottomBoundary === 0){
              yScale2.domain(yScale.domain()).range(yScale.range());
            }else{
              yScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([height, 0]);
              //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
              if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
                yScale.domain(yScale2.domain()).range(yScale2.range());
              }
            }
                      
            if (!primaryAxisManualRange && !secondaryAxisManualRange)
            {
                Scaler.perfectDual(yScale, yScale2);
            }
            else if(!primaryAxisManualRange && secondaryAxisManualRange)
            {
                Scaler.perfect(yScale);
                Scaler.getRoughTickNum(yScale2);
            }
            else if(primaryAxisManualRange && !secondaryAxisManualRange)
            {
                Scaler.perfect(yScale2);
                Scaler.getRoughTickNum(yScale);
            }
            else 
            {
                Scaler.getRoughTickNum(yScale);
                Scaler.getRoughTickNum(yScale2);
            }
          }else{
            if (!primaryAxisManualRange) {
              Scaler.perfect(yScale);
            } else {
              Scaler.getRoughTickNum(yScale);
            }
          }
        }
        if(!TypeUtils.isExist(data2)){
            yScale2.range([0, 0]);
        }
    };

    chart.colorPalette = function(Palette){
        if (!arguments.length){
          return colorPalette;
       }
        colorPalette = Palette;
       return chart;        
    };
    
    chart.primaryDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = primaryAxisBottomBoundary < 0 ? primaryAxisBottomBoundary : 0;
          maxt = primaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      if (range !== null) {
          primaryAxisTopBoundary = range.max;
          primaryAxisBottomBoundary = range.min;
          if (range.from === 'axis') {
            primaryAxisManualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            makeScales();
          }
      }
      return chart;
    };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = secondaryAxisBottomBoundary< 0 ? secondaryAxisBottomBoundary : 0 ;
          maxt = secondaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        if (range !== null) {
            secondaryAxisTopBoundary = range.max;
            secondaryAxisBottomBoundary = range.min;
            if (range.from === 'axis') {
                secondaryAxisManualRange = true;
            }
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
              makeScales();
            }
        }
        return chart;
      };

    chart.categoryScale = function(scale){
        if (!arguments.length){
          return xScale;
       }
        xScale = scale;
       return chart;
    };
       
    chart.primaryScale = function(scale){
        if (!arguments.length){
          return yScale;
       }
        yScale = scale;
        valueScales[0] = yScale;
       return chart;
    };  
    
    chart.secondScale = function(scale){
            if (!arguments.length){
                return yScale2;
            }
            yScale2 = scale;
            valueScales[0] = yScale2;
            return chart;
        };        

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(TypeUtils.isExist(seriesData[0][1]) && !hasMNDonCategoryAxis){
          return axis2ColorPalette[seriesData[0][1].length-1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };  
        
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      chart.dataLabel = function(_){};
      
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length){
            return y;
        }
        y = _;
        return this;
      };
      
      chart.dispatch = function(_){
        if(!arguments.length){
            return eDispatch;
        }
        eDispatch = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.parent = function(){
          return gWrapper;
        };
        
      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
        if (tooltipVisible) {
          eDispatch.hideTooltip();
        }
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
              elems[i].setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
            elems[i].setAttribute('fill-opacity', 1);
            if(!enableRoundCorner){
                elems[i].setAttribute('stroke', '#333333');
            }
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
          elems.setAttribute('fill-opacity', 1);
          if(!enableRoundCorner){
              elems.setAttribute('stroke', '#333333');
          }
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gWrapper, true, elems);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('class',CLASSDATAPOINT);
            elems[i].setAttribute('fill-opacity', 0.4);
            elems[i].setAttribute('stroke','none');
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINT);
          elems.setAttribute('fill-opacity', 0.4);
          elems.setAttribute('stroke','none');
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gWrapper, false, elems);
        }
      };
      
      chart.clear = function(gray){
        if( gray === null || gray === undefined || gray === false){
          var rects = gWrapper.selectAll('.v-datapoint');
              rects.attr('fill-opacity', 1).attr('stroke','none').attr('class',CLASSDATAPOINT);
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(gWrapper, false, rects);
          }
        }else{
          gWrapper.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke','none').attr('class',CLASSDATAPOINT);
        }
      };
      

      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
        // find the closet dimension
        var i = -1;
        while (i < seriesData.length) {
          if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
            break;
          }
          i++;
        }

        if (i > (seriesData.length - 1) || i < 0) {
          decorativeShape.attr('visibility', 'hidden');
          return;
        }

        decorativeShape.attr('x',xScale.rangeBand() * i + barWidth/4)
                       .attr('visibility', 'visible');

        if(lastHovered !== i){
          if (tooltipVisible){      
            lastHovered = i;
            
            //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
            var transform = gWrapper.node().getTransformToElement(gWrapper.node().ownerSVGElement);
            var xoffset = transform.e;
            var sumAxis1 = 100, sumAxis2 = 100 , m = 0;
            var tData = tooltipDataHandlerObj.generateTooltipData(data, tooltipData, i, colorPalette, shapePalette);
            tData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: point.y
            };
            tData.plotArea = {
              x : transform.e,
              y : transform.f,
              width : width,
              height : height
            };
            tData.valueAxis0Count = seriesData[0][0].length;
            tData.valueAxis1Count = TypeUtils.isExist(seriesData[0][1]) ? seriesData[0][1].length:0;
            eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
          }
        }
      };
      
//        var dataTransform = function(data1,data2){
//            var stackedBarGroup = [];
//            // the number of bar in each group
//            var barGroupNumber =  data1[0].length;;
//            var transferredDataSet = data1;
//            var temp;
//            for(var j=0; j < barGroupNumber; j++){
//                var ds = [];
//                temp = 0
//                for(i=0; i< transferredDataSet.length; i++){
//                    ds.push(transferredDataSet[i][j]);
//                    temp += transferredDataSet[i][j].val;
//                }
//                if(primaryAxisBoundary < temp){
//                    primaryAxisBoundary = temp
//                }
//                stackedBarGroup.push(ds);
//            }
//            if(TypeUtils.isExist(data2)){
//                barGroupNumber =  data2[0].length;;
//                transferredDataSet = data2;
//                for(var j=0; j < barGroupNumber; j++){
//                    temp = 0
//                    for(i=0; i< transferredDataSet.length; i++){
//                        stackedBarGroup[j].push(transferredDataSet[i][j]);
//                        temp += transferredDataSet[i][j].val;
//                    }
//                    if(secondaryAxisBoundary < temp){
//                        secondaryAxisBoundary = temp;
//                    }
//                }
//            }
//            return stackedBarGroup;
//        };
        
        
      var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
        
        var positiveIndex = -1, negativeIndex = -1;
        positiveIndexes = [[],[]], negativeIndexes = [[],[]];
      
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        
        var stackedBarGroupsData = [];
        
      // the number of bar in each group
      barGroupNumber =  valueAxis1Data[0].length;
      var temp, temp2;
      for(var j=0; j < barGroupNumber; j++){
        var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
        var oneGroupDataSet = [];
        temp = 0, temp2 = 0;
        positiveIndex = -1, negativeIndex = -1;
        for(var i=0; i< valueAxis1Data.length; i++){
          if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
            //Jimmy/1/9/2013, what happens if we use null as the number value
            //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
            //and http://bclary.com/2004/11/07/#a-11.8.5
            //checked in chrome/IE9/firefox/javafx, it works fine
            //the change is to ensure we display 'No Value' in other places related to this data point
            valueAxis1Data[i][j].val = null;
            valueAxis1Data[i][j].isNaN = true;
          }else{
            
            if(valueAxis1Data[i][j].val >= 0){
              temp += valueAxis1Data[i][j].val;
              positiveIndex = i;
            }else{
              temp2 += valueAxis1Data[i][j].val;
              negativeIndex = i;
            }
          }
          tempDataSetAxis1.push(valueAxis1Data[i][j]);
        }
        positiveIndexes[0].push(positiveIndex);
        negativeIndexes[0].push(negativeIndex);
        
        if(primaryAxisTopBoundary < temp){
          primaryAxisTopBoundary = temp;
        }
        if(primaryAxisBottomBoundary > temp2){
          primaryAxisBottomBoundary = temp2;
        }
        oneGroupDataSet.push(tempDataSetAxis1);
        
        
        if(TypeUtils.isExist(valueAxis2Data)){
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for(i=0; i< valueAxis2Data.length; i++){
            if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
              //Jimmy/1/9/2013, what happens if we use null as the number value
              //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
              //and http://bclary.com/2004/11/07/#a-11.8.5
              //checked in chrome/IE9/firefox/javafx, it works fine
              //the change is to ensure we display 'No Value' in other places related to this data point
              valueAxis2Data[i][j].val = null;
              valueAxis2Data[i][j].isNaN = true;
            }else{
              
              if(valueAxis2Data[i][j].val >= 0){
                temp += valueAxis2Data[i][j].val;
                positiveIndex = i;
              }else{
                temp2 += valueAxis2Data[i][j].val;
                negativeIndex = i;
              }
            }
            tempDataSetAxis2.push(valueAxis2Data[i][j]);
          }
          positiveIndexes[1].push(positiveIndex);
          negativeIndexes[1].push(negativeIndex);
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
            secondaryAxisBottomBoundary = temp2;
          }
          oneGroupDataSet.push(tempDataSetAxis2);
        }
        stackedBarGroupsData.push(oneGroupDataSet);
      }
      
        return stackedBarGroupsData;
      };
        
      properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.stackedverticalbar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedverticalbar',
      'name' : 'stacked vertical bar',
      base : "sap.viz.modules.verticalbar",
      'properties' : {
        'mode' : {
          'name' : 'mode',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'comparison', 'percentage' ],
          'defaultValue' : 'comparison',
          'description' : 'Set dispaly mode of stacked vertical bar.',
            'isExported' : true
        }
      },
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_dual_stacked_column',
    name : 'IDS_MULTIDUALSTACKEDVERTICALBARCHART',
    base : 'viz/multi_dual_column',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualPercentageStackedVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_100_dual_stacked_column',
    name : 'IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART',
    base : 'viz/multi_dual_stacked_column',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                modules : {
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      properties : {
                        isPercentMode : true
                      }
                    }
                  },
                  yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      properties : {
                        isPercentMode : true
                      }
                    }
                  },
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                      properties : {
                        'mode' : 'percentage'
                      }
                    }
                  },
                  
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          isPercentMode : true,
                          type : 'value',
                          showZero : true
                        }
                      }
                    }
                }
              }
            }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
            formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
        }
      }
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var multiBarChart = {
    id : 'viz/multi_dual_bar',
    name : 'IDS_MULTIDUALBARCHART',
    base : 'viz/multi_bar',
    modules : {
      root : {
        modules : {
          main : {
            configure : { properties : { 'mergeDataRange' : ['primary', 'second'] } },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                   plot : {
                    configure : {
                      propertiesOverride : {
                        primaryValuesColorPalette : { isExported: true },
                        secondaryValuesColorPalette: { isExported: true }
                      }
                    }
                  },
                  
                  xAxis:{
                    id : 'sap.viz.modules.axis',
                    configure:{
                      description : 'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                  },
                  
                  xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      description : 'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                      propertyCategory : 'xAxis2',
                      properties : {
                        title : { visible : false },
                        gridline : { visible : false },
                        type : 'value',
                        position : 'top'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      multiplier : { max:1 },
      secondaryValues : { min: 1, max : Number.POSITIVE_INFINITY },
      axisLabels : { max:1 }
    },
    
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },   {
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },   {
        targetModule : 'root.main.plot.xAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'secondScale'
      },
   {
        targetModule : 'root.main.plot.xAxis2',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'root.main.plot.xAxis2',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.stackedbar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(TypeUtils, ObjectUtils, dispatch, MNDHandler,tooltipDataHandler, ColorSeries, Scaler, ObjectUtils, NumberUtils, Objects, langManager, boundUtil, defaultSelUtil, UADetector) {
  var bar = function(manifest, ctx) {
	var CLASSMARKERSELECTED = "v-datapoint-selected",
	    CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint";
    var tooltipHandlerObj = null;
    var data, 
        data1 = [[]],
        data2 = [[]],
        seriesData = [], tooltipData = [], //in stacked chart the value in tooltip is the same with data in seriesData, but in percentage chart it use the absolute value of negative data.
        primaryAxisTopBoundary = 0,
        primaryAxisBottomBoundary = 0,
        primaryAxisManualRange = false,
        secondaryAxisManualRange = false,
        secondaryAxisTopBoundary = 0,
        secondaryAxisBottomBoundary = 0,
        gWrapper = null;
    
    var width, 
        height,
        id = Math.floor(Math.random() * 10000),
        x = 0, y = 0,
        isDualAxis = false,
        colorPalette = [],
        axis1ColorPalette,
        axis2ColorPalette,
        MNDInnerOnColor = false,
        measureOnAxis1 = 0,
        measureOnAxis2 = 0,
        shapePalette = ['squareWithRadius'],
        properties,
        eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
      
    var effectManager = ctx.effectManager;
    
    var yScale = d3.scale.ordinal(),
        xScale = d3.scale.linear(),
        xScale2 = d3.scale.linear();
      
    var decorativeShape = null,
        lastSelected = [],
        evtData = [],
        lastHovered = null,
        isLasso = false;
      
    var barNumber = 1,
        barGroupNumber,
        barNumberinGroup,
        barHeight,
        positiveIndexes = [], 
        negativeIndexes = [];
      
    var enableDataLoadingAnimation = true,
        enableDataUpdatingAnimation = true,
        enableResizingAnimation = true, // control resizing animation
        enableRoundCorner = false,
        clipEdge = true,
        hasDefaultSelection = false,
        hasMNDonCategoryAxis = false,
        isOnlyInitAnimation = false,
        afterAttachToDOM = false,
        tooltipVisible,
        totalIntervalTime = 1000;
    
    var defsEnter = null, 
        roundCornerDefs = null,
        suffix = ObjectUtils.guid();
    
    var mode = 'comparison'; // bar display mode
    
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;
    
    var totalAnimationCount, currentAnimationCount;
    
    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(!isOnlyInitAnimation){
        hasAnmation = enableDataLoadingAnimation;
      }else if(dataStructureChange || dataValueChange){
        hasAnmation = enableDataUpdatingAnimation;
      }else if(sizeChange){
        hasAnmation = enableResizingAnimation;
      }
      return hasAnmation;
    }
    
    var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        mode = properties.mode === 'percentage'? 'percentage': 'comparison';
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
        enableResizingAnimation = properties.animation.resizing;
        tooltipVisible = properties.tooltip.enabled;      
        if(isDualAxis && !hasMNDonCategoryAxis){
          axis1ColorPalette = properties.primaryValuesColorPalette;   
          axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
          axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }

        drawingEffect = properties.drawingEffect;
        
        var indexforSecondaryAxis = data1.length;
            colorPalette = [];
        var i,j;
        if(MNDInnerOnColor){
          var flag = 0, flag2 = 0;
          for(i=0; i < seriesData[0][0].length; i++){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
            flag++;
            if(flag === measureOnAxis1 && isDualAxis && TypeUtils.isExist(seriesData[0][1])){
              flag2 = 0;
              for(j=0; j <=seriesData[0][1].length; j++){
                if(flag2 >= measureOnAxis2){
                  flag = 0;
                  break;
                }
              colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              flag2++;
            }
          }
        }
      }else{
          for(i=0 ; i < seriesData[0].length; i++){
            for(j=0; j < seriesData[0][0].length; j++){
               colorPalette.push(axis1ColorPalette[j % axis1ColorPalette.length]);
            }
            if(isDualAxis && TypeUtils.isExist(seriesData[0][1])){
              for(j=0; j < seriesData[0][1].length; j++){
                colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              }
            }
          }
        }                    
      };
      
      function chart(selection){
        boundUtil.drawBound(selection, width, height);
        
        //deal with percentage mode
        if(mode === 'percentage'){
          turnToPercentage();          
        }
        
        tooltipHandlerObj = tooltipDataHandler();
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(!TypeUtils.isExist(xScale) && !TypeUtils.isExist(xScale2)) {
          return;
        }
        eDispatch.startToInit();
        
        selection.each(function(){
          
        barNumber = (TypeUtils.isExist(data2)) ? 2 : 1;
        barHeight = 8 * (yScale.rangeBand()) / (9*barNumber +7 );
        
        barNumberinGroup = seriesData[0][0].length + ((TypeUtils.isExist(seriesData[0][1])) ? seriesData[0][1].length : 0);
        var barHeightInitial = 8 * (yScale.rangeBand()) / (9*barNumberinGroup +7 );
        
        currentAnimationCount = 0;
        totalAnimationCount = barNumberinGroup * seriesData.length;
        
        var svg = (gWrapper = d3.select(this));
        //append decorativeShape
          if(decorativeShape === null){
            decorativeShape = svg.append('rect').attr('width', width).attr('height',
            yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden').attr(
                'fill', ctx.styleManager.queryDefault('v-hovershadow').fill).attr('class', 'v-hovershadow');
          }else{
            decorativeShape.attr('width', width).attr('height', yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden');
          }
          
        if(defsEnter === null){
          defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
        }else{
          defsEnter.attr('width', width).attr('height', height);
        }  
          
        if(roundCornerDefs === null){      
          roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + suffix);
        }else{
          if( dataStructureChange || sizeChange || dataValueChange  || !enableRoundCorner){
            roundCornerDefs.selectAll(".v-clippath").remove();
          }
        }    
        
        var r = Math.log(barHeight)/Math.log(2);
        if( r < 0 ){
          enableRoundCorner = false;
        }
        var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
        if(!TypeUtils.isExist(datashapesgroup[0][0])){
          datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup');
        }
        var barGroup;
            barGroup = datashapesgroup.selectAll('g.v-stackedbar').data(seriesData);     
            barGroup.enter().append('g');
            barGroup.attr('class','v-stackedbar').each( function (perGroupData,i) {
              var axisGroup = d3.select(this).selectAll('g.v-axisGroup').data(perGroupData);     
                axisGroup.enter().append('g');
                axisGroup.attr('class','v-axisGroup').each( function (perAxisData,j) {  
                  // This is for dual axis
                  var valueScale = (j === 0) ? xScale : xScale2;
                  var startPoint = (j === 0) ? barHeight /2 : (barHeight /2 + barHeight + barHeight/8);
                  var initStartPoint = (j === 0) ? yScale(i) : (yScale(i) + barHeight / 2 + barHeight) ;
                  var fillingColor =  (j === 0) ? axis1ColorPalette : axis2ColorPalette;
                  
                  // This is for pos/neg values.
                  var positiveX = 0, negativeX = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                  var yArray = [], xArray=[];
                  // wrap a datashape g for each rect
                  var barShape = d3.select(this).selectAll('g.v-datashape').data(perAxisData);
                      barShape.enter().append('g').attr('class','v-datashape').append('rect').attr('class', 'v-datapoint');
                      barShape.exit().remove();
                      
                      // [21-Nov-2012 Nick] Keep the original x-position for each g.datashape, it is used when data value changes.
                      if(afterAttachToDOM){
                        barShape.each(function(){
                          xArray.push(this.getTransformToElement(this.parentNode).e);
                        });
                      }
                      
                      // [20-Nov-2012 Nick] As g.datashape is considered as a 'shape' concept, all positioning behavior is applied to this element
                      barShape.attr('transform', function (perRectData, k) {
                        var y = yScale(i) + startPoint;
                        yArray.push(y);
                        
                        var x;
                        if(perRectData.val >= 0){
                          positiveX = valueScale(positiveStackedValue);
                          positiveStackedValue += perAxisData[k].val;
                                         x = positiveX;
                        }else{
                          negativeStackedValue += perAxisData[k].val;
                          x =  valueScale(negativeStackedValue);
                        }     
                          return 'translate('+x+','+y+')'
                      });
                      
                  var bar = barShape.select('rect.v-datapoint');
                      bar.attr('fill', function(d,colorIndex){  
                        d.fillColor = fillingColor[colorIndex % fillingColor.length];
                        var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : d.fillColor,
                          direction : 'vertical'
                        };
                        return effectManager.register(parameter);
                      }).attr('shape-rendering','crispEdges').attr('fill-opacity', 1).attr('stroke','none');
                  
                  // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                  // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                      if(enableAnimation()){
                  if(dataStructureChange){
                    bar.attr('height',barHeightInitial)
                       .attr('y', function (perRectData, m) {
                           var y = initStartPoint - yArray[m] + barHeightInitial * m;
                           y = y + barHeightInitial/8 *(m) + barHeightInitial /2;
                           return y;
                       }).attr('x', function(perRectData){
                         if(perRectData.val  > 0){
                           return 0;
                         }else{
                           return valueScale(0) - valueScale(perRectData.val);
                         }
                       }).attr('width', 0);

                    // [04 - Sep - 2012 Nick] Round corner enabled. Do the same transition as the bars do.
                    if(enableRoundCorner){
                     var rcFunction = function(){bar.attr('clip-path', function(perRectData, indexinGroup){
                        if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                            var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                            var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                      .append('rect').attr('class', 'roundCorner-clip')
                                      .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                      .attr('height',barHeightInitial).attr('width', 0)
                                      .attr('x', this.x.baseVal.value)
                                      .transition().duration(totalIntervalTime/2)
                                      .attr('x',function(){
                                        if(indexinGroup ===  negativeIndexes[j][i] ){
                                          return 0;
                                        }else{
                                          return 0 - r;
                                        }
                                      })
                                      .attr('width', function(){
                                         return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                      })
                                      .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                      .attr('height',barHeight).attr('y', 0);
                          return 'url(#' + id + ')' ;
                        }
                      });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                    }
                    negativeStackedValue = 0;
                    bar.transition().duration(totalIntervalTime/2)
                       .attr('width', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0));
                       })
                       .attr('x', 0).each('end', function(d, m){
                           //As in large data with animation, transition code will be washed away, we should reset the width of rect in the animation end.
                           this.setAttribute('x', 0); 
                           this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)) );
                           d3.select(this).transition().duration(totalIntervalTime/2).attr('height', barHeight).attr('y', 0).each('end', function(){
                               this.setAttribute('height',  barHeight);
                               this.setAttribute('y', 0);
                               completeAnimation();
                           });
                       });
                  }
                  else if(sizeChange){
                    bar.attr('x',function(d,k){
                          return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                       })
                       .attr('width', function(perRectData){
                         var newWidth = Math.abs(valueScale(perRectData.val) - valueScale(0));
                         if(parseFloat(this.width.baseVal.value) > newWidth){
                           return this.width.baseVal.value;
                         }else{
                           return newWidth;
                         }
                     });
                    var sizeTransition = bar.transition();
                    sizeTransition.duration(totalIntervalTime/2)
                       .attr('width', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0));
                       })
                       .attr('x',0)
                       .attr('y', 0)
                       .attr('height',barHeight)
                       .each('end', function(d, m){
                        this.setAttribute('x', 0);
                        this.setAttribute('height',  barHeight);
                        this.setAttribute('y', 0);
                        this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)));
                         // Fire out event to tell the animation is done.
                       completeAnimation();
                       });
                    
                      if(enableRoundCorner){
                        var rcFunction = function(){ sizeTransition.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                            var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                            var x = parseFloat(this.x.baseVal.value) ;
                            var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                        .append('rect').attr('class', 'v-roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                        .attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                        .attr('x', function(){
                                          return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                        })
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('x',function(){
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0;
                                          }else{
                                            return 0 - r;
                                          }
                                        })
                                        .attr('width', function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                        })
                                        .attr('height',barHeight).attr('y', 0);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                      }
                  }
                  // [04 - Sep - 2012 Nick] Data has the same structure, but the value changed.
                  // TO BE TESTED ! WE DO NOT HAVE THIS WORK FLOW NOW.  
                  else if(dataValueChange){
                    bar.attr('x',function(d,k){
                        return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                    });
                    var stateChange = bar.transition();
                      stateChange.duration(totalIntervalTime/2)
                        .attr('width', function(perRectData){
                          return Math.abs(valueScale(perRectData.val) - valueScale(0));
                        })
                        .attr('x', 0)
                        .each('end', function(d, m){
                          this.setAttribute('x', 0);
                          this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)));
                          // Fire out event to tell the animation is done.
                            completeAnimation();
                        });
                        if(enableRoundCorner){
                            var rcFunction = function(){ stateChange.attr('clip-path', function(perRectData, indexinGroup){
                            if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var x = parseFloat(this.x.baseVal.value) ;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                        .append('rect').attr('class', 'v-roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                        .attr('height',barHeight).attr('width', this.width.baseVal.value + r)
                                        .attr('x', function(){
                                          return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                        })
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('x',function(){
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return 0;
                                          }else{
                                            return 0 - r;
                                          }
                                        })
                                        .attr('width', function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                        });  
                              return 'url(#' + id + ')' ;
                            }
                          });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                      }
                  }
                  else if (enableRoundCorner){
                      var rcFunction = function(){ bar.attr('clip-path', function(perRectData, indexinGroup){
                      if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                        var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                        var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                    .append('rect').attr('class', 'v-roundCorner-clip')
                                    .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                    .attr('height',barHeight).attr('width', function(){
                                                                  return  Math.abs(valueScale(perRectData.val) - valueScale(0) ) + r;
                                                              });
                        if(indexinGroup === negativeIndexes[j][i]){
                          roundCorner.attr('x',0);
                        }else{
                          roundCorner.attr('x',0 - r);  
                        }
            
                        return 'url(#' + id + ')' ;
                      }
                    completeAnimation();
                       
                    });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                  }

                //  bar.exit().remove();  
                }else{
                  bar.attr('y',0).attr('x', 0) 
                     .attr('width',function(perRectData,k){
                           var width = Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           return width;                   
                     })
                     .attr('height',barHeight);
                  
                  if(enableRoundCorner){
                      var rcFunction = function(){bar.attr('clip-path', function(perRectData, indexinGroup){
                      if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                        var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                        var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                    .append('rect').attr('class', 'v-roundCorner-clip')
                                    .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                    .attr('height',barHeight).attr('width', function(){
                                                                  return  Math.abs(valueScale(perRectData.val) - valueScale(0) ) + r;
                                                              });
                        if(indexinGroup === negativeIndexes[j][i]){
                          roundCorner.attr('x',0);
                        }else{
                          roundCorner.attr('x',0 - r);  
                        }
            
                        return 'url(#' + id + ')' ;
                      }
                       
                    });};
                     if(UADetector.isSafari() && UADetector.os === "Windows"){
                         window.setTimeout(rcFunction, 0);
                      } else{
                        rcFunction();
                      }
                  }
                }
              });
              axisGroup.exit().remove();
          });
          barGroup.exit().remove();
         
        
        });
        
        
        if (! enableAnimation()){
           eDispatch.initialized();
        }  
        sizeChange = false, dataValueChange = false, dataStructureChange = false;
        isOnlyInitAnimation = true;
        return chart;
      }
     
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1) || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }

      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + barHeight/4).attr(
          'visibility', 'visible');

      if(i !== lastHovered){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode.parentNode.parentNode point to the main container
          var transform = gWrapper[0][0].getTransformToElement(gWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          var sumAxis1 = 1, sumAxis2 = 1 , m = 0;
          var tData = tooltipHandlerObj.generateTooltipData(data, tooltipData, barGroupNumber-1-i, colorPalette, shapePalette);
          
          tData.point = {
              x: point.x,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tData.plotArea = {
            x : transform.e,
            y : transform.f,
            width : width,
            height : height
          };
          tData.valueAxis0Count = seriesData[0][0].length;
          tData.valueAxis1Count = TypeUtils.isExist(seriesData[0][1]) ? seriesData[0][1].length:0;
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
      };
      
      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {      
        eDispatch.hideTooltip();
      }
      };
      
      chart.parent = function(){
        return gWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
        	elems[i].setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
            elems[i].setAttribute('fill-opacity', 1);
            if(!enableRoundCorner){
              elems[i].setAttribute('stroke', '#333333');
            }
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
          elems.setAttribute('fill-opacity', 1);
          if(!enableRoundCorner){
            elems.setAttribute('stroke', '#333333');
          }
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gWrapper, true, elems);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
        	elems[i].setAttribute('class',CLASSDATAPOINT);
            elems[i].setAttribute('fill-opacity', 0.4);
            elems[i].setAttribute('stroke','none');
          }
        }else{
          elems.setAttribute('class',CLASSDATAPOINT);
          elems.setAttribute('fill-opacity', 0.4);
          elems.setAttribute('stroke','none');
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gWrapper, false, elems);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null || gray == false){
          var rects = gWrapper.selectAll('.v-datapoint');
          rects.attr('fill-opacity', 1).attr('stroke','none').attr('class',CLASSDATAPOINT);
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(gWrapper, false, rects);
          }
        }else{
          gWrapper.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke','none').attr('class',CLASSDATAPOINT);
        }
      };
      
      
        function turnToPercentage(){
          for(var i=0, len = seriesData.length; i < len; i++){
            for(var j=0 , rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++){
              var sum = 0, avaCount = 0, k;
              for(k=0; k < rowSeriesData[j].length; k++){
                sum += Math.abs(rowSeriesData[j][k].val);
                if(!rowSeriesData[j][k].isNaN) {
                  avaCount++;
                }
              }
              if(sum === 0){

                for(k=0; k < rowSeriesData[j].length; k++){
                        rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                        rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                        }
                }
              }else{
                for(k=0; k < rowSeriesData[j].length; k++){
                    if(rowSeriesData[j][k].val < 0){
                      rowSeriesData[j][k].isNegative = true;
                    }
                    rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                    rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
                    if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                      rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
                    }
                }
              }
              
            }
          }
      }
      
        function completeAnimation(){
            if( ++currentAnimationCount ===  totalAnimationCount){
                eDispatch.initialized();
                afterAttachToDOM = true;
            }
          }
      
      chart.afterUIComponentAppear = function(){
        eDispatch.initialized(); 
      };
      
      
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };
      /**
       * set/get data, for some modules like Title, it doesn't need data
       */
      chart.data = function(value){
        if (!arguments.length){
          return data;
        }
        data = value;
        var obj = MNDHandler(data);
                 
        var _data1 = obj["MG1"];
        var _data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        tooltipData = [];
        var i;
        
        if( _data1[0] && _data1[0][0].info && _data1[0][0].info.defaultSelection){
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        }
        
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
          var tempData1 = [], tempData2 = [];
          var tempStackedData1 = [], tempStackedData2 = [];
          for(i=0; i<_data1.length; i++){
            tempData1 = [];
            tempData2 = [];
            for(var j=0; j<_data1[i].length; j++){
              if(obj.color[j] === 0){
                tempData1.push(_data1[i][j]);
                tempData2.push({
                  val:null,
                  hasMNDonCategoryAxis : true
                });
              }else{
                tempData1.push({
                  val:null,
                  hasMNDonCategoryAxis : true
                });
                tempData2.push(_data1[i][j]);
              }
            }
            tempStackedData1.push(tempData1);
            tempStackedData2.push(tempData2);
          }
          _data1 = tempStackedData1;
          _data2 = tempStackedData2;
          
      }else{
            hasMNDonCategoryAxis = false;
            if(TypeUtils.isExist(_data2)){
              if(! dataStructureChange && 
                  (data2.length !== _data2.length || data2[0].length !== _data2[0].length)){
                  dataStructureChange = true;
               }
              isDualAxis = true;
            }else{
              isDualAxis = false;
            }
     }
     if(data1.length !== _data1.length || data1[0].length !== _data1[0].length){
       dataStructureChange = true;
     }

      var _seriesData = dataHandler(_data1, _data2, obj.color);
      
        //judge what changed in dataset
        if(!dataStructureChange){
          dataValueChange = true;
        }
        seriesData = _seriesData;
        data1 = _data1;
        data2 = _data2;
        
        if(hasMNDonCategoryAxis){
          for(i=0; i< seriesData.length; i++){
            var temp = seriesData[i];
            if(temp[0][0].hasMNDonCategoryAxis){
              tooltipData.push(temp[1]);
            }else{
              tooltipData.push(temp[0]);
            }
          }
        }else{
          tooltipData = ObjectUtils.extend(true, {}, seriesData); 
        }
        
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
      
      return chart;        
    };


    /**
     * set/get properties
    */
    chart.properties = function(props){
      if (!arguments.length){
          return properties;
       }
      Objects.extend(true, properties, props);
            parseOptions();
        
        return chart;        
    };
       

    var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
          domain.push(i);
        }
        yScale.domain(domain).rangeBands([height, 0]);
        if(mode === 'percentage'){
          xScale.domain([0,1]).range([0, width]);
          xScale2.domain([0,1]).range([0, width]);
          Scaler.perfect(xScale);
          Scaler.perfect(xScale2);
        }else{
          //when all data is 0 or null ,we make the domain from 0 to 1
          if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0 ){
            xScale.domain([0,1]).range([0, width]);
          }else{
            xScale.domain([primaryAxisBottomBoundary,primaryAxisTopBoundary]).range([0, width]);            
          }
         
          
          if( TypeUtils.isExist(data2) || isDualAxis ){
          //when data of second axis is all 0 or null, we make the xScale2 same with xScale .

            if(secondaryAxisTopBoundary === 0 && secondaryAxisBottomBoundary === 0){
              xScale2.domain(xScale.domain()).range(xScale.range());
            }else{
              xScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([0, width])
              //when data of first axis is all 0 or null, we make the xScale same with xScale2 .
              if(primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
                xScale.domain(xScale2.domain()).range(xScale2.range());
              }
            }
            if (!primaryAxisManualRange && !secondaryAxisManualRange)
            {
                Scaler.perfectDual(xScale, xScale2);
            }
            else if(!primaryAxisManualRange && secondaryAxisManualRange)
            {
                Scaler.perfect(xScale);
                Scaler.getRoughTickNum(xScale2);
            }
            else if(primaryAxisManualRange && !secondaryAxisManualRange)
            {
                Scaler.perfect(xScale2);
                Scaler.getRoughTickNum(xScale);
            }
            else 
            {
                Scaler.getRoughTickNum(xScale);
                Scaler.getRoughTickNum(xScale2);
            }
          } else {
            if (!primaryAxisManualRange) {
              Scaler.perfect(xScale);
            } else {
              Scaler.getRoughTickNum(xScale);
            }
          }
        }

        if(!TypeUtils.isExist(data2)){
            xScale2.range([0, 0]);
        }
    };


    chart.colorPalette = function(Palette){
        if (!arguments.length){
          return colorPalette;
       }
        colorPalette = Palette;
       return chart;        
    };

    chart.categoryScale = function(scale){
        if (!arguments.length){
          return yScale;
       }
        yScale = scale;
       return chart;
    };
    
    chart.primaryDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = primaryAxisBottomBoundary < 0 ? primaryAxisBottomBoundary : 0;
          maxt = primaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      if (range !== null) {
          primaryAxisTopBoundary = range.max;
          primaryAxisBottomBoundary = range.min;
          if (range.from === 'axis') {
            primaryAxisManualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            makeScales();
          }
      }
      return chart;
    };
      
    chart.secondDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = secondaryAxisBottomBoundary< 0 ? secondaryAxisBottomBoundary : 0 ;
          maxt = secondaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      if (range !== null) {
          secondaryAxisTopBoundary = range.max;
          secondaryAxisBottomBoundary = range.min;
          if (range.from === 'axis') {
            secondaryAxisManualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            makeScales();
          }
      }
      return chart;
    }; 
       
    chart.primaryScale = function(scale){
        if (!arguments.length){
          return xScale;
       }
        xScale = scale;
       return chart;
    };     
    
    chart.secondScale = function(scale){
            if (!arguments.length){
                return xScale2;
            }
            xScale2 = scale;
            return chart;
        };    

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
          //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(TypeUtils.isExist(seriesData[0][1]) && !hasMNDonCategoryAxis){
          return axis2ColorPalette[seriesData[0][1].length-1];
        }else{
          //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };          
        
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
     
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length){
          return y;
        }
        y = _;
        return this;
      };
      
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return this;
      };
      
      chart.dataLabel = function(_){};
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
//      var dataTransform = function(data1, data2){
//        var stackedBarGroup = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;;
//      var transferredDataSet = data1;
//      var temp, temp2;
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        temp = 0, temp2 = 0
//        for(i=0; i< transferredDataSet.length; i++){
//          ds.push(transferredDataSet[i][j]);
//          if(transferredDataSet[i][j].val >= 0){
//            temp += transferredDataSet[i][j].val;
//          }else{
//            temp2 += transferredDataSet[i][j].val;
//          }
//        }
//        if(primaryAxisTopBoundary < temp){
//          primaryAxisTopBoundary = temp
//        }
//        if(primaryAxisBottomBoundary > temp2){
//          primaryAxisBottomBoundary = temp2
//        }
//        stackedBarGroup.push(ds);
//      }
//      if(TypeUtils.isExist(data2)){
//          barGroupNumber =  data2[0].length;;
//                transferredDataSet = data2;
//                for(var j=0; j < barGroupNumber; j++){
//                    temp = 0
//                    for(i=0; i< transferredDataSet.length; i++){
//                        stackedBarGroup[j].push(transferredDataSet[i][j]);
//                        temp += transferredDataSet[i][j].val;
//                    }
//                    if(secondaryAxisBoundary < temp){
//                        secondaryAxisBoundary = temp
//                    }
//                }
//            }
//      
//        return stackedBarGroup;
//      };
      
      var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
        
        var positiveIndex = -1, negativeIndex = -1;
        positiveIndexes = [[],[]], negativeIndexes = [[],[]];
      
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        
        var stackedBarGroupsData = [];
        // the number of bar in each group
        barGroupNumber =  valueAxis1Data[0].length;
        var temp, temp2;
        for(var j=0; j < barGroupNumber; j++){
          var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
          var oneGroupDataSet = [];
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for(var i=0; i< valueAxis1Data.length; i++){
            if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
              //Jimmy/1/9/2013, what happens if we use null as the number value
              //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
              //and http://bclary.com/2004/11/07/#a-11.8.5
              //checked in chrome/IE9/firefox/javafx, it works fine
              //the change is to ensure we display 'No Value' in other places related to this data point
              valueAxis1Data[i][j].val = null;
              valueAxis1Data[i][j].isNaN = true;
            }else{
              
              if(valueAxis1Data[i][j].val >= 0){
                temp += valueAxis1Data[i][j].val;
                positiveIndex = i;
              }else{
                temp2 += valueAxis1Data[i][j].val;
                negativeIndex = i;
              }
            }
          tempDataSetAxis1.push(valueAxis1Data[i][j]);
        }
        positiveIndexes[0].push(positiveIndex);
        negativeIndexes[0].push(negativeIndex);
        
        if(primaryAxisTopBoundary < temp){
          primaryAxisTopBoundary = temp;
        }
        if(primaryAxisBottomBoundary > temp2){
          primaryAxisBottomBoundary = temp2;
        }
        oneGroupDataSet.push(tempDataSetAxis1);
        
        
        if(TypeUtils.isExist(valueAxis2Data)){
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for(i=0; i< valueAxis2Data.length; i++){
            positiveIndex = 0, negativeIndex = -1;
            if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
              //Jimmy/1/9/2013, what happens if we use null as the number value
              //see http://stackoverflow.com/questions/2910495/why-null-0-null-0-but-not-null-0
              //and http://bclary.com/2004/11/07/#a-11.8.5
              //checked in chrome/IE9/firefox/javafx, it works fine
              //the change is to ensure we display 'No Value' in other places related to this data point
              valueAxis2Data[i][j].val = null;
              valueAxis2Data[i][j].isNaN = true;
            }else{
              
              if(valueAxis2Data[i][j].val >= 0){
                temp += valueAxis2Data[i][j].val;
                positiveIndex = i;
              }else{
                temp2 += valueAxis2Data[i][j].val;
                negativeIndex = i;
              }
            }
            tempDataSetAxis2.push(valueAxis2Data[i][j]);
          }
          positiveIndexes[1].push(positiveIndex);
          negativeIndexes[1].push(negativeIndex);
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
            secondaryAxisBottomBoundary = temp2;
          }
          oneGroupDataSet.push(tempDataSetAxis2);
        }
        stackedBarGroupsData.push(oneGroupDataSet);
       }
        
        return stackedBarGroupsData;
      };
    
      properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.stackedbar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedbar',
      'name' : 'stacked bar',
      base : "sap.viz.modules.bar",
      'properties' : {
        'mode' : {
          'name' : 'mode',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'comparison', 'percentage' ],
          'defaultValue' : 'comparison',
          'description' : 'Set dispaly mode of stacked bar.',
          'isExported' : true
        }
      },
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_dual_stacked_bar',
    name : 'IDS_MULTIDUALSTACKEDBARCHART',
    base : 'viz/multi_dual_bar',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualPercentageStackedBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_dual_stacked_bar',
    name : 'IDS_MULTIDUALPERCENTAGESTACKEDBARCHART',
    base : 'viz/multi_dual_stacked_bar',
    modules : {
      root : {
        modules : {
          main : {
              modules: {
                plot : {
                  id : 'sap.viz.modules.xycontainer',
                  modules : {
                    xAxis : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                        properties : {
                          isPercentMode : true
                        }
                      }
                    },
                    xAxis2 : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                        properties : {
                          isPercentMode : true
                        }
                      }
                    },
                    plot : {
                      id : 'sap.viz.modules.stackedbar',
                      configure : {
                        properties : {
                          'mode' : 'percentage'
                        }
                      }
                    },
                    
                    dataLabel : {
                        id : 'sap.viz.modules.datalabel',
                        configure : {
                          propertyCategory : 'dataLabel',
                          properties : {
                            isPercentMode : true,
                            type : 'value',
                            showZero : true
                          }
                        }
                      }
                  }
                }
              }
            },
            
            tooltip : {
                id : 'sap.viz.modules.tooltip',
                configure : {
                  propertyCategory : 'tooltip',
                  properties : {
                    formatString: [["0.00%"],["0.00%"]]
                  }
                }
            }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_stacked_column',
    name : 'IDS_MULTISTACKEDVERTICALBARCHART',
    base : 'viz/multi_column',
    modules : {
      root : {
        modules : {
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                      'description' : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        max : 1
      },
      axisLabels : {
        max : 1
      },
      secondaryValues : null
    },
    dependencies : {
      attributes : [{
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      }, {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      }, {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      }, {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         *
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageStackedVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_stacked_column',
    name : 'IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART',
    base : 'viz/multi_stacked_column',
    feeds : { 
      multiplier : { max : 1 },
      secondaryValues : null, 
      axisLabels : { max:1 }
    },
    modules : {
      root : {
        modules : {
          main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : { isPercentMode : true }
                }
              },
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
                  properties : { 'mode' : 'percentage' }
                }
              },
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode : true,
                      showZero : true
                    }
                  }
                }
                }
              }
            }
          },
          
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
            formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_stacked_bar',
    name : 'IDS_MULTISTACKEDBARCHART',
    base : 'viz/multi_bar',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    },
    feeds:{  
        multiplier:{
        max:1
      },
        axisLabels:{
        max:1
      },
      secondaryValues:null
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },{ 
      targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageStackedBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_stacked_bar',
    name : 'IDS_MULTIPERCENTAGESTACKEDBARCHART',
    base : 'viz/multi_stacked_bar',
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues: null,
      axisLabels:{
        max:1
      }
    },
    modules : {
      root : {
        modules : {
          main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              },
              dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode : true,
                      type : 'value',
                      showZero : true
                    }
                  }
                  }
                }
              }
            }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
            formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Radar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
}
],
function Setup( Manifest, constants ) {
  var colors = {
    id : "regionColor",
    name : "IDS_REGIONCOLOR",
    type : constants.Type.Dimension,
    min : 0,
    max : 2,
    aaIndex : 2,
    acceptMND : 2
  },
  
  shapes = {
    id : "regionShape",
    name : "IDS_REGIONSHAPE",
    type : constants.Type.Dimension,
    min : 0,
    max : 2,
    aaIndex : 3,
    acceptMND : 0
  },
  
  axes = {
    id : "radarAxes",
    name : "IDS_RADARAXES",
    type : constants.Type.Dimension,
    min : 1,
    max : 1,
    aaIndex : 1,
    acceptMND : 1
  },

  values = {
    id : "radarAxesValues",
    name : "IDS_RADARAXESVALUE",
    type : constants.Type.Measure,
    min : 1,
    max : constants.Constraints.INF,
    mgIndex : 1
  };

  var feeds = {
    id : "radar",
    feeds : [ colors, shapes, axes, values ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.2'},
[

],
function Setup(){
  var ShapeSeries = {
    sapShapes : function(){
      return d3.scale.ordinal().range(['circle', 'diamond', 'triangleUp', 'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection']);
    }
  };
  return ShapeSeries;
});sap.riv.module(
{
  qname : 'sap.viz.modules.radar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup( callouts, types, texts, evtHub, axis, colorRange, shapeRange, scaler, global, 
  painter, langManager, tooltipDataHandler, Objects, BoundUtil, defaultSelUtil) {
  return function ( conf, ctx ) {
    var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint";
  
    var width = 0, height = 0, data = {}, properties = {}, angles,
        rescale, styles = {}, radar, valueaxis, yscale = d3.scale.linear(), 
        defaults, brush = {}, colorPalette = [], shapePalette = [], textRuler,
        dispatch, container = null, ranges, selections = {}, selectionMode = 'multiple', 
        arrange, effects = ctx.effectManager,  hasDefaultSelection = false;
    
    dispatch = evtHub("selectData", "deselectData", 
      "showTooltip", "hideTooltip", "initialized", 'startToInit');
    
    radar = {
      clazz : "v-spiderweb",
      node : null,
      color : colorRange.sap32(),
      shape : shapeRange.sapShapes(),
      radiusLength : 0,
      radius : d3.scale.linear(),
      anchor : { x : 0, y : 0 },
      radians : [],
      series : [],
      categories : [],
      caption : { 
        node : null,
        name : "v-polar-axis-title",
        width : 0,
        height : 0
      },
      labels : {},
      locked : false,
    };
    
    valueaxis = {
      clazz : "v-valueaxis",
      anchor : { x : 0, y : 0 },
      ref : axis(global.get("sap.viz.modules.axis"), ctx),
      node : null,
      width : 0,
      height : 0
    };
    
//    properties = {
//      drawingEffect : "normal",
//      polarGrid : { visible : true, color : "#d8d8d8" },
//      polarAxis : { title : { visible : false, text : "Categories" } },
//      valueAxis : { visible : true, title : { visible : false, text : "Value" }, label : { formatString : null} },
//      line : { width : 2 },
//      surface : { fill : { visible : true, transparency : 0.3 } },
//      colorPalette : [],
//      shapePalette : [],
//      marker : { size : 6 },
//      tooltip : { enabled : true },
//      multichart : false
//    };
    properties = conf.props(null);
    
    css = {
     // background : "viz-plot-background",
      axisTitle : "viz-axis-title"
    },
    
    styles = {
      spacing : { hgap : 5, vgap : 5 },
     // background : { css : { key : "viz-plot-background", def : null } },
      alignment : { horizontal : "center" },
      polaraxis : { 
        clazz : "polar_axis", 
        color : "#6c6c6c", 
        weight : "1px",
        labels : { css : { key : "viz-polar-axis-label", def : null } },
        title : { css: { key : "viz-polar-axis-title", def : null } }
      },
      polargrid : { clazz : "polar_grid", color : "#d8d8d8", weight : "1px" },
      line : { clazz : "v-dataline" },
      valueaxis : { clazz : "value_axis", title : { css : { key : "viz-axis-title", def : null } }},
      marker : { clazz : CLASSDATAPOINT, css : { key : "viz-radar-marker", def : null },
                 stroke : "transparent" },
      labels : { color : "#333333", fontSize : "14px", fontWeight : "normal", fontFamily : "Arial" },
      tooltip : { radialOffset : 1 * 10  } // 1em
    };
    
    ranges = {
      dataline : {
        weight : [ 1, 7 ]
      },
      marker : {
        size : [ 4, 32 ]
      }
    };
    
    defaults = {
      options : $.extend( true, {}, properties ),
      styles : $.extend( true, {}, styles ),
      wording : {
        dash : " - ",
        dot : ".",
        slash : " / ",
        ellipsis : "...",
        series : "s",
        data : "d",
        measureIndex : " mi",
        and : " & "
      }
    };
    
    // only deal with domain values
    rescale = function () {
      var series = radar.series, min = arguments[0], max = arguments[1];
      // Measure values are always two-dimensional.
      radar.max = typeof max !== "undefined" ? max :
                  d3.max( d3.merge( d3.merge(series) ), function (_) { return _.val; } );
      radar.min = typeof min !== "undefined" ? min : 
                  d3.min( d3.merge( d3.merge(series) ), function (_) { return _.val; } );
      
      if ( radar.min === radar.max ) {
        if ( radar.min === 0 ) radar.max = 100;
        if ( radar.min < 0 ) radar.max = 0;
        if ( radar.min > 0 ) radar.min = 0;
      }
      
      if ( !radar.min || radar.min === "NaN" ) {
        radar.min = 0;
      }
      if ( !radar.max || radar.max === "NaN" ) {
        radar.max = 0;
      }
    };

    textRuler = function ( text, style ) {
      return texts.fastMeasure(text, style["font-size"] || style.fontSize,
        style["font-weight"] || style.fontWeight, style["font-family"] || style.fontFamily);
    };
    
    /* Layout algorithm. Arguments are preferred widths */
    arrange = function () {
      var sizes = arguments[0],
          axisWidth = sizes.valueaxis, lblW = sizes.lblW, lblH = sizes.lblH,
          caption = sizes.caption,
          pole = {}, w, r, adjust, bbox,
          hgap = styles.spacing.hgap, vgap = styles.spacing.vgap,
          counter = -1, mem = [];
      
      (function layout() {
        counter++;
        if ( lblH - 1/3 * height > 0 ) lblH = 0;
        if ( caption.height - 1/3 * height > 0 ) caption.height = 0;
        if ( caption.width - 2/3 * width > 0 ) caption.width = 0;  
        
        if ( width - height >= 0 ) {
          r = ( height - 2 * (lblH + 2 * vgap) - 
            (caption.height !== 0 ? caption.height + 2 * vgap : 0) ) / 2;
          w = 2 * r + 2 * (lblW + 2 * hgap) + axisWidth;
          if ( w > width ) {
            adjust = w - width;
            r = ( height - adjust - 2 * (lblH + 2 * vgap) - 
              (caption.height !== 0 ? caption.height + 2 * vgap : 0) ) / 2;
          }
        } else {
          r = ( width - 2 * (lblW + 2 * hgap) - axisWidth ) / 2;
        }
    
        mem[counter] = r;
        if ( typeof mem[counter - 2] !== 'undefined' && mem[counter - 2] <= 0 ) { return 0; } // prevent infinite loops   
        
        if ( lblW > r || r <= 0 ) {
          lblW = 0, lblH = 0; 
          caption.width = 0, caption.height = 0; 
          r = layout();
          
          if ( axisWidth > r) {
            axisWidth = 0;
            r = layout();
            if ( width >= height ) {
              if ( r < height / 2 ) r = height / 2, vgap = 0;
            } else {
              if ( r < width / 2 ) r = width / 2, hgap = 0;
            }
          }
        }
        return r;
      })();
      
      bbox = { // bounding box
        width : axisWidth + 2 * r + 4 * hgap + 2 * lblW,
        height : 2 * ( lblH + r ) + 4 * vgap + 
          (caption.height !== 0 ? caption.height + 2 * vgap : 0)
      };
      
      radar.radiusLength = r;
      valueaxis.width = axisWidth;
      valueaxis.anchor.x = 0;
      valueaxis.anchor.y = lblH + 2 * vgap;
      radar.caption.width = caption.width;
      radar.caption.height = caption.height;
      pole.x = axisWidth + lblW + r + hgap * 2;
      pole.y = lblH + r + vgap * 2;
      caption.x = pole.x;
      caption.y = pole.y + r + lblH + 2 * vgap + caption.height / 2;
      
      var xoffset = 0, yoffset = 0;
      if ( axisWidth ) {
        valueaxis.ref.gridlineLength(pole.x - axisWidth);
        if ( width > height ) {
          xoffset = width / 2 - bbox.width / 2;
          valueaxis.anchor.x += xoffset;
          pole.x += xoffset;
          caption.x += xoffset;
        }
      } else {
        if ( width > height ) {
          xoffset = width / 2 - pole.x;
          pole.x += xoffset;
          caption.x += xoffset;
        } 
      }
      
      //radar.caption.node.attr("transform", "translate(" + caption.x + "," + caption.y + ")");
      radar.caption.node.attr("x", caption.x);
      radar.caption.node.attr("y", caption.y);
      valueaxis.node.attr("transform", "translate(" + 
        valueaxis.anchor.x + "," + valueaxis.anchor.y + ")");
      radar.node.attr("transform", "translate(" + pole.x + "," + pole.y + ")");
      radar.pole = pole;
      radar.labels.width = lblW;
      radar.labels.height = lblH;
    };
    
    /*
     * Creates scale function/object for angular computation.
     * 
     * @param nulls - indexes of empty elements
     * @param N - numbers of non-empty elements
     * @param cardinal - numbers of all elements
     */
    angles = function ( nulls, N, cardinal ) {
      var domain = [], intervals = [], i;
      if ( !nulls.length ) {
        return d3.scale.linear()
          .domain([ 0, cardinal ])
          .range([ 0, 2 * Math.PI ]);
      }
      //if ( nulls.length > N ) callouts.error("Invalid argument.");
      for ( i = 0; i < cardinal; i++ ) {
        domain.push(i);
        intervals.push(i / cardinal * 2 * Math.PI);
      }
      for ( i = nulls.length - 1; i >= 0; i-- ) {
        intervals.splice(nulls[i].order, 1);
      }
      
      return d3.scale.ordinal()
            .domain(domain)
            .range(intervals);
    };
    
    function chart ( selection ) {
      BoundUtil.drawBound(selection, width, height);
      dispatch.startToInit();
      selection.each(function ( datum ) {
        var parent = d3.select(this), prefix = defaults.wording;
        valueaxis.node = null;
        radar.node = null;
        radar.radiusLength = 0;
        container = parent;
        
        parent.select(prefix.dot.concat(valueaxis.clazz)).remove();
        parent.select(prefix.dot.concat(radar.clazz)).remove();
        parent.select( prefix.dot + radar.caption.name ).remove();
        
        valueaxis.node = parent.append("g").attr("class", valueaxis.clazz);
        radar.node = parent.append("g").attr("class", radar.clazz + ' v-datashapesgroup');
        radar.caption.node = parent.append("text").attr("class", radar.caption.name);
        
        styles.valueaxis.title.css.def = ctx.styleManager.query(styles.valueaxis.title.css.key);
        styles.polaraxis.labels.css.def = ctx.styleManager.query(styles.polaraxis.labels.css.key);
        styles.polaraxis.title.css.def = ctx.styleManager.query(styles.polaraxis.title.css.key);
        
        var cardinal, lblW, lblH, r, i, j, pole = {},
            labels = radar.categories, series = radar.series,
            hgap = styles.spacing.hgap, vgap = styles.spacing.vgap, 
            radians = (radar.radians = []);
        
        var ls = []; // Labels array
        for ( i = 0; i < labels.length; i++ ) {
          ls.push( textRuler(labels[i], styles.polaraxis.labels.css.def) );
        }
        lblW = d3.max( ls, function (_) { return _.width; } );
        lblH = d3.max( ls, function (_) { return _.height; } );

        yscale.domain([radar.min, radar.max])
              .range([200, 0]); // fake radius length
        scaler.perfect(yscale);
        
        var props = {
          label : {
            visible : true,
            formatString : properties.valueAxis.label.formatString
          },
          title : {
            visible : properties.valueAxis.title.visible,
            text : properties.valueAxis.title.text
          },
          type : "value",
          position : "left",
          gridline : {
            visible : true,
            showFirstLine : true,
            showLastLine : true,
            type : "dotted"
          }
        };
        
        if ( properties.valueAxis.gridline && properties.valueAxis.gridline.color ) { 
          props.gridline.color = properties.valueAxis.gridline.color;
        }
        valueaxis.ref.scale(yscale).properties(props);
        
        valueaxis.width = properties.valueAxis.visible ? valueaxis.ref.getPreferredSize().width : 0;
        if ( valueaxis.width > 0.5 * width ) valueaxis.width = 0;
        
        arrange({ 
          valueaxis : valueaxis.width, 
          lblW : lblW,
          lblH : lblH, 
          caption : {
            width : textRuler( properties.polarAxis.title.visible ? 
              properties.polarAxis.title.text : 0, styles.polaraxis.title.css.def ).width,
            height : textRuler( properties.polarAxis.title.visible ? 
              properties.polarAxis.title.text : 0, styles.polaraxis.title.css.def).height,
          }});
        
        if ( properties.polarAxis.title.visible && radar.caption.width 
             && radar.caption.height ) {
          radar.caption.node
            .text(properties.polarAxis.title.text)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle");
          ctx.styleManager.queryDefault(radar.caption.name).toAttrs(radar.caption.node);
        }
        
        yscale.range([ radar.radiusLength, 0 ]); // Re-calculate scale
        scaler.perfect(yscale);
        
        valueaxis.ref.scale(yscale);
        if ( properties.valueAxis.visible && valueaxis.width ) {
          valueaxis.node.call(valueaxis.ref);
        }
        
        var line = radar.node.append("g").attr("class", "v-polaraxes-group")
                  .selectAll(styles.polaraxis.clazz).data(labels);
        // Create nodes upon new data injected
        line.enter()
          .append("g")
          .attr("transform", function (d , i) {
            var rotation = i / labels.length * 360 - 90;
            if ( rotation > -180 && rotation < 180 ) {
              radians.push({ axisIdx : i,
                radian : -1 * rotation * Math.PI / 180 });
            } else { // rotation > 180 and rotation < 270
              radians.push({ axisIdx : i,
                radian : (360 - rotation) * Math.PI / 180 });
            }
            return "rotate("+ rotation +") translate("+ radar.radiusLength +")";
          });
        line.append("svg:line")
          .attr("x2", -1 * radar.radiusLength)
          .attr("stroke", effects.register({
            drawingEffect: "normal",
            fillColor: styles.polaraxis.color
          }))
          .attr("stroke-width", styles.polaraxis.weight)
          .attr("fill", "transparent");
        
        radians.sort( function (a, b) { return a.radian - b.radian; } );
        
        var angle; // Polar angle
        
        if ( radar.labels.width && radar.labels.height ) {
          // Plot category labels
          line
            .append("text").attr("class", "v-polar-axis-label")
            .text(function (d, i) { return d; })
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("transform", function (d, i) {
              angle = i / labels.length * 360 - 90;
              if ( angle % 90 === 0 ) {
                if ( angle === -90 || angle === 270 ) {
                  return "rotate(90) translate(0," + (-1 * ( 
                    textRuler(d, styles.polaraxis.labels.css.def).height / 2 + vgap ) ) +")";
                } else if ( angle === 0 ) {
                  return "translate("+ ( textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) +")";
                } else if ( angle === 180 ) {
                  return "rotate(180) translate(" + ( -1 * ( 
                    textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) ) +")";
                } else {
                  return "rotate(-90) translate(0," + ( 
                    textRuler(d, styles.polaraxis.labels.css.def).height / 2 + vgap ) +")";
                }
              }
              if ( (angle > -90 && angle < 0) || (angle > 0 && angle < 90) ) {
                return "rotate("+ (-1 * angle) +") translate(" + 
                  ( textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) +",0)";
              }
              return "rotate("+ (-1 * angle) +") translate(" +
                ( -1 * (textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap) ) +",0)";

            })
            .attr("font-family", ctx.styleManager.queryDefault('v-polar-axis-label')["font-family"])
            .attr("font-size", ctx.styleManager.queryDefault('v-polar-axis-label')["font-size"])
            .attr("fill", effects.register({
              drawingEffect: "normal",
              fillColor: ctx.styleManager.queryDefault('v-polar-axis-label').fill
            }));        
        }
        
        if ( !radar.min && !radar.max ) {
          dispatch.initialized();
          return;
        }
        
        // Reset value scales to desired orders
        yscale.domain([ radar.max, radar.min ]);
        scaler.perfect(yscale);
        
        cardinal  = radar.categories.length;
        
        // Default polar angle scale
        angle = angles([], cardinal, cardinal);
        
        // Path generator of line data on the radar plate
        var polarLine = d3.svg.line.radial()
          .interpolate("linear")
          .radius(yscale)
          .angle(function (d, i) { return angle(i); });

        var tickValues = yscale.ticks( yscale.tickNum ), polarTicks = [], circle = [];
        for ( i = 0; i < tickValues.length; i++ ) {
          circle = [];
          for ( j = 0; j < labels.length; j++ ) {
            circle.push(tickValues[i]);
          }
          polarTicks.push(circle);
        }

        if ( properties.polarGrid.visible ) {
          radar.node.append("g").attr("class", "v-polargrid-group")
            .selectAll( "." + styles.polargrid.clazz )
            .data( polarTicks )
          .enter()
            .append("path")
            .attr("class", styles.polargrid.childClazz)
            .attr("d", function (d) { return polarLine(d) + "Z"; })
            .attr("fill", "none")
            .attr("stroke", effects.register({
              drawingEffect : "normal",
              fillColor : styles.polargrid.color}))
            .attr("stroke-width", styles.polargrid.weight);
        }
        
        // Plot actual data
        radar.node.append("g")
          .attr("class", "v-dataline-group")
          .selectAll( "." + styles.line.clazz )
          .data(series)
        .enter()
          .append("path")
          .attr("class", function (d, i) {
            return prefix.series.concat(i + " ").concat(styles.line.clazz);
           })
          .attr("d", function (d, i) { // Each d is a data series
            if ( !d.length ) return;
            var numbers = [];
            angle = angles([], cardinal, cardinal);
            for ( var n = 0; n < d.length; n++ ) numbers.push(d[n].val);
            if ( numbers.length !== radar.categories.length ) {
              angle = angles(chart.vacants[i], numbers.length, cardinal);
            }
            return polarLine(numbers) + "Z"; 
          })
          .attr("fill", function (d, i) {
            if ( !d.length ) return; 
            if ( properties.surface.fill.visible ) {
              return effects.register({
                drawingEffect: "normal",
                fillColor: d[0].color
              });
            }
          })
          .attr("fill-opacity", function (d, i) {
            if ( properties.surface.fill.visible ) return properties.surface.fill.transparency;
            return 0;
          })
          .attr("stroke", function (d, i) { 
            if ( !d.length ) return;
            return effects.register({
              drawingEffect: "normal",
              fillColor: d[0].color}); 
          })
          .attr("stroke-width", properties.line.width > ranges.dataline.weight[1] || 
             properties.line.width < ranges.dataline.weight[0] ? 
             defaults.options.line.width : properties.line.width
          );
        
        // draw markers
        var markerContainer = radar.node.append("g")
          .attr("class", "v-marker-container")
          .selectAll("." + styles.marker.clazz)
          .data(series).enter().append("g");

        markerContainer.attr("class", "v-marker-group").each(function ( datum, index ) { 
          // for each series
          var nulls = chart.vacants[index], radians = [];
          $.each(radar.categories, function ( i, d ) { 
            radians.push(i / cardinal * 2 * Math.PI - 0.5 * Math.PI);
          });
          for ( var i = nulls.length - 1; i >= 0; i-- ) {
            radians.splice(nulls[i].order, 1);
          }
          
          d3.select(this).append("g")
            .attr("class", "v-marker-series")
            .selectAll("." + styles.marker.clazz)
            .data(datum)
            .enter()
            .append('g').attr('class','v-datashape')
            .attr("transform", function (d, i) {
              var x = yscale(d.val) * Math.cos(radians[i]);
                  y = yscale(d.val) * Math.sin(radians[i]);
              return "translate("+ x + ", " + y + ") rotate(0)";
            })
            .append("path")
            .attr("class", function (d, i) {
              return (
                prefix.series + index + " " +        // series index 
                prefix.data + d.order + " " +        // data index 
                prefix.measureIndex + d.ctx.path.mi + " " + // measure index
                styles.marker.clazz                  // class

              );
            })
            .attr("d", function (d, i) {
              return painter.createMarkerData({
                type : d.shape,
                rx : styles.marker.size / 2,
                ry : styles.marker.size / 2,
                borderWidth : 2
              });
            })
            .attr("fill", function (d) {
              var parameters = {
                drawingEffect : properties.drawingEffect,
                graphType : d.shape,
                fillColor : d.color,
                direction : 'vertical',
              };
              return effects.register(parameters);
            });
          });
        
        // create place holder elements for empty values
        var phantomMarker = radar.node.append("g")
          .attr("class", "v-phantom-marker-group")
          .selectAll(".v-phantom-marker-series").data(chart.vacants)
          .enter().append("g");
          
        phantomMarker
          .attr("class", "v-phantom-marker-series")
          .each(function ( datum, index ) {
            d3.select(this)
              .selectAll(".v-phantom-marker")
              .data(datum)
            .enter()
              .append("path")
              .attr("class", function (d, i) {
                return (
                  prefix.series + index + " " +       // series index 
                  prefix.data + d.order + " " +       // data index 
                  prefix.measureIndex + d.ctx.path.mi // measure index
                );
              })
              .attr("fill", "none");
          });
        
        dispatch.initialized();
      });
      radar.locked = false;
    }
    
    chart.dataLabel = function(_){}
    
    chart.data = function (_) {
      if ( !arguments.length ) return data;
      data = _, radar.series = [], radar.categories = [],
      //radar.radians = [],
      shapePalette = [], colorPalette = [], chart.vacants = [];
      
      // Data processing is effective upon the
      // completion of various customizations.
      if ( !chart.caliberated ) return chart;
      
      // Analysis Axis 1 and one Measure Group 
      // are required to be fed to radar chart.
      var aa1 = data.getAnalysisAxisDataByIdx(0).values,
          mg = data.getMeasureValuesGroupDataByIdx(0).values,
          aa2 = data.getAnalysisAxisDataByIdx(1),
          aa3 = data.getAnalysisAxisDataByIdx(2),
          series = [], depth, cardinal, layer, hierarchy = [],
          feedings = {
            aa2 : { fed : aa2 !== null && aa2.values.length ? true : false, axesFed : false, hasMND : false },
            aa3 : { fed : aa3 !== null && aa3.values.length ? true : false, axesFed : false, hasMND : false }
          }, i, j, x;
      
      radar.mndized = aa1[0].type && aa1[0].type.toLowerCase() === "mnd" ? true : false;
      
      if( mg[0] && mg[0].rows && mg[0].rows[0][0].info &&  mg[0].rows[0][0].info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      // Extracts dimension labels
      for ( i = 0; i < aa1.length; i++ ) {
        layer = [];
        for ( j = 0; j < aa1[i].rows.length; j++ ) {
          layer.push(aa1[i].rows[j].val);
        }
        hierarchy.push(layer);
      }
      
      depth = hierarchy.length, cardinal = hierarchy[0].length;
      if ( depth === 1 ) {
        for ( i = 0; i < cardinal; i++ ) { 
          radar.categories.push(hierarchy[0][i] === '' || hierarchy[0][i] === null ?
            langManager.get('IDS_ISNOVALUE') : hierarchy[0][i]);
        }
      } else { // splice layered dimension labels
        var column = [];
        for ( i = 0; i < cardinal; i++ ) {
          for ( j = 0; j < depth; j++ ) column.push(hierarchy[j][i]);
          radar.categories.push(column.join(defaults.wording.slash));
          column = [];
        }
      }

      cardinal = mg[0].rows[0].length;

      // deal with two-dimensional data
      if ( radar.mndized ) {
        /*
         * In case of AA1 is MNDized, each of the 
         * analysis axis has the chance of getting 
         * fed by one, two or not any axes at all.
         */
        if ( !feedings.aa2.fed && !feedings.aa3.fed ) {
          colorPalette.push(radar.color(0));
          shapePalette.push(radar.shape(0));
        }
        
        // AA2's always bound to rows in cross-table.
        if ( feedings.aa2.fed ) {
          for ( i = 0; i < aa2.values[0].rows.length; i++ ) {
            colorPalette.push(radar.color(i));
          }
          if ( !feedings.aa3.fed ) shapePalette.push(radar.shape(0));
        }
        
        // AA3's usually bound to columns in cross-table.
        if ( feedings.aa3.fed ) {
          for ( i = 0; i < aa3.values[0].rows.length; i++ ) {
            shapePalette.push(radar.shape(i));
          }
          if ( !feedings.aa2.fed ) colorPalette.push(radar.color(0));
        }
        
        for ( i = 0; i < mg.length; i++ ) {
          for ( j = 0; j < mg[i].rows.length; j++ ) {
            for ( x = 0; x < cardinal; x++ ) {
              mg[i].rows[j][x].color = colorPalette[x] || radar.color(0);
              if ( feedings.aa2.fed ) {
                mg[i].rows[j][x].shape = shapePalette[j] || radar.shape(0);
              } else {
                mg[i].rows[j][x].shape = shapePalette[x] || radar.shape(0);
              }
            }
          }
        }
        
        // Transform measure group into series.
        var entry, temp = [], item = [];
        for ( i = 0; i < mg[0].rows.length; i++ ) {
          entry = [];
          for ( j = 0; j < mg.length; j++ ) {
            entry.push(mg[j].rows[i]);
          }
          temp.push(entry);
        }

        for ( i = 0; i < temp.length; i++ ) {
          // process each same row of cross tables
          for ( x = 0; x < cardinal; x++ ) {
            // loops against columns
            for ( j = 0; j < temp[i].length; j++, nulls = [] ) {
              item.push(temp[i][j][x]);
            }
            series.push(item);
            item = [];
          }
        }
        
        $.each(series, function ( index, item ) {
          var values = item, nulls = [];
          for ( var i = 0; i < values.length; i++ ) {
            values[i].order = i; // actual data index
            if ( values[i].val === null ) nulls.push(values[i]);
          }
          for ( i = values.length - 1; i >= 0; i-- ) {
            if ( values[i].val === null ) values.splice(i, 1);
          }
          chart.vacants.push(nulls);
        });
        
        if ( properties.polarAxis.title.text === "Categories" ) { // not customized
          properties.polarAxis.title.text = langManager.get('IDS_DEFAULTMND');
        }
      } else {
        if ( feedings.aa2.fed ) {
          for ( i = 0; i < aa2.values.length; i++ ) {
            if ( aa2.values[i].type && 
                 aa2.values[i].type.toLowerCase() === "mnd" ) {
              feedings.aa2.hasMND = true;
            }
          }
          if ( feedings.aa2.hasMND ) {
            if ( aa2.values.length >= 2 ) feedings.aa2.axesFed = true;
            else feedings.aa2.axesFed = false;
          } else {
            feedings.aa2.axesFed = true;
          }
        }
        
        if ( feedings.aa3.fed ) {
          for ( i = 0; i < aa3.values.length; i++ ) {
            if ( aa3.values[i].type && 
                 aa3.values[i].type.toLowerCase() === "mnd" ) {
              feedings.aa3.hasMND = true;
            }
          }
          if ( feedings.aa3.hasMND ) {
            if ( aa3.values.length >= 2 ) feedings.aa3.axesFed = true;
            else feedings.aa3.axesFed = false;
          } else {
            feedings.aa3.axesFed = true;
          }
        }
  
        // Extract series values from measure groups
        var colorCursor = 0, shapeCursor = 0, x,
            aa2mndized = feedings.aa2.hasMND && !feedings.aa2.axesFed,
            aa3mndized = feedings.aa3.hasMND && !feedings.aa3.axesFed,
            nulls = [];
            
        for ( i = 0; i < mg.length; i++ ) {
          if ( aa2mndized ) colorPalette.push(radar.color(i));
          if ( aa3mndized ) shapePalette.push(radar.shape(i));
          
          for ( j = 0; j < mg[i].rows.length; j++, nulls = []) {
            // filter out null values
            for ( x = 0; x < mg[i].rows[j].length; x++ ) {
              if ( mg[i].rows[j][x].val === null ) {
                nulls.push(mg[i].rows[j][x]);
              }
              mg[i].rows[j][x].order = x;
            }
            series.push(mg[i].rows[j]);
            chart.vacants.push(nulls);
            
            if ( feedings.aa2.fed ) {
              if ( aa2mndized ) {
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(i);
                }
              } else if ( feedings.aa2.hasMND && feedings.aa2.axesFed ) {
                colorCursor++;
                colorPalette.push(radar.color(colorCursor));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(colorCursor);
                }
              } else {
                colorPalette.push(radar.color(j));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(j);
                }
              }
            } else {
              // Default value in case aa2 is fed nothing
              colorPalette.push(radar.color(0));
              for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                mg[i].rows[j][x].color = radar.color(0);
              }
            }
            if ( feedings.aa3.fed ) {
              if ( aa3mndized ) {
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].shape = radar.shape(i);
                }
              } else if ( feedings.aa3.hasMND && feedings.aa3.axesFed ) {
                shapeCursor++;
                shapePalette.push(radar.shape(shapeCursor));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].shape = radar.shape(shapeCursor);
                }
              } else {
                if ( feedings.aa2.fed ) {
                  if ( feedings.aa2.hasMND ) {
                    shapePalette.push(radar.shape(j));
                    for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                      mg[i].rows[j][x].shape = radar.shape(j);
                    }
                  } else {
                    for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                      shapePalette.push(radar.shape(x));
                      mg[i].rows[j][x].shape = radar.shape(x);
                    }
                  }
                }

              }
            } else {
              shapePalette.push(radar.shape(0));
              for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                mg[i].rows[j][x].shape = radar.shape(0);
              }
            }
          }
        }
        for ( i = 0; i < series.length; i++ ) {
          for ( j = series[i].length - 1; j >= 0; j-- ) {
            for ( var n = 0; n < chart.vacants[i].length; n++ ) {
              if ( chart.vacants[i][n].order === j ) series[i].splice(j, 1);
            }
          }
        }
        if ( properties.polarAxis.title.text === "Categories" ) { // not customized
          properties.polarAxis.title.text = combine_dimension_titles(aa1);
        }
      }
      if ( properties.valueAxis.title.text === "Value" ) {
        var measures = [];
        for ( i = 0; i < mg.length; i++ ) {
          measures.push(mg[i].col === '' || mg[i].col === null ? langManager.get('IDS_ISNOVALUE') : mg[i].col);
        }
        properties.valueAxis.title.text = measures.join(defaults.wording.and);
      }
      
      radar.series = series;
      radar.feedings = feedings;
      if ( !radar.locked ) rescale();
      
      return chart;
    };
    
    function combine_dimension_titles ( axes ) {
      var str = '';
      for ( var i = 0; i < axes.length; i++ ) {
        str = str.concat(axes[i].col.val === null ? langManager.get('IDS_ISNOVALUE') : axes[i].col.val + 
          defaults.wording.slash);
      }
      return str.lastIndexOf(defaults.wording.slash) > 0 ? 
             str.substr(0, str.lastIndexOf(defaults.wording.slash)) : str;
    }
    
    chart.primaryDataRange = function (_) {
      if ( !arguments.length ) return { 
        min : radar.min, max : radar.max 
      };
      radar.min = _.min;
      radar.max = _.max;
      rescale(_.min, _.max);
      radar.locked = true;
      return chart;
    };
    
    chart.colorPalette = function (_) {
      if ( !arguments.length ) return colorPalette;
      colorPalette = _;
      return chart;
    };
    
    chart.shapes = function (_) {
      if ( !arguments.length ) return shapePalette;
      shapePalette = _;
      return chart;
    };
    
    chart.dispatch = function (_) {
      if ( !arguments.length ) return dispatch;
      dispatch = _;
      return chart;
    };
    
    chart.properties = function (_) {
      if ( !arguments.length ) return properties;
      Objects.extend(true, properties, _);
      if ( properties.colorPalette.length ) radar.color.range(properties.colorPalette);
      if ( properties.shapePalette.length ) radar.shape.range(properties.shapePalette);
      styles.marker.size = properties.marker.size;
      if ( styles.marker.size > ranges.marker.size[1] ||  styles.marker.size < ranges.marker.size[0]) styles.marker.size =  6;
      styles.polargrid.color = properties.polarGrid.color;
      chart.caliberated = true;
      chart.data(data);
      return chart;
    };
    
    chart.afterUIComponentAppear = function(){
      dispatch.initialized(); 
    };
    
    chart.width = function (_) {
      if ( !arguments.length ) return width;
      var changed = width === _ ? false : true;
      width = _;
      if ( types.isEmptyObject(data) && height ) chart.data(data);
      if ( changed && !radar.locked  ) rescale();
      return chart;
    };
    
    chart.height = function (_) {
      if ( !arguments.length ) return height;
      var changed = height === _ ? false : true;
      height = _;
      if ( types.isEmptyObject(data) && width ) chart.data(data);
      if ( changed && !radar.locked ) rescale();
      return chart;
    };
    
    chart.size = function (_) {
      if ( !arguments.length ) return {
        width : width, height : height
      };
      width = _;
      height = _;
      if ( types.isEmptyObject(data) && width && height ) chart.data(data);
      if ( width && height && radar.series.length ) rescale();
      return chart;
    };
    
    chart.parent = function (_) {
      if ( !arguments.length ) return container;
      container = _;
      return chart;
    };
    
    chart.hoverOnPoint = function ( cursor ) {
      var pole = radar.pole, theta, r,
          prefix = defaults.wording,
          radians = radar.radians,
          point = {
            x : cursor.x - pole.x,
            y : pole.y - cursor.y
          };
      r = Math.sqrt( Math.pow(point.x, 2) + Math.pow(point.y, 2) );
      
      // out of radius range
      if ( r > radar.radiusLength ) {
        if ( typeof chart.last !== "undefined" && 
            (types.isEmptyObject(selections)) ) {
          brush.straight(prefix.dot + prefix.data + chart.last, true);
        }
        // hide tool tip
        if ( properties.tooltip.enabled ) radar.prompt();
        return;
      }
      
      // range is (-PI, PI]
      theta = Math.atan2( point.y, point.x );
      
      // search for the target interval that the angle locates in
      var bisect = d3.bisector(function (d) { return d.radian; }).right,
          intv = bisect(radians, theta), mid, left, right, target;          
      
      if ( intv === 0 ) {
        left = radians.length - 1, right = 0;
        if ( radians[left].radian === Math.PI ) {
          mid = -1 * (Math.PI + Math.abs(radians[right].radian)) / 2;
          target = theta > mid ? target = radians[right].axisIdx : 
                   target = radians[left].axisIdx;
        } else {
          target = radians[0].axisIdx;
        }
      } else if ( intv === radians.length ) {
        target = radians[radians.length - 1].axisIdx;
      } else {
        left = intv - 1, right = intv;
        mid = (radians[left].radian + radians[right].radian) / 2;
        target = theta > mid ? target = radians[right].axisIdx : 
                 target = radians[left].axisIdx;
      }
      
      if ( typeof chart.last !== "undefined" && chart.last !== target ) {
        brush.straight(prefix.dot + prefix.data + chart.last, true);
      }
      
      brush.focus(prefix.dot + prefix.data + target, true);
      
      if ( !types.isEmptyObject(selections) ) {
        brush.dim(prefix.dot + prefix.data + target, true);
        for ( var key in selections ) {
          for ( var i = 0; i < selections[key].length; i++ )
            brush.highlight(selections[key]);
        }
      }
      
      // prompt tool tip if allowed
      if ( properties.tooltip.enabled ) radar.prompt(target);
      
      // Memorize the last processed axis index
      chart.last = target;
    };
    
    chart.clear = function () {
      if ( !arguments[0] ) {
        brush.straight().bright();
        selections = {};
        if(hasDefaultSelection){
          var datapoints = [];
          var prefix = defaults.wording;
          datapoints.push(radar.node.selectAll(prefix.dot + styles.line.clazz));
          datapoints.push(radar.node.selectAll(prefix.dot + styles.marker.clazz));
          defaultSelUtil.clearSelectionInfo(container, false, datapoints);
        }
      } else {
        brush.dim();
      }
    };
    
    chart.highlight = function ( objects ) {
      if ( !radar.min && !radar.max ) return;
      
      var target = objects instanceof Array ? objects : [ objects ], query = /[sS][0-9]+/, key;
      
      selectionMode = typeof arguments[1] === 'boolean' ? 'multiple' : ( 
        typeof arguments[1] === 'string' ? arguments[1].toLowerCase() :
        typeof arguments[2] === 'string' ? arguments[2].toLowerCase() : 'multiple');
          
      brush.highlight(target);
      
      for ( var i = 0, exists = false; i < target.length; i++, exists = false ) {
        key = target[i].className.baseVal.match(query)[0];
        if ( selections[key] ) {
          for ( var j = 0; j < selections[key].length; j++ ) {
            if ( selections[key][j] === target[i] ) exists = true;
          }
          if ( !exists ) selections[key].push(target[i]);
        } else {
          selections[key] = [];
          selections[key].push(target[i]);
        }
      }

      if ( selectionMode === 'single' ) return;

      var cardinal, seriesOrder;
      for ( var n in selections ) {
        if ( selections.hasOwnProperty(n) ) {
          seriesOrder = n.substr(1);
          cardinal = radar.series[seriesOrder].length;
          highlight(n, selections[n], cardinal);
        }
      }
      
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(container, true, target);
      }
      
    };
    
    function highlight( series, datapoints, cardinal ) {
      if ( datapoints.length === cardinal ) {
        brush.highlight2(defaults.wording.dot + series, true);
      } else {
        brush.highlight(datapoints);
      }
    }
    
    chart.unhighlight = function ( object ) {
      var target = object instanceof Array ? object : [object];
      brush.straight(target).dim(target);
     
      if ( selectionMode === 'single' ) { 
        selections = []; return; 
      }
      
      $.each(target, function ( index, item ) {
        var series = item.className.baseVal.match(/[sS][0-9]+/)[0];
      
        for ( var key in selections ) {
          for ( var i = 0; i < selections[key].length; i++ ) {
            if ( selections[key][i] === object ) {
              selections[key].splice(i, 1); break;
            }
          }
        }
        brush.straight2(defaults.wording.dot + series)
             .dim(defaults.wording.dot + series);
      });
      
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(container, false, target);
      }
      
    };
    
    chart.blurOut = function () {
      dispatch.hideTooltip();
    };
    
    radar.prompt = function () {
      if ( typeof arguments[0] === "undefined" ) { dispatch.hideTooltip(); return; }
      
      var volume, item = {}, elements, target = arguments[0], 
          prefix = defaults.wording, anchor = {}, angle = 0,
          r = radar.radiusLength - styles.tooltip.radialOffset, 
          translation = container[0][0].getTransformToElement(container[0][0].ownerSVGElement),
          i;
      
      for ( i = 0; i < radar.radians.length; i++ ) {
        if ( radar.radians[i].axisIdx === target ) {
          angle = radar.radians[i].radian; break;
        }
      }
      
      anchor.x = r * Math.cos(angle);
      anchor.y = r * Math.sin(angle);
      orient = angle <= 0.5 * Math.PI && angle > -0.5 * Math.PI ? "left" : "right";
      
      volume = {
        body : [],
        plotArea : {
          x : translation.e,
          y : translation.f,
          width : width,
          height : height
        },
        point : { // where tool tip arrow points to
          x : anchor.x + radar.pole.x + translation.e,
          y : anchor.y < 0 ? 
              Math.abs(anchor.y) + radar.pole.y + translation.f : 
              radar.pole.y - anchor.y + translation.f, 
          orientation : orient,
          angle : angle,
          range : {
            x : angle === 0.5 * Math.PI || angle === -0.5 * Math.PI ? 0 : 
                Math.abs(anchor.x),
            y : angle === 0 || angle === Math.PI || angle === -1 * Math.PI ? 0 : 
                Math.abs(anchor.y)
          }
        },
        footer : []
      };

      var aa1 = data.getAnalysisAxisDataByIdx(0).values,
          aa2 = radar.feedings.aa2.fed ? data.getAnalysisAxisDataByIdx(1).values : null,
          aa3 = radar.feedings.aa3.fed ? data.getAnalysisAxisDataByIdx(2).values : null,
          mg = data.getMeasureValuesGroupDataByIdx(0).values;
      
      elements = radar.node.selectAll("." + prefix.data + target);
      var col, row, cardinal, index, i, j, temp;
      
      if ( radar.mndized ) {
        item = { 
          name : radar.categories[target] === '' || radar.categories[target] === null ? 
                 langManager.get('IDS_ISNOVALUE') : radar.categories[target], 
          val : []
        };
        
        // normal case
        elements.each(function (d) {
          var entry = {};
          entry.color = d.color;
          entry.shape = d.shape;
          entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
          
          if ( !radar.feedings.aa2.fed && !radar.feedings.aa3.fed ) {
            entry.label = null;
          }
          
          if ( radar.feedings.aa2.fed ) {
            index = properties.multichart ? d.ctx.path.dii_a2 : d.ctx.path.dii_a1;
            for ( i = 0, temp = []; i < aa2.length; i++ ) {
              temp.push(aa2[i].rows[index]);
            }
            col = temp;
            if ( !radar.feedings.aa3.fed ) entry.label = col;
          }
          
          if ( radar.feedings.aa3.fed ) {
            index = radar.feedings.aa2.fed ? d.ctx.path.dii_a2 : d.ctx.path.dii_a1;
            for ( i = 0, temp = []; i < aa3.length; i++ ) {
              temp.push(aa3[i].rows[index]);
            }
            if ( radar.feedings.aa2.fed ) {
              row = temp;
              entry.label = [];
              entry.label = entry.label.concat(col);
              entry.label = entry.label.concat(row);
            } else {
              col = temp;
              entry.label = col;
            }
          }
          
          item.val.push(entry);
        });
        
        volume.body.push(item);
      } else {
        if ( !radar.feedings.aa2.axesFed && !radar.feedings.aa3.axesFed ) {
          elements.each(function (d) {
            var entry = {}, item = { name : mg[d.ctx.path.mi].col, val : [] };
            entry.color = d.color;
            entry.shape = d.shape;
            entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
            entry.label = null;
            
            item.val.push(entry);
            volume.body.push(item);
          });
        } else {
          for ( var x = 0; x < mg.length; x++ ) {
            item = { name : mg[x].col === null ? langManager.get('IDS_ISNOVALUE') : mg[x].col, val : [] };
            
            elements.each(function (d) {
              var entry = {};
              entry.color = d.color;
              entry.shape = d.shape;
              entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
              
              var clazz = d3.select(this)[0][0].className.baseVal
                .match(/\smi[0-9]+/);
              if ( clazz !== null ) clazz = clazz[0];
              else return;
              
              temp = [];
              if ( clazz === (prefix.measureIndex + x) ) {
                var aa = aa2 !== null ? aa2 : aa3;
                for ( i = 0; i < aa.length; i++ ) {
                  if ( d.ctx.path.dii_a2 > aa[i].rows.length - 1 ) {
                    d.ctx.path.dii_a2 = aa[i].rows.length - 1;
                  }
                  temp.push(aa[i].rows[d.ctx.path.dii_a2]);
                }
                entry.label = temp;
              } else return;
              item.val.push(entry);
            });
            volume.body.push(item);
          }
        }
        
        var dimension = {};
        for ( i = 0; i < aa1.length; i++ ) {
          dimension = {};
          dimension.label = aa1[i].col;
          dimension.value = aa1[i].rows[target];
          volume.footer.push(dimension);
        }
      }
      dispatch.showTooltip(tooltipDataHandler.formatTooltipData(volume));
    };
    
    brush.params = { // UX defined
      stroke : {
        invisible : "transparent",
        natural : "#ffffff",
        heavy : "#333333"
      },
      
      weight : {
        natural : properties.line.width,
        heavy : "2px"
      },
      
      opacity : {
        natural : 1,
        low : 0.4
      }
    };
    
    /*
     * Functions of the effects library are
     * state-less. Each of the function accepts
     * one of the two types of arguments: 
     * DOM nodes in array, or
     * CSS class with an optional boolean field
     * in determining whether all elements with
     * the given CSS class will be selected.
     */
    brush.dim = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) { // select everything
        radar.node.selectAll(prefix.dot + styles.line.clazz)
          .attr("opacity", brush.params.opacity.low);
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .attr("opacity", brush.params.opacity.low);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .attr("opacity", brush.params.opacity.low);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .attr("opacity", brush.params.opacity.low);
      } else {
        radar.node.select(arguments[0])
          .attr("opacity", brush.params.opacity.low);
      }
      return brush;
    };
    
    brush.bright = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.line.clazz)
          .attr("opacity", brush.params.opacity.natural);
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .attr("opacity", brush.params.opacity.natural);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .attr("opacity", brush.params.opacity.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .attr("opacity", brush.params.opacity.natural);
      } else {
        radar.node.select(arguments[0])
          .attr("opacity", brush.params.opacity.natural);
      }
      return brush;
    };
    
    // remove all decorations
    brush.straight = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.marker.clazz).each(function(){
            straightHelper(d3.select(this));
        });
      } else       if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          straightHelper(d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0]).each(function(){
            straightHelper(d3.select(this));
        });
      } else {
        straightHelper(radar.node.select(arguments[0]));
      }
      return brush;
    };
    function straightHelper(d3node) {
      d3node.attr("stroke", brush.params.stroke.invisible);
      var os = d3node.attr('class');
      var i = os.indexOf(CLASSDATAPOINT);
      if (i>=0){
          d3node.attr('class', os.substring(0,i) + CLASSDATAPOINT);
      }
    }
    // Just recover stroke-width
    brush.straight2 = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.marker.clazz).each(function(){
            straight2Helper(d3.select(this));
        });
      } else       if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          straight2Helper(d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0]).each(function(){
            straight2Helper(d3.select(this));
        });
      } else {
        straight2Helper(radar.node.select(arguments[0]));
      }
      return brush;
    };
    
    function straight2Helper(d3node) {
      d3node.attr("stroke-width", brush.params.weight.natural);
      var os = d3node.attr('class');
      var i = os.indexOf(CLASSDATAPOINT);
      if (i>=0){
          d3node.attr('class', os.substring(0,i) + CLASSDATAPOINT);
      }
    }
    // Change stroke color and stroke-width
    brush.highlight = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          highlightHelper(d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0]).each(function(){
            highlightHelper(d3.select(this));
        });
      } else {
        highlightHelper(radar.node.select(arguments[0]));
      }
      return brush;
    };
    
    function highlightHelper(d3node) {
      d3node.attr("stroke", brush.params.stroke.heavy)
        .attr("stroke-width", brush.params.weight.heavy)
        .attr("opacity", brush.params.opacity.natural);
      var os = d3node.attr('class');
      var i = os.indexOf(CLASSDATAPOINT);
      if (i>=0){
          d3node.attr('class', os.substring(0,i) + CLASSDATAPOINT+" "+CLASSMARKERSELECTED);
      }
    }
    
    // Just thicken stroke-width
    brush.highlight2 = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          highlight2Helper(d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0]).each(function(){
            highlight2Helper(d3.select(this));
        });
      } else {
        highlight2Helper(radar.node.select(arguments[0]));
      }
      return brush;
    };
    
    function highlight2Helper(d3node) {
      d3node.attr("stroke-width", brush.params.weight.heavy)
        .attr("opacity", brush.params.opacity.natural);
      var os = d3node.attr('class');
      var i = os.indexOf(CLASSDATAPOINT);
      if (i>=0){
          d3node.attr('class', os.substring(0,i) + CLASSDATAPOINT+" "+CLASSMARKERSELECTED);
      }
    }
    
    brush.focus = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          focusHelper(d3.select(arguments[0][i]));
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0]).each(function(){
            focusHelper(d3.select(this));
        });
      } else {
        focusHelper(radar.node.select(arguments[0]));
      }
      return brush;
    };
    
    function focusHelper(d3node) {
      d3node.attr("stroke", brush.params.stroke.natural)
            .attr("stroke-width", brush.params.weight.natural);
      var os = d3node.attr('class');
      var i = os.indexOf(CLASSDATAPOINT);
      if (i>=0){
          d3node.attr('class', os.substring(0,i) + CLASSDATAPOINT+" "+CLASSMARKERHOVER);
      }    
    }
    
    return chart;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.radar',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.Radar',
  version : '4.0.2'
}
],
function Setup( Manifest, Constants, fn ) {
  var module = {
    id : "sap.viz.modules.radar",
    type : Constants.Module.Type.Chart,
    name : "radar",
    description : "Radar module properties",
    properties : {
      drawingEffect : {
        name : 'drawingEffect',
        supportedValueType : 'List',
        supportedValues : [ 'normal', 'glossy' ],
        defaultValue : 'normal',
        description : 'Set drawing effect of radar.',
        isExported : true
      },
      polarGrid : {
        name : "polarGrid",
        supportedValueType : "Object",
        supportedValues : {
          visible : {
            name : "visible",
            supportedValueType : "Boolean",
            defaultValue : true,
            description : "Set polar gridline visibility switch."
          },
          color : {
            name : "color",
            supportedValueType : "String",
            defaultValue : "#d8d8d8",
            description : "Set polar gridline color."
          }
        },
        description : "Settings for Polar gridline customizations."
      },
      valueAxis : {
        name : "valueAxis",
        supportedValueType : "Object",
        supportedValues : {
          visible : {
            name : "visible",
            supportedValueType : "Boolean",
            defaultValue : true,
            description : "Set value axis visibility switch."
          },
          title : {
            name : "title",
            supportedValueType : "Object",
            supportedValues : {
              visible : {
                name : "visible",
                supportedValueType : "Boolean",
                defaultValue : false,
                description : "Set value axis title visibility switch."
              },
              text : {
                name : "text",
                supportedValueType : "String",
                defaultValue : "Value",
                description : "Set value axis title text."
              },
            },
            description : "Settings for value axis title."
          },
          label : {
        	name : "label",
        	supportedValueType : "Object",
        	supportedValues : {         	  
        	  formatString : {
                name : 'formatString',
        		supportedValueType : 'String',
        		defaultValue : null,
        		description : 'Set format string of value axis. If number format and format string are both set, number format will be ignored. '
        	  }
            },
              description : "Settings for axis label."
          }
        },
        description : "Settings for value axis at side bar."
      },
      polarAxis : {
        name : "polarAxis",
        supportedValueType : "Object",
        supportedValues : {
          title : {
            name : "title",
            description: "Settings for polar axis title.",
            supportedValueType : "Object",
            supportedValues : {
              visible : {
                name : "visible",
                supportedValueType : "Boolean",
                defaultValue : false,
                description : "Set category axis visibility switch."
              },
              text : {
                name : "text",
                supportedValueType : "String",
                defaultValue : "Categories",
                description : "Set category axis text."
              }
            }
          }
        },
        description : "Settings for polar axes customizations."
      },
      colorPalette : {
        name : "colorPalette",
        defaultValue : Constants.SAPColor,
        description : "Set marker color customizations."
      },
      shapePalette : {
        name : "shapePalette",
        supportedValueType : "StringArray",
        defaultValue : [ "circle", "diamond", "triangleUp", "triangleDown", 
                  "triangleLeft", "triangleRight", "cross", "intersection" ],
        supportedValues : [ "circle", "diamond", "triangleUp", "triangleDown", 
                  "triangleLeft", "triangleRight", "cross", "intersection" ],
        description : 'Set marker shape customizations.'
      },
      line : {
        name : "line",
        description : "Settings for line customizations.",
        supportedValueType : "Object",
        supportedValues : {
          width : {
            name : 'width',
            supportedValueType : 'PositiveInt',
            defaultValue : 2,
            description : "Line weight settings. Range is [1, 7]"
          }
        }
      },
      surface : {
        name : "surface",
        supportedValueType : "Object",
        supportedValues : {
          fill : {
            name : 'fill',
            supportedValueType : 'Object',
            supportedValues : {
              visible : {
                name : 'visible',
                supportedValueType : 'Boolean',
                defaultValue : true,
                description : 'Set enable/disable fill effect for polar area.'
              },
              transparency : {
                name : 'transparency',
                supportedValueType : 'Double',
                defaultValue : 0.3,
                //min : '0',
                //max : '1',
                description : 'Set alpha value for polar area fill color.'
              },
            }
          }
        },
        description : "Settings for Surface customizations."
      },
      marker : {
        name : "marker",
        //description : "Settings for data point marker customizations.",
        supportedValueType : "Object",
        supportedValues : {
          size : {
            name : "size",
            supportedValueType : "PositiveInt",
            defaultValue : 6,
            min : 4,
            max : 32,
            description : "Set marker size customization."
          }
        },
        description : "Settings for marker/data point graphics."
      },
      tooltip : {
        name : "tooltip",
        supportedValueType : "Object",
        supportedValues : {
          enabled : {
            name : "enabled",
            supportedValueType : "Boolean",
            supportedValues : [ true, false ],
            defaultValue : true,
            description : "Set tooltip enablement."
          }
        },
        'isExported' : false,
        description : "Settings for tooltip customization."
      },
    },
    events : {
      'initialized': Constants.Module.Event.Initialized.desc,
      selectData : Constants.Module.Event.SelectData.desc,
      deselectData : Constants.Module.Event.DeSelectData.desc,
      showTooltip : Constants.Module.Event.TooltipShow.desc,
      hideTooltip : Constants.Module.Event.TooltipHide.desc
    },
    feeds : {
      id : "radar"
    },
    css : {    
      ".viz-axis-title.v-title" : {
        description : "Font style for value axis title.",
        value : {
          fill : "#333333",
          "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
          "font-size" : "14px",
          "font-weight" : "bold"
        }
      },
      '.viz-axis-label.v-label' : {
        'description' : 'Define style for value axis label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      },     
      ".viz-polar-axis-label.v-polar-axis-label" : {
        description : "Font styles for polar axis labels.",
        value : {
          "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
          "fill" : "#333333",
          "font-size" : "11px",
          "font-weight" : "bold"
        }
      },
      ".viz-polar-axis-title.v-polar-axis-title" : {
          description : "Font styles for polar axis title.",
          value : {
            "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
            "fill" : "#333333",
            "font-size" : "14px",
            "font-weight" : "bold"
          }
        }
    },
    configure : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiRadarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiRadarChart = {
    id : 'viz/multi_radar',
    name : 'IDS_MULTIRADARCHART',
    base : 'riv/base/multiple/xy',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : { data : { aa : [ 3] } }
            }
          },
          tooltip : {
            id : "sap.viz.modules.tooltip",
            configure : {
              properties : {
                chartType : "radar",
                orientation : "left"
              }
            }
          },
          
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction',
              properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
              }
            }
          },
          
          main : {
            configure : {
              properties : {
                'mergeDataRange' : ['primary']
              }
            },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        orientation : 'vertical',
                        position : 'outside',
                        automaticInOutside : false,
                        outsidePosition : 'up',
                        positionPreference : true
                      }
                    }
                  },
                  plot : {
                    id : 'sap.viz.modules.radar',
                    configure : {
                      description: 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : "plotArea",
                      properties : {
                        multichart : true
                      }
                    }
                  },
                  background : {
                    configure : {
                      propertyCategory : 'background',
                      properties : {
                        visible : false
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    },
    feeds : {
      multiplier : {
        acceptMND : 0,
        max : 2
      },
      
      regionShape : {
        max : 0
      }
      
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : "root.legends.legend",
        target : "colorPalette",
        sourceModule : "root.main.plot.plot",
        source : "colorPalette"
      }, 
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapes'
      }
      ], 
      events : [ 
      {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main',
        type : 'hideTooltip'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'root.main.plot.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.plot.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot.plot',
        type : 'startToInit.datalabel'
      }]
    }
  };

  Manifest.register(multiRadarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.rotate',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
}
],
function Setup(Objects) {
  
  return function(manifest){
    
    var m = null, g = null, props =  manifest.props(null), xAngle = 0, yAngle = 0, mousedown = false;
    var rotate = function(){
      
      return rotate;
    };
    

    rotate.registerEvent = function() {
      g.on('mousedown.rotate', start).on('mousemove.rotate', move).on(
          'mouseup.rotate', end);
      
      $(g.node()).mouseleave(end);
      
      var angle = m.rotate();
      xAngle = angle.xAngle;
      yAngle = angle.yAngle;
      
    };

    function start() {
      if (!isEnable()) {
        return;
      }
      oldX = d3.event.layerX;
      oldY = d3.event.layerY;
      mousedown = true;
    };

    function move() {
      if (!isEnable()) {
        return;
      }
      
      if(mousedown == true){
       var x = d3.event.layerX;
       var y = d3.event.layerY;
       
       yAngle += (oldX - x) /2;
       if(yAngle > 180){
         yAngle -= 360;
       }else if(yAngle < -180){
         yAngle += 360;
       }
       
       xAngle += (y - oldY)/2;
       if(xAngle > 90){
         xAngle = 90;
       } else if(xAngle < -90){
         xAngle = -90;
       }
       
       oldX = x;
       oldY = y;
       
       m.rotate({
         xAngle: xAngle,
         yAngle: yAngle
         });

       //stop event, as if we bubble this event. It will be caught by framework. It will find the UI component and fire error
       //message that the parent node is not exist.
       d3.event.stopPropagation();
       d3.event.preventDefault();
      }
    }

    function end() {
      if (!isEnable()) {
        return;
      }
      mousedown = false;
    }
    
    function isEnable() {
        var result = true;
        if (props.disableWithCtrlKey) {
            var originalEvent = getCurrentEvent();
            if (originalEvent.ctrlKey) {
                result = false;
            }
        }
        return result;
    }

    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }

    rotate.module = function(_){
      if(!arguments.length){
        return m;
      }
      m = _; g = m.parent();
      return rotate;
    };
    
    rotate.properties = function(_){
      if(!arguments.length){
        return props;
      }
      Objects.extend(true, props, _);
      return rotate;
    };
    
    return rotate;
    
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.controller.Rotate',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.controller.rotate',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Base',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.controller.rotate',
    'name' : 'selection',
    'base' : "sap.viz.modules.controller.base",
    'description': 'Settings for the interactions of the chart.',
    'properties' : {
        disableWithCtrlKey: {
            name:"disable",
            supportedValueType:"Boolean",
            defaultValue: true,
            description: "Set whether rotate when ctrl key pressed.",
            isExported: false
        }
    },
    'fn' : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.Vector3D',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.threeD.Vector',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.2'
}
],
function Setup(Vector, Point) {
  function Vector3D() {
    Vector.apply(this, arguments);
  }

  Vector3D.prototype = Object.create(Vector.prototype);

  Vector3D.prototype.transform = function(m) {
    var p1 = new Point(0, 0, 0).transform(m);
    var p2 = new Point(this.value(0), this.value(1), this.value(2))
        .transform(m);
    this.value(0, p2.x - p1.x);
    this.value(1, p2.y - p1.y);
    this.value(2, p2.z - p1.z);
    return this;
  };

  return Vector3D;
});sap.riv.module(
{
  qname : 'sap.viz.modules.threeD.cube',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.threeD.Vector4D',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.Vector3D',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.2'
}
],
function Setup(Vector4D, Vector3D, matrix, Point3D) {
  return function() {
    var width, height, depth, transformMatrix, color, colorlightC, colordarkC;
    function cube(parent) {
      var wrapper = parent.selectAll("g.v-cube").data(function(d, i) {
        var wv = d3.functor(width).apply(this, arguments);
        var hv = d3.functor(height).apply(this, arguments);
        var dv = d3.functor(depth).apply(this, arguments);
        var m = d3.functor(transformMatrix).apply(this, arguments);
        var c = d3.functor(color).apply(this, arguments);
        var lightC = d3.functor(colorlightC).apply(this, arguments);
        var darkC = d3.functor(colordarkC).apply(this, arguments);

        return [ {
          wv : wv,
          hv : hv,
          dv : dv,
          m : m,
          data : d,
          c : c,
          lightC: lightC,
          darkC: darkC,
          ctx : d.data.ctx
        } ];
      });
      wrapper.exit().remove();
      wrapper.enter().append("g").attr("class", "v-cube v-datapoint");

      var initBoundingBox = function(w, h, d){
        return [
                [0,0,0],
                [0,h,0],
                [0,h,d],
                [0,0,d],
                [w,0,0],
                [w,h,0],
                [w,h,d],
                [w,0,d]
                ];
      };
      
      var rects = wrapper.selectAll("rect[class|=\"v-cube-surface\"]").data(
          function(d) {
            var wv = d.wv;
            var hv = d.hv;
            var dv = d.dv;

            var c = d.c;
            //var hsl = d3.rgb(c).hsl();
            //var light = hsl.l;
            //var lightC = d3.hsl(hsl.h, hsl.s, light * 1.06).rgb().toString();
            var lightC = d.lightC;
            //var darkC = d3.hsl(hsl.h, hsl.s, light * 0.94).rgb().toString();
            var darkC = d.darkC;

            var rectDatas = new Array({
              m : matrix().rotateX(90).translate(0, hv, 0).transform(d.m),
              type : "bottom"
            }, {
              m : matrix().rotateY(180).translate(0, 0, dv).transform(d.m),
              type : "back"
            }, {
              m : matrix().rotateY(90).transform(d.m),
              type : "left"
            }, {
              type : "front",
              m : d.m
            }, {
              m : matrix().rotateY(-90).translate(wv, 0, 0).transform(d.m),
              type : "right"
            }, {
              m : matrix().rotateX(-90).transform(d.m),
              type : "top"
            });

            rectDatas.forEach(function(o) {
              o.normal = new Vector3D(0, 0, -1).transform(o.m);
            });

            rectDatas = rectDatas.filter(function(o) {
              return o.normal.value(2) < 0;
            });

            rectDatas.forEach(function(o) {
              switch (o.type) {
              case "bottom":
                o.x = 0;
                o.y = 0;
                o.w = wv;
                o.h = dv;
                break;
              case "back":
                o.x = -wv;
                o.y = 0;
                o.w = wv;
                o.h = hv;
                break;
              case "left":
                o.x = -dv;
                o.y = 0;
                o.w = dv;
                o.h = hv;
                break;
              case "front":
                o.x = 0;
                o.y = 0;
                o.w = wv;
                o.h = hv;
                break;
              case "right":
                o.x = 0;
                o.y = 0;
                o.w = dv;
                o.h = hv;
                break;
              case "top":
                o.x = 0;
                o.y = -dv;
                o.w = wv;
                o.h = dv;
                break;
              }

              var normalX = o.normal.value(0);
              o.fill = normalX === 0 ? lightC : (normalX < 0 ? c : darkC);
            });

            return rectDatas;
          });

      rects.exit().remove();

      rects.enter().append("rect").attr("class", function(d) {
        return "v-cube-surface-" + d.type;
      });

      rects.attr("x", function(d) {
        return d.x;
      }).attr("y", function(d) {
        return d.y;
      }).attr("width", function(d) {
        return d.w;
      }).attr("height", function(d) {
        return d.h;
      }).attr("transform", function(d) {
        if (d.m) {
          return d.m.projection();
        }
      }).attr("fill", function(d) {
        return d.fill;
      });

      wrapper.each(function(d) {
        var flbpz = 0;
        if (d.m) {
          var ctMz = d.m.row(2);
          flbpz = new Vector4D(0, d.hv, 0, 1).dotProduct(ctMz);
        }
        d3.select(this.parentNode).datum().flbpz = flbpz;
        
        var points = initBoundingBox(d.wv, d.hv, d.dv), npoints = [];
        points.forEach(function(p){
          npoints.push(new Point3D(p[0], p[1], p[2]).transform(d.m));
        });
        
        npoints.sort(function(a, b) {
          return (b.x - a.x);
         });
         
         npoints.splice(2);
         
         npoints.sort(function(a,b){
           return (a.y - b.y);
         });
       
         d.rtp = npoints[0];
      });

      parent.sort(function(a, b) {
        return d3.descending(a.flbpz, b.flbpz);
      });
    }

    cube.width = function() {
      if (arguments.length === 0) {
        return width;
      }

      width = arguments[0];
      return cube;
    };

    cube.height = function() {
      if (arguments.length === 0) {
        return height;
      }

      height = arguments[0];
      return cube;
    };

    cube.depth = function() {
      if (arguments.length === 0) {
        return depth;
      }

      depth = arguments[0];
      return cube;
    };

    cube.matrix = function() {
      if (arguments.length === 0) {
        return transformMatrix;
      }

      transformMatrix = arguments[0];
      return cube;
    };

    cube.color = function() {
      if (arguments.length === 0) {
        return color;
      }

      color = arguments[0];
      return cube;
    };
    cube.colorlightC = function() {
        if (arguments.length === 0) {
          return colorlightC;
        }

        colorlightC = arguments[0];
        return cube;
      };
    cube.colordarkC = function() {
        if (arguments.length === 0) {
          return colordarkC;
        }

        colordarkC = arguments[0];
        return cube;
      };
    return cube;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.bar3d',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.cube',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
}
],
function Setup(MNDHandler, Scaler, Objects, cube, matrix, langManager, ObjectUtils, dispatch, TypeUtils, tooltip, tooltipDataHandler, NumberUtils, langManager) {

  var barPaddingRatio = 0.5;

  return function(manifest,ctx) {
    var width = 0, height = 0, depth = 0, data, properties = manifest.props(null), m = matrix();
    var datas, d = dispatch('initialized', 'showTooltip', 'hideTooltip', 'valueScaleChange', 'primaryCategoryScaleChange', 'secondaryCategoryScaleChange');
    var parent = null;
    var lastHovered = null;
    var drawingEffect = 'normal';
    
    var styles = {
        'normal' : 'stroke:#FFF;opacity:1',
        'selected' : 'stroke:#000;opacity:1',
        'deselected': 'stroke:#FFF;opacity:0.4'
    };
    
    var secondaryCategoryData = {
        'sap.viz.modules.column3d.dimension':{
          key: 'sap.viz.modules.column3d.dimension',
          values : [{
            col: {val:''},
            rows: []
          }]
        }
    };
    
    var primaryCategoryData = {
        'sap.viz.modules.column3d.dimension':{
          key: 'sap.viz.modules.column3d.dimension',
          values : [{
            col: {val:''},
            rows: []
          }]
        }
    };
    
    var primaryCategoryScale = d3.scale.ordinal(), secondaryCategoryScale = d3.scale
        .ordinal(), valueScale = d3.scale.linear();

    var cubeBuilder = cube();

    var colorPalette = d3.scale.ordinal();

    var effectManager = ctx.effectManager;
    function chart(selection) {

      parent = selection;

      colorPalette.range(properties.colorPalette);
      drawingEffect = properties.drawingEffect; 

      var primaryCategoryRangeBand = primaryCategoryScale.rangeBand();
      var secondaryCategoryRangeBand = secondaryCategoryScale.rangeBand();

      var vertical = isVertical();

      var barCategorySize = primaryCategoryRangeBand /
          (1 + 2 * barPaddingRatio);
      var barDepth = barCategorySize;
      var barCategoryPadding = barCategorySize * barPaddingRatio;
      var barValueSize = vertical ? function(d) {
          if(NumberUtils.isNoValue(d.data.val)) {return 0;}
          if(d.data.val < 0){ 
              return valueScale(d.data.val) - valueScale(0);
          } else {
              return valueScale(0) - valueScale(d.data.val) ;
          }
      } : function(d) {
        if(NumberUtils.isNoValue(d.data.val)) {return 0;}
        if(d.data.val < 0){ 
            return valueScale(0) - valueScale(d.data.val);
        } else {
            return valueScale(d.data.val) - valueScale(0);
        }
      };
      var barDepthValue = function(d){
          if(NumberUtils.isNoValue( d.data.val) ){
              return 0;
          }else{
              return barDepth;
          }
      };
      
      cubeBuilder.width(vertical ? barCategorySize : barValueSize).height(
          vertical ? barValueSize : barCategorySize).depth(barDepthValue).matrix(
          function(d) {
            var primaryCategoryOffset = d.aa1 * primaryCategoryRangeBand +
                barCategoryPadding;

            var x = 0;
            
            if(vertical){
                x = primaryCategoryOffset;
            }else{
                if(d.data.val < 0){
                    x =  valueScale(d.data.val);
                }else{
                    x =  valueScale(0);
                }
            }
            
            var y = 0;
            if(vertical){
                if(d.data.val < 0){
                    y = valueScale(0);
                }else{
                    y = valueScale(d.data.val);
                }
            }else{
                y = height -
                primaryCategoryOffset - 2*barCategoryPadding;
            }
            var z = d.aa2 * secondaryCategoryRangeBand + barCategoryPadding;
            return matrix().translate(x, y, z).transform(m);
          }).color(function(d) {       
        	  var parameter = {
                    drawingEffect: drawingEffect,
                    fillColor : colorPalette(d.aa2),
                    direction : isVertical()?'horizontal':'vertical'
                };
            return effectManager.register(parameter);
      }).colorlightC(function(d)
        {
    	  var c = colorPalette(d.aa2);
    	  var hsl = d3.rgb(c).hsl();
          var light = hsl.l;
    	  var parameter = {
                  drawingEffect: drawingEffect,
                  fillColor : d3.hsl(hsl.h, hsl.s, light * 1.06).rgb().toString(),
                  direction : isVertical()?'horizontal':'vertical'
              };
		  return effectManager.register(parameter);          
      }).colordarkC(function(d)
    	{
    	  var c = colorPalette(d.aa2);
    	  var hsl = d3.rgb(c).hsl();
          var light = hsl.l;
    	  var parameter = {
                  drawingEffect: drawingEffect,
                  fillColor : d3.hsl(hsl.h, hsl.s, light * 0.94).rgb().toString(),
                  direction : isVertical()?'horizontal':'vertical'
              };
		  return effectManager.register(parameter); 
      });

      var mainShapesGroup = selection.select('g.v-datashapesgroup');
      if(!TypeUtils.isExist(mainShapesGroup[0][0])){
        mainShapesGroup = selection.append('g').attr('class', 'v-datashapesgroup');
      }
      
      var dataShapes = mainShapesGroup.selectAll("g.v-datashape").data(datas);
      
      dataShapes.enter().append("g").attr("class", "v-datashape");
      dataShapes.exit().remove();
      
      cubeBuilder(mainShapesGroup.selectAll('g.v-datashape'));

      selection.selectAll('.v-datapoint').each(function(){
          this.setAttribute('style', styles.normal);
      });
      
      d.initialized();
     
    }
    chart.afterUIComponentAppear = function(){
      d.initialized(); 
    };
    
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }

      width = value;

      if (isVertical()) {
        updatePrimaryCategoryScaleRange();
        updateSecondaryCategoryScaleRange();
      } else {
        updateValueScaleRange();
      }

      return chart;
    };

    chart.depth = function(value){
        if (!arguments.length){
            return depth;
        }
        depth = value;
        return chart;
    };
    
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;

      if (isVertical()) {
        updateValueScaleRange();
      } else {
        updatePrimaryCategoryScaleRange();
        updateSecondaryCategoryScaleRange();
      }

      return chart;
    };

    chart.primaryCategoryScale = function(scale) {
      if (!arguments.length) {
        return primaryCategoryScale;
      }
      primaryCategoryScale = scale;
      return chart;
    };

    chart.secondaryCategoryScale = function(scale) {
      if (!arguments.length) {
        return secondaryCategoryScale;
      }
      secondaryCategoryScale = scale;
      return chart;
    };

    chart.valueScale = function(scale) {
      if (!arguments.length) {
        return valueScale;
      }
      valueScale = scale;
      return chart;
    };

    chart.valueScaleTitle = function(_){
          if(!arguments.length){
            var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
            if(titles){
              for(var i=0, len =titles.values.length; i< len;i++ ){
                  if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                  {
                      title.push(titles.values[i].col);
                  }
                  else
                  {
                      title.push(langManager.get('IDS_ISNOVALUE'));
                  }
              }
            }
            return title.join('/');
          }
          return this;
    };
    
    chart.data = function(value) {
      if (!arguments.length) {
        return data;
      }
      data = value;

      var mndData = MNDHandler(data);
      
      generateSecondCategoryData(mndData, data);
      
      var parsedData = mndData.MG1;

      var i;

      var primaryCategoryLength = parsedData[0].length;
      var primaryCategoryDomain = new Array(primaryCategoryLength);
      for (i = 0; i < primaryCategoryLength; i++) {
        primaryCategoryDomain[i] = i;
      }
      primaryCategoryScale.domain(primaryCategoryDomain);

      var secondaryCategoryLength = parsedData.length;
      var secondaryCategoryDomain = new Array(secondaryCategoryLength);
      for (i = 0; i < secondaryCategoryLength; i++) {
        secondaryCategoryDomain[i] = i;
      }
      secondaryCategoryScale.domain(secondaryCategoryDomain);

      updateSecondaryCategoryScaleRange();

      datas = [];
      for ( var i = 0, len1 = parsedData.length; i < len1; i++) {
        var groupData = parsedData[i];
        for ( var j = 0, len2 = groupData.length; j < len2; j++) {
          datas.push({
            data : groupData[j],
            aa2 : i,
            aa1 : j
          });
        }
      }

      var extent = d3.extent(datas, function(o) {
        return o.data.val;
      });
      var min = extent[0], max = extent[1];
      min = (min === undefined)? 0 : min;
      max == (max === undefined ) ? 1 :max;
      var bottom = min >= 0 ? 0 : min;
      var top = max <= 0 ? 0 : max;
      if (bottom === 0 && top === 0) {
        top = 1;
      }

      valueScale.domain([ bottom, top ]);
      Scaler.perfect(valueScale);
      return chart;
    };

    /**
     * set/get properties
     */
    chart.properties = function(props) {
      if (!arguments.length) {
        return properties;
      }
      Objects.extend(true, properties, props);

      updatePrimaryCategoryScaleRange();
      updateSecondaryCategoryScaleRange();
      updateValueScaleRange();

      return chart;
    };

    chart.colorPalette = function(_) {
      if (!arguments.length) {
        return properties.colorPalette;
      }
      properties.colorPalette = _;
      return this;
    };

    chart.matrix = function(_) {
      if (!arguments.length) {
        return m;
      }
      m = _;
      return this;
    };

    chart.secondaryCategoryData = function(_){
      if(!arguments.length){
        return secondaryCategoryData;
      }
      secondaryCategoryData = _;
      return this;
    };

    chart.primaryCategoryData = function(_){
      if(!arguments.length) {
        return primaryCategoryData;
      }
      primaryCategoryData = _;
      return chart;
    };
    
    chart.dispatch = function(_){
      if(!arguments.length){
        return d;
      }
      d = _;
      return chart;
    };
    
    chart.parent = function(){
      if( !arguments.length ){
        return parent;
      }
      parent = _;
      return chart;
    };
    
    chart.highlight = function(_){
      if (_ instanceof Array) {
        for ( var i = 0; i < _.length; i++) {
          // _[i].setAttribute('opacity', 1);
            _[i].setAttribute('style', styles.selected);
        }
      } else {
        // _.setAttribute('opacity', 1);
          _.setAttribute('style', styles.selected);
      }
    };
    
    chart.unhighlight = function(_){
      if (_ instanceof Array) {
        for ( var i = 0; i < _.length; i++) {
          // _[i].setAttribute('opacity', 0.4);
            _[i].setAttribute('style', styles.deselected);
        }
      } else {
          _.setAttribute('style', styles.deselected);
      }
    };
    
    chart.clear = function(gray){
      if (gray == null) {
        parent.selectAll('.v-datapoint').each(function(){
            this.setAttribute('style', styles.normal);
        });
      } else {
        parent.selectAll('.v-datapoint').each(function(){
            this.setAttribute('style', styles.deselected);
        });
      }
    };
    
    chart.mouseover = function(node) {
      if (lastHovered === node) {
        return;
      }

      var tooltipData = {
        body : [],
        footer : []
      };

      var nd = node.__data__.data, body = tooltipData.body, footer = tooltipData.footer;
      var path = nd.data.ctx.path;

      body.push({
        name : handleNull(data.getMeasureValuesGroupDataByIdx(0).values[path.mi].col),
        val : [ {
          value : handleNull(nd.data.val),
          color : node.__data__.c,
          shape : 'squareWithRadius'
        } ]
      });

      var a0data = data.getAnalysisAxisDataByIdx(0), aa1 = path.dii_a1;
      if (a0data) {
        for ( var i = 0, len = a0data.values.length; i < len; i++) {
          if (a0data.values[i].type === 'MND') {
            continue;
          }
          footer.push({
            'label' : handleNull(a0data.values[i].col.val),
            'value' : handleNull(a0data.values[i].rows[aa1].val)
          });
        }
      }

      var a1data = data.getAnalysisAxisDataByIdx(1), aa2 = path.dii_a2;
      if (a1data) {
        for ( var i = 0, len = a1data.values.length; i < len; i++) {
          if (a1data.values[i].type === 'MND') {
            continue;
          }
          footer.push({
            'label' : handleNull(a1data.values[i].col.val),
            'value' : handleNull(a1data.values[i].rows[aa2].val)
          });
        }
      }
      var transform = parent.node().getTransformToElement(
          parent.node().ownerSVGElement);

      var rtp = node.__data__.rtp;
      tooltipData.point = {
        x : rtp.x + transform.e,
        y : rtp.y + transform.f
      };

      tooltipData.plotArea = {
        x : transform.e,
        y : transform.f,
        width : width,
        height : height
      };

      lastHovered = node;
      d.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));

    };

    chart.mouseout = function(target) {
      lastHovered = null;
      d.hideTooltip();
    };
    
    function isVertical() {
      return properties.direction === "vertical";
    }

    function updatePrimaryCategoryScaleRange() {
      primaryCategoryScale.rangeBands(isVertical() ? [ 0, width ]
          : [ height, 0 ]);
      d.primaryCategoryScaleChange(primaryCategoryScale,isVertical() ? [ 0, width ]
      : [ height, 0 ]);
    }

    function updateSecondaryCategoryScaleRange() {
      
      depth = primaryCategoryScale.rangeBand() * secondaryCategoryScale.domain().length;
      secondaryCategoryScale.rangeBands([
          0, depth]);
      d.secondaryCategoryScaleChange(secondaryCategoryScale, [0, depth ]);
    }

    function updateValueScaleRange() {
      valueScale.range(isVertical() ? [ height, 0 ] : [ 0, width ]);
      d.valueScaleChange(valueScale,  isVertical() ? [ height, 0 ] : [ 0, width ]);
    }
    
    var handleNull = function(_){
      var defaultString = langManager.get('IDS_ISNOVALUE');
      if (_ === null || _ === undefined){
        return defaultString;
      }
      else{ 
        return _;
      }
    };
    
    var handleNullInArray = function(array){
      for (var i = 0; i < array.length; ++i){
        array[i].val = handleNull(array[i].val);
      }
      return array;
    };
    
    var _setPathByaa = function(path){
      var pathObj = {};
      switch(path.aa){
        case 0:
          pathObj.dii_a1 = path.dii;
          break;
        case 1:
          pathObj.dii_a2 = path.dii;
          break;
        case 2:
          pathObj.dii_a3 = path.dii;
          break;
      }
      return pathObj;
    };
    
    var _parseColorLegendFeeds = function(colorFeeds, shapeFeeds){
      var title, colorFeedLength, shapeFeedLength;
      var colorData = _parseLegendFeed(title, colorFeeds, colorFeedLength);
      colorFeedLength = colorData.feedsLength;
      var shapeData = _parseLegendFeed(title, shapeFeeds, shapeFeedLength);
      shapeFeedLength = shapeData.feedsLength;
      
      secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].rows = shapeData.labels;
      secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].col.val = shapeData.title;
      if(shapeData.MNDInfo.hasOnlyMND){
          secondaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].type = 'MND';
      }
      
      
      primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].rows = colorData.labels;
      primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].col.val = colorData.title;
      if(colorData.MNDInfo.hasOnlyMND){
          primaryCategoryData['sap.viz.modules.column3d.dimension'].values[0].type = 'MND';
      }
    };
    
    var getCartesian = function(arrays, symbol) {
      var result = arrays[0];
      var fff = function(arr) {
        var ar = result;
        result = [];
        for(var i = 0; i < ar.length; i++) {
          for(var j = 0; j < arr.length; j++) {
            var t1 = (ar[i].val === undefined) ? ar[i].val : ar[i].val, t2 = (arr[j].val === undefined) ? arr[j].val : arr[j].val;
            var ctx = {
              path : {}
            };
            ObjectUtils.extend(ctx.path, ar[i].ctx.path, arr[j].ctx.path);
            result.push({
              'val': t1 + symbol + t2, 
              'ctx': ctx
            });
          }
        }
      };
      for(var i = 1; i < arrays.length; i++) {
        fff(arrays[i]);
      }

      return result;
    };
    
    var _parseLegendFeed = function(title, feeds, feedsLength){
      var labels = [], rows = [], dimensionTag = ' / ', measureTag = ' - ';
      var MNDIndex, hasOnlyMND = false, i, j, len;
      //Handle colors feeds
      if(feeds && feeds.length > 0){
        for(i = 0, len = feeds.length; i < len; i++) {
          if(feeds[i].type !== 'MND') {
            if(title === undefined) {
              title = handleNull(feeds[i].col.val);
            } else {
              title = title + dimensionTag + handleNull(feeds[i].col.val);
            }
            
            rows = feeds[i].rows;
            for(j = 0; j < rows.length; j++) {
              if(labels[j] === undefined) {
                labels[j] = {};
                labels[j].val = handleNull(rows[j].val);
                labels[j].ctx = {
                  path : _setPathByaa(rows[j].ctx.path)
                };
              } else {
                labels[j].val = labels[j].val + dimensionTag + handleNull(rows[j].val);
              }
            }
          } else {
            MNDIndex = i;
          }
        }
        feedsLength = labels.length;
      }
      
      //Handle Colors with MND
      if(MNDIndex !== undefined) {
        //Save color feed with MND status.
        if(labels.length > 0){
          if(feeds[MNDIndex].rows.length > 1){
            if(MNDIndex === 0) {
              title = langManager.get('IDS_DEFAULTMND') + measureTag + title; 
              //MND is the first feed type. Legend label should be 'MND - A/B/C'
              labels = getCartesian([handleNullInArray(feeds[MNDIndex].rows), labels], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } else if(MNDIndex === feeds.length - 1) {
              title = title + measureTag + langManager.get('IDS_DEFAULTMND');
              //MND is the last feed type. Legend label should be 'A/B/C - MND'
              labels = getCartesian([labels, handleNullInArray(feeds[MNDIndex].rows)], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } 
          }
        }else{
          title = langManager.get('IDS_DEFAULTMND');
          rows = feeds[MNDIndex].rows;
          for(j = 0; j < rows.length; j++) {
            rows[j].val = handleNull(rows[j].val);
            labels.push(rows[j]);
          }
          feedsLength = rows.length;
          if(feeds.length === 1){
            hasOnlyMND = true;
          }
        }
      }
      
      return {
        'title' : title,
        'labels' : labels,
        'feedsLength' : feedsLength,
        'MNDInfo' : {
          'MNDIndex' : MNDIndex,
          'hasOnlyMND': hasOnlyMND //Only has MND, no cartesian
        }
      };
    };

    function generateSecondCategoryData(){
      var colorFeeds = null, shapeFeeds = null;;
      var aa = data.getAnalysisAxisDataByIdx(0);
      if(aa){ 
        colorFeeds = aa.values;
      }
     
      aa = data.getAnalysisAxisDataByIdx(1);
      if(aa){
        shapeFeeds = aa.values;
      }
     
      _parseColorLegendFeeds(colorFeeds, shapeFeeds);
    };
    
    return chart;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xyz.Bar3D',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.bar3d',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.2'
}
],
function Setup(Manifest, fn, Constants) {
  var module = {
    'id' : 'sap.viz.modules.bar3d',
    'name' : '3d bar',
    'type' : Constants.Module.Type.Chart,
    fn : fn,
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set color palette.'
      },
      'direction' : {
        'name' : "direction",
        'supportedValueType' : 'List',
        'supportedValues' : [ 'vertical', 'horizontal' ],
        'defaultValue' : "vertical",
        'description' : 'Set direction.',
        'isExported' : false
      }
    },
    'feeds' : {
      id : "xy",
      configure : {
        secondaryValues : null
      }
    }
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.xyzcontainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.handler.SingleChartDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.matrix',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.Point',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.threeD.Vector3D',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ignite',
  version : '4.0.2'
}
],
function Setup(TypeUtils, Objects, Functions, Manifest,
    SingleChartDataHandler, dispatch, matrix, Point3D, Vector3D, boundUtil, ignite) {

  // xyzcontainer
  var retfn = function(manifest, ctx) {

    var width = 0, height = 0, properties = {}, data = {}, config = {}, modules = {}, selections = {}, spaceWithoutPlot, parent = null; // a d3
    // selection

    var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), 
        initializedModules = 0;
    
    var innerProperties = manifest.props(null);
    var xAngle = 20, yAngle = 50;

    var yAxisScale = d3.scale.linear(); // can be linear or ordinal scale
    var xAxisScale =  d3.scale.ordinal(); // can be linear or ordinal scale
    var zAxisScale =  d3.scale.ordinal();
    // /////////////////////can be moved to base container/////////////////////
    var resolveProperties = function(nodeConfig, isContainer) {
      var props = {}, // Empty properties basket
      propsCat, // Property category node
      usrProps, // User set properties
      sysProps; // Predefined properties in configure node
      if (isContainer) {
        // Jimmy/8/15/2012 pay attention to the property structure, for
        // container we will pass
        // all properties instead of properties under propsCat only.
        if (nodeConfig) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = properties;
          sysProps = {};
          sysProps[propsCat] = nodeConfig.properties;
          Objects.extend(true, props, sysProps, usrProps);
        } else {
          props = properties;
        }
      } else {
        if (nodeConfig) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = properties[propsCat];
          sysProps = nodeConfig.properties;
          // User properties will override predefined properties
          Objects.extend(true, props, sysProps, usrProps);
        }
      }
      return props;
    };

    var updateProperties = function(id, isContainer) {
      var moduleManifest = config.modules; // Module configurations
      var props, nodeConfig, propsCat;
      if (moduleManifest[id] && modules[id]) {
        nodeConfig = moduleManifest[id].configure;
        if (isContainer) {
          props = properties;
        } else {
          if (nodeConfig) {
            propsCat = nodeConfig.propertyCategory;
            props = Objects.extend(true, {}, properties[propsCat]);
          } else {
            props = {};
          }
        }
        modules[id].properties(props);
      }
    };
    // /////////////////////can be moved to base container/////////////////////

    function initialize() {
      if (TypeUtils.isEmptyObject(config))
        Functions.error('Container configuration missing');

      initializedModules = 0;

      initAxis('xAxis');
      initAxis('yAxis');
      initAxis('zAxis');
      initAxis('background');

      var plotConfig = config.modules.plot;
      if (!plotConfig)
        return;
      var plot = modules.plot = ignite(plotConfig.id, ctx, "plot");
      var dataHandler = new SingleChartDataHandler(data);
      plot.data(dataHandler.getDataAdapter());

      var props;
      if (plotConfig.configure) {
        props = resolveProperties(plotConfig.configure);
        plot.properties(props);
      }

      if (plot.dispatch) {
        var dis = plot.dispatch();
        if (dis.initialized) {
          initializedModules++;
          dis.on('initialized.xycontainer', initialized);
        }
        ;
        if (dis.showTooltip)
          dis.on('showTooltip.xycontainer', showTooltip);
        if (dis.hideTooltip)
          dis.on('hideTooltip.xycontainer', hideTooltip);
      }

      var dataLabelConfig = config.modules.dataLabel;
      if (TypeUtils.isExist(dataLabelConfig)
          && TypeUtils.isExist(plot.dataLabel)) {
        var dataLabel = modules.dataLabel = ignite(dataLabelConfig.id, ctx);
        plot.dataLabel(dataLabel);
        dataLabel.plot(plot);
        if (dataLabelConfig.configure) {
          props = resolveProperties(dataLabelConfig.configure);
          dataLabel.properties(props);
        }
      }

      if (modules.xAxis && !selections.xAxis)
        selections.xAxis = parent.append('g').attr('class', 'v-m-xAxis');
      if (modules.yAxis && !selections.yAxis)
        selections.yAxis = parent.append('g').attr('class', 'v-m-yAxis');
      if (modules.zAxis && !selections.zAxis)
        selections.zAxis = parent.append('g').attr('class', 'v-m-zAxis');
      if (modules.plot && !selections.plot)
        selections.plot = parent.append('g').attr('class', 'v-m-plot');
      if (modules.background && !selections.background)
        selections.background = parent.insert('g', ':first-child').attr(
            'class', 'background');
    }

    function updateAxisData(id) {
      if (modules[id]) {
        var axisConfig = config.modules[id];
        var axisDataConfig = axisConfig.data;
        if (axisDataConfig) {
          modules[id].data(data.createDataAdapterForModule(axisDataConfig));
        }
      }
    }
    ;

    function initAxis(id) {
      if (!config.modules[id])
        return;

      var axisConfig = config.modules[id], axis = modules[id] = ignite(axisConfig.id, ctx, id);

      updateAxisData(id);

      var props = resolveProperties(axisConfig.configure);
      axis.properties(props);

      if (axis.dispatch && axis.dispatch()['initialized']) {
        initializedModules++;
        axis.dispatch().on('initialized.xycontainer', initialized);
      }
    }

    var initBoundingBox = function(width, height, depth) {
      var bounds = [ {
        x : 0,
        y : 0,
        z : 0
      }, {
        x : 0,
        y : 0,
        z : depth
      }, {
        x : width,
        y : 0,
        z : 0
      }, {
        x : width,
        y : 0,
        z : depth
      }, {
        x : 0,
        y : height,
        z : 0
      }, {
        x : 0,
        y : height,
        z : depth
      }, {
        x : width,
        y : height,
        z : 0
      }, {
        x : width,
        y : height,
        z : depth
      } ];

      return bounds.map(function(bound) {
        return new Point3D(bound.x, bound.y, bound.z);
      });
    };

    var computeTransformBB = function(bounds, m) {
      var point = bounds[0];
      point.transform(m);

      var minx = point.x, miny = point.y, maxx = point.x, maxy = point.y;

      for ( var i = 1, len = bounds.length; i < len; i++) {
        point = bounds[i];
        point.transform(m);

        minx = Math.min(minx, point.x);
        miny = Math.min(miny, point.y);
        maxx = Math.max(maxx, point.x);
        maxy = Math.max(maxy, point.y);
      }

      return {
        x : minx,
        y : miny,
        z : maxx,
        w : maxy
      };

    };

    function radian(deg) {
      return deg * Math.PI / 180;
    }

    var computeMargin = function(params, info3d, omatrix, cwidth, cheight,
        cdepth, southPrefSize, westPrefSize, eastPrefSize) {

      var sangle = layoutAxis('south', params, 'xAxis', xAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var asangle = Math.abs(radian(sangle));

      var wangle = layoutAxis('west', params, 'yAxis', yAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var awangle = Math.abs(radian(wangle));

      var zangle = layoutAxis('none', params, 'zAxis', zAxisScale, omatrix, 0,
          0, cwidth, cheight, cdepth, info3d.x0, info3d.x1, info3d.y0,
          info3d.z0, info3d.z1)
      var azangle = Math.abs(radian(zangle));

      var left = 0, top = 0, right = 0, bottom = 0;

      left = westPrefSize.width * Math.cos(awangle);

      if (zangle <= 1 && sangle > 0
          && !(zangle == 1 && sangle == 91 && xAngle > 0)) {
        left = (left > southPrefSize.height * Math.cos(asangle)) ? left
            : southPrefSize.height * Math.cos(asangle);
        right = eastPrefSize.height * Math.cos(azangle);

        bottom = (southPrefSize.height * Math.sin(asangle) > eastPrefSize.height
            * Math.sin(azangle)) ? southPrefSize.height * Math.sin(asangle)
            : eastPrefSize.height * Math.sin(azangle);

      } else {
        left = (left > eastPrefSize.height * Math.cos(azangle)) ? left
            : eastPrefSize.height * Math.cos(azangle);
        right = southPrefSize.height * Math.cos(asangle);

        bottom = (southPrefSize.height * Math.sin(asangle) > eastPrefSize.height
            * Math.sin(azangle)) ? southPrefSize.height * Math.sin(asangle)
            : eastPrefSize.height * Math.sin(azangle);
      }
      return {
        top : 0,
        left : left,
        bottom : bottom,
        right : right
      };
    };

    var prepareScale = function(sizeH, sizeV, bb, margin, param) {
      var bbSizeX = bb.z - bb.x;
      var bbSizeY = bb.w - bb.y;

      var ratioX = sizeH / bbSizeX;
      var ratioY = sizeV / bbSizeY;
      var minRatio = Math.min(ratioX, ratioY);

      return {
        x : minRatio,
        y : ratioY,
        z : minRatio
      };

    };

    var generateRendererParam = function(m) {
      var camera_ = new Vector3D(0, 0, 1);

      var isRenderRT = false, // left
      isRenderTP = false, // top
      isRenderFT = false; // front

      var origin = new Point3D(0, 0, 0);
      var pointX = new Point3D(1, 0, 0);
      var pointY = new Point3D(0, -1, 0);
      var pointZ = new Point3D(0, 0, 1);

      origin.transform(m);
      pointX.transform(m);
      pointY.transform(m);
      pointZ.transform(m);

      var renderingOrderX = new Vector3D(pointX.x - origin.x, pointX.y
          - origin.y, pointX.z - origin.z), renderingOrderY = new Vector3D(
          pointY.x - origin.x, pointY.y - origin.y, pointY.z - origin.z), renderingOrderZ = new Vector3D(
          pointZ.x - origin.x, pointZ.y - origin.y, pointZ.z - origin.z)

      if (camera_.dotProduct(renderingOrderX) < 0) {
        isRenderRT = true;
      }

      if (camera_.dotProduct(renderingOrderY) < 0) {
        isRenderTP = true;
      }

      if (camera_.dotProduct(renderingOrderZ) > 0) {
        isRenderFT = true;
      }

      return {
        isRenderRT : isRenderRT,
        isRenderTP : isRenderTP,
        isRenderFT : isRenderFT,
        renderingOrderX : renderingOrderX,
        renderingOrderY : renderingOrderY,
        renderingOrderz : renderingOrderZ
      };
    };

    function layoutAxis3D(params_, x_, y_, width_, height_, yDepth_) {
      var x0, x1, y0, y1, z0, z1;
      y0 = y_ + height_;

      if (params_.isRenderFT) {
        x0 = x_;
        if (params_.isRenderTP)
          z0 = 0;
        else
          z0 = yDepth_;
      } else {
        x0 = x_ + width_;
        if (params_.isRenderTP)
          z0 = yDepth_;
        else
          z0 = 0;
      }
      if (params_.isRenderRT) {
        z1 = 0;
        if (params_.isRenderTP)
          x1 = x_ + width_;
        else
          x1 = x_;
      } else {
        z1 = yDepth_;
        if (params_.isRenderTP)
          x1 = x_;
        else
          x1 = x_ + width_;
      }

      return {
        x0 : x0,
        x1 : x1,
        y0 : y0,
        z0 : z0,
        z1 : z1
      };
    }
    ;

    function layoutAxis(type, params, axis, scale, m, x_, y_, width_, height_,
        yDepth_, x0, x1, y0, z0, z1) {
      var origin, point, tick, vector;
      var length, angle, labelAngle, tickAngle, gap;

      switch (type) {
        case 'south':
          origin = new Point3D(x_, y0, z0);
          gap = (0 == z0) ? -yDepth_ : yDepth_;
          tick = new Point3D(x_, y0, z0 + gap);
          point = new Point3D(x_ + width_, y0, z0);
          break;
        case 'north':
          origin = new Point3D(x_, height_ - y0, yDepth_ - z0);
          gap = (0 == z0) ? -yDepth_ : yDepth_;
          tick = new Point3D(x_, y0, yDepth_ - z0 + gap);
          point = new Point3D(x_ + width_, height_ - y0, yDepth_ - z0);
          break;
        case 'west':
          origin = new Point3D(x0, y_, z1);
          tick = new Point3D(x0 - width_, y_, z1);
          point = new Point3D(x0, y_ - height_, z1);
          break;
        case 'east':
          origin = new Point3D(width_ - x0, y_ + height_, yDepth_ - z1);
          tick = new Point3D(width_, y_ + height_, yDepth_ - z1);
          point = new Point3D(width_ - x0, y_, yDepth_ - z1);
          break;
        default:
          origin = new Point3D(x1, y0, 0);
          gap = (x_ == x1) ? -width_ : width_;
          tick = new Point3D(x1 + gap, y0, 0);
          point = new Point3D(x1, y0, yDepth_);
          break;
      }

      origin.transform(m);
      tick.transform(m);
      point.transform(m);

      if (type == 'west') {
        labelAngle = 0;
        tickAngle = 0;
      } else {
        vector = new Vector3D(tick.x - origin.x, tick.y - origin.y, point.z
            - origin.z);
        labelAngle = Math.atan2(vector.values[0], vector.values[1]) * 180
            / Math.PI + 90;
        if (labelAngle > 90)
          labelAngle -= 180;
        else if (labelAngle < -90)
          labelAngle += 180;
        labelAngle = computeAngle3D(labelAngle);
        tickAngle = Math.atan2(vector.values[1], vector.values[0]) * 180
            / Math.PI;
      }

      modules[axis].labelAngle(labelAngle).tickAngle(tickAngle);

      vector = new Vector3D(point.x - origin.x, point.y - origin.y, point.z
          - origin.z);
      selections[axis].attr('transform', 'translate(' + origin.x + ' '
          + origin.y + ')');
      angle = Math.atan2(vector.values[1], vector.values[0]) * 180 / Math.PI
          + 90;

      // a special setting, if the angle
      if (type === 'none' && angle == 0) {
        angle = -1;
      }
      modules[axis].angle(angle);

      modules[axis].labelAlign('start');

      length = (point.x - origin.x) * (point.x - origin.x)
          + (point.y - origin.y) * (point.y - origin.y);

      if (length < 0.01)
        length = 0;

      if (type == 'west') {
        modules[axis].height(Math.sqrt(length));
      } else {
        modules[axis].width(Math.sqrt(length));
      }

      if (scale.rangeBands) {
          var range = scale.range();
          if(range[range.length -1] > range[0]){
              scale.rangeBands([ Math.sqrt(length),  0 ]);
          }else{
              scale.rangeBands([ 0, Math.sqrt(length) ]);
          }
      } else {
          var range = scale.range();
          if(range[range.length -1] > range[0]){
              scale.range([ Math.sqrt(length), 0]);
          }else{
              scale.range([ 0, Math.sqrt(length)]);
          }
      }

      return labelAngle;
    }
    ;

    function computeAngle3D(angleParam) {

      var angle = angleParam % 360;
      if (-271 < angle && angle < -270)
        return -271;
      else if (-270 <= angle && angle < -269)
        return -269;
      if (-181 < angle && angle < -180)
        return -181;
      else if (-180 <= angle && angle < -179)
        return -179;
      else if (-91 < angle && angle < -90)
        return -91;
      else if (-90 <= angle && angle < -89)
        return -89;
      else if (-1 < angle && angle < 0)
        return -1;
      else if (0 <= angle && angle < 1)
        return 1;
      else if (89 < angle && angle < 90)
        return 89;
      else if (90 <= angle && angle < 91)
        return 91;
      else if (179 < angle && angle < 180)
        return 179;
      else if (180 <= angle && angle < 181)
        return 181;
      else if (269 < angle && angle < 270)
        return 269;
      else if (270 <= angle && angle < 271)
        return 271;
      else if (359 < angle && angle < 360)
        return 359;
      return Math.round(angleParam);
    }

    function relayout(firstLayout) {
      if (TypeUtils.isEmptyObject(modules) || !width || !height)
        return;

      width = width < 0 ? 0 : width;
      height = height < 0 ? 0 : height;

        modules.plot.width(width).height(height);
        
        modules.xAxis.drawable(true);
        modules.yAxis.drawable(true);
        modules.zAxis.drawable(true);
        

        var southPrefSize = modules.xAxis.getPreferredSize();
        var westPrefSize = modules.yAxis.getPreferredSize();
        var eastPrefSize = modules.zAxis.getPreferredSize();

        var cwidth = modules.plot.width(), cheight = modules.plot.height(), cdepth = modules.plot.depth();
        var omatrix = matrix().rotateY(yAngle).rotateX(xAngle);

        var params = generateRendererParam(omatrix);
        var info3d = layoutAxis3D(params, 0, 0, cwidth, cheight, cdepth);

        var bounds = initBoundingBox(cwidth, cheight, cdepth);
        var bb = computeTransformBB(bounds, omatrix);

        var margin = computeMargin(params, info3d, omatrix, cwidth, cheight,
            cdepth, southPrefSize, westPrefSize, eastPrefSize);
        
        if(margin.left > width/3 || margin.right > width/3 || margin.bottom > height/3){
            modules.yAxis.drawable(false);
            modules.zAxis.drawable(false);
            modules.xAxis.drawable(false);

            southPrefSize = modules.xAxis.getPreferredSize();
            westPrefSize = modules.yAxis.getPreferredSize();
            eastPrefSize = modules.zAxis.getPreferredSize();

            cwidth = modules.plot.width(), cheight = modules.plot.height(), cdepth = modules.plot.depth();
            omatrix = matrix().rotateY(yAngle).rotateX(xAngle);

            params = generateRendererParam(omatrix);
            info3d = layoutAxis3D(params, 0, 0, cwidth, cheight, cdepth);

            bounds = initBoundingBox(cwidth, cheight, cdepth);
            bb = computeTransformBB(bounds, omatrix);

            margin = computeMargin(params, info3d, omatrix, cwidth, cheight,
                cdepth, southPrefSize, westPrefSize, eastPrefSize);
        } 
        
        var sizeV = height - margin.bottom - margin.top;
        var sizeH = width - margin.left - margin.right;
        var scale = prepareScale(sizeH, sizeV, bb, margin);
        var scaleMatrix = omatrix.unit().scale(scale.x, scale.y, scale.z)
            .clone();
        omatrix.rotateY(yAngle).rotateX(xAngle);

        var offsetX = 0, offsetY = 0;
        var exit = 0;
        while (exit < 10) {

          bounds = initBoundingBox(cwidth, cheight, cdepth);
          bb = computeTransformBB(bounds, omatrix);

          offsetX = 0 - bb.x + margin.left + (sizeH - bb.z + bb.x) / 2;
          offsetY = 0 - bb.y + margin.top + (sizeV - bb.w + bb.y) / 2;

          if (offsetX > 0 && offsetY > 0) {
            break;
          }

          scale = prepareScale(sizeH, sizeV, bb, margin);

          omatrix = scaleMatrix.clone();
          omatrix.scale(scale.x, scale.y, scale.z);
          scaleMatrix = omatrix.clone();

          omatrix.rotateY(yAngle).rotateX(xAngle);
          exit++;
        }

        modules.plot.matrix(omatrix);

        layoutAxis('south', params, 'xAxis', xAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1);

        layoutAxis('west', params, 'yAxis', yAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1);

        layoutAxis('none', params, 'zAxis', zAxisScale, omatrix, 0, 0, cwidth,
            cheight, cdepth, info3d.x0, info3d.x1, info3d.y0, info3d.z0,
            info3d.z1);

        var nwestPrefSize =  modules.yAxis.getPreferredSize();
        
        var node = selections.yAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.yAxis.attr('transform', 'translate('
            + (transform.e - nwestPrefSize.width) + ',' + transform.f + ')');

        bounds = initBoundingBox(cwidth, cheight, cdepth);
        bb = computeTransformBB(bounds, omatrix);

        node = selections.yAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.yAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.xAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.xAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.zAxis.node(), transform = node
            .getTransformToElement(node.parentNode);
        selections.zAxis.attr('transform', 'translate('
            + (transform.e + offsetX) + ',' + (transform.f + offsetY) + ')');

        node = selections.plot.node();
        selections.plot.attr('transform', 'translate(' + (offsetX) + ','
            + (offsetY) + ')');

    };

    function container(selection) {
        relayout();
      selection.each(function(data) {
        parent = selection;
        boundUtil.drawBound(selection, width, height);
        if (TypeUtils.isEmptyObject(modules))
          initialize();
        render();
      });
      return container;
    }

    container.width = function(_, firstLayout) {
      if (!arguments.length)
        return width;
      width = _;
      // Jimmy,8/20/2012, as a container, you don't know whether your
      // sub elements need relayout even if the container size remains
      // the same. so here we just give a chance to sub elements to relayout
      if ( height ) { relayout(); }
      return container;
    };

    container.height = function(_, firstLayout) {
      if (!arguments.length)
        return height;
      height = _;
      // see @width
      if ( width ) { relayout(); }
      return container;
    };

    container.size = function(_) {
      if (!arguments.length)
        return {
          'width' : width,
          'height' : height
        };
      height = _.height;
      width = _.width;
      // see @width
      relayout();
      return container;
    };

    container.data = function(_) {
      if (!arguments.length)
        return data;
      data = _;
      if (!TypeUtils.isEmptyObject(modules)) {
        // plot exists, we need update its data
        var dataHandler = new SingleChartDataHandler(data);
        modules.plot.data(dataHandler.getDataAdapter());
        updateAxisData('xAxis');
        updateAxisData('yAxis');
        updateAxisData('zAxis');
      }

      return container;
    };

    container.properties = function(_) {
      if (!arguments.length)
        return innerProperties;
      properties = _;
      if (!TypeUtils.isEmptyObject(modules)) {
        updateProperties('xAxis');
        updateProperties('yAxis');
        updateProperties('zAxis');
        updateProperties('plot');
        updateProperties('datalabel');
        updateProperties('background');
      }
      Objects.extend(true, innerProperties, _.xyzcontainer);
      xAngle = innerProperties && innerProperties.xAngle ? innerProperties.xAngle
          : xAngle;
      yAngle = innerProperties && innerProperties.yAngle ? innerProperties.yAngle
          : yAngle;
      return container;
    };

    container.config = function(_) {
      if (!arguments.length)
        return config;
      config = _;
      return container;
    };

    container.modules = function(_) {
      if (!arguments.length) {
        if (TypeUtils.isEmptyObject(modules)) {
          initialize();
        }
        return modules;
      }
      modules = _;
      return container;
    };

    container.parent = function(_) {
      if (!arguments.length)
        return parent;
      parent = _;
      return container;
    };

    container.rotate = function(_){
      if(!arguments.length){
        return {
          xAngle: xAngle,
          yAngle: yAngle
        };
      }
      
      xAngle = _.xAngle;
      yAngle = _.yAngle;
      relayout();
      render();
      
      return container;
    };
    
    container.dispatch = function(_) {
      if (!arguments.length)
        return eDispatch;
      eDispatch = _;
      return container;
    };

    container.infoForSizeLegend = function() {
      return {
        space : spaceWithoutPlot,
        number : 1,
        plotHeight : modules.plot.height()
      };
    };

    container.yAxis = function(_) {
      if (!arguments.length) {
        return yAxisScale;
      }
      yAxisScale = _.copy();
      yAxisScale.tickHint = _.tickHint;
      yAxisScale.tickNum = _.tickNum;
      return container;
    };

    container.xAxis = function(_) {
      if (!arguments.length) {
        return xAxisScale;
      }
      xAxisScale = _.copy();
      xAxisScale.tickHint = _.tickHint;
      xAxisScale.tickNum = _.tickNum;
      return container;
    };

    container.zAxis = function(_) {
      if (!arguments.length) {
        return zAxisScale;
      }
      zAxisScale = _.copy();
      return container;
    };

    container.xAxisScaleChange = function(_, range){
      if(  xAxisScale.rangeBands ){
        xAxisScale.rangeBands(range);
      }else {
        xAxisScale.range(range);
      }
    };
    
    container.zAxisScaleChange = function(_, range){
        zAxisScale.rangeBands(range);
    };
    
    container.yAxisScaleChange = function(_, range){
      if(  yAxisScale.rangeBands ){
        yAxisScale.rangeBands(range);
      }else {
        yAxisScale.range(range);
      }
    };
    
    
    function render() {
      for ( var sel in selections) {
        if (selections.hasOwnProperty(sel)) {
          selections[sel].datum(modules[sel].data()).call(modules[sel]);
        }
      }
      if (TypeUtils.isExist(modules.dataLabel)) {
        modules.dataLabel();
      }
    }

    var initializedCount = 0;
    function initialized() {
      if (initializedModules == ++initializedCount) {
        initializedCount = 0;
        eDispatch.initialized();
      }
    }

    function showTooltip(evt) {
      eDispatch.showTooltip(evt);
    }

    function hideTooltip(evt) {
      eDispatch.hideTooltip(evt);
    }

    return container;
  };
  return retfn;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.XYZContainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.xyzcontainer',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.xyzcontainer',
    'type' : Constants.Module.Type.Container,
    'name' : 'single container',
    'properties' : {
      'xAngle': {
         name : 'xAngle',
         supportedValueType: 'Number',
         defaultValue: 20,
         description : 'The angle should between -90 and 90.'
      },
      'yAngle': {
         name: 'yAngle',
         supportedValueType: 'Number',
         defaultValue : 50,
         description : 'The angle should between -180 and 180.'
      }
    },
    'css' : null,
    'configure' : null,
    'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xyz.Base3DChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYZContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xyz.Bar3D',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Rotate',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.layout.Dock',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.legend.Common',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  return function(direction) {
    var isVertical = direction === "vertical";

    var categoryAxis, valueAxis;
    if ( isVertical ) {
      categoryAxis = "xAxis";
      valueAxis = "yAxis";
    } else {
      categoryAxis = "yAxis";
      valueAxis = "xAxis";
    }

    var chart = {
      id : 'viz/3d_' + (isVertical ? 'column' : 'bar'),
      name : 'IDS_3D_' + (isVertical ? 'COLUMN' : 'BAR'),
      'isExported':false,
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          configure : { propertyCategory : 'general' },
          modules : {
            title : {
              id : 'sap.viz.modules.title',
              configure : {
                propertyCategory : 'title',
                properties : {
                  layout : {
                    position : 'top',
                    priority : 1
                  }
                }
              }
            },
            legends : {
              id : 'sap.viz.modules.legend',
              configure : {
                propertyCategory : 'legendGroup',
                properties : {
                  layout : {
                    position : 'right',
                    priority : 1
                  }
                }
              },
              modules : {
                layout : {
                  id : 'sap.viz.modules.layout.stack'
                },
                legend : {
                  id : 'sap.viz.modules.legend.common',
                  data : { aa : [ 2 ] },
                  configure : {
                    propertyCategory : 'legend',
                    properties : {
                      layout : {
                        position : 'top',
                        priority : 0
                      }
                    }
                  }
                }
              }
            },
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : { orientation : 'left' }
              }
            },
            
            layout : {
              id : 'sap.viz.modules.layout.dock'
            },
            
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  //supportedEventNames: ['mouseup', 'mousemove', 'touchstart'],
                  selectability: {
                    mode: 'multiple',
                    lassoWithCtrlKey: true
                  },
                  preserveSelectionWhenDragging: true
                }
              }
            },
            
            rotate : {
              id : 'sap.viz.modules.controller.rotate',
              configure : {
                clientID : 'main',
                propertyCategory: 'rotate'
              }
            },
            
            main : {
              id : 'sap.viz.modules.xyzcontainer',
              modules : {
                plot : {
                  id : 'sap.viz.modules.bar3d',
                  configure : {
                    'description' : 'Settings regarding the chart area and plot area as well as general chart options.',
                    propertyCategory : 'plotArea',
                    properties : { direction : direction }
                  }
                },
                
                zAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    'description' : 'Settings for the category axis of an XYZ chart.',
                    propertyCategory : 'zAxis',
                    properties : {
                      type : 'category',
                      position : 'bottom',
                      forceVerticalFont : true,
                      gridline : {
                        visible : false
                      },
                      shapeRendering : false,
                      isIndependentMode : true
                    },
                propertiesOverride : {
                          gridline : { isExported : false },
                          axisline: { isExported : false }
                        }
                  }
                },
    
                background : {
                  id : 'sap.viz.modules.background',
                  configure : {
                    propertyCategory : 'background',
                    properties : {
                      direction : direction
                    }
                  }
                }
              },
              
              configure : {
                propertyCategory : 'xyzcontainer',
                properties : {
                  xAngle : 20, 
                  yAngle : 50,
                  layout : {
                    position : 'center',
                    priority : 10
                  }
                }
              }
            }
          }
        }
      },
      
      dependencies : {
        attributes : [{
          targetModule : 'root.main',
          target : categoryAxis ,
          sourceModule : 'root.main.plot',
          source : 'primaryCategoryScale'
        }, {
          targetModule : 'root.main',
          target : valueAxis,
          sourceModule : 'root.main.plot',
          source : 'valueScale'
        },{
          targetModule : 'root.main.' + valueAxis,
          target : 'scale',
          sourceModule : 'root.main',
          source : valueAxis
        }, {
          targetModule : 'root.main.' + categoryAxis,
          target : 'scale',
          sourceModule : 'root.main',
          source : categoryAxis
        },{
          targetModule : 'root.main',
          target : 'zAxis',
          sourceModule : 'root.main.plot',
          source : 'secondaryCategoryScale'
        }, {
          targetModule : 'root.main.zAxis',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'zAxis'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
          targetModule : 'root.main.zAxis',
          target : 'independentData',
          sourceModule : 'root.main.plot',
          source : 'secondaryCategoryData'
        },{
        targetModule : 'root.main.'+categoryAxis,
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'primaryCategoryData'
      }, {
          targetModule : 'root.main.'+valueAxis,
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'valueScaleTitle'
      } ],
        events : [ {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'root.rotate',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.rotate'
        }, {
          targetModule : 'root.main',
          listener : isVertical? 'xAxisScaleChange': 'yAxisScaleChange',
          sourceModule : 'root.main.plot',
          type : 'primaryCategoryScaleChange.xyzcontainer'
        },{
          targetModule : 'root.main',
          listener : isVertical? 'yAxisScaleChange': 'xAxisScaleChange',
          sourceModule : 'root.main.plot',
          type : 'valueScaleChange.xyzcontainer'
        },{
          targetModule : 'root.main',
          listener : 'zAxisScaleChange',
          sourceModule : 'root.main.plot',
          type : 'secondaryCategoryScaleChange.xyzcontainer'
        },{
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip.tooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip.tooltip'
        },{
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }]
      }
    };

    var modules = chart.modules.root.modules.main.modules;

    modules[categoryAxis] = {
      id : 'sap.viz.modules.axis',
      data : {
        aa : [ 1 ]
      },
      configure : {
        'description' : 'Settings for the value axis of an XYZ chart.',
        propertyCategory : categoryAxis,
        properties : {
          type : 'category',
          isIndependentMode : true,
          position : isVertical ? 'bottom' : 'left',
          forceVerticalFont : (isVertical ? true : undefined),
          gridline : {
            visible : false,
            showFirstLine: (isVertical ? false : true),
            showLastLine: (isVertical ? false : true)
          },
          shapeRendering : false
        },
        propertiesOverride : {
          gridline : {
            isExported : false
          },
          label : {
            isExported : false
          },
          axisline : {
            isExported : false
          }
        }
      }
    };

    modules[valueAxis] = {
      id : 'sap.viz.modules.axis',
      configure : {
        'description' : 'Settings for the category axis of an XYZ chart.',
        propertyCategory : valueAxis,
        properties : {
          type : 'value',
          position : (isVertical ? 'left' : 'bottom'),
          forceVerticalFont : (isVertical ? undefined : true),
          shapeRendering : false,
          gridline : {
              showFirstLine: (isVertical ? true : false),
              showLastLine: (isVertical ? true : false)
          }
        },
        propertiesOverride : {
            gridline : {
              isExported : false
            }
        }
      }
    };

    Manifest.register(chart);
  };
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xyz.Bar3DChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.xyz.Base3DChart',
  version : '4.0.2'
}
],
function Setup(fn) {
  fn("horizontal");
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xyz.Column3DChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.xyz.Base3DChart',
  version : '4.0.2'
}
],
function Setup(fn) {
  fn("vertical");
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.layout.Dock',
  version : '4.0.2'
}
],
function Setup ( Manifest ) {
    var chart = {
      id : 'riv/basehorizontalchart',
      name : 'IDS_BASEHORIZONTALCHART',
     'abstract' : true,
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          configure : { propertyCategory : 'general' },
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart']
                }
              }
            },
            
            layout : {
              id : 'sap.viz.modules.layout.dock'
            },

            title : {
              id : 'sap.viz.modules.title',
              configure : {
                propertyCategory : 'title',
                properties : {
                  layout : {
                    position : 'top',
                    priority : 0
                  }
                }
              }
            },
            
            legends : {
              id : 'sap.viz.modules.legend',
              configure : {
                propertyCategory : 'legendGroup',
                properties : {
                  layout : {
                    position : 'right',
                    priority : 1
                  }
                }
              },
              
              modules : {
                legend : {
                  id : 'sap.viz.modules.legend.common',
                  data : { aa : [ 2 ] },
                  configure : {
                    propertyCategory : 'legend',
                    properties : {
                      layout : { order : 0 }
                    }
                  }
                },
                
                layout : {
                  id : 'sap.viz.modules.layout.stack'
                }
              }
            },
            
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : { chartType : 'bar', orientation : 'left' }
              }
            },
            
            main : {
              id : 'sap.viz.modules.xycontainer',
              configure : {
                propertyCategory : 'xyContainer',
                properties : {
                  layout : {
                    position : 'center',
                    priority : 3
                  }
                }
              },
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      paintingMode : 'rectCoordinate',
                      visible : false,
                      orientation : 'horizontal',
                      position : 'inside',
                      automaticInOutside : true,
                      showZero : true,
                      isStackMode : false,
                      isPercentMode : false,
                      outsideVisible : true,
                      outsidePosition : 'right'
                    }
                  }
                },
                
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                  'description': 'Settings for the value axis of an XY chart.',
                    propertyCategory : 'xAxis',
                    properties : { type : 'value', position : 'bottom' }
                  }
                },
    
                yAxis : {
                  id : 'sap.viz.modules.axis',
                  data : { aa : [ 1 ] },
                  configure : {
                  'description': 'Settings for the category axis of an XY chart.',
                    propertyCategory : 'yAxis',
                    properties : {
                      type : 'category',
                      position : 'left',
                      gridline : { visible : false }
                    },
                    propertiesOverride : {
                      gridline : { isExported : false },
                      label : { isExported : false },
                      axisline : { isExported : false }
                    }
                  }
                },
          
                background : {
                  id: 'sap.viz.modules.background',
                  configure : {
                    propertyCategory : 'background',
                    properties : { direction : 'horizontal' }
                  }
                },
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{ isExported: false },
                      secondaryValuesColorPalette: { isExported: false }
                    }
                  }
                }
              }
            }
          }
        }
      },
      
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        } ],
        events : [ {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        } ]
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalAreaChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_area',
    name : 'IDS_HORIZONTALAREACHART',
    base: 'riv/basehorizontalchart',
    modules : {
      root : {      
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left'
              }
            }
          },

          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    automaticInOutside : false,
                    outsidePosition  : 'left',
                    showZero : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.area',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  propertiesOverride: {
                    bStacked :true             
                  },
                  properties : {
                     orientation:'horizontal'
                  }
                }
              }
            }
          }
     
        }
      }
    },
    feeds:{
      secondaryValues:null
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.xAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'root.main.xAxis',
      target : 'title',
      sourceModule : 'root.main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageHorizontalAreaChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalAreaChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_horizontal_area',
    name : 'IDS_PERCENTAGEHORIZONTALAREACHART',
    base: 'viz/horizontal_area',
    
    modules : {  
      root : {
        modules : {
           main : {    
              'modules' : {
                plot : {
                  
                  configure : {
                    properties: {
                      mode : "percentage"
                    }
                  }
                },
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                  'description': 'Settings for the value axis of an XY chart.',
                    propertyCategory : 'xAxis',
                    properties : {
                      isPercentMode : true
                    }
                  }
                },
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode: true
                    }
                  }
                }
              }
            },
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'horizontalline',
                  orientation : 'left',
                  formatString: [["0.00%"],["0.00%"]]
                }
              }
          }
           
        }
      }

    }   
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.legend.Common',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.layout.Dock',
  version : '4.0.2'
}
],
function Setup ( Manifest ) {
    var chart = {
      id : 'riv/baseverticalchart',
      name : 'IDS_BASEVERTICALCHART',
      'abstract' : true,
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          configure : {
            propertyCategory : 'general',
            properties : {
              layout : {
                padding : 24,
                vgap : 8,
                hgap : 8
              }
            }
          },
          modules : {
            layout : {
              id : 'sap.viz.modules.layout.dock'
            },
            
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousedown', 'mousemove', 'mouseover', 'mouseout', 'touchstart']
                }
              }
            },          
            title : {
              id : 'sap.viz.modules.title',
              configure : {
                propertyCategory : 'title',
                properties : {
                  layout : {
                    position : 'top',
                    priority : 0
                  }
                }
              }
            },
            
            legends : {
              id : 'sap.viz.modules.legend',
              configure : {
                propertyCategory : 'legendGroup',
                properties : {
                  layout : {
                    position : 'right',
                    priority : 1
                  }
                }
              },
              modules : {
                layout : {
                  id : 'sap.viz.modules.layout.stack'
                },
                legend : {
                  id : 'sap.viz.modules.legend.common',
                  data : {
                      aa : [ 2 ]
                  },
                  configure : {
                    propertyCategory : 'legend',
                    properties : {
                      layout : {
                        order : 0
                      }
                    }
                  }
                }
              }
            },
            
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'verticalbar',
                  orientation : 'left'
                }
              }
            },
            main : {
              id : 'sap.viz.modules.xycontainer',
              configure : {
                properties : {
                  layout : {
                    position : 'center',
                    priority : 5
                  }
                }
              },
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      paintingMode : 'rectCoordinate',
                      visible : false,
                      orientation : 'vertical',
                      position : 'inside',
                      automaticInOutside : true,
                      showZero : true,
                      isStackMode : false,
                      isPercentMode : false,
                      outsideVisible : true,
                      outsidePosition : 'up'
                    }
                  }
                },
                yAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                  'description': 'Settings for the value axis of an XY chart.',
                   propertyCategory : 'yAxis',
                    properties : {
                      type : 'value',
                      position : 'left'
                    }
                  }
                },
    
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  data : {
                      aa : [ 1 ]
                  },
                  configure : {
                  'description': 'Settings for the category axis of an XY chart.',
                    propertyCategory : 'xAxis',
                    properties : {
                      type : 'category',
                      position : 'bottom',
                      gridline : { visible : false }
                    },
                    propertiesOverride : {
                      gridline : { isExported : false },
                      label : { isExported : false },
                      axisline : { isExported : false }
                    }
                  }
                },
          
                background : {
                  id: 'sap.viz.modules.background',
                  configure : {
                    propertyCategory : 'background',
                    properties : { direction : 'vertical' }
                  }
                },
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{ isExported: false },
                      secondaryValuesColorPalette: { isExported: false }
                    }
                  }
                }
              }
            }
          }
        }
      },
      
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        } ],
         events : [ {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        } ]
      }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.AreaChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Area',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/area',
    name : 'IDS_AREACHART',
    base: 'riv/baseverticalchart',
    
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : { properties : { chartType : 'line', orientation : 'left' } }
          },

          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    automaticInOutside : false,
                    outsidePosition : 'down',
                    showZero : false
                  },
                  propertiesOverride:{
                    position : { isExported : false }
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.area',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  propertiesOverride: { bStacked :true }
                }
              }
            }
          }
        }
      }
    },
    
    feeds:{ secondaryValues: null },
    
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.yAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'root.main.yAxis',
      target : 'title',
      sourceModule : 'root.main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
    }
  };
  
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageAreaChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.AreaChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_area',
    name : 'IDS_PERCENTAGEAREACHART',
    base: 'viz/area',
    
    modules : {
      root : {
        modules : {
          main : {    
            'modules' : {
              plot : {
                configure : {
                  properties: {
                    mode : "percentage"
                  }
                }
              },
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                'description': 'Settings for the value axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    isPercentMode : true
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    isPercentMode: true
                  }
                }
              }
            }
          },
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'line',
                orientation : 'left',
                formatString: [["0.00%"],["0.00%"]]
              }
            }
          }
        }
      }
    }   
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.mekko',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
}
],
function Setup(TypeUtils, ObjectUtils, dispatch, MNDHandler,tooltipDataHandler, ColorSeries, Scaler, ObjectUtils, NumberUtils,Objects, langManager, BoundUtil, defaultSelUtil, UADetector) {
 var mekko = function(manifest, ctx) {
	  var CLASSMARKERSELECTED = "v-datapoint-selected",
          CLASSMARKERHOVER = "v-datapoint-hover",
          CLASSDATAPOINT = "v-datapoint";
      var CSSCLASS_HOVERLINE = 'v-hovershadow';
      var data,
          data1 = [[]],
          data2 = [[]],
          seriesData , tooltipData = [], //in stacked chart the value in tooltip is the same with data in seriesData, but in percentage chart it use the absolute value of negative data.
          primaryAxisTopBoundary = 0,
          primaryAxisBottomBoundary = 0,
          secondaryAxisTopBoundary = 0,
          secondaryAxisBottomBoundary = 0,
          gWrapper = null;
      
      var defaultString = langManager.get('IDS_ISNOVALUE');
      
      var width, 
          height,
          x = 0, y = 0,
          colorPalette = [],
          axis1ColorPalette,
          shapePalette = ['squareWithRadius'],
          properties,
          eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
      var style = {};
                
      var effectManager = ctx.effectManager;
      
      var categoryScale = d3.scale.ordinal(),
          valueScale = d3.scale.linear();
      categoryScale.noEqual = true;
      
      var decorativeShape = null,
          lastHovered = null;
        
      var barNumber = 1,
          barGroupNumber,
          barNumberinGroup,
          barHeight,
          positiveIndexes = [], 
          negativeIndexes = [];
        
      var enableDataLoadingAnimation = true,
          enableDataUpdatingAnimation = true,
          enableResizingAnimation = true, // control resizing animation
          enableRoundCorner = false,
          clipEdge = true,
          hasDefaultSelection = false,
          hasMNDonCategoryAxis = false,
          isOnlyInitAnimation = false,
          tooltipVisible = true,
          totalIntervalTime = 1000;
      
      var defsEnter = null, 
          roundCornerDefs = null,
          suffix = ObjectUtils.guid();
      
      var mode = 'comparison'; // bar display mode
      
      var drawingEffect = 'normal';
      
      var sizeChange = false, dataStructureChange = false, dataValueChange = false,modeChange = false;
    
      var dimensionData = {
          'sap.viz.modules.mekko.dimension':{
            key: 'sap.viz.modules.mekko.dimension',
            values : [{
              col: {val:''},
              rows: []
            }]
          }
      };
      
      var rangeBounds = [], rangeSumForScale = [],rangeSumForValue = [];

      var isHorizontal = true, afterAttachToDOM = false;
      
      //@Alex Su, judge whether we should enable animation
      
      function enableAnimation(){
        var hasAnmation = false;
        if(!isOnlyInitAnimation){
          hasAnmation = enableDataLoadingAnimation;
        }else if(dataStructureChange || dataValueChange){
          hasAnmation = enableDataUpdatingAnimation;
        }else if(sizeChange){
          hasAnmation = enableResizingAnimation;
        }
        return hasAnmation;
      }
      
      var parseOptions = function(){
          if(mode !== properties.mode){
            modeChange = true;
          }
          mode = properties.mode === 'percentage'? 'percentage': 'comparison';
          isHorizontal = properties.orientation === 'horizontal'? true: false;
          enableRoundCorner = properties.isRoundCorner;
          enableDataLoadingAnimation =  properties.animation.dataLoading; 
          enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
          enableResizingAnimation = properties.animation.resizing;
          tooltipVisible = properties.tooltip.enabled;      
    
          axis1ColorPalette = properties.colorPalette;
          
          drawingEffect = properties.drawingEffect;
          
          colorPalette = [];
          var i,j;
      
          for(i=0 ; i < seriesData[0].length; i++){
              for(j=0; j < seriesData[0][0].length; j++){
               colorPalette.push(axis1ColorPalette[j % axis1ColorPalette.length]);
              }
            }           
        };
        
        function chart(selection){
            BoundUtil.drawBound(selection, width, height);
            //deal with percentage mode
            if(mode === 'percentage'){
              turnToPercentage();
              

            }
            if(mode ==='comparison'){
              turnToComparison();
              
            }
            //if there is no scale, do not need to draw anything.
            if(!TypeUtils.isExist(valueScale)) {
              return;
            }
            eDispatch.startToInit();
            selection.each(function(){
              
            barNumber = (TypeUtils.isExist(data2)) ? 2 : 1;
            barHeight = 8 * (categoryScale.rangeBand()) / (9*barNumber +7 );
            
            barNumberinGroup = seriesData[0][0].length + ((TypeUtils.isExist(seriesData[0][1])) ? seriesData[0][1].length : 0);
          
          var barGroupNumber = seriesData.length;
            var svg = (gWrapper = d3.select(this));
            //append decorativeShape
              if(decorativeShape === null){
                decorativeShape = svg.append('rect').attr('visibility', 'hidden').attr('fill', style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE);
                if(isHorizontal){
                  decorativeShape.attr('width', width).attr('height', categoryScale.rangeBand() - barHeight/2);
                }
                else{
                  decorativeShape.attr('width', categoryScale.rangeBand() - barHeight/2).attr('height',height);
                }
              }else{
                if(isHorizontal){
                  decorativeShape.attr('width', width).attr('height', categoryScale.rangeBand() - barHeight/2).attr('visibility', 'hidden');
                }
                else{
                  decorativeShape.attr('width', categoryScale.rangeBand() - barHeight/2).attr('height', height).attr('visibility', 'hidden');
                
                }
              }
              
              if(defsEnter === null){
              defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
            }else{
              defsEnter.attr('width', width).attr('height', height);
            }  
              
            if(roundCornerDefs === null){      
              roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + suffix);
            }else{
              if( dataStructureChange || sizeChange || dataValueChange  || !enableRoundCorner){
                roundCornerDefs.selectAll(".v-clippath").remove();
              }
            }    
            
            
            var datashapesgroup = svg.selectAll('g.v-datashapesgroup');
            if(!TypeUtils.isExist(datashapesgroup[0][0])){
              datashapesgroup = svg.append('g').attr('class', 'v-datashapesgroup');
            }
            
            var barGroup;
            if(enableAnimation()){
                barGroup = datashapesgroup.selectAll('g.v-bar').data(seriesData);       
                barGroup.enter().append('g');
                
                barGroup.attr('class','v-bar').each( function (perGroupData,i) {
            var barHeightInitial = isHorizontal? 8 * (rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i]) / (9*barNumberinGroup +7 ):8 * (rangeBounds[i+1]- rangeBounds[i]) / (9*barNumberinGroup +7 );
            
            //2012-12-31 for roundcorner by yuanhao.
            var barFinalHeight = isHorizontal? rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] : rangeBounds[i+1]- rangeBounds[i];
            if( barFinalHeight > 1){
              barFinalHeight = barFinalHeight - 1;
            }
            var r = Math.log(barFinalHeight)/Math.log(2);
            if( r < 0 ){
              enableRoundCorner = false;
            } 
            var axisGroup = d3.select(this).selectAll('g.v-axisGroup').data(perGroupData);     
                    axisGroup.enter().append('g');
                    axisGroup.attr('class','v-axisGroup').each( function (perAxisData,j) {  
                      // This is for dual axis
                      
                      var fillingColor = axis1ColorPalette ;
                      var startPoint = barHeight /2;
                      var initStartPoint = categoryScale(i);

                      // This is for pos/neg values.
                      var positiveX = 0, negativeX = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                      var yArray = [],xArray = [];
                      // wrap a datashape g for each rect
                      var barShape = d3.select(this).selectAll('g.v-datashape').data(perAxisData);
                          barShape.enter().append('g').attr('class','v-datashape')

                          barShape.each(function(d){
                            var bar = d3.select(this).selectAll('rect').data([d]);
                            bar.enter().append('rect');
                            bar.exit().remove();
                          });
                          barShape.exit().remove();

                          if(afterAttachToDOM){
                            barShape.each(function(){
                              if(TypeUtils.isExist(this.getTransformToElement(this.parentNode))){
                                xArray.push(this.getTransformToElement(this.parentNode).e);
                                yArray.push(this.getTransformToElement(this.parentNode).f);
                              }else{
                                xArray.push(0);
                                yArray.push(0);
                              }

                            });
                          }
                          //transform for datashape
                          barShape.attr('transform', function (perRectData, k){
                            if(isHorizontal){
                              var y = height - rangeBounds[barGroupNumber - i - 1] ;
                              
                              var x;
                              if(perRectData.val >= 0){
                                
                                positiveX = valueScale(positiveStackedValue);
                                positiveStackedValue += perRectData.val;
                                x = positiveX;
                               }else{
                                negativeStackedValue += perRectData.val;
                                negativeX = valueScale(negativeStackedValue);
                               
                                x = negativeX;
                               }
                            }
                            //for vertical valueScale has been reversed.
                            else{
                              var x = rangeBounds[i];

                              var y ;
                              if(perRectData.val >= 0){
                                positiveStackedValue += perRectData.val;
                                positiveY = valueScale(positiveStackedValue);
                                
                                y = positiveY;
                               }else{
                                
                                negativeY = valueScale(negativeStackedValue);
                                negativeStackedValue += perRectData.val;
                                y = negativeY;
                               }
                            }
                             return 'translate('+x+','+y+')';
                          });

                      var bar = d3.select(this).selectAll('rect');
                        
                        bar.attr('fill', function(d,colorIndex){  
                          d.fillColor = fillingColor[colorIndex % fillingColor.length];
                          var parameter = {
                              drawingEffect:drawingEffect,
                              fillColor : d.fillColor,
                              direction : isHorizontal?'vertical': 'horizontal'
                          };
                          return effectManager.register(parameter);
                        }).attr('class', 'v-datapoint').attr('fill-opacity', 1).attr('stroke','none');
                      
                      //If data structure change or data value change, we should do animation from beginning.
                      if(dataStructureChange){
                        if(isHorizontal){
                          bar.attr('height', barHeightInitial).attr('y', function (perRectData, m) {
                              return  barHeightInitial*m;
                             })
                             .attr('x', 0)
                             .attr('width', 0);
                           
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            var rcFunction = function(){bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var roudCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                                                .append('rect').attr('class', 'v-roundCorner-clip')
                                                                .attr('rx', r).attr('ry', r).attr('y', this.y.baseVal.value)
                                                                .attr('height', barHeightInitial).attr('width', 0)
                                                                .attr('x', this.x.baseVal.value)
                                                                .transition().duration(totalIntervalTime/2)
                                                                .attr('x',function(){
                                                                  if(indexinGroup === negativeIndexes[j][i] ){
                                                                    return 0;
                                                                  }else{
                                                                    return 0 -r;
                                                                  }
                                                                })
                                                                .attr('width',function(){
                                                                  return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                                })
                                                                .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                                                .attr('height', barFinalHeight).attr('y', 0);
                                return 'url(#' + id + ')';
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }

                           negativeStackedValue = 0;
                           bar.transition().duration(totalIntervalTime/2).attr('width', function(perRectData, m){
                            return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                          }).attr('x', 0)
                            .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2).attr('height',function(perRectData , m){
                              var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                              if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                              }else{
                                return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                              }})
                            .attr('y', 0)
                            .attr('width', function(perRectData, m){
                              return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                            })
                            .each('end', function(perRectData, m){
                              if(i === 0 && m === barNumberinGroup - 1){
                                initialized();
                              }
                            });
                        }
                        else{
                          bar.attr('width', barHeightInitial).attr('x', function (perRectData, m) {
                              return  barHeightInitial*m;
                             })
                             .attr('y', function(perRectData, m){
                              return Math.abs(valueScale(perRectData.val) - valueScale(0));
                             })
                             .attr('height', 0);
                           
                           //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            var rcFunction = function() {bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var roudCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                                                .append('rect').attr('class', 'v-roundCorner-clip')
                                                                .attr('rx', r).attr('ry', r).attr('y', this.y.baseVal.value)
                                                                .attr('width', barHeightInitial).attr('height', 0)
                                                                .attr('x', this.x.baseVal.value)
                                                                .transition().duration(totalIntervalTime/2)
                                                                .attr('y',function(){
                                                                  if(indexinGroup === negativeIndexes[j][i] ){
                                                                    return 0 -r;
                                                                  }else{
                                                                    return 0;
                                                                  }
                                                                })
                                                                .attr('height',function(){
                                                                  return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                                })
                                                                .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                                                .attr('width', barFinalHeight).attr('x', 0);
                                return 'url(#' + id + ')';
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }

                           negativeStackedValue = 0;
                           bar.transition().duration(totalIntervalTime/2).attr('height', function(perRectData, m){
                            return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                          }).attr('y', 0)
                            .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2).attr('width',function(perRectData , m){
                              var w = rangeBounds[i + 1]- rangeBounds[i];
                              if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                              }else{
                                return rangeBounds[i + 1]- rangeBounds[i];
                              }})
                            .attr('x', 0)
                            .attr('height', function(perRectData, m){
                              return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                            })
                            .each('end', function(perRectData, m){
                              if(i === 0 && m === barNumberinGroup - 1){
                                initialized();
                              }
                            });
                        }
                      }
                      //if datavalue change , we need put the x,y,width ,height to last postion
                      else if( dataValueChange){
                        bar.attr('x',function(d,k){
                          return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                        })
                        .attr('y',function(d,k){
                          return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                        });
                        var barTransition = bar.transition();
                        if(isHorizontal){
                          barTransition.duration(totalIntervalTime/2)
                          .attr('width', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                           .attr('x', 0)
                          .attr('height',function(perRectData , m){
                            var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                            }else{
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            }
                          })
                          .attr('y', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                           var rcFunction = function(){ barTransition.attr('clip-path', function(perRectData, indexinGroup){                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var x = parseFloat(this.x.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                          .append('rect').attr('class', 'v-roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                          .attr('x', function(){
                                            return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                          })
                                          .attr('y',this.y.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('x',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0;
                                            }else{
                                              return 0 - r;
                                            }
                                          })
                                          .attr('width', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('height',barFinalHeight).attr('y',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }
                        }
                        else{
                          barTransition.duration(totalIntervalTime/2)
                          .attr('height', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                           .attr('y', 0)
                          .attr('width',function(perRectData , m){
                            var w = rangeBounds[i + 1]- rangeBounds[i];
                            if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                            }else{
                              return rangeBounds[i + 1]- rangeBounds[i];
                            }
                          })
                          .attr('x', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            var rcFunction = function(){ barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var y = parseFloat(this.y.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                          .append('rect').attr('class', 'v-roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('width',this.width.baseVal.value).attr('height', this.height.baseVal.value + r)
                                          .attr('y', function(){
                                            return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                          })
                                          .attr('x',this.x.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('y',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0 - r;
                                            }else{
                                              return 0 ;
                                            }
                                          })
                                          .attr('height', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('width',barFinalHeight).attr('x',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }
                        }
                      }
                      //if plot container size change, we should update x, y, width, height of bar rects.
                      //The behavour of value change is not same as bar's, in mekko, it also has to change
                      //x, y, width, height of bar rects.
                      else if(sizeChange){
                        if(isHorizontal){
                          bar.attr('x',function(d,k){
                            return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                          })
                          .attr('width', function(perRectData){
                           var newWidth = Math.abs(valueScale(perRectData.val) - valueScale(0));
                           if(parseFloat(this.width.baseVal.value) > newWidth){
                             return this.width.baseVal.value;
                           }else{
                             return newWidth;
                           }
                          });
                          var barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime/2)
                          .attr('width', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                          .attr('x', 0)
                          .attr('height',function(perRectData , m){
                            var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                            }else{
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            }
                          })
                          .attr('y', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            var rcFunction = function() {barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var x = parseFloat(this.x.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                          .append('rect').attr('class', 'v-roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                          .attr('x', function(){
                                            return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                          })
                                          .attr('y',this.y.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('x',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0;
                                            }else{
                                              return 0 - r;
                                            }
                                          })
                                          .attr('width', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('height',barFinalHeight).attr('y',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }
                        }
                        else{
                          bar.attr('y',function(d,k){
                            return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                          })
                          .attr('height', function(perRectData){
                           var newHeight = Math.abs(valueScale(perRectData.val) - valueScale(0));
                           if(parseFloat(this.height.baseVal.value) > newHeight){
                             return this.height.baseVal.value;
                           }else{
                             return newHeight;
                           }
                          });
                          var barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime/2)
                          .attr('height', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                          .attr('y', 0)
                          .attr('width',function(perRectData , m){
                            var w = rangeBounds[i + 1]- rangeBounds[i];
                            if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                            }else{
                              return rangeBounds[i + 1]- rangeBounds[i];
                            }
                          })
                          .attr('x', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            var rcFunction = function() {barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var y = parseFloat(this.y.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                          .append('rect').attr('class', 'v-roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('width',this.width.baseVal.value).attr('height', this.height.baseVal.value + r)
                                          .attr('y', function(){
                                            return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                          })
                                          .attr('x',this.x.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('y',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0 - r;
                                            }else{
                                              return 0 ;
                                            }
                                          })
                                          .attr('height', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('width',barFinalHeight).attr('x',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }
                        }
                      }
                      //if modeChange we just adjust the x of bar to last postion
                      else if(modeChange){
                        if(isHorizontal){
                          bar.attr('x',function(d,k){
                          return xArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).e;
                          });
                          var barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime/2)
                          .attr('width', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                           .attr('x', 0)
                          .attr('height',function(perRectData , m){
                            var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                            }else{
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            }
                          })
                          .attr('y', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            var rcFunction = function () {barTransition.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var x = parseFloat(this.x.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                          .append('rect').attr('class', 'v-roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                          .attr('x', function(){
                                            return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                          })
                                          .attr('y',this.y.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('x',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0;
                                            }else{
                                              return 0 - r;
                                            }
                                          })
                                          .attr('width', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('height',barFinalHeight).attr('y',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }
                        }
                        else{
                          bar.attr('y',function(d,k){
                          return yArray[k] - this.parentNode.getTransformToElement(this.parentNode.parentNode).f;
                          });
                          var barTransition = bar.transition();
                          barTransition.duration(totalIntervalTime/2)
                          .attr('height', function(perRectData, m){
                             return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                           .attr('y', 0)
                          .attr('width',function(perRectData , m){
                            var w = rangeBounds[i + 1]- rangeBounds[i];
                            if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                            }else{
                              return rangeBounds[i + 1]- rangeBounds[i];
                            }
                          })
                          .attr('x', 0)
                          .each('end', function(perRectData, m){
                            if(i === 0 && m === barNumberinGroup - 1){
                              initialized();
                            }
                          });
                          //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                           var rcFunction = function(){ barTransition.attr('clip-path', function(perRectData, indexinGroup){                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var y = parseFloat(this.y.baseVal.value) ;
                                var roundCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                          .append('rect').attr('class', 'v-roundCorner-clip')
                                          .attr('rx', r).attr('ry', r).attr('width',this.width.baseVal.value).attr('height', this.height.baseVal.value + r)
                                          .attr('y', function(){
                                            return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                          })
                                          .attr('x',this.x.baseVal.value)
                                          .transition().duration(totalIntervalTime/2)
                                          .attr('y',function(){
                                            if(indexinGroup === negativeIndexes[j][i]){
                                              return 0 - r;
                                            }else{
                                              return 0 ;
                                            }
                                          })
                                          .attr('height', function(){
                                             return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                          })
                                          .attr('width',barFinalHeight).attr('x',0);  
                                return 'url(#' + id + ')' ;
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }
                        }
                      } else if (enableRoundCorner){
                        if (isHorizontal){
                         var rcFunction = function(){ bar.attr('clip-path', function(perRectData, indexinGroup){
                            if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var roudCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")                                                              .append('rect').attr('class', 'v-roundCorner-clip')
                                                              .attr('rx', r).attr('ry', r)
                                                              .attr('x',function(){
                                                                if(indexinGroup === negativeIndexes[j][i] ){
                                                                  return 0;
                                                                }else{
                                                                  return 0 -r;
                                                                }
                                                              })
                                                              .attr('width',function(){
                                                                return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                              })
                                                              .attr('height', barFinalHeight).attr('y', 0);
                              return 'url(#' + id + ')';
                            }
                            if(i === 0 && indexinGroup === barNumberinGroup - 1){
                              initialized();
                            }
                          }); };
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }                         
                        } else {
                         var rcFunction = function(){  bar.attr('clip-path', function(perRectData, indexinGroup){
                            if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var roudCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")                                                              .append('rect').attr('class', 'v-roundCorner-clip')
                                                              .attr('rx', r).attr('ry', r)
                                                              .attr('y',function(){
                                                                if(indexinGroup === negativeIndexes[j][i] ){
                                                                  return 0 - r;
                                                                }else{
                                                                  return 0 ;
                                                                }
                                                              })
                                                              .attr('height',function(){
                                                                return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                              })
                                                              .attr('width', barFinalHeight).attr('x', 0);
                              return 'url(#' + id + ')';
                            }
                            if(i === 0 && indexinGroup === barNumberinGroup - 1){
                              initialized();
                            }
                          });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          
                        }
                      }
                      
                      //bar.exit().remove();  //Nick                
                    });
                  axisGroup.exit().remove();
                });
                barGroup.exit().remove();
              }else{
                barGroup = datashapesgroup.selectAll('g.v-bar').data(seriesData);     
                barGroup.enter().append('g');
                barGroup.attr('class','v-bar').each( function (perGroupData,i) {
                var barFinalHeight = isHorizontal? rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] : rangeBounds[i+1]- rangeBounds[i];
                if( barFinalHeight > 1){
                  barFinalHeight = barFinalHeight - 1;
                }
                var r = Math.log(barFinalHeight)/Math.log(2);
                if( r < 0 ){
                  enableRoundCorner = false;
                } 
                var axisGroup = d3.select(this).selectAll('g.v-axisGroup').data(perGroupData);     
                  axisGroup.enter().append('g');
                  axisGroup.attr('class','v-axisGroup').each( function (perAxisData,j) {
                    
                    
                    var fillingColor =  axis1ColorPalette;
                    var positiveX = 0, negativeX = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                    var positiveIndex = 0, negativeIndex = -1;
                    var yArray = [] ,xArray = [];
                    
                    // wrap a datashape g for each rect
                    var barShape = d3.select(this).selectAll('g.v-datashape').data(perAxisData);
                        barShape.enter().append('g').attr('class','v-datashape')
                        barShape.each(function(d){
                          var bar = d3.select(this).selectAll('rect').data([d]);
                          bar.enter().append('rect');
                          bar.exit().remove();
                        });
                        barShape.exit().remove();

                        
                        //transform for datashape
                        barShape.attr('transform', function (perRectData, k){
                            if(isHorizontal){
                              var y = height - rangeBounds[barGroupNumber - i - 1] ;
                              
                              var x;
                              if(perRectData.val >= 0){
                                
                                positiveX = valueScale(positiveStackedValue);
                                positiveStackedValue += perRectData.val;
                                x = positiveX;
                               }else{
                                negativeStackedValue += perRectData.val;
                                negativeX = valueScale(negativeStackedValue);
                               
                                x = negativeX;
                               }
                            }
                            //for vertical valueScale has been reversed.
                            else{
                              var x = rangeBounds[i];

                              var y ;
                              if(perRectData.val >= 0){
                                positiveStackedValue += perRectData.val;
                                positiveY = valueScale(positiveStackedValue);
                                
                                y = positiveY;
                               }else{
                                
                                negativeY = valueScale(negativeStackedValue);
                                negativeStackedValue += perRectData.val;
                                y = negativeY;
                               }
                            }
                             return 'translate('+x+','+y+')';
                          });
                        var bar = d3.select(this).selectAll('rect');
                    
                        if(isHorizontal){
                          bar.attr('width', function(perRectData, m){
                           return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                          .attr('x', 0)
                          .attr('height',function(perRectData , m){
                            var h = rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            if(h > 1){
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i] - 1;
                            }else{
                              return rangeBounds[barGroupNumber - i -1]- rangeBounds[barGroupNumber - i];
                            }})
                          .attr('y', 0)
                          .attr('fill', function(d,colorIndex){  
                            d.fillColor = fillingColor[colorIndex % fillingColor.length];
                            var parameter = {
                              drawingEffect:drawingEffect,
                              fillColor : d.fillColor,
                              direction : 'vertical'
                            };
                          return effectManager.register(parameter);
                           })
                           .attr('class', 'v-datapoint').attr('fill-opacity', 1);
                            //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                           var rcFunction = function(){ bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var roudCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                                                .append('rect').attr('class', 'v-roundCorner-clip')
                                                                .attr('rx', r).attr('ry', r)
                                                                .attr('x',function(){
                                                                  if(indexinGroup === negativeIndexes[j][i] ){
                                                                    return 0;
                                                                  }else{
                                                                    return 0 -r;
                                                                  }
                                                                })
                                                                .attr('width',function(){
                                                                  return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                                })
                                                                .attr('height', barFinalHeight).attr('y', 0);
                                return 'url(#' + id + ')';
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }

                         }
                         else{
                          bar.attr('height', function(perRectData, m){
                           return Math.abs(valueScale(perRectData.val) -  valueScale(0));
                           })
                          .attr('x', 0)
                          .attr('width',function(perRectData , m){
                            var w = rangeBounds[i + 1]- rangeBounds[i];
                            if(w > 1){
                              return rangeBounds[i + 1]- rangeBounds[i] - 1;
                            }else{
                              return rangeBounds[i + 1]- rangeBounds[i];
                            }
                          })
                          .attr('y', 0)
                          .attr('fill', function(d,colorIndex){  
                            d.fillColor = fillingColor[colorIndex % fillingColor.length];
                            var parameter = {
                              drawingEffect:drawingEffect,
                              fillColor : d.fillColor,
                              direction : 'horizontal'
                            };
                          return effectManager.register(parameter);
                           })
                           .attr('class', 'v-datapoint').attr('fill-opacity', 1);
                            //2012-12-31 by yuanhao for roundcorner
                          if(enableRoundCorner){
                            var rcFunction = function () {bar.attr('clip-path', function(perRectData, indexinGroup){
                              if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                                var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                                var roudCorner = roundCornerDefs.append('clipPath').attr('id', id).attr("class", "v-clippath")
                                                                .append('rect').attr('class', 'v-roundCorner-clip')
                                                                .attr('rx', r).attr('ry', r)
                                                                .attr('y',function(){
                                                                  if(indexinGroup === negativeIndexes[j][i] ){
                                                                    return 0 - r;
                                                                  }else{
                                                                    return 0 ;
                                                                  }
                                                                })
                                                                .attr('height',function(){
                                                                  return Math.abs(valueScale(perRectData.val) -  valueScale(0)) + r;
                                                                })
                                                                .attr('width', barFinalHeight).attr('x', 0);
                                return 'url(#' + id + ')';
                              }
                            });};
                           if(UADetector.isSafari() && UADetector.os === "Windows"){
                              window.setTimeout(rcFunction, 0);
                            } else{
                              rcFunction();
                            }
                          }
                          }
                      });
                    axisGroup.exit().remove();
                  });        
                barGroup.exit().remove();
                initialized();
            }
            
            });
            
            sizeChange = false, dataValueChange = false, dataStructureChange = false;
            isOnlyInitAnimation = true;
            return chart;
          }
        
        chart.hoverOnPoint = function(point){
          var xOnModule = point.x, yOnModule = point.y;
          // find the closet dimension
          var i = 0, len = rangeBounds.length -1, currentBound = 0;
          if(isHorizontal){
            while (i < len ) {
              if (yOnModule >= (height - rangeBounds[i]) && yOnModule < (height - rangeBounds[i+1])) {
                currentBound = rangeBounds[i] - rangeBounds[i+1];
                break;
              };
              i++;
            }
          }else{
            while (i < len ) {
              if (xOnModule >= (rangeBounds[i]) && xOnModule < (rangeBounds[i+1])) {
                currentBound = rangeBounds[i+1] - rangeBounds[i];
                break;
              };
              i++;
            }
          }
          if (i > (seriesData.length - 1) || i < 0) {
            decorativeShape.attr(
                'visibility', 'hidden');
            return;
          }
          
          if(isHorizontal){
            decorativeShape.attr(
              'y', height - rangeBounds[i]).attr(
              'visibility', 'visible').attr('height', currentBound);
          }else{
            decorativeShape.attr(
              'x', rangeBounds[i]).attr(
              'visibility', 'visible').attr('width', currentBound);
          }
          if(i !== lastHovered){
            if (tooltipVisible) {
              lastHovered = i;
              //this.parentNode.parentNode.parentNode point to the main container
              var transform = gWrapper[0][0].getTransformToElement(gWrapper[0][0].ownerSVGElement);
              var yoffset = transform.f;
              var xoffset = transform.e;
              var tData = isHorizontal? generateTooltipData(barGroupNumber - i -1): generateTooltipData(i);
              
              tData.point = {
                  x: isHorizontal? point.x : rangeBounds[i] + currentBound/2 + xoffset,
                  y: isHorizontal? height - rangeBounds[i] + currentBound/2 + yoffset: point.y
              };
              tData.plotArea = {
                x : transform.e,
                y : transform.f,
                width : width,
                height : height
              };
              tData.valueAxis0Count = seriesData[0][0].length;
              tData.valueAxis1Count = TypeUtils.isExist(seriesData[0][1]) ? seriesData[0][1].length:0;
              eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
            }
          }
        };
        
        var generateTooltipData = function(aai1){
        var tData = {
          'body' : [],
          'footer' : []
        };
        var a0data = data.getAnalysisAxisDataByIdx(0).values;

        var g0data = data.getMeasureValuesGroupDataByIdx(0).values;
        var g1data = data.getMeasureValuesGroupDataByIdx(1).values;
        // have two analysis
        if( TypeUtils.isExist(data.getAnalysisAxisDataByIdx(1)) ){
          var a1data = data.getAnalysisAxisDataByIdx(1).values;
        }
        //make up body data
        var elemcount = tooltipData[0][0].length;
        
        for(var i = 0, ilen = g0data.length; i < ilen; i++){
          var tbody = {}, rows = [];
          tbody.name = g0data[i].col;
          tbody.val = rows;
          for(var j = 0; j < elemcount; j++){
            var label = '';
            if(TypeUtils.isExist(a1data)){
              for(var t = 0, tlen = a1data.length;  t < tlen; t++){
                if(t === 0){
                  label += a1data[t].rows[j].val;
                }else{
                  label += ' / ' + a1data[t].rows[j].val;
                }
                
              }
            }
            rows.push({
              value: tooltipData[aai1][0][j].isNaN ? defaultString : tooltipData[aai1][0][j].val,  
              label: label,
              shape: 'squareWithRadius',
              color: colorPalette[j]
            });
          }
          
          tData.body.push(tbody);
        }


      //make up body data
        //from d1data
        var tbody = {}, rows = [];
        tbody.name = g1data[0].col;
        tbody.val = rows;
        rows.push({
          value:TypeUtils.isExist( rangeSum[aai1] ) ? rangeSum[aai1] : defaultString,
          valueAxis: 1
        });
        tData.body.push(tbody);
      
      //from a0data
      for(var i =0, len = a0data.length; i < len; i++){
        var footer = {};
        footer.label = a0data[i].col.val;
        footer.value = a0data[i].rows[aai1].val;
        
        tData.footer.push(footer);
      }
        
      return tData;
      };
        


        chart.blurOut = function(){
          decorativeShape.attr('visibility', 'hidden');
          lastHovered = null;
          if (tooltipVisible) {      
            eDispatch.hideTooltip();
          }
        };
        
        chart.parent = function(){
          return gWrapper;
        };
        
        chart.highlight = function(elems){
          if(elems instanceof Array){
            for(var i = 0, len = elems.length; i < len; i++){
              elems[i].setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
              elems[i].setAttribute('fill-opacity', 1);
              if(!enableRoundCorner){
                  elems[i].setAttribute('stroke', '#333333');
              }
            }
          }else{
        	elems.setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
            elems.setAttribute('fill-opacity', 1);
            if(!enableRoundCorner){
                elems.setAttribute('stroke', '#333333');
            }
          }
          
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(gWrapper, true, elems);
          }
          
        };
        
        chart.unhighlight = function(elems){
          if(elems instanceof Array){
            for(var i = 0, len = elems.length; i < len; i++){
              elems[i].setAttribute('class',CLASSDATAPOINT);
              elems[i].setAttribute('fill-opacity', 0.4);
              elems[i].setAttribute('stroke','none');
            }
          }else{
        	elems.setAttribute('class',CLASSDATAPOINT);
            elems.setAttribute('fill-opacity', 0.4);
            elems.setAttribute('stroke','none');
          }
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(gWrapper, false, elems);
          }
          
        };
        
        chart.clear = function(gray){
          if( gray == null || gray == false){
            var rects = gWrapper.selectAll('.v-datapoint');
            rects.attr('fill-opacity', 1).attr('stroke','none').attr('class',CLASSDATAPOINT);
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(gWrapper, false, rects);
            }
          }else{
            gWrapper.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke','none').attr('class',CLASSDATAPOINT);
          }
        };
        
          function turnToPercentage(){
            for(var i=0, len = seriesData.length; i < len; i++){
              for(var j=0 , rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++){
                var sum = 0, avaCount = 0, k;
                for(k=0; k < rowSeriesData[j].length; k++){
                  sum += Math.abs(rowSeriesData[j][k].val);
                  if(!rowSeriesData[j][k].isNaN) {
                    avaCount++;
                  }
                }
                if(sum === 0){

                  for(k=0; k < rowSeriesData[j].length; k++){
                          rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                          rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                          if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                            rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                          }
                  }
                }else{
                  for(k=0; k < rowSeriesData[j].length; k++){
                        if(rowSeriesData[j][k].val < 0){
                          rowSeriesData[j][k].isNegative = true;
                        }
                        rowSeriesData[j][k].value = TypeUtils.isExist(rowSeriesData[j][k].value) ? rowSeriesData[j][k].value : rowSeriesData[j][k].val;
                        rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
                        }
                  }
                }
                
              }
            }
        }
        function turnToComparison(){
          var obj = ObjectUtils.extend(true, {}, MNDHandler(data));
                   
          var _data1 = obj["MG1"];
          var _data2 = obj["MG2"];
          measureOnAxis1 = obj.MG1Number;
          tooltipData = [];
          
          var _seriesData = dataHandler(_data1, _data2, obj.color);
           
          
          seriesData = _seriesData;
          data1 = _data1;
          data2 = _data2;
          
          tooltipData = ObjectUtils.extend(true, {}, seriesData); 
        }

        function initialized(){
            eDispatch.initialized();
            afterAttachToDOM = true;

        }
        
        chart.afterUIComponentAppear = function(){
          eDispatch.initialized(); 
        };
        
        
        
        /**
        * set/get width
        */
        chart.width = function(value){
            if (!arguments.length){
              return width;
            }
            sizeChange = (width === value)&&!sizeChange? false:true;
            width = value;
        
            makeScales();
          
            return chart;
        };

        /**
        * set/get height
        */
        chart.height = function(value){
          if (!arguments.length){
            return height;
           }
          sizeChange = (height === value)&&!sizeChange? false:true;
          height = value;
        
            makeScales();
          
           return chart;        
        };
        /**
         * set/get data, for some modules like Title, it doesn't need data
         */
        chart.data = function(value){
          if (!arguments.length){
            return data;
          }

          data = value;
          var obj = ObjectUtils.extend(true, {}, MNDHandler(data));
                   
          var _data1 = obj["MG1"];
          var _data2 = obj["MG2"];
          measureOnAxis1 = obj.MG1Number;
          tooltipData = [];
          if( _data1[0] && _data1[0][0].info && _data1[0][0].info.defaultSelection){
            hasDefaultSelection = true;
          }else{
            hasDefaultSelection = false;
          }
          var _seriesData = dataHandler(_data1, _data2, obj.color);
          
          if(data1.length !== _data1.length || data1[0].length !== _data1[0].length){
              dataStructureChange = true;
          }else{
            dataValueChange = true;
          }
          
          seriesData = _seriesData;
          data1 = _data1;
          data2 = _data2;
          
      tooltipData = ObjectUtils.extend(true, {}, seriesData); 
          
          
        
      makeScales();
          
        
        parseOptions();
        
        return chart;        
      };


      /**
       * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
            return properties;
         }
         
          Objects.extend(true, properties, props);
          parseOptions();
          
          makeScales();
          
          return chart;        
      };
         
      //adjust domain and rangebouds, for all no_value or zero value
      var adjustScale = function( rangeBounds){
        for(var i = 0; i< rangeBounds.length ;i++){
          if(!NumberUtils.isNoValue(rangeBounds[i]) && rangeBounds[i] != 0 )
            return;
        }

        for(var i = 1; i< rangeBounds.length ;i++){
            rangeBounds[i] = i*(isHorizontal? height / (rangeBounds.length -1) : width /(rangeBounds.length -1));
        }
      }
      var makeScales = function(){
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
            var domain = [], total = 0, tempsum = 0;
            rangeBounds = [], rangeSum = [],  rangeBounds[0] = 0;
            var rows = dimensionData['sap.viz.modules.mekko.dimension'].values[0].rows = [];
            dimensionData['sap.viz.modules.mekko.dimension'].values[0].col.val = data.getMeasureValuesGroupDataByIdx(1).values[0].col;
            for (var i=0, len = data2.length; i < len; i++){
              for(var j = 0; j< data2[i].length; j++){
                
                if(TypeUtils.isExist(rangeSum[j])){
                  rangeSum[j] += data2[i][j].val;
                }
                else{
                  rangeSum[j] = data2[i][j].val;
                }
              }
            }
            for (var i = 0 ,len = rangeSum.length; i < len; i++){
              domain.push(i);
              total += rangeSum[i] > 0? rangeSum[i] : (0 - rangeSum[i]);
            }  
            for(var j =0, len = rangeSum.length; tempsum += Math.abs(rangeSum[j]), j<len; j++){
              tempsum = parseFloat(tempsum.toFixed(8));
              rangeBounds[j+1] = total==0? null : Math.abs(isHorizontal? tempsum/total*height : tempsum/total*width);
              rows.push({
                val : TypeUtils.isExist( rangeSum[j] ) ? rangeSum[j] : defaultString
              });
            }
            //adjust domain and rangebouds, for all no_value or zero value
            adjustScale(rangeBounds);
            //if is horizontal we need to reverse the categoryScale, otherwise we need to reverse the valueScale
            if(isHorizontal){
              
              categoryScale.domain(domain).range(rangeBounds.reverse());
              if(mode === 'percentage'){                
                valueScale.domain([0,1]).range([0, width]).nice();
                Scaler.perfect(valueScale);
              }else{
                //when all data is 0 or null, we make domain (0,1)
                if( primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
                  valueScale.domain([0,1]).range([0, width]).nice();
                }else{
                  valueScale.domain([primaryAxisBottomBoundary,primaryAxisTopBoundary]).range([0, width]).nice();
                }
                Scaler.perfect(valueScale);
              }
            }else{
              categoryScale.domain(domain).range(rangeBounds);
              if(mode === 'percentage'){
                valueScale.domain([1,0]).range([0, height]).nice();
                Scaler.perfect(valueScale);
              }else{
                if( primaryAxisBottomBoundary === 0 && primaryAxisTopBoundary === 0){
                  valueScale.domain([1, 0]).range([0, height]).nice();                 
                }else{
                  valueScale.domain([primaryAxisTopBoundary, primaryAxisBottomBoundary]).range([0, height]).nice();
                }
                Scaler.perfect(valueScale);
              }
            }
          }
        
        };

      chart.colorPalette = function(Palette){
          if (!arguments.length){
            return colorPalette;
         }
          colorPalette = Palette;
         return chart;        
      };

      chart.categoryScale = function(scale){
          if (!arguments.length){
            return categoryScale;
         }
          categoryScale = scale;
         return chart;
      };
      
      chart.dimensionData = function(_){
        if(!arguments.length){
          return dimensionData;
        }
        dimensionData = _;
        return chart;
      };
      
      chart.secondCategoryScale = function(){
        if(!arguments.length){
          return categoryScale;
        }
        categoryScale = _;
        return chart;
      };
      
      chart.primaryDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = primaryAxisBottomBoundary < 0 ? primaryAxisBottomBoundary : 0;
            maxt = primaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        primaryAxisTopBoundary = range.max;
        primaryAxisBottomBoundary = range.min;
        
        makeScales();
        
        return chart;
      };
        
      chart.secondDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = secondaryAxisBottomBoundary< 0 ? secondaryAxisBottomBoundary : 0 ;
            maxt = secondaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        secondaryAxisTopBoundary = range.max;
        secondaryAxisBottomBoundary = range.min;
        
        makeScales();
        
        return chart;
      }; 
         
      chart.primaryScale = function(scale){
          if (!arguments.length){
            return valueScale;
         }
          valueScale = scale;
         return chart;
      };       

        chart.primaryAxisColor = function(){
            //as in mekko, it does not has MND feed, so always return undefined.
            return undefined;
        };        
          
        /**
        * get preferred size
        * @return {
            'width': NUMBER,
            'height' : NUMBER
          }
        */
        chart.getPreferredSize = function(){
          
        };
       
        chart.x = function(_){
          if(!arguments.length){
            return x;
          }
          x= _;
          return this;
        };
        
        chart.y = function(_){
          if(!arguments.length){
            return y;
          }
          y = _;
          return this;
        };
        
        chart.dispatch = function(_){
          if(!arguments.length){
            return eDispatch;
          }
          eDispatch = _;
          return this;
        };
        
        chart.dataLabel = function(_){};
        
        chart.primaryAxisTitle = function(_){
          if(!arguments.length){
            var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
            if(titles){
              for(var i=0, len =titles.values.length; i< len;i++ ){
                  if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                  {
                      title.push(titles.values[i].col);
                  }
                  else
                  {
                      title.push(langManager.get('IDS_ISNOVALUE'));
                  }
              }
            }
            return title.join('/');
          }
          return this;
        };
        
        chart.secondAxisTitle = function(_){
          if(!arguments.length){
            var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
            if(titles){
              for(var i=0, len =titles.values.length; i< len;i++ ){
                  if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                  {
                      title.push(titles.values[i].col);
                  }
                  else
                  {
                      title.push(langManager.get('IDS_ISNOVALUE'));
                  }
              }
            }
            return title.join('/');
          }
          return this;
        };
        
        var mergeA1A2Info = function(a1Info, a2Info)
        {            
            if(a2Info && a2Info.defaultSelection)
            {
                if(a2Info.defaultSelection.isSelected)
                {
                    var tempSelObj = Objects.extend(true, {}, a2Info.defaultSelection);
                    a1Info.defaultSelection = tempSelObj;
                }
            }
        };

        var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){

          var i;
          var j;

          if(valueAxis2Data)
          {
              for(i = 0; i < valueAxis1Data.length; i++)
              {
                  if(valueAxis2Data[i])
                  {
                      for(j = 0; j < valueAxis1Data[i].length; j++)
                      {
                          mergeA1A2Info(valueAxis1Data[i][j].info, valueAxis2Data[i][j].info); 
                      }
                  }
              }
          }

          mergeA1A2Info(valueAxis1Data, valueAxis2Data);
          
          var positiveIndex = -1, negativeIndex = -1;
          positiveIndexes = [[],[]], negativeIndexes = [[],[]];
        
          primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
          secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
          
          var stackedBarGroupsData = [];
          // the number of bar in each group
          barGroupNumber =  valueAxis1Data[0].length;

          var temp, temp2;
          for(j=0; j < barGroupNumber; j++){
            var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
            var oneGroupDataSet = [];
            temp = 0, temp2 = 0;
            positiveIndex = -1, negativeIndex = -1;
            for(i=0; i< valueAxis1Data.length; i++){
              if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
                valueAxis1Data[i][j].val = 0;
                valueAxis1Data[i][j].isNaN = true;
              }else{

                if(valueAxis1Data[i][j].val >= 0){
                  temp += valueAxis1Data[i][j].val;
                  positiveIndex = i;
                }else{
                  temp2 += valueAxis1Data[i][j].val;
                  negativeIndex = i;
                }
              }
            tempDataSetAxis1.push(valueAxis1Data[i][j]);
          }
          positiveIndexes[0].push(positiveIndex);
          negativeIndexes[0].push(negativeIndex);
          
          if(primaryAxisTopBoundary < temp){
            primaryAxisTopBoundary = temp;
          }
          if(primaryAxisBottomBoundary > temp2){
            primaryAxisBottomBoundary = temp2;
          }
          oneGroupDataSet.push(tempDataSetAxis1);
          
          stackedBarGroupsData.push(oneGroupDataSet);
        }
          
          return stackedBarGroupsData;
        };

        function getCSSStyle() {
          style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
        }

        getCSSStyle();
        properties = manifest.props(null);
        return chart;
    };
    return mekko;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Mekko',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.mekko',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
	/**
	 * Mekko chart's feed defination is similar with bar chart. It accept a dimension axis and two measure value axis like dual bar chart.
	 */
  var module = {
    'id' : 'sap.viz.modules.mekko',
    'name' : 'mekko',
    base : "sap.viz.modules.xy.bar.base",
    'properties' : {
    	'mode' : {
            'name' : 'mode',
            'supportedValueType' : 'List',
            'supportedValues' : [ 'comparison', 'percentage' ],
            'defaultValue' : 'comparison',
            'description' : 'Set dispaly mode of mekko chart.'
          },
          'orientation' : {
            'name' : 'orientation',
            'supportedValueType' : 'List',
            'supportedValues' : [ 'vertical', 'horizontal' ],
            'defaultValue' : 'horizontal',
            'description' : 'vertical or horizontal mekko chart.'
          },
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/bar',
      name : 'IDS_BARCHART',
      base : 'riv/basehorizontalchart',
      modules : {
        root : {
          id : 'sap.viz.modules.rootContainer',
          modules : {
            main : {
              modules : {
                plot : {
                  id : 'sap.viz.modules.bar',
                  configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                    propertyCategory : 'plotArea'
                  }
                }
              }
            }
          }
        }
      },
      
      feeds : { secondaryValues:  null },
      
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
        events : [ {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, 
        {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        },{
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }]
      }      
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalMekkoChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Mekko',
  version : '4.0.2'
}
],
function Setup ( Manifest,Constants ) {
  var chart = {
    id : 'viz/horizontal_mekko',
    name : 'IDS_HORIZONTALMEKKOCHART',
    base : 'viz/bar',
    modules : {
      root : {
        modules : {
          main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      showZero : false
                    },
                    propertiesOverride:{
                      position : {
                        isExported : false
                      }
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                          isExported: false
                        }
                     }
                  }
                },
                xAxis:{
                      id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                },
                yAxis : {
                   id : 'sap.viz.modules.axis',
                   configure : {
                     properties:{
                       type : 'category',
                             position : 'left',
                             label:{
                               hideStrategy : 'greedy'
                             }
                     }
                   }
                },
                yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'yAxis2',
                        properties : {
                          isIndependentMode : true,
                            type : 'category',
                            position : 'right',
                            gridline : {
                                visible : false
                            },                          
                            label:{
                              hideStrategy : 'greedy'
                            }
                  
                        },
                        propertiesOverride:{
                          gridline: {
                              isExported: false
                            },
                            axisline: {
                              isExported: false
                            },
                            label:{
                              numberFormat:{
                                isExported: false
                              }
                            }
                         }
                    }
                }
         
              }
          },
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'mekko',
                orientation : 'left'
              }
            }
        }
        }
      }      
    },
    feeds:{
    secondaryValues: {
      min : 1,
      max : 1
    },
    primaryValues : {
       min : 1,
         max : 1
    },
    regionColor :{
      min: 0,
      max: 1,
      acceptMND: -1
    },
    axisLabels :{
      min: 1,
      max: 1,
      acceptMND: -1
    }
    },
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.yAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondCategoryScale'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'root.main.xAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    }, {
      targetModule : 'root.main.yAxis2',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'secondAxisTitle'
    },{
        targetModule : 'root.main.yAxis2',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
    }, {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageHorizontalMekkoChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalMekkoChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_horizontal_mekko',
    name : 'IDS_PERCENTAGEHORIZONTALMEKKOCHART',
    base : 'viz/horizontal_mekko',
      modules : {
        root : {
          modules : {
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'mekko',
                  formatString: [["0.00%"],[""]]
                }
              }
          },
          main : {
              modules : {
                dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode: true
                      }
                    }
                  },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        mode: 'percentage'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                            isExported: false
                          }
                     }
                  }
                },
                xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  }
              }
            }
          }
        }
      }
    };


  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/column',
      name : 'IDS_VERTICALBARCHART',
      base : 'riv/baseverticalchart',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                plot : {
                    id : 'sap.viz.modules.verticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
          }
          }
        }
         
      },
      feeds:{
        secondaryValues:  null
      },
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'root.main.yAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
        } ],
         events : [ 
         {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
            targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
      }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.MekkoChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Mekko',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/mekko',
    name : 'IDS_MEKKOCHART',
    base : 'viz/column',
    modules : {
      root : {
        modules : {
          main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      showZero : false
                    },
                    propertiesOverride:{
                      position : {
                        isExported : false
                      }
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        orientation: 'vertical'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                        
                        mode: {
                          isExported: false
                        },
                        orientation: {
                          isExported: false
                        }
                     }
                  }
                },
                yAxis:{
                      id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                      properties:{
                        position : 'left'
                      }
                    }
                },
                xAxis : {
                   id : 'sap.viz.modules.axis',
                   configure : {
                     properties:{
                       type : 'category',
                             position : 'bottom',
                             label:{
                               hideStrategy : 'greedy'
                             }
                     }
                   }
                },
                xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'xAxis2',
                        properties : {
                          isIndependentMode : true,
                            type : 'category',
                            position : 'top',
                            gridline : {
                                visible : false
                            },                          
                            label:{
                              hideStrategy : 'greedy'
                            }
                  
                        },
                        propertiesOverride:{
                          gridline: {
                              isExported: false
                            },
                            axisline: {
                              isExported: false
                            },
                            label:{
                              numberFormat:{
                                isExported: false
                              }
                            }
                         }
                    }
                }
         
              }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'mekko',
                  orientation : 'bottom'
                }
              }
          }
        }
      }
    },
    feeds:{
    secondaryValues: {
      min : 1,
      max : 1
    },
    primaryValues : {
       min : 1,
         max : 1
    },
    regionColor :{
      min: 0,
      max: 1,
      acceptMND: -1
    },
    axisLabels :{
      min: 1,
      max: 1,
      acceptMND: -1
    }
    },
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondCategoryScale'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'root.main.yAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    }, {
      targetModule : 'root.main.xAxis2',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'secondAxisTitle'
    },{
        targetModule : 'root.main.xAxis2',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
    }, {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageMekkoChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.MekkoChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/100_mekko',
    name : 'IDS_PERCENTAGEMEKKOCHART',
    base : 'viz/mekko',
      modules : {
        root : {
          modules : {
             tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  formatString: [["0.00%"],[""]]
                }
              }
          },
          main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    propertyCategory : 'dataLabel',
                    properties : {
                      isPercentMode: true
                    }
                  }
                },
                plot: {
                  id : 'sap.viz.modules.mekko',
                  configure: {
                    propertyCategory : 'plotArea',
                    properties : {
                        mode: 'percentage'
                      },
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: false
                        },
                       
                        mode: {
                          isExported: false
                        },
                        orientation: {
                            isExported: false
                          }
                     }
                  }
                },
                yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  }
              }
            }
          }
        }
      }
    };


  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalboxplot',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, Scaler, NumberUtils,tooltipDataHandler,Objects, langManager, BoundUtil, defaultSelUtil) {
  var boxplot = function(manifest, ctx) {
    var CSSCLASS_HOVERLINE = 'v-hovershadow';
    var sWrapper = null, 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
    var  dimensions = {
        'sap.viz.modules.horizontalboxplot.dimension' : {
                'key' : 'sap.viz.modules.horizontalboxplot.dimension',
                'values' : null
        }
      };

    var width,
      height, 
      yScale = d3.scale.ordinal(),
      xScale = d3.scale.linear(),
      yDimensionScale = d3.scale.ordinal(),
      decorativeShape,
      boxWidth,
      boxHeight,
      lastHovered = null,
      tooltipVisible = true,
      hasDefaultSelection = false,
      scaleMinMax = {
          min: 0,
          max: 0
      },
      effectManager = ctx.effectManager,
      drawingEffect = 'normal';
    
    var _properties = {}, eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    var style = {};
    var outLierLayout = {
      width : '1',
      color : '#000000'
    };

    var quartileLayout = {
      width: '0',
      midLineColor: '#000000'
    };
    
    var lowOutLiersObj = [], highOutLiersObj = [], whiskersObj = [], lowWhiskerObj = [], highWhiskerObj = [], quartilesObj = [], outLiersObj = [];
    var keysArray = ['Maximum:', '3rd Quartile:', 'Median:', '1st Quartile:', 'Minimum:'], noValueStr = 'No value';
    
    var makeScales = function() {
      var domain = [];
      for ( var i = 0; i < seriesData.length; i++) {
        domain.push(i);
      }
      yScale.domain(domain).rangeBands([0, height]);
      yDimensionScale.domain(dimensionDomain).rangeBands([0, height]); 
      //when all data is 0 or null, we make xScale.domain(0,1)
      if(!scaleMinMax || ( scaleMinMax.min === 0 && scaleMinMax.max === 0)){
        xScale.domain([ 0, 1 ]).range([ 0, width]).nice();
      }else{
        xScale.domain([ scaleMinMax.min, scaleMinMax.max ]).range([ 0, width]).nice();        
      }   
      Scaler.perfect(xScale);

    };
    chart.dimensionData = function(_)
    {
      if (!arguments.length){
        return dimensions;
      }
      dimensions = _;
      return chart;    
    };
    
    function locateBoundary(data) {
      
      if (TypeUtils.isExist(data)) {
        length = data.length;
        var firstLoop = false;
        for (var i = 0; i < length; i++) {
          
          if (data[i].length > 0) {
            if (!firstLoop) {
              scaleMinMax = findMinMax(data[i]);
              firstLoop = true;
            } else {
              var tmp = findMinMax(data[i]);
              if (tmp) {
                if (tmp.min < scaleMinMax.min) {
                  scaleMinMax.min = tmp.min;
                }
                if (tmp.max > scaleMinMax.max) {
                  scaleMinMax.max = tmp.max;
                }
              }
              
            }
          }
        }
      }
      
    }
    
    function findMinMax(range) {
      var minMax = {min:0, max:0};
      if (TypeUtils.isExist(range)) {
        range.sort( function(aObj, bObj) { return aObj.val - bObj.val; });
        
        minMax = {min: range[0].val, max: range[range.length - 1].val};
      }
      return minMax;
    }

    function clearBoxData() {
      lowOutLiersObj = [];
      highOutLiersObj = [];
      whiskersObj = [];
      lowWhiskerObj = [];
      highWhiskerObj = [];
      quartilesObj = [];
      outLiersObj = [];
    }
    
    function clearGlobalData() {
      dimensionGroup = []; 
      dimensionDomain = []; 
      seriesData = []; 
      legendData = []; 
      regionData = []; 
      dimensionData = []; 
      boxplotData = []; 
    }

    function even(n) {
      return (n & 1) == 0;
    }

    function median(distribution, start, end) {
      var n = end - start + 1;
      if (n <= 0)
        return -1;

      var ret;
      var ctxValue = distribution[start + Math.floor((n + 1) / 2) - 1].ctx;
      var infoValue = distribution[start + Math.floor((n + 1) / 2) - 1].info;

      if (even(n)) {
        ret = (distribution[start + Math.floor((n + 1) / 2) - 1].val + distribution[start
            + Math.floor((n + 1) / 2)].val) / 2;
      } else {
        ret = distribution[start + Math.floor((n + 1) / 2) - 1].val;
      }
      return {
        'ctx' : ctxValue,
        'info': infoValue,
        'val' : ret
      };
    }

    function setDistribution(distribution) {

      if (distribution && distribution.length > 0) {
        var n = distribution.length,
          box = {
            'Maximum:': null,
            '3rd Quartile:': null,
            'Median:': null,
            '1st Quartile:': null,
            'Minimum:': null  
          };
        
            midLine = median(distribution,  0,  n - 1);
            box['Median:'] = midLine;
            
          // Q1 is the median of the first half of the set; we add the median to
            // it if the whole set length is even
            var bak = distribution[Math.floor(n / 2)];
            distribution[Math.floor(n / 2)] = midLine;
            var boxBottom = median(distribution, 0, Math.floor(n / 2));
            distribution[Math.floor(n / 2)] = bak;
            
            // Q3 is the median of the second half of the set; we add the median to
            // it if the whole set length is even
            bak = distribution[Math.floor((n - 1) / 2)];
            distribution[Math.floor((n - 1) / 2)] = midLine;
            var boxTop  = median(distribution, Math.floor((n - 1) / 2), n - 1);
            distribution[Math.floor((n - 1) / 2)] = bak;
            box['3rd Quartile:'] = boxTop;
            box['1st Quartile:'] = boxBottom;
            
        // inter-quartile range
        var iqr = boxTop.val - boxBottom.val;
        // lower adjacent limit
        var lal = boxBottom.val - 1.5 * iqr;
        // upper adjacent limit
        var ual = boxTop.val + 1.5 * iqr;

        // search for the lowest non outlier
        var i = 0;
        while (distribution[i].val < lal)
          i++;
        lowWhisker = distribution[i];
        box['Minimum:'] = lowWhisker;

        if (lowWhisker) {
          if (boxBottom) {
            if (boxBottom.val != lowWhisker.val) {
              lowWhiskerObj.push({
                'pair' : [boxBottom, lowWhisker],
                'ctx' : [boxBottom.ctx, lowWhisker.ctx],
                'val' : [boxBottom.val, lowWhisker.val],
                'info' : [boxBottom.info, lowWhisker.info],
              });
            }
          }
        }

        // low outliers are all the values lower than lowest non outlier
        for ( var k = 0; k < i; k++)
          outLiersObj.push(distribution[k]);

        // search for the largest non outlier
        var j = n - 1;
        while (distribution[j].val > ual)
          j--;
        highWhisker = distribution[j];
        box['Maximum:'] = highWhisker;

        for ( var k = 0; k < n - j - 1; k++)
          outLiersObj.push(distribution[j + 1 + k]);

        if (outLiersObj.length > 0)
          box['outLiers(s)'] = outLiersObj.length;
        // if (lowWhiskerObj.length == 1) {
        // whiskersObj.push(lowWhiskerObj[0]);
        // }

        // if (highWhiskerObj.length == 1) {
        // whiskersObj.push(highWhiskerObj[0]);
        // }

        if (highWhisker) {
          if (boxTop) {
            if (boxTop.val != highWhisker.val) {
              highWhiskerObj.push({
                'pair' : [highWhisker, boxTop],
                'ctx' : [highWhisker.ctx, boxTop.ctx],
                'val' : [highWhisker.val, boxTop.val],
                'info' : [highWhisker.info, boxTop.info]
              });
            }
          }
        }

        if (boxBottom && boxTop && midLine) {
          if (boxBottom.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxBottom, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],
              'info' : [boxBottom.info]
            });
          } else if (midLine.val == boxTop.val || midLine.val == boxBottom.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxTop.ctx, boxBottom.ctx],
              'val' : [boxTop.val, boxBottom.val],
              'info' : [boxBottom.info]
            });
          } else {
            quartilesObj.push({
              'pair' : [boxTop, midLine],
              'midLine': midLine,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val],
              'info' : [boxTop.info]
            });
            quartilesObj.push({
              'pair' : [midLine, boxBottom],
              'midLine': midLine,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],
              'info' : [boxBottom.info]
            });
          }
        }
        
        boxplotData.push(box);
      }
    }
      
    function chart(selection) { 
      BoundUtil.drawBound(selection, width, height);
      selection.each(function() {
          
        boxNumber = 1, boxGroupNumber = seriesData.length, boxHeight = 8 * (yScale.rangeBand()) / (9 * boxNumber + 7);
  
          var svg = sWrapper = d3.select(this);
          svg.selectAll('g.v-box').remove();
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', width).attr('height', yScale.rangeBand() - boxHeight/2).style('visibility', 'hidden').attr('fill', style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE);
          }else{
            decorativeShape.attr('width', width).attr('height', yScale.rangeBand() - boxHeight/2).style('visibility', 'hidden');
          }
          
          var boxGroup = svg.selectAll('g.v-box').data(seriesData);

          boxGroup.enter().append('g');
        boxGroup.attr('class', 'v-box').each( function(boxData, outerIndex) {
              
            if (boxData.length == 0) {
              boxplotData.push({});
              return;
            }
            
            boxData = boxData.sort(function(aObj, bObj) { return aObj.val - bObj.val; });
    
                var arrLength = boxData.length, min = boxData[0], max = boxData[arrLength - 1];
    
                setDistribution(boxData);
    
                var outLiersSelector = d3.select(this).selectAll('circle.outliers').data(outLiersObj);
                outLiersSelector.enter().append('circle');
                outLiersSelector.attr('cy', function(outLier) {
                  var y = yScale(outerIndex) + boxHeight;
                  return y;
                })
                .attr('cx', function(outLier, num) {
                  var x = xScale(outLier.val);
                  return x;
                })
                .attr('r', '2')
                //.attr('shape-rendering', 'crispEdges')
                .attr('stroke', effectManager.register(
                                                    {
                                                  drawingEffect : 'normal',
                                                  fillColor : outLierLayout.color
                                                  }
                                                      )
             )
                .attr('stroke-width', outLierLayout.width)
                .attr('fill', 'none')
                .attr('class', 'v-datapoint v-outliers');
                
                outLiersSelector.exit().remove();
    
                var quartileSelector = d3.select(this).selectAll('rect.quartile').data(quartilesObj);
                quartileSelector.enter().append('rect');
                quartileSelector.attr('y', function(quartile) {
                  var y = yScale(outerIndex) + boxHeight / 2;
                  return y;
                })
                .attr('x', function(quartile, num) {
                  var x = xScale(quartile.pair[1].val);
                  return x;
                })
                .attr('height', boxHeight)
                .attr('width', function(quartile, num) {
                  var width = 0;
                  var pairDiff = quartile.pair[0].val - quartile.pair[1].val;
                  if (pairDiff == 0) {
                    width = 1;
                  } else {
                    width = xScale(quartile.pair[0].val) - xScale(quartile.pair[1].val);
                  }
  
                  return width;
                })
                .attr('shape-rendering', 'crispEdges')
                .attr( 'fill', function(d){
                  var parameter = {
                      drawingEffect : drawingEffect,
                      fillColor : boxColorPalette[outerIndex % boxColorPalette.length],
                      direction : 'vertical'
                    };
            return effectManager.register(parameter);                
                })
                .attr('stroke-width', quartileLayout.width)
                //.attr('stroke', '#000000')
                .attr('class', 'v-datapoint v-quartile');
                
                if (quartilesObj.length == 2) {
                  var midLineYStart = yScale(outerIndex) + boxHeight / 2;
                  var midLineYEnd = midLineYStart + boxHeight;
                  var midLineXStart = midLineXEnd = xScale(quartilesObj[0].midLine.val);
                  var lineSelector = d3.select(this);
                  lineSelector.append('line')
                  .attr('x1', midLineXStart)
                  .attr('y1', midLineYStart)
                  .attr('x2', midLineXEnd)
                  .attr('y2', midLineYEnd)
                  .attr('stroke', '#ffffff')
                  .attr('stroke-width', 1)
                  .attr('shape-rendering', 'crispEdges')
                  .attr('class', 'v-midline');
                }
                
                quartileSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.v-rectlowwhisker').data(lowWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector.attr('y', function(whisker) {
                  var y = yScale(outerIndex) + boxHeight / 2;
                  horizontalLineYStart = horizontalLineYEnd = y + boxHeight / 2 ;
                  verticalLineYStart = y;
                  verticalLineYEnd = y + boxHeight;
                  return y;
                  })
                  .attr('x', function(whisker) {
                    var x = xScale(whisker.pair[1].val);
                    horizontalLineXStart = x;
                    verticalLineXStart = verticalLineXEnd = x;
                    return x;
                   })
                  .attr('height', boxHeight)
                    .attr('width', function(whisker) {
                      var width = xScale(whisker.pair[0].val) - xScale(whisker.pair[1].val);
                      horizontalLineXEnd = xScale(whisker.pair[1].val) + width;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke', function(d){
                           var parameter = {
                                 drawingEffect : 'normal',
                                 fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                                };
                         return effectManager.register(parameter);  
                             }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-lineverticallowwhisker');
                    
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', horizontalLineXStart)
                    .attr('y1', horizontalLineYStart)
              .attr('x2', horizontalLineXEnd)
                    .attr('y2', horizontalLineYEnd)
                    .attr('stroke', effectManager.register(
                                            {
                                              drawingEffect : 'normal',
                                              fillColor : '#000000'
                                            }
                                          )
                               )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'v-linehorizontallowwhisker v-innerwhisker');
                    return width;
                    })
                .attr('shape-rendering', 'crispEdges')
                .attr('fill-opacity', '0')
                .attr('stroke-width', '0')
                .attr('class', 'v-datapoint v-rectlowwhisker');
                
                whiskerSelector.exit().remove();
                
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.v-recthighwhisker').data(highWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector
                    .attr('y', function(whisker) {
                      var y = yScale(outerIndex) + boxHeight / 2;
              horizontalLineYStart = horizontalLineYEnd = y + boxHeight / 2;
              verticalLineYStart = y;
              verticalLineYEnd = y + boxHeight;
                      return y;
                      })
                    .attr('x', function(whisker, num) {
                      var x = xScale(whisker.pair[1].val);
                    horizontalLineXStart = x;
                    verticalLineXStart = verticalLineXEnd = xScale(whisker.pair[0].val);
                      return x;
                      })
                    .attr('height', boxHeight)
                    .attr('width', function(whisker, num) {
                      var width = xScale(whisker.pair[0].val) - xScale(whisker.pair[1].val);
                      horizontalLineXEnd = xScale(whisker.pair[1].val) + width;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke',  function(d){
                              var parameter = {
                           drawingEffect : 'normal',
                           fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                          };
                              
                                    return effectManager.register(parameter);  
                                }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-lineverticalhighwhisker');
  
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', horizontalLineXStart)
                      .attr('y1', horizontalLineYStart)
                      .attr('x2', horizontalLineXEnd)
                      .attr('y2', horizontalLineYEnd)
                      .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-linehorizontalhighwhisker v-innerwhisker');
                       
                      return width;
                      })
                      .attr('shape-rendering', 'crispEdges')
                      .attr('fill-opacity', '0')
                      .attr('stroke-width', '0')
                      .attr('class', 'v-datapoint v-recthighwhisker');
                
                whiskerSelector.exit().remove();               
                clearBoxData();   
          });
          eDispatch.initialized();
          boxGroup.exit().remove();
      });
    return chart;
    };
  
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }
      
      width = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };
      
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };  
    
    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };
  
    function getTooltipData(index) {
      
      var tooltipData =  {
          'body': [],
          'footer': []
        },
        internalIndex = 0;
      
      if (regionData) {

        var body = {
          'name': null,
          'val': []
        };
        
        internalIndex = index % regionData.length;
        body.name = regionData[internalIndex].name;
  
        if (regionData[internalIndex].label != null && regionData[internalIndex].shape != null && boxColorPalette[internalIndex] != null) {
          var item = {
              'shape': null,
              'color': null,
              'label': null,
              'value': null
            };
          
          item.shape = regionData[internalIndex].shape;
          item.color = boxColorPalette[internalIndex];
          item.label = regionData[internalIndex].label;
          body.val.push(item);
        }
        
        if (boxplotData) {
          
          if (boxplotData[index]) {
            var hasData = false;
            for (var i in boxplotData[index]) {
              var item = {
                  'shape': null,
                  'color': null,
                  'label': null,
                  'value': null
                };
              hasData = true;
              item.label = i;
              if (boxplotData[index][i]) {
                if (i == 'outLiers(s)') {
                  item.value = boxplotData[index][i];
                } else {
                  item.value = boxplotData[index][i].val;
                }
              }
              body.val.push(item);
            }
            
            if (!hasData) {
              for (var j = 0; j < keysArray.length; j++) {
                var item = {};
                item.label = keysArray[j];
                item.value = noValueStr;
                item.color = null;
                item.shape = null;
                body.val.push(item);
              }
            }
          }
        }
        
        tooltipData.body.push(body);
      }
      
      if (dimensionData) {
        internalIndex = Math.floor(index / regionData.length);
        for (var i = 0; i < dimensionData.length; i++) {
          
          if (dimensionData[i].rows.length > 0) {
            var footer = {
                'label': null,
                'value': null
              };
            footer.label = dimensionData[i].col;
            footer.value = dimensionData[i].rows[internalIndex];
            
            tooltipData.footer.push(footer);
          }
        }
      }
      
      return tooltipData;
    }
    
    function generateTooltipData() {
      
      if (dimensions) {
        for (var i in dimensions) {
          dimensionData = dimensions[i].values;
        }
      }
      
      if (legendData) {
        var legendList = legendData.values;
        if (legendList.length > 1) {
          if (legendList[0].type == 'MND') {
            //mnd scan
            for (var mndIndex = 0; mndIndex < legendList[0].rows.length; mndIndex++) {

              //vertical scan
              for (var m = 0; m < legendList[1].rows.length; m++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.name = legendList[0].rows[mndIndex];
                var label = [];
                
                //horizontal scan
                for (var n = 1; n < legendList.length; n++) {
                  label.push(legendList[n].rows[m]);
                }
                legendObj.label = label;
                regionData.push(legendObj);
              }    

            }
          } else if (legendList[legendList.length - 1].type == 'MND') {

            for (var m = 0; m < legendList[0].rows.length; m++) {

              var label = [];
              for (var n = 0; n < legendList.length - 1; n++) {
                label.push(legendList[n].rows[m]);              
              }
              

              for (var mndIndex = 0; mndIndex < legendList[legendList.length - 1].rows.length; mndIndex++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.label = label;
                legendObj.name = legendList[legendList.length - 1].rows[mndIndex];
                regionData.push(legendObj);
              }
            }
          } 
        } else {
          for (var m = 0; m < legendList[0].rows.length; m++) {
            var legendObj = {
                'name': null,
                'shape': null,
                'color': null,
                'label': null
              };
            legendObj.name = legendList[0].rows[m];
            regionData.push(legendObj);
          }
        }
      }
      
      for (var k = 0; k < regionData.length; k++) {
        //regionData[k].color = boxColorPalette[k % boxColorPalette.length];
        regionData[k].shape = 'squareWithRadius';
      }
    }

    function setElementAttribute(element, attribute, value) {
      if (element) {
        var className = element.getAttribute('class');
        if(className.indexOf('v-recthighwhisker') == -1 && className.indexOf('v-rectlowwhisker') == -1
           && className.indexOf('v-linehorizontalhighwhisker') == -1 && className.indexOf('v-lineverticalhighwhisker') == -1
           && className.indexOf('v-linehorizontallowwhisker') == -1 && className.indexOf('v-lineverticallowwhisker') == -1) {
          element.setAttribute(attribute, value);
        }else if (className.indexOf('v-recthighwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('v-linehorizontalhighwhisker') != -1 || nodeClassName.indexOf('v-lineverticalhighwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }
        } else if(className.indexOf('v-rectlowwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('v-linehorizontallowwhisker') != -1 || nodeClassName.indexOf('v-lineverticallowwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }        
        }      
      }
    }
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, elemsLen = elems.length; i < elemsLen; i++) {
          var item = elems[i];
          setElementAttribute(item, 'opacity', 1);
          }
        }else{
        setElementAttribute(elems, 'opacity', 1);
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, true, elems);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
          var item = elems[i];
          setElementAttribute(item, 'opacity', 0.4);
          }
        }else{
        setElementAttribute(elems, 'opacity', 0.4);
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, false, elems);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null || gray == false){
          sWrapper.selectAll('.v-datapoint').attr('opacity', 1);
          sWrapper.selectAll('.v-lineverticallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-lineverticalhighwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-linehorizontallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-linehorizontalhighwhisker').attr('opacity', 1);
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(sWrapper, false, sWrapper.selectAll('.v-datapoint'));
          }
          
        }else{
          sWrapper.selectAll('.v-datapoint').attr('opacity', 0.4);
          sWrapper.selectAll('.v-lineverticallowwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-lineverticalhighwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-linehorizontallowwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-linehorizontalhighwhisker').attr('opacity', 0.4);
        }
        
        sWrapper.selectAll('.v-recthighwhisker').attr('opacity', 0);
        sWrapper.selectAll('.v-rectlowwhisker').attr('opacity', 0);
      };
  
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.style(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + boxHeight/4).style(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element.
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          
          var tooltipData = getTooltipData(i);
          
          tooltipData.point = {
              x: point.x,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      }
      
      };
  
      chart.blurOut = function(){
        decorativeShape.style('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      function makeSubGroup(row, start, end, groups, parentGroupIndex) {
      if (row && start <= end && end < row.length) {
        var subStart = subEnd = pos = start;
        while (pos <= end) {
          var contexts = []; 
          while (((pos+1) <= end) && (row[pos + 1].val == row[pos].val)) {
            contexts.push(row[subEnd].ctx);
            subEnd++;
            pos++;
          }
          if(subEnd < row.length)
          {
            contexts.push(row[subEnd].ctx);
          }
          row[subStart].contexts = contexts;
          groups.push({
            'val': row[subStart],
            'parentGroupIndex': parentGroupIndex,
            'start': subStart,
            'end': subEnd
          });
          pos++;
          subStart = subEnd = pos;
        }          
      }
    }

    
    function generateGroup(row) {
      var curGroups = [];
      if (row) {
        var mapLen = dimensionGroup.length;
        var preGroups = mapLen > 0?dimensionGroup[mapLen - 1].val : null;
        if (preGroups) {
          for (var i = 0, len = preGroups.length; i < len; i++) {
            var preGroup = preGroups[i];
            var start = preGroup.start;
            var end = preGroup.end;
            makeSubGroup(row, start, end, curGroups, i );
          }
        } else {
          makeSubGroup(row, 0, row.length - 1, curGroups, null);
        }
      }
      return curGroups;
    }

    function dataTransform(originalData) {
      if (originalData) {
        var originalDimension = originalData.getAnalysisAxisDataByIdx(0);
        legendData = originalData.getAnalysisAxisDataByIdx(1);
        if (originalDimension) {
          var len = originalDimension.values.length;
          if (len == 1) {
            dimensionGroup.push({'col': originalDimension.values[0].col.val, 'val': []});
          } else {
            for (var i = 0; i < len - 1; i++) {
              var row = originalDimension.values[i].rows;
              dimensionGroup.push({'col': originalDimension.values[i].col.val, 'val': generateGroup(row)});
            }
          }
        }
      }
    }
    
    function caculateLeavesNum(start, end) {
      
      var len = dimensionGroup.length, num = 0, index = 0, leavesGroups = dimensionGroup[len - 1].val;
      while (leavesGroups[index].start != start) {
        index++;
      }      
      while (leavesGroups[index].end != end) {
        num++;
        index++;
      }
      num++;
      return num;
    }

    function generateDimensions() {
      if (dimensionGroup) {
        var len = dimensionGroup.length, groups = null;
        
        groups = dimensionGroup[len - 1].val;
        if (groups.length == 0) {
          dimensionDomain.push(0);
          dimensionDomain.push(1);
        } else {
          for (var i = 0, lenScale = groups.length; i < lenScale; i++) {
            dimensionDomain.push(i);
          }
        }
        
        if (groups.length == 0) {
          dimensions['sap.viz.modules.horizontalboxplot.dimension'].values = [{'col': {'val': dimensionGroup[len - 1].col}, 'rows': []}];
        } else {
          
          var scaleValues = [];
          for (var j = 0; j < len; j++) {
            var obj = {
              'col': {'val': ''},
              'rows': []
            };
            obj.col.val = dimensionGroup[j].col;
            var rowGroups = dimensionGroup[j].val;
            for (var k = 0,  lenRowGroups =  rowGroups.length; k < lenRowGroups; k++) {
              var start = rowGroups[k].start, end = rowGroups[k].end, num = caculateLeavesNum(start, end);
              for (var m = 0; m < num; m++) {
                obj.rows.push({
                  'val': handleNull(rowGroups[k].val.val),
                  'info' : rowGroups[k].val.info,
                  'contexts' : rowGroups[k].val.contexts
                });
              }
            }
            
            scaleValues.push(obj);
          }
              
          dimensions['sap.viz.modules.horizontalboxplot.dimension'].values = scaleValues;
        }        
      }      
    }
  
    function createColorPalette(length) {
      boxColorPalette = [];
      if (colorPalette.length > 0) {
        for( var i = 0; i < length; ++i) {
          boxColorPalette.push(colorPalette[i % colorPalette.length]);
        }
      }
    }
      function parseOptions(){
      tooltipVisible = _properties.tooltip.enabled ;
        colorPalette = _properties.colorPalette;
        drawingEffect = _properties.drawingEffect;
      }
      
    chart.data = function(value) {
      if (!arguments.length) {
        return _data;
      }
      
      clearGlobalData();
      parseOptions();
      
      _data = value;
        var obj = MNDHandler(_data);
        dataTransform(_data);
        dataMG1 = obj["MG1"];
        
        if( dataMG1[0] && dataMG1[0][0].info && dataMG1[0][0].info.defaultSelection){
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        } 
        
      var len = dataMG1.length;
      var groups = dimensionGroup[dimensionGroup.length - 1].val;
      if (groups.length != 0) {
        for (var i = 0, groupsLen = groups.length; i < groupsLen; i++) {
          var start = groups[i].start, end = groups[i].end;
          for (var j = 0; j < len; j++) {
            var row = [], left = start, right = end;
            for (;left <= right; left++) {
              if (!NumberUtils.isNoValue(dataMG1[j][left].val))
                row.push(dataMG1[j][left]);
            }
            seriesData.push(row);
          }
        }
      } else {
        for (var j = 0; j < len; j++) {
          var row = [];
          for (var m = 0; m < dataMG1[j].length; m++) {
            if (!NumberUtils.isNoValue(dataMG1[j][m].val)) {
              row.push(dataMG1[j][m]);
            } 
          }
          seriesData.push(row);
        }
      }
        
      locateBoundary(seriesData);
      generateDimensions();
      
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
        makeScales();
      }
      
      generateTooltipData();
            createColorPalette(regionData.length);
      
      return chart;
    };
    
    chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
    chart.properties = function(props){

        if (!arguments.length){
          return _properties;
         }
      
      Objects.extend(true, _properties, props);
            parseOptions();
            createColorPalette(regionData.length);
            
         return chart;        
      };
    
    chart.categoryScale = function(scale){
      if (!arguments.length){
        return yDimensionScale;
      }
      yDimensionScale = scale;
      return chart;
     };
     
     chart.primaryScale = function(scale){
       if (!arguments.length){
         return xScale;
       }
       xScale = scale;
       return chart;
     };
  
    chart.colorPalette = function(Palette){
      if (!arguments.length){
        return colorPalette;
      }
      colorPalette = Palette;
      return chart;
     };
  
     chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };

    function getCSSStyle() {
      style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
    }

    getCSSStyle();
    _properties = manifest.props(null);
    return chart;
  };

  return boxplot;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalBoxplot',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.horizontalboxplot',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.horizontalboxplot',
    'name' : 'horizontal boxplot',
    base : "sap.viz.modules.xy.base",
    'properties' : { 
          'primaryValuesColorPalette' : { 'isExported' : false },
          'secondaryValuesColorPalette' : { 'isExported' : false },
          'tooltip' : {
            'name' : 'tooltip',
            'supportedValueType' : 'Object',
            'supportedValues' : {
              'enabled' : {
                'name' : 'enabled',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set enabled/disabled tooltip.'
              }
            },
            'isExported' : false,
            'description' : 'Settings for tooltip related properties.'
          }
    },
    'feeds' : {
      configure : {
          secondaryValues:null,
          axisLabels:{
            acceptMND: -1,
            min : 1,
            max : 1
          }
      }
    },
    'css' : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
            'value' : {
                'fill' : '#cccccc',
            }
        }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalBoxplotChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalBoxplot',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/horizontal_boxplot',
      name : 'IDS_HORIZONTALBOXPLOTCHART',
      base : 'riv/basehorizontalchart',
      modules : {
        root : {
          modules : {
            tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'horizontalboxplot',
                  orientation : 'left'
                }
              }
          },
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction'
            }
          },
          main : {
              modules : {
                dataLabel:null,
                yAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                plot : {
                  id : 'sap.viz.modules.horizontalboxplot',
                  configure : {
                    'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                    propertyCategory : 'plotArea'
                  }
                }
              }
            }
          }
        }
     },

     dependencies : {
       attributes : [ {
         targetModule : 'root.main.yAxis',
         target : 'scale',
         sourceModule : 'root.main.plot',
         source : 'categoryScale'
          },{
            targetModule : 'root.main.xAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'primaryScale'
          },{
         targetModule : 'root.main.xAxis',
         target : 'title',
         sourceModule : 'root.main.plot',
         source : 'primaryAxisTitle'
          },{
              targetModule : 'root.main.yAxis',
              target : 'independentData',
              sourceModule : 'root.main.plot',
              source : 'dimensionData'
          },{
            targetModule : 'root.legends.legend',
            target : 'colorPalette',
            sourceModule : 'root.main.plot',
            source : 'colorPalette'
          }, {
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
          } ],
           events : [ {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized'
          }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
          }, {
          targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }
          ]
        }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.verticalboxplot',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, Scaler, NumberUtils, langManager,tooltipDataHandler, Objects, boundUtil, defaultSelUtil) {
  var boxplot = function(manifest, ctx) {
    var CSSCLASS_HOVERLINE = 'v-hovershadow';
    var sWrapper = null, 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
    var  dimensions = {
        'sap.viz.modules.verticalboxplot.dimension' : {
                'key' : 'sap.viz.modules.verticalboxplot.dimension',
                'values' : null
        }
      };

    var width, 
      height, 
      xScale = d3.scale.ordinal(), 
      yScale = d3.scale.linear(), 
      xDimensionScale = d3.scale.ordinal(),
      decorativeShape,
      boxWidth,
      lastHovered = null,
      tooltipVisible = true,
      hasDefaultSelection = false,
      scaleMinMax = {
          min: 0,
          max: 0
      },
      effectManager = ctx.effectManager,
      drawingEffect = 'normal',
      defaultString = langManager.get('IDS_ISNOVALUE');
    
    var _properties = {}, eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    var style = {};
    var outLierLayout = {
      width : '1',
      color : '#000000'
    };

    var quartileLayout = {
      width: '0',
      midLineColor: '#000000'
    };
    
    var lowOutLiersObj = [], highOutLiersObj = [], whiskersObj = [], lowWhiskerObj = [], highWhiskerObj = [], quartilesObj = [], outLiersObj = [];
    var keysArray = ['Maximum:', '3rd Quartile:', 'Median:', '1st Quartile:', 'Minimum:'], noValueStr = 'No value';
    
    var makeScales = function() {
      var domain = [];
      for ( var i = 0; i < seriesData.length; i++) {
        domain.push(i);
      }
      //when all data is 0 or null ,we should make yScale.domain from 0 to 1
      xScale.domain(domain).rangeBands([0, width]);
      xDimensionScale.domain(dimensionDomain).rangeBands([0, width]);   
      if(!scaleMinMax || (scaleMinMax.min === 0 && scaleMinMax.max === 0)){
        yScale.domain([ 0, 1 ]).range([ height, 0 ]).nice();

      } else{
        yScale.domain([ scaleMinMax.min, scaleMinMax.max ]).range([ height, 0 ]).nice();

      }
      Scaler.perfect(yScale);

    };
    
    chart.dimensionData = function(_)
    {
      if (!arguments.length){
        return dimensions;
      }
      dimensions = _;
      return chart;    
    };
    
    function locateBoundary(data) {
      
      if (TypeUtils.isExist(data)) {
        length = data.length;
        var firstLoop = false;
        for (var i = 0; i < length; i++) {
          
          if (data[i].length > 0) {
            if (!firstLoop) {
              scaleMinMax = findMinMax(data[i]);
              firstLoop = true;
            } else {
              var tmp = findMinMax(data[i]);
              if (tmp) {
                if (tmp.min < scaleMinMax.min) {
                  scaleMinMax.min = tmp.min;
                }
                if (tmp.max > scaleMinMax.max) {
                  scaleMinMax.max = tmp.max;
                }
              }
              
            }
          }
        }
      }
      
    }
    
    function findMinMax(range) {
      var minMax = {min:0, max:0};
      if (TypeUtils.isExist(range)) {
        range.sort( function(aObj, bObj) { return aObj.val - bObj.val; });
        
        minMax = {min: range[0].val, max: range[range.length - 1].val};
      }
      return minMax;
    }

    function clearBoxData() {
      lowOutLiersObj = [];
      highOutLiersObj = [];
      whiskersObj = [];
      lowWhiskerObj = [];
      highWhiskerObj = [];
      quartilesObj = [];
      outLiersObj = [];
    }
    
    function clearGlobalData() {
      dimensionGroup = []; 
      dimensionDomain = []; 
      seriesData = []; 
      legendData = []; 
      regionData = []; 
      dimensionData = []; 
      boxplotData = []; 
    }

    function even(n) {
      return (n & 1) == 0;
    }

    function median(distribution, start, end) {
      var n = end - start + 1;
      if (n <= 0)
        return -1;

      var ret;
      var ctxValue = distribution[start + Math.floor((n + 1) / 2) - 1].ctx;
      var infoValue = distribution[start + Math.floor((n + 1) / 2) - 1].info;

      if (even(n)) {
        ret = (distribution[start + Math.floor((n + 1) / 2) - 1].val + distribution[start
            + Math.floor((n + 1) / 2)].val) / 2;
      } else {
        ret = distribution[start + Math.floor((n + 1) / 2) - 1].val;
      }
      return {
        'ctx' : ctxValue,
        'info' : infoValue,
        'val' : ret
      };
    }

    function setDistribution(distribution) {

      if (distribution && distribution.length > 0) {
        var n = distribution.length,
          box = {
            'Maximum:': null,
            '3rd Quartile:': null,
            'Median:': null,
            '1st Quartile:': null,
            'Minimum:': null  
          };
        
            midLine = median(distribution,  0,  n - 1);
            box['Median:'] = midLine;
            
          // Q1 is the median of the first half of the set; we add the median to
            // it if the whole set length is even
            var bak = distribution[Math.floor(n / 2)];
            distribution[Math.floor(n / 2)] = midLine;
            var boxBottom = median(distribution, 0, Math.floor(n / 2));
            distribution[Math.floor(n / 2)] = bak;
            
            // Q3 is the median of the second half of the set; we add the median to
            // it if the whole set length is even
            bak = distribution[Math.floor((n - 1) / 2)];
            distribution[Math.floor((n - 1) / 2)] = midLine;
            var boxTop  = median(distribution, Math.floor((n - 1) / 2), n - 1);
            distribution[Math.floor((n - 1) / 2)] = bak;
            box['3rd Quartile:'] = boxTop;
            box['1st Quartile:'] = boxBottom;
            
        // inter-quartile range
        var iqr = boxTop.val - boxBottom.val;
        // lower adjacent limit
        var lal = boxBottom.val - 1.5 * iqr;
        // upper adjacent limit
        var ual = boxTop.val + 1.5 * iqr;

        // search for the lowest non outlier
        var i = 0;
        while (distribution[i].val < lal)
          i++;
        lowWhisker = distribution[i];
        box['Minimum:'] = lowWhisker;

        if (lowWhisker) {
          if (boxBottom) {
            if (boxBottom.val != lowWhisker.val) {
              lowWhiskerObj.push({
                'pair' : [boxBottom, lowWhisker],
                'ctx' : [boxBottom.ctx, lowWhisker.ctx],
                'val' : [boxBottom.val, lowWhisker.val],
                'info' : [boxBottom.info, lowWhisker.info],
              });
            }
          }
        }

        // low outliers are all the values lower than lowest non outlier
        for ( var k = 0; k < i; k++)
          outLiersObj.push(distribution[k]);

        // search for the largest non outlier
        var j = n - 1;
        while (distribution[j].val > ual)
          j--;
        highWhisker = distribution[j];
        box['Maximum:'] = highWhisker;

        for ( var k = 0; k < n - j - 1; k++)
          outLiersObj.push(distribution[j + 1 + k]);

        if (outLiersObj.length > 0)
          box['outLiers(s)'] = outLiersObj.length;
        // if (lowWhiskerObj.length == 1) {
        // whiskersObj.push(lowWhiskerObj[0]);
        // }

        // if (highWhiskerObj.length == 1) {
        // whiskersObj.push(highWhiskerObj[0]);
        // }

        if (highWhisker) {
          if (boxTop) {
            if (boxTop.val != highWhisker.val) {
              highWhiskerObj.push({
                'pair' : [highWhisker, boxTop],
                'ctx' : [highWhisker.ctx, boxTop.ctx],
                'val' : [highWhisker.val, boxTop.val],
                'info' : [highWhisker.info, boxTop.info],
              });
            }
          }
        }

        if (boxBottom && boxTop && midLine) {
          if (boxBottom.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxBottom, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],
              'info' : [boxBottom.info]
            });
          } else if (midLine.val == boxTop.val || midLine.val == boxBottom.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxTop.ctx, boxBottom.ctx],
              'val' : [boxTop.val, boxBottom.val],
              'info' : [boxTop.info, boxBottom.info]
            });
          } else {
            quartilesObj.push({
              'pair' : [boxTop, midLine],
              'midLine': midLine,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val],
              'info' : [boxTop.info]
            });
            quartilesObj.push({
              'pair' : [midLine, boxBottom],
              'midLine': midLine,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val],
              'info' : [boxBottom.info]
            });
          }
        }
        
        boxplotData.push(box);
      }
    }
      
    function chart(selection) { 
      
      selection.each(function() {
        
        boundUtil.drawBound(selection, width, height);
          
        boxNumber = 1, boxGroupNumber = seriesData.length, boxWidth = 8 * (xScale.rangeBand()) / (9 * boxNumber + 7);
  
          var svg = sWrapper = d3.select(this);
          svg.selectAll('g.v-box').remove();
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() - boxWidth/2).attr('height', height).style('visibility', 'hidden').attr('fill', style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE);
          }else{
            decorativeShape.attr('width', xScale.rangeBand() - boxWidth/2).attr('height',height).style('visibility', 'hidden');
          }
          
          var boxGroup = svg.selectAll('g.v-box').data(seriesData);

          boxGroup.enter().append('g');
        boxGroup.attr('class', 'v-box').each( function(boxData, outerIndex) {
              
            if (boxData.length == 0) {
              boxplotData.push({});
              return;
            }
            
            boxData = boxData.sort(function(aObj, bObj) { return aObj.val - bObj.val; });
    
                var arrLength = boxData.length, min = boxData[0], max = boxData[arrLength - 1];
    
                setDistribution(boxData);
    
                var outLiersSelector = d3.select(this).selectAll('circle.outliers').data(outLiersObj);
                outLiersSelector.enter().append('circle');
                outLiersSelector.attr('cx', function(outLier) {
                  var x = xScale(outerIndex) + boxWidth;
                  return x;
                })
                .attr('cy', function(outLier, num) {
                  var y = yScale(outLier.val);
                  return y;
                })
                .attr('r', '2')
                //.attr('shape-rendering', 'crispEdges')
                .attr('stroke', effectManager.register(
                                                    {
                                                  drawingEffect : 'normal',
                                                  fillColor : outLierLayout.color
                                                }
                                                      )
             )
                .attr('stroke-width', outLierLayout.width)
                .attr('fill', 'none')
                .attr('class', 'v-datapoint v-outliers');
                
                outLiersSelector.exit().remove();

                var quartileSelector = d3.select(this).selectAll('rect.quartile').data(quartilesObj);
                quartileSelector.enter().append('rect');
                quartileSelector.attr('x', function(quartile) {
                  var x = xScale(outerIndex) + boxWidth / 2;
                  return x;
                })
                .attr('y', function(quartile, num) {
                  var y = yScale(quartile.pair[0].val);
                  return y;
  
                })
                .attr('width', boxWidth)
                .attr('height', function(quartile, num) {
                  var height = 0;
                  var pairDiff = quartile.pair[1].val - quartile.pair[0].val;
                  if (pairDiff == 0) {
                    height = 1;
                  } else {
                    height = yScale(quartile.pair[1].val) - yScale(quartile.pair[0].val);
                  }
  
                  return height;
                })
                .attr('shape-rendering', 'crispEdges')
                .attr( 'fill', function(d){
                  var parameter = {
                      drawingEffect : drawingEffect,
                      fillColor : boxColorPalette[outerIndex % boxColorPalette.length],
                      direction : 'horizontal'
                    };
            return effectManager.register(parameter);   
                })
                .attr('stroke-width', quartileLayout.width)
                //.attr('stroke', '#000000')
                .attr('class', 'v-datapoint v-quartile');
                
                if (quartilesObj.length == 2) {
                  var midLineXStart = xScale(outerIndex) + boxWidth / 2;
                  var midLineXEnd = midLineXStart + boxWidth;
                  var midLineYStart = midLineYEnd = yScale(quartilesObj[0].midLine.val);
                  var lineSelector = d3.select(this);
                    lineSelector.append('line')
                    .attr('x1', midLineXStart)
                    .attr('y1', midLineYStart)
                    .attr('x2', midLineXEnd)
                    .attr('y2', midLineYEnd)
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'v-midline');
                }
                
                quartileSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.v-rectlowwhisker').data(lowWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector.attr('x', function(whisker) {
                  var x = xScale(outerIndex) + boxWidth / 2;
                  horizontalLineXStart = x;
                  horizontalLineXEnd = x + boxWidth;
                  verticalLineXStart = verticalLineXEnd = x + boxWidth / 2;
                  return x;
                  })
                  .attr('y', function(whisker) {
                    var tmpPair = whisker.pair;
                    var y = yScale(tmpPair[0].val);
                    verticalLineYStart = y;
                    horizontalLineYStart = horizontalLineYEnd = yScale(tmpPair[1].val);
                    return y;
                  })
                  .attr('width', boxWidth)
                  .attr('height', function(whisker) {
                    var height = yScale(whisker.pair[1].val) - yScale(whisker.pair[0].val);
                    verticalLineYEnd = yScale(whisker.pair[1].val);
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', verticalLineXStart)
                    .attr('y1', verticalLineYStart)
                    .attr('x2', verticalLineXEnd)
                    .attr('y2', verticalLineYEnd)
                    .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'v-lineverticallowwhisker v-innerwhisker');
                    
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', horizontalLineXStart)
                    .attr('y1', horizontalLineYStart)
                    .attr('x2', horizontalLineXEnd)
                    .attr('y2', horizontalLineYEnd)
                    .attr('stroke', function(d){
                          var parameter = {
                         drawingEffect : 'normal',
                         fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                        };
                                   return effectManager.register(parameter);  
                                }
                         )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'v-linehorizontallowwhisker');
                    return height;
                    })
                  .attr('shape-rendering', 'crispEdges')
                  .attr('fill-opacity', '0')
                  .attr('stroke-width', '0')
                  .attr('class', 'v-datapoint v-rectlowwhisker');
                
                whiskerSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.v-recthighwhisker').data(highWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector
                    .attr('x', function(whisker) {
                      var x = xScale(outerIndex) + boxWidth / 2;
                      horizontalLineXStart = x;
                      horizontalLineXEnd = x + boxWidth;
                      verticalLineXStart = verticalLineXEnd = x + boxWidth / 2;
                      return x;
                      })
                    .attr('y', function(whisker, num) {
                      var tmpPair = whisker.pair;
                      var y = yScale(tmpPair[0].val);
                      verticalLineYStart = y;
                      horizontalLineYStart = horizontalLineYEnd = yScale(tmpPair[0].val);
                      return y;
                      })
                    .attr('width', boxWidth)
                    .attr('height', function(whiskersObj, num) {
                      var height = yScale(whiskersObj.pair[1].val) - yScale(whiskersObj.pair[0].val);
                      verticalLineYEnd = verticalLineYStart + height;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-lineverticalhighwhisker v-innerwhisker');
  
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', horizontalLineXStart)
                      .attr('y1', horizontalLineYStart)
                      .attr('x2', horizontalLineXEnd)
                      .attr('y2', horizontalLineYEnd)
                      .attr('stroke', function(d){
                            var parameter = {
                         drawingEffect : 'normal',
                         fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                        };
                                   return effectManager.register(parameter);  
                                }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'v-linehorizontalhighwhisker');
                       
                      return height;
                      })
                    .attr('shape-rendering', 'crispEdges')
                    .attr('fill-opacity', '0')
                    .attr('stroke-width', '0')
                    .attr('class', 'v-datapoint v-recthighwhisker');
                
                whiskerSelector.exit().remove();      
                clearBoxData();
          });
          eDispatch.initialized();
          boxGroup.exit().remove();
      });
    return chart;
    };
  
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }
      
      width = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };
      
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    }; 
    
    var handleNull = function(_) {
      if (_ === null || _ === undefined) {
        return defaultString;
      } else {
        return _;
      }
    };

    function getTooltipData(index) {
      
      var tooltipData =  {
          'body': [],
          'footer': []
        },
        internalIndex = 0;
      
      if (regionData) {

        var body = {
          'name': null,
          'val': []
        };
        
        internalIndex = index % regionData.length;
        body.name = regionData[internalIndex].name;
  
        if (regionData[internalIndex].label != null && regionData[internalIndex].shape != null && boxColorPalette[internalIndex] != null) {
          var item = {
              'shape': null,
              'color': null,
              'label': null,
              'value': null
            };
          
          item.shape = regionData[internalIndex].shape;
          item.color = boxColorPalette[internalIndex];
          item.label = regionData[internalIndex].label;
          body.val.push(item);
        }
        
        if (boxplotData) {
          
          if (boxplotData[index]) {
            var hasData = false;
            for (var i in boxplotData[index]) {
              var item = {
                  'shape': null,
                  'color': null,
                  'label': null,
                  'value': null
                };
              hasData = true;
              item.label = i;
              if (boxplotData[index][i]) {
                if (i == 'outLiers(s)') {
                  item.value = boxplotData[index][i];
                } else {
                  item.value = boxplotData[index][i].val;
                }
              }
              body.val.push(item);
            }
            
            if (!hasData) {
              for (var j = 0; j < keysArray.length; j++) {
                var item = {};
                item.label = keysArray[j];
                item.value = noValueStr;
                item.color = null;
                item.shape = null;
                body.val.push(item);
              }
            }
          }
        }
        
        tooltipData.body.push(body);
      }
      
      if (dimensionData) {
        internalIndex = Math.floor(index / regionData.length);
        for (var i = 0; i < dimensionData.length; i++) {
          
          if (dimensionData[i].rows.length > 0) {
            var footer = {
                'label': null,
                'value': null
              };
            footer.label = dimensionData[i].col;
            footer.value = dimensionData[i].rows[internalIndex];
            
            tooltipData.footer.push(footer);
          }
        }
      }
    
      return tooltipData;
    }
    
    function generateTooltipData() {
      
      if (dimensions) {
        for (var i in dimensions) {
          dimensionData = dimensions[i].values;
        }
      }
      
      if (legendData) {
        var legendList = legendData.values;
        if (legendList.length > 1) {
          if (legendList[0].type == 'MND') {
            //mnd scan
            for (var mndIndex = 0; mndIndex < legendList[0].rows.length; mndIndex++) {

              //vertical scan
              for (var m = 0; m < legendList[1].rows.length; m++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.name = legendList[0].rows[mndIndex];
                var label = [];
                
                //horizontal scan
                for (var n = 1; n < legendList.length; n++) {
                  label.push(legendList[n].rows[m]);
                }
                legendObj.label = label;
                regionData.push(legendObj);
              }    

            }
          } else if (legendList[legendList.length - 1].type == 'MND') {

            for (var m = 0; m < legendList[0].rows.length; m++) {

              var label = [];
              for (var n = 0; n < legendList.length - 1; n++) {
                label.push(legendList[n].rows[m]);              
              }
              

              for (var mndIndex = 0; mndIndex < legendList[legendList.length - 1].rows.length; mndIndex++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.label = label;
                legendObj.name = legendList[legendList.length - 1].rows[mndIndex];
                regionData.push(legendObj);
              }
            }
          } 
        } else {
          for (var m = 0; m < legendList[0].rows.length; m++) {
            var legendObj = {
                'name': null,
                'shape': null,
                'color': null,
                'label': null
              };
            legendObj.name = legendList[0].rows[m];
            regionData.push(legendObj);
          }
        }
      }
      
      for (var k = 0; k < regionData.length; k++) {
        //regionData[k].color = boxColorPalette[k % boxColorPalette.length];
        regionData[k].shape = 'squareWithRadius';
      }
    }

    function setElementAttribute(element, attribute, value) {
      if (element) {
        var className = element.getAttribute('class');
        if(className.indexOf('v-recthighwhisker') == -1 && className.indexOf('v-rectlowwhisker') == -1
           && className.indexOf('v-linehorizontalhighwhisker') == -1 && className.indexOf('v-lineverticalhighwhisker') == -1
           && className.indexOf('v-linehorizontallowwhisker') == -1 && className.indexOf('v-lineverticallowwhisker') == -1) {
          element.setAttribute(attribute, value);
        }else if (className.indexOf('v-recthighwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('v-linehorizontalhighwhisker') != -1 || nodeClassName.indexOf('v-lineverticalhighwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }
        } else if(className.indexOf('v-rectlowwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('v-linehorizontallowwhisker') != -1 || nodeClassName.indexOf('v-lineverticallowwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }        
        }      
      }
    }
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, elemsLen = elems.length; i < elemsLen; i++) {
          var item = elems[i];
          setElementAttribute(item, 'opacity', 1);
          }
        }else{
        setElementAttribute(elems, 'opacity', 1);
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, true, elems);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
          var item = elems[i];
          setElementAttribute(item, 'opacity', 0.4);
          }
        }else{
        setElementAttribute(elems, 'opacity', 0.4);
        }
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(sWrapper, false, elems);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null || gray == false){
          sWrapper.selectAll('.v-datapoint').attr('opacity', 1);
          sWrapper.selectAll('.v-lineverticallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-lineverticalhighwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-linehorizontallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.v-linehorizontalhighwhisker').attr('opacity', 1);
          
          if(hasDefaultSelection){
            defaultSelUtil.clearSelectionInfo(sWrapper, false, sWrapper.selectAll('.v-datapoint'));
          }
          
        }else{
          sWrapper.selectAll('.v-datapoint').attr('opacity', 0.4);
          sWrapper.selectAll('.v-lineverticallowwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-lineverticalhighwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-linehorizontallowwhisker').attr('opacity', 0.4);
          sWrapper.selectAll('.v-linehorizontalhighwhisker').attr('opacity', 0.4);
        }
        
        sWrapper.selectAll('.v-recthighwhisker').attr('opacity', 0);
        sWrapper.selectAll('.v-rectlowwhisker').attr('opacity', 0);
      };
  
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.style(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'x',
          xScale.rangeBand() * i + boxWidth/4).style(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element.
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var xoffset = transform.e;

          var tooltipData = getTooltipData(i);
          
          tooltipData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: point.y
              };
          tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      }
      
      };
  
      chart.blurOut = function(){
        decorativeShape.style('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      function makeSubGroup(row, start, end, groups, parentGroupIndex) {
      if (row && start <= end && end < row.length) {
        var subStart = subEnd = pos = start;
        while (pos <= end) {
          var contexts = []; 
          while (((pos+1) <= end) && (row[pos + 1].val == row[pos].val)) {
            contexts.push(row[subEnd].ctx);
            subEnd++;
            pos++;
          }
          if(subEnd < row.length)
          {
            contexts.push(row[subEnd].ctx);
          }
          row[subStart].contexts = contexts;
          groups.push({
            'val': row[subStart],
            'parentGroupIndex': parentGroupIndex,
            'start': subStart,
            'end': subEnd
          });
          pos++;
          subStart = subEnd = pos;
        }          
      }
    }

    
    function generateGroup(row) {
      var curGroups = [];
      if (row) {
        var mapLen = dimensionGroup.length;
        var preGroups = mapLen > 0?dimensionGroup[mapLen - 1].val : null;
        if (preGroups) {
          for (var i = 0, len = preGroups.length; i < len; i++) {
            var preGroup = preGroups[i];
            var start = preGroup.start;
            var end = preGroup.end;
            makeSubGroup(row, start, end, curGroups, i );
          }
        } else {
          makeSubGroup(row, 0, row.length - 1, curGroups, null);
        }
      }
      return curGroups;
    }

    function dataTransform(originalData) {
      if (originalData) {
        var originalDimension = originalData.getAnalysisAxisDataByIdx(0);
        legendData = originalData.getAnalysisAxisDataByIdx(1);
        if (originalDimension) {
          var len = originalDimension.values.length;
          if (len == 1) {
            dimensionGroup.push({'col': originalDimension.values[0].col.val, 'val': []});
          } else {
            for (var i = 0; i < len - 1; i++) {
              var row = originalDimension.values[i].rows;
              dimensionGroup.push({'col': originalDimension.values[i].col.val, 'val': generateGroup(row)});
            }
          }
        }
      }
    }
    
    function caculateLeavesNum(start, end) {
      
      var len = dimensionGroup.length, num = 0, index = 0, leavesGroups = dimensionGroup[len - 1].val;
      while (leavesGroups[index].start != start) {
        index++;
      }      
      while (leavesGroups[index].end != end) {
        num++;
        index++;
      }
      num++;
      return num;
    }

    function generateDimensions() {
      if (dimensionGroup) {
        var len = dimensionGroup.length, groups = null;
        
        groups = dimensionGroup[len - 1].val;
        if (groups.length == 0) {
          dimensionDomain.push(0);
          dimensionDomain.push(1);
        } else {
          for (var i = 0, lenScale = groups.length; i < lenScale; i++) {
            dimensionDomain.push(i);
          }
        }
        
        if (groups.length == 0) {
          dimensions['sap.viz.modules.verticalboxplot.dimension'].values = [{'col': {'val': dimensionGroup[len - 1].col}, 'rows': []}];
        } else {
          
          var scaleValues = [];
          for (var j = 0; j < len; j++) {
            var obj = {
              'col': {'val': ''},
              'rows': []
            };
            obj.col.val = dimensionGroup[j].col;
            var rowGroups = dimensionGroup[j].val;
            for (var k = 0,  lenRowGroups =  rowGroups.length; k < lenRowGroups; k++) {
              var start = rowGroups[k].start, end = rowGroups[k].end, num = caculateLeavesNum(start, end);
              for (var m = 0; m < num; m++) {
                obj.rows.push({
                  'val': handleNull(rowGroups[k].val.val),
                  'info' : rowGroups[k].val.info,
                  'contexts' : rowGroups[k].val.contexts
                });
              }
            }
            
            scaleValues.push(obj);
          }
              
          dimensions['sap.viz.modules.verticalboxplot.dimension'].values = scaleValues;
        }        
      }      
    }
    
    function createColorPalette(length) {
      boxColorPalette = [];
      if (colorPalette.length > 0) {
        for( var i = 0; i < length; ++i) {
          boxColorPalette.push(colorPalette[i % colorPalette.length]);
        }
      }
    }
    
      function parseOptions(){  
      tooltipVisible = _properties.tooltip.enabled;
        colorPalette = _properties.colorPalette;
        drawingEffect = _properties.drawingEffect;
      }
      
    chart.data = function(value) {
      if (!arguments.length) {
        return _data;
      }
      
      clearGlobalData();
      parseOptions();
      
      _data = value;
        var obj = MNDHandler(_data);
        dataTransform(_data);
        dataMG1 = obj["MG1"];
        
        if( dataMG1[0] && dataMG1[0][0].info && dataMG1[0][0].info.defaultSelection){
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        }   
      var len = dataMG1.length;
      var groups = dimensionGroup[dimensionGroup.length - 1].val;
      if (groups.length != 0) {
        for (var i = 0, groupsLen = groups.length; i < groupsLen; i++) {
          var start = groups[i].start, end = groups[i].end;
          for (var j = 0; j < len; j++) {
            var row = [], left = start, right = end;
            for (;left <= right; left++) {
              if (!NumberUtils.isNoValue(dataMG1[j][left].val))
                row.push(dataMG1[j][left]);
            }
            seriesData.push(row);
          }
        }
      } else {
        for (var j = 0; j < len; j++) {
          var row = [];
          for (var m = 0; m < dataMG1[j].length; m++) {
            if (!NumberUtils.isNoValue(dataMG1[j][m].val)) {
              row.push(dataMG1[j][m]);
            } 
          }
          seriesData.push(row);
        }
      }
        
      locateBoundary(seriesData);
      generateDimensions();
      
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
        makeScales();
      }
      
      generateTooltipData();
            createColorPalette(regionData.length);
      
      return chart;
    };
    
    chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
    chart.properties = function(props){

        if (!arguments.length){
          return _properties;
         }
      
      Objects.extend(true, _properties, props);
            parseOptions();
            createColorPalette(regionData.length);
            
         return chart;        
      };
    
    chart.categoryScale = function(scale){
      if (!arguments.length){
        return xDimensionScale;
      }
      xDimensionScale = scale;
      return chart;
     };
     
     chart.primaryScale = function(scale){
       if (!arguments.length){
         return yScale;
       }
       yScale = scale;
       return chart;
     };
  
    chart.colorPalette = function(Palette){
      if (!arguments.length){
        return colorPalette;
      }
      colorPalette = Palette;
      return chart;
     };
  
     chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };

    function getCSSStyle() {
      style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
    }

    getCSSStyle();
    _properties = manifest.props(null);
    return chart;
  };

  return boxplot;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.VerticalBoxplot',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.verticalboxplot',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.verticalboxplot',
    'name' : 'vertical boxplot',
    base : "sap.viz.modules.xy.base",
    'properties' : { 
          'primaryValuesColorPalette' : { 'isExported' : false },
          'secondaryValuesColorPalette' : { 'isExported' : false },
          'tooltip' : {
            'name' : 'tooltip',
            'supportedValueType' : 'Object',
            'supportedValues' : {
              'enabled' : {
                'name' : 'enabled',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set enabled/disabled tooltip.'
              }
            },
            'isExported' : false,
            'description' : 'Settings for tooltip related properties.'
          }
    },
    'feeds' : {
      configure : {
          secondaryValues:null,
          axisLabels:{
          acceptMND: -1,
          min : 1,
          max : 1
        }
      }
    },
    'css' : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
            'value' : {
                'fill' : '#cccccc',
            }
        }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.VerticalBoxplotChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBoxplot',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/boxplot',
      name : 'IDS_VERTICALBOXPLOTCHART',
      base : 'riv/baseverticalchart',
      modules : {
        root : {
          modules : {
             tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'verticalboxplot',
                  orientation : 'left'
                }
              }
          },
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : { clientID : 'main', propertyCategory : 'interaction' }
          },
          main : {
              modules : {
                dataLabel:null,
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                plot : {
                    id : 'sap.viz.modules.verticalboxplot',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
            }
          }
        }
         
      },

     dependencies : {
       attributes : [ {
         targetModule : 'root.main.yAxis',
         target : 'scale',
         sourceModule : 'root.main.plot',
         source : 'primaryScale'
          },{
         targetModule : 'root.main.yAxis',
         target : 'title',
         sourceModule : 'root.main.plot',
         source : 'primaryAxisTitle'
          },{
            targetModule : 'root.main.xAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'categoryScale'
          },{
              targetModule : 'root.main.xAxis',
              target : 'independentData',
              sourceModule : 'root.main.plot',
              source : 'dimensionData'
          },{
            targetModule : 'root.legends.legend',
            target : 'colorPalette',
            sourceModule : 'root.main.plot',
            source : 'colorPalette'
          },{
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
          } ],
           events : [ {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
          }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
          }, {
            targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          }
          ]
        }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.combination',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
}
],
function Setup(dispatch, ModuleManifest, ColorSeries, MNDHandler, TypeUtils, ObjUtils, MultiAxesDataAdapter, TooltipDataHandler, Scaler, NumberUtils, Objects, langManager, BoundUtil, dataUtil) {
  var combination = function(manifest, ctx) {
    var hasAnimationEnd;
    function module(selection) {
      BoundUtil.drawBound(selection, _width, _height);
      _tooltipDataHandler = TooltipDataHandler();
      selection.each(

        function(inputData) {
          if (inputData !== undefined) {
            prepareData(inputData);
          }
          _d3root = d3.select(this);
          
          redraw();
        }
      );//each
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return module;
    }

    module.afterUIComponentAppear = function(){
      _eDispatch.initialized(); 
    };
    
    
    /**
     * set/get width
     */
    module.width = function(_) {
      if (!arguments.length) {
        return _width;
      }
      isSizeChanged = (!isSizeChanged && (_ === _width)) ? false : true;
      _width =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get height
     */
    module.height = function(_) {
      if (!arguments.length) {
        return _height;
      }
      isSizeChanged = (!isSizeChanged && (_ === _height)) ? false : true;
      _height =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get size
     * 
     * @param {Object}
     *            {'width':Num, 'height':Num}
     */
    module.size = function(_) {
      if (!arguments.length) {
        return {
          width : _width,
          height: _height
        };
      }
      _width = _.width;
      _height = _.height;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };

    /**
     * set/get properties
     */
    module.properties = function(_) {
      if (!arguments.length) {
        return getProperty();
      }
      setProperty(Objects.extend(true, getProperty(), _));
      prepareData(_rawdata, true);
      return module;
    };
    
    module.dataLabel = function(_){};
    /**
     * set/get data
     */
    module.data = function(_) {
      if (!arguments.length) {
        return _rawdata;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(_rawdata, _)){
        isDataSchemaChanged = true;
      }
      prepareData(_);
      return module;
    };

    module.primaryAxisTitle = function(_){
        if(!arguments.length) {
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      module.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
     
      module.dispatch = function(_){
        if(!arguments.length) {
          return _eDispatch;
        }
        _eDispatch = _;
        return module;
      };

      module.primaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis1.scale;
        }
        _valueAxis1.scale = scale;
        return module;
      };
      
      module.secondaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis2.scale;
        }
        _valueAxis2.scale = scale;
        return module;
      };
      
      module.categoryScale = function(scale)
      {
        if(!arguments.length) {
          return _xScale;
        }
        _xScale = scale;
        return module;
      };

    module.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis1.scale.domain()[0],
          max: _valueAxis1.scale.domain()[1]
        };
      }
      
      if (range !== null) {
          _valueAxis1.topValue = range.max;
          _valueAxis1.bottomValue = range.min;
          if (range.from === 'axis') {
            _valueAxis1.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis1, _valueAxis1.scale);
          }
      }
      return module;
    };

    module.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis2.scale.domain()[0],
          max: _valueAxis2.scale.domain()[1]
        };
      }
      if (range !== null) {
          _valueAxis2.topValue = range.max;
          _valueAxis2.bottomValue = range.min;
          if (range.from === 'axis') {
            _valueAxis2.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis2, _valueAxis2.scale);
          }
      }
      return module;
    };

    module.primaryAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.primaryValuesColorPalette[0];
      } else {
        return null;
      }
    };
    
    module.secondAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.secondaryValuesColorPalette[0];
      } else {
        return null;
      }
    };

      module.colorPalette = function(Palette){
        if (!arguments.length){
          return _colorPalette;
         }
         return module;
      };

      module.shapePalette = function(Palette){
        if (!arguments.length){
          return _shapePalette;
         }
         return module;
      };

    module.parent = function () {
      return _d3root;
    };
    
    module.clear = function (gray) {
      for (var i in _module)
      {
        if (gray === undefined || gray === false) {
          _module[i].module.clear();
        } else {
          _module[i].module.clear('grayall');
        }
      }
    };

    module.highlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      if (elementArray.length === 0) {
        return;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].highlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].highlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.highlight(_module[i].highlightArray);
        }
      }
    };

    module.unhighlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }    
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].unhighlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].unhighlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.unhighlight(_module[i].unhighlightArray);
        }
      }
    };
    
    module.hoverOnPoint = function( point ) {
      var i;
      if (_props.tooltip.enabled) {
        var point0= point.x, point1 = point.y;
  
        if(point0 < 0 || point0 > _width) {
          return;
        }
        var xIndex = getCategoryIndex(point0);
        if(_preMouseMoveXIndex === xIndex) {
          return;
        }
        _preMouseMoveXIndex = xIndex;

        var tData = _tooltipDataHandler.generateTooltipData(_rawdata, 
                                   _tooltipdata, 
                                   xIndex, 
                                   _colorPalette, 
                                   _shapePalette);
        var matrix = _d3root.node().getTransformToElement(_d3root.node().ownerSVGElement);                                   
        tData.point = {
            x: _xScale.rangeBand()*(xIndex + 0.5) + matrix.e,
            y: _height / 4 + matrix.f
        };
        _eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.hoverOnPoint(point);
        }
      }
      return true;
    };

    module.blurOut = function( ) {
      var i;
      if (_props.tooltip.enabled) {
        _eDispatch.hideTooltip();
        _preMouseMoveXIndex = -1;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.blurOut();
        }
      }      
      return true;
    };  

      var _xScale = d3.scale.ordinal(),
          _valueAxis1 = {
            scale: d3.scale.linear()
          },
          _valueAxis2 = {
            scale: d3.scale.linear()
          };

    
    //private field
    var CLASSNAME_MODULE = 'v-module';

    var _tooltipDataHandler;
    var _eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    //property
    var _width, _height;
    var _props = {
      priorityMap : {
        'bar' : 5,
        'line' : 0
      },
      defaultShape : 'line',
      MNDOnCategory : false,
      MNDInner : false
    };
    var _effectManager = ctx.effectManager;
    
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    //data
    var _rawdata, _tooltipdata;
    var _d3root;
    var _colorPalette, _shapePalette;
    
    //module
    var _module;

    var _preMouseMoveXIndex = -1;

    var dummyDispatch = function (_) {
      this.mtype = _;
    };
    dummyDispatch.prototype.initialized = function() {
      _dummyDispatchHelper.initialized(this.mtype);
    };
    dummyDispatch.prototype.startToInit = function() {
      _eDispatch.startToInit();
    };
    var _dummyDispatchHelper = {
      initialized : function(mtype) {
        var i;
        if (_module[mtype]) {
          _module[mtype].isCompleteAnimation = true;
        }
        for (i in _module) {
          if (!_module[i].isCompleteAnimation) {
            return true;
          }
        }
        hasAnimationEnd = true;
        return true;
      }
    };

    function init() {
      //TODO: should destroy useless module here(stop animation of useless module)
      _module = {};
    }
    function prepareData ( rawdata , isMandatory ) {
      var i, j, mtype, tm;
      if ((rawdata === null) || (rawdata === undefined) || (!isMandatory && (_rawdata === rawdata))) {
        return;
      }

      init();
      _rawdata = rawdata;

       var obj = MNDHandler(_rawdata );
      _props.MNDInner = obj.MNDInner;
      _valueAxis1.data = obj['MG1'];
      _valueAxis2.data = obj['MG2'];
      _tooltipdata = TooltipDataHandler.dataTransform(obj);

      if (obj.color) {
        var tempData = obj['MG1'];
        var data0 = [];
        var data1 = [];
        for (i=0; i<tempData.length; i++) {
          var temp0 = [];
          var temp1 = [];
          var temp = tempData[i];
          for (j=0; j<temp.length; j++) {
            if (obj.color[j] === 0) {
              temp0.push(temp[j]);
            } else if (obj.color[j] === 1) {
              temp1.push(temp[j]);
            }
          }
          data0.push(temp0);
          data1.push(temp1);
        }
        _valueAxis1.data = data0;
        _valueAxis2.data = data1;
      }
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      if (obj.hasMND && !obj.MNDOnColor) {
        mtype = _props.dataShape.primaryAxis[0];
        if (mtype === undefined || mtype === null) {
          mtype = _props.defaultShape;
        }
        if (_module[mtype] === undefined) {
          _module[mtype] = {};
        }
        _module[mtype].data = _rawdata;
        _props.MNDOnCategory = true;
      } else {
        _props.MNDOnCategory = false;
        var daa1 = _rawdata.getAnalysisAxisDataByIdx(0);
        var daa2 = _rawdata.getAnalysisAxisDataByIdx(1);
        var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        for (i=0; i<dva1.values.length; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined || mtype === null) {
            mtype = _props.defaultShape;
          }
          if (_module[mtype] === undefined) {
            _module[mtype] = {m1Num:0, m2Num:0};
          }
          tm = _module[mtype];
          tm.m1Num ++;
          if (tm.data === undefined) {
            tm.data = new MultiAxesDataAdapter();
            tm.data.addAnalysisAxis(daa1);
            tm.data.addAnalysisAxis(daa2);
            tm.data.addMeasureValuesGroup({
              index: dva1.index,
              values: []
            });
            if (dva2) {
              tm.data.addMeasureValuesGroup({
                index: dva2.index,
                values: []
              });
            }
          }
          var tva1 = tm.data.getMeasureValuesGroupDataByIdx(0);
          tva1.values.push(dva1.values[i]);
        }
        
        if (dva2) {
          for (i=0; i<dva2.values.length; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined || mtype === null) {
              mtype = _props.defaultShape;
            }
            if (_module[mtype] === undefined) {
              _module[mtype] = {m1Num:0, m2Num:0};
            }
            tm = _module[mtype];
            tm.m2Num ++;
            if (tm.data === undefined) {
              tm.data = new MultiAxesDataAdapter();
              tm.data.addAnalysisAxis(daa1);
              tm.data.addAnalysisAxis(daa2);
              tm.data.addMeasureValuesGroup({
                index: dva1.index,
                values: []
              });
              if (dva2) {
                tm.data.addMeasureValuesGroup({
                  index: dva2.index,
                  values: []
                });
              }
            }
            var tva2 = tm.data.getMeasureValuesGroupDataByIdx(1);
            tva2.values.push(dva2.values[i]);
          }
        }
      }
      prepareColor();
    }
    
    function prepareColor() {
      var i, j, color, mtype, tm;
      if (_rawdata === undefined) { return; }
      
      var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
      var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
      var valueAxis1ColorPalette;
      var valueAxis2ColorPalette;

      if (dva2 && !_props.MNDOnCategory) {
        valueAxis1ColorPalette = _props.primaryValuesColorPalette;  
      }else{
        valueAxis1ColorPalette = _props.colorPalette;
      }
      
      valueAxis2ColorPalette = _props.secondaryValuesColorPalette;
      
      _colorPalette = [];
      _shapePalette = [];
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].colorPaletteY1 = [];
            _module[i].currentM1Index = -1;
            if (dva2) {
              _module[i].colorPaletteY2 = [];
              _module[i].currentM2Index = -1;
            }
        }
      }
      
      if (_props.MNDOnCategory) {
        mtype = _props.dataShape.primaryAxis[0];
        var rowslength = dva1.values[0].rows.length;
        for (j=0; j<rowslength; j++) {
          _module[mtype].colorPaletteY1.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
          _shapePalette.push(getShape(mtype));
          _colorPalette.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
        }
      } else {
        var measure1Num = dva1.values.length;
        var measure2Num = 0;
        if (dva2) {
          measure2Num = dva2.values.length;
        }
        var measureNum = measure1Num + measure2Num;
        var colorAxisDataNum = dva1.values[0].rows.length;
        for (i=0; i<measure1Num; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined || mtype === null) {
            mtype = _props.defaultShape;
          }
          tm = _module[mtype];
          tm.currentM1Index ++;
          for (j=0; j<colorAxisDataNum; j++) {
            if (_props.MNDInner) {
              color = valueAxis1ColorPalette[(i+j*measure1Num ) % valueAxis1ColorPalette.length];
              tm.colorPaletteY1[tm.currentM1Index+j*tm.m1Num] = color;
              _shapePalette[i+j*measureNum] = getShape(mtype);
              _colorPalette[i+j*measureNum] = color;
            } else {
              color = valueAxis1ColorPalette[(i*colorAxisDataNum+j) % valueAxis1ColorPalette.length];
              _module[mtype].colorPaletteY1.push(color);
              _shapePalette.push(getShape(mtype));
              _colorPalette.push(color);
            }
          }
        }

        if (dva2) {
          for (i=0; i<measure2Num; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined || mtype === null) {
              mtype = _props.defaultShape;
            }
            tm = _module[mtype];
            tm.currentM2Index ++;
            for (j=0; j<colorAxisDataNum; j++) {
              if (_props.MNDInner) {
                color = valueAxis2ColorPalette[(i+j*measure2Num ) % valueAxis2ColorPalette.length];
                tm.colorPaletteY2[tm.currentM2Index+j*tm.m2Num] = color;
                _shapePalette[measure1Num+i+j*measureNum] = getShape(mtype);
                _colorPalette[measure1Num+i+j*measureNum] = color;
              } else {
                color = valueAxis2ColorPalette[(i*colorAxisDataNum+j) % valueAxis2ColorPalette.length];
                _module[mtype].colorPaletteY2.push(color);
                _shapePalette.push(getShape(mtype));
                _colorPalette.push(color);
              }
            }
          }
        }
      } // _props.MNDOnCategory
    }
    function moduleSortHelp(a, b) {
      return (_props.priorityMap[b] - _props.priorityMap[a]);
    }
    function prepareModule() {
      var tempA = [],i;
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          tempA.push(i);
        }
      }
      tempA.sort(moduleSortHelp);

      _d3root.selectAll('.' + CLASSNAME_MODULE).remove(); //TODO: should not always remove all
      var d3modules = _d3root.selectAll('.' + CLASSNAME_MODULE).data(tempA);
      d3modules.enter().append('svg:g').attr('class', CLASSNAME_MODULE);
      d3modules.exit().remove();
      
      d3modules.each(function(d) {
        _module[d].d3root = d3.select(this);
      });
      
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].module = getModule(i); //TODO: should not always new module instance
            var hasAnimation = false;
            if(isDataLoading){
              hasAnimation = _props.animation.dataLoading;
            }else if(isDatasetChanged){
              hasAnimation = _props.animation.dataUpdating;
            }else if(isSizeChanged){
              hasAnimation = _props.animation.resizing;
            }
            var props = {
              colorPalette: _module[i].colorPaletteY1,
              primaryValuesColorPalette : _module[i].colorPaletteY1,
              tooltip : {enabled : false},
              animation : {
                dataLoading: hasAnimation
              },
              drawingEffect: _props.drawingEffect
            };
            if (_module[i].colorPaletteY2) {
              props.secondaryValuesColorPalette = _module[i].colorPaletteY2;
            }
            switch (i) {
            case 'line' :
              props.hoverline = { visible : false };
              ObjUtils.extend(props, _props.line);
              break;
            case 'bar' :
              ObjUtils.extend(props, _props.bar);
              break;
            default :
              break;
            }
            _module[i].props = props;
            _module[i].module.dispatch(new dummyDispatch(i));
        }
      }
    }

    function redraw() {
      hasAnimationEnd = false;
      var i;
      prepareModule();

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            var m = _module[i];
            m.module.width(_width).height(_height).data(m.data)
                .properties(m.props).primaryScale(_valueAxis1.scale)
                .categoryScale(_xScale);
            var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
            if (dva2) {
              switch(i) {
              case 'bar' :
                m.module.secondScale(_valueAxis2.scale); break;
              case 'line' :
                m.module.secondaryScale(_valueAxis2.scale); break;
              default:
                break;
              }
            }
            m.d3root.call(m.module);
            m.dataPointElements = [];
            m.d3root.selectAll('.v-datapoint').each(function(){m.dataPointElements.push(this);});
        }
      }
 
      if(hasAnimationEnd)
      {
          _eDispatch.initialized();
      }
      else
      {
        var timeInterval = 20;
        var totalTime = 0;
        var maxTime = 5000;

        var func = setInterval(function(){
          if(hasAnimationEnd || totalTime > maxTime)
          {
            clearInterval(func);
            _eDispatch.initialized();
          }
          else
          {
            totalTime += timeInterval;
          }
        },
        timeInterval);
      }
    }

    function getCategoryIndex(val)
    {
      var index = val / _xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (_valueAxis1.data.length !== 0) {
        categoryNum = _valueAxis1.data[0].length;
      } else {
        categoryNum = _valueAxis2.data[0].length;
      }
      if(index > categoryNum - 1) {index = categoryNum - 1;}
      if(index < 0) { index = 0;}
      return index;
    }

      function computeScales() {
          var domain = [];
          var categoryNum = 0;
          if (_props.MNDOnCategory) {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum += _valueAxis1.data[0].length;
            }
            if (_valueAxis2.data && _valueAxis2.data.length > 0) {
              categoryNum += _valueAxis2.data[0].length;
            }        
          } else {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum = _valueAxis1.data[0].length;
            } else {
              categoryNum = _valueAxis2.data[0].length;  
            }
          }
          for (var i=0; i < categoryNum; i++) {
             domain.push(i);
          }      
          _xScale.domain(domain).rangeBands([0, _width]);

          calculateScale(_valueAxis1, _valueAxis1.scale);
          calculateScale(_valueAxis2, _valueAxis2.scale);

        if (_valueAxis1.data && _valueAxis1.data.length > 0 &&
            _valueAxis2.data && _valueAxis2.data.length > 0 ) {
          if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([_height, 0]); 
            _valueAxis2.scale.domain([0, 1]).range ([_height, 0]); 
          } else if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length !== 0){
            _valueAxis1.scale.domain(_valueAxis2.scale.domain()).range(_valueAxis2.scale.range());
          } else if(_valueAxis1.scale.domain().length !== 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain(_valueAxis1.scale.domain()).range(_valueAxis1.scale.range());
          }

          if (!_valueAxis1.manualRange && !_valueAxis2.manualRange) {
              Scaler.perfectDual(_valueAxis1.scale, _valueAxis2.scale);
          } else if (!_valueAxis1.manualRange) {
              Scaler.perfect(_valueAxis1.scale);
              Scaler.getRoughTickNum(_valueAxis2.scale);
          } else if (!_valueAxis2.manualRange) {
              Scaler.perfect(_valueAxis2.scale);
              Scaler.getRoughTickNum(_valueAxis1.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis1.scale);
            Scaler.getRoughTickNum(_valueAxis2.scale);
          }
        } else if (_valueAxis1.data && _valueAxis1.data.length > 0) {
          if(_valueAxis1.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([_height, 0]);
          }
          if (!_valueAxis1.manualRange) {
            Scaler.perfect(_valueAxis1.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis1.scale);
          }
        } else if (_valueAxis2.data && _valueAxis2.data.length > 0) {
          if(_valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain([0, 1]).range ([_height, 0]);
          }
          if (!_valueAxis2.manualRange) {
            Scaler.perfect(_valueAxis2.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis2.scale);
          }
        }
      }

    function calculateScale(axisValue, scale) {
        if(axisValue.data && axisValue.data.length > 0) {
            if(axisValue.topValue === undefined) {
              var minMax = calculateMinMax(axisValue);
              if(!minMax||(minMax.min === 0 && minMax.max === 0)) {
                scale.domain([]).range ([]);             
              }else{
                scale.domain([minMax.min, minMax.max]).range ([_height, 0]);                
              }
            } else {
              scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([_height, 0]);
            }
        } else {
          scale.domain([0,0]).range(0,0);
        }
      }

    function getProperty() {
      var temp = {};
      temp.tooltip = {enabled:  _props.tooltip.enabled};
      temp.primaryValuesColorPalette = _props.primaryValuesColorPalette;
      temp.secondaryValuesColorPalette = _props.secondaryValuesColorPalette;
      temp.colorPalette = _props.colorPalette;
      temp.drawingEffect = _props.drawingEffect;
      temp.animation = {};
      ObjUtils.extend(true, temp.animation, _props.animation);
      temp.dataShape = {};
      ObjUtils.extend(true, temp.dataShape, _props.dataShape);
      temp.bar = {};
      ObjUtils.extend(true, temp.bar, _props.bar);
      temp.line = {};
      ObjUtils.extend(true, temp.line, _props.line);
  
      return temp;
    }

    function setProperty (props) {
      _props.tooltip = {enabled: props.tooltip.enabled};
      _props.primaryValuesColorPalette = props.primaryValuesColorPalette;
      _props.secondaryValuesColorPalette = props.secondaryValuesColorPalette;
      _props.drawingEffect = props.drawingEffect;
      _props.colorPalette = props.colorPalette;
      _props.animation = {};
      ObjUtils.extend(true, _props.animation, props.animation);
      _props.dataShape = {};
      ObjUtils.extend(true, _props.dataShape, props.dataShape);
      _props.bar = {};
      ObjUtils.extend(true, _props.bar, props.bar);
      _props.line = {};
      ObjUtils.extend(true, _props.line, props.line);

      return _props;
    }
    function getModule(mtype) {
      var result;
      switch (mtype) {
      case 'bar':
        result = ModuleManifest.get("sap.viz.modules.verticalbar"); break;
      case 'line':
        result = ModuleManifest.get("sap.viz.modules.line"); break;
      default:
        break;
      }
      return result.execute(ctx);
    }
    
    function getShape(mtype) {
      var result;
      switch (mtype) {
      case 'line':
        result = _props.line.marker.shape;
        break;
      case 'bar':
        result = 'squareWithRadius'; break;
      default:
        break;
      }
      return result;
    }

    function isExist(ao, element) {
      for (var n=0; n<ao.length; n++) {
        if (ao[n] === element) {
          return true;
        }
      }
      return false;
    }

    function calculateMinMax(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0) {
        return null;
      }
      var minMax = {
          min: null,
          max: null
      };
      minMax.max = d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      });
      minMax.min = d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      });
      if(NumberUtils.isNoValue(minMax.max )) { 
        return null;
       }
      if(minMax.min >= 0) {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / _height ;
      } else if(minMax.max <= 0) {
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ _height;
      } else {
        var temp = (minMax.max - minMax.min) * 5 / _height;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }
    setProperty(manifest.props(null));
    return module;
  };
  return combination;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.combination',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {

  var module = {
    base : "sap.viz.modules.xy.base",
    'id' : 'sap.viz.modules.combination',
    'name' : 'combination',
    'properties' : {
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
      },
      'dataShape' : {
          'name' : 'dataShape',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'primaryAxis' : {
              'name' : 'primaryAxis',
              'supportedValueType' : 'StringArray',
              'supportedValues' : [ 'bar', 'line' ],
              'defaultValue' : [ 'bar', 'line', 'line'],
              'description' : 'Set shape of measure index1 data.'
            },
            'secondAxis' : {
              'name' : 'secondAxis',
              'supportedValueType' : 'StringArray',
              'supportedValues' : [ 'line', 'line' ],
              'defaultValue' : [ 'line', 'line', 'line'],
              'description' : 'Set shape of measure index2 data.',
                'isExported': true
            }
          },
          'description' : 'Set shape of measure data.'
      },
      'bar' : {
          'name' : 'bar',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'isRoundCorner' : {
            'name' : 'isRoundCorner',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set enable/disable round corner of bar.'
          }
          },
          'description' : 'Settings for bar properties.'     
      }, //bar
      'line' : {
          'name' : 'line',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'width' : {
            'name' : 'width',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : 2,
            'description' : 'Set width of line, range[1,7]. When beyond the range, the line width is default size 2.'
            },
            'marker' : {
                'name' : 'marker',
                'description' : 'Set marker/data point graphics settings.',
                'supportedValueType' : 'Object',
                'supportedValues' : {
                    'visible' : {
                      'name' : 'visible',
                      'supportedValueType' : 'Boolean',
                      'defaultValue' : false,
                      'description' : 'Set to show marker or not.'
                    },
                    'shape' : {
                      'name' : 'shape',
                      'supportedValueType' : 'StringArray',
                      'supportedValues' : ['circle', 'diamond', 'triangleUp', 'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection'],
                      'defaultValue' : 'circle',
                      'description' : 'Set marker shapes for chart.'
                    },
                    'size' : {
                      'name' : 'size',
                      'supportedValueType' : 'PositiveInt',
                      'defaultValue' : "6",
                      'min' : '4',
                      'max' : '32',
                      'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 6.'
                    }
                }
            }
          },
          'description' : 'Settings for line properties.'
      } //line
    }, 
    css : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
              'value' : {
                'fill' : '#cccccc'
              }
        }
    },
    fn : fn
  
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalcombination',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
}
],
function Setup(dispatch, Manifest, ColorSeries, MNDHandler, TypeUtils, ObjUtils, MultiAxesDataAdapter, TooltipDataHandler, Scaler, NumberUtils, Objects, langManager, BoundUtil, dataUtil) {
  var combination = function(manifest, ctx) {
    function module(selection) {
      _tooltipDataHandler = TooltipDataHandler();
      BoundUtil.drawBound(selection, _width, _height);
      selection.each(
        function(inputData) {
          if (inputData !== undefined) {
            prepareData(inputData);
          }
          _d3root = d3.select(this);
          
          redraw();
        }
      );//each
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return module;
    }

    /**
     * set/get width
     */
    module.width = function(_) {
      if (!arguments.length) {
        return _width;
      }
      isSizeChanged = (!isSizeChanged && (_ === _width)) ? false : true;
      _width =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    /**
     * set/get height
     */
    module.height = function(_) {
      if (!arguments.length) {
        return _height;
      }
      isSizeChanged = (!isSizeChanged && (_ === _height)) ? false : true;
      _height =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };
    
    module.afterUIComponentAppear = function(){
      _eDispatch.initialized(); 
    };
    /**
     * set/get size
     * 
     * @param {Object}
     *            {'width':Num, 'height':Num}
     */
    module.size = function(_) {
      if (!arguments.length) {
        return {
          width : _width,
          height: _height
        };
      }
      _width = _.width;
      _height = _.height;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      return module;
    };

    /**
     * set/get properties
     */
    module.properties = function(_) {
      if (!arguments.length) {
        return getProperty();
      }
      setProperty(Objects.extend(true, getProperty(), _));
      prepareData(_rawdata, true);
      return module;
    };
    
    module.dataLabel = function(_){};
    /**
     * set/get data
     */
    module.data = function(_) {
      if (!arguments.length) {
        return _rawdata;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(_rawdata, _)){
        isDataSchemaChanged = true;
      }
      prepareData(_);
      return module;
    };

    module.primaryAxisTitle = function(_){
        if(!arguments.length) {
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      module.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
     
      module.dispatch = function(_){
        if(!arguments.length) {
          return _eDispatch;
        }
        _eDispatch = _;
        return module;
      };

      module.primaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis1.scale;
        }
        _valueAxis1.scale = scale;
        return module;
      };
      
      module.secondaryScale = function(scale)
      {
        if(!arguments.length) {
          return _valueAxis2.scale;
        }
        _valueAxis2.scale = scale;
        return module;
      };
      
      module.categoryScale = function(scale)
      {
        if(!arguments.length) {
          return _xScale;
        }
        _xScale = scale;
        return module;
      };

    module.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis1.scale.domain()[0],
          max: _valueAxis1.scale.domain()[1]
        };
      }
      
      if (range !== null) {
          _valueAxis1.topValue = range.max;
          _valueAxis1.bottomValue = range.min;
          if (range.from === 'axis') {
            _valueAxis1.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis1, _valueAxis1.scale);
          }
      }
      return module;
    };

    module.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: _valueAxis2.scale.domain()[0],
          max: _valueAxis2.scale.domain()[1]
        };
      }
      if (range !== null) {
          _valueAxis2.topValue = range.max;
          _valueAxis2.bottomValue = range.min;
          if (range.from === 'axis') {
            _valueAxis2.manualRange = true;
          }
          if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)){
            calculateScale(_valueAxis2, _valueAxis2.scale);
          }
      }
      return module;
    };

    module.primaryAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.primaryValuesColorPalette[0];
      } else {
        return null;
      }
    };
    
    module.secondAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.secondaryValuesColorPalette[0];
      } else {
        return null;
      }
    };

      module.colorPalette = function(Palette){
        if (!arguments.length){
          return _colorPalette;
         }
         return module;
      };

      module.shapePalette = function(Palette){
        if (!arguments.length){
          return _shapePalette;
         }
         return module;
      };

    module.parent = function () {
      return _d3root;
    };
    
    module.clear = function (gray) {
      for (var i in _module)
      {
        if (gray === undefined) {
          _module[i].module.clear();
        } else {
          _module[i].module.clear('grayall');
        }
      }
    };

    module.highlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      if (elementArray.length === 0) {
        return;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].highlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].highlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.highlight(_module[i].highlightArray);
        }
      }
    };

    module.unhighlight = function (elements) {
      var i, j;
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }    
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].unhighlightArray = [];
        }
      }

      for (i=0; i<elementArray.length; i++) {
        var element = elementArray[i];
        for (j in _module) {
          if (_module.hasOwnProperty(j)) {
              var dpa = _module[j].dataPointElements;
              if (isExist(dpa, element)) {
                _module[j].unhighlightArray.push(element);
                break;
              }
          }
        }
      }

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.unhighlight(_module[i].unhighlightArray);
        }
      }
    };
    
    module.hoverOnPoint = function( point ) {
      var i;
      if (_props.tooltip.enabled) {
        var point0= point.x, point1 = point.y;
  
        if(point1 < 0 || point1 > _height) {
          return;
        }
        var xIndex = getCategoryIndex(point1);
        if(_preMouseMoveXIndex === xIndex) {
          return;
        }
        _preMouseMoveXIndex = xIndex;

        var tData = _tooltipDataHandler.generateTooltipData(_rawdata, 
                                   _tooltipdata, 
                                   xIndex, 
                                   _colorPalette, 
                                   _shapePalette);
        var matrix = _d3root.node().getTransformToElement(_d3root.node().ownerSVGElement);
        tData.point = {
            y: (_height - _xScale.rangeBand()*(xIndex + 0.5)) + matrix.f,
            x: _width*3/4 + matrix.e
        };
        _eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.hoverOnPoint(point);
        }
      }
      return true;
    };

    module.blurOut = function( ) {
      var i;
      if (_props.tooltip.enabled) {
        _eDispatch.hideTooltip();
        _preMouseMoveXIndex = -1;
      }
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          _module[i].module.blurOut();
        }
      }      
      return true;
    };  

      var _xScale = d3.scale.ordinal(),
        _valueAxis1 = {
        scale: d3.scale.linear()
      },
      _valueAxis2 = {
        scale: d3.scale.linear()
      };

    
    //private field
    var _tooltipDataHandler;
    var _eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    //property
    var _width, _height;
    var _props = {
      priorityMap : {
        'bar' : 5,
        'line' : 0
      },
      defaultShape : 'line',
      MNDOnCategory : false,
      MNDInner : false
    };
    
    var _effectManager = ctx.effectManager;
    
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    //data
    var _rawdata, _tooltipdata;
    var _d3root;
    var _colorPalette, _shapePalette;
    
    //module
    var _module;

    var _preMouseMoveXIndex = -1;

    var dummyDispatch = function (_) {
      this.mtype = _;
    };
    dummyDispatch.prototype.initialized = function() {
      _dummyDispatchHelper.initialized(this.mtype);
    };
    dummyDispatch.prototype.startToInit = function() {
      _eDispatch.startToInit();
    };

    var _dummyDispatchHelper = {
      initialized : function(mtype) {
        var i;
        if (_module[mtype]) {
          _module[mtype].isCompleteAnimation = true;
        }
        for (i in _module) {
          if (!_module[i].isCompleteAnimation) {
            return true;
          }
        }
        _eDispatch.initialized();
        return true;
      }
    };

    function init() {
      //TODO: should destroy useless module here(stop animation of useless module)
      _module = {};
    }
    function prepareData ( rawdata , isMandatory ) {
      var i, j, mtype, tm;
      if ((rawdata === null) || (rawdata === undefined) || (!isMandatory && (_rawdata === rawdata))) {
        return;
      }

      init();
      _rawdata = rawdata;

       var obj = MNDHandler(_rawdata );
      _props.MNDInner = obj.MNDInner;
      _valueAxis1.data = obj['MG1'];
      _valueAxis2.data = obj['MG2'];
      _tooltipdata = TooltipDataHandler.dataTransform(obj);

      if (obj.color) {
        var tempData = obj['MG1'];
        var data0 = [];
        var data1 = [];
        for (i=0; i<tempData.length; i++) {
          var temp0 = [];
          var temp1 = [];
          var temp = tempData[i];
          for (j=0; j<temp.length; j++) {
            if (obj.color[j] === 0) {
              temp0.push(temp[j]);
            } else if (obj.color[j] === 1) {
              temp1.push(temp[j]);
            }
          }
          data0.push(temp0);
          data1.push(temp1);
        }
        _valueAxis1.data = data0;
        _valueAxis2.data = data1;
      }
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata)) {
        computeScales();
      }
      if (obj.hasMND && !obj.MNDOnColor) {
        mtype = _props.dataShape.primaryAxis[0];
        if (mtype === undefined || mtype === null) {
          mtype = _props.defaultShape;
        }
        if (_module[mtype] === undefined) {
          _module[mtype] = {};
        }
        _module[mtype].data = _rawdata;
        _props.MNDOnCategory = true;
      } else {
        _props.MNDOnCategory = false;
        var daa1 = _rawdata.getAnalysisAxisDataByIdx(0);
        var daa2 = _rawdata.getAnalysisAxisDataByIdx(1);
        var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        for (i=0; i<dva1.values.length; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined || mtype === null) {
            mtype = _props.defaultShape;
          }
          if (_module[mtype] === undefined) {
            _module[mtype] = {m1Num:0, m2Num:0};
          }
          tm = _module[mtype];
          tm.m1Num ++;
          if (tm.data === undefined) {
            tm.data = new MultiAxesDataAdapter();
            tm.data.addAnalysisAxis(daa1);
            tm.data.addAnalysisAxis(daa2);
            tm.data.addMeasureValuesGroup({
              index: dva1.index,
              values: []
            });
            if (dva2) {
              tm.data.addMeasureValuesGroup({
                index: dva2.index,
                values: []
              });
            }
          }
          var tva1 = tm.data.getMeasureValuesGroupDataByIdx(0);
          tva1.values.push(dva1.values[i]);
        }
        
        if (dva2) {
          for (i=0; i<dva2.values.length; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined || mtype === null) {
              mtype = _props.defaultShape;
            }
            if (_module[mtype] === undefined) {
              _module[mtype] = {m1Num:0, m2Num:0};
            }
            tm = _module[mtype];
            tm.m2Num ++;
            if (tm.data === undefined) {
              tm.data = new MultiAxesDataAdapter();
              tm.data.addAnalysisAxis(daa1);
              tm.data.addAnalysisAxis(daa2);
              tm.data.addMeasureValuesGroup({
                index: dva1.index,
                values: []
              });
              if (dva2) {
                tm.data.addMeasureValuesGroup({
                  index: dva2.index,
                  values: []
                });
              }
            }
            var tva2 = tm.data.getMeasureValuesGroupDataByIdx(1);
            tva2.values.push(dva2.values[i]);
          }
        }
      }
      prepareColor();
    }
    
    function prepareColor() {
      var i, j, color, mtype, tm;
      if (_rawdata === undefined) { return; }
      
      var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
      var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
      var valueAxis1ColorPalette;
      var valueAxis2ColorPalette;

      if (dva2 && !_props.MNDOnCategory) {
        valueAxis1ColorPalette = _props.primaryValuesColorPalette;  
      }else{
        valueAxis1ColorPalette = _props.colorPalette;
      }
      
      valueAxis2ColorPalette = _props.secondaryValuesColorPalette;
      
      _colorPalette = [];
      _shapePalette = [];
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].colorPaletteY1 = [];
            _module[i].currentM1Index = -1;
            if (dva2) {
              _module[i].colorPaletteY2 = [];
              _module[i].currentM2Index = -1;
            }
        }
      }
      
      if (_props.MNDOnCategory) {
        mtype = _props.dataShape.primaryAxis[0];
        var rowslength = dva1.values[0].rows.length;
        for (j=0; j<rowslength; j++) {
          _module[mtype].colorPaletteY1.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
          _shapePalette.push(getShape(mtype));
          _colorPalette.push(valueAxis1ColorPalette[(j) % valueAxis1ColorPalette.length]);
        }
      } else {
        var measure1Num = dva1.values.length;
        var measure2Num = 0;
        if (dva2) {
          measure2Num = dva2.values.length;
        }
        var measureNum = measure1Num + measure2Num;
        var colorAxisDataNum = dva1.values[0].rows.length;
        for (i=0; i<measure1Num; i++) {
          mtype = _props.dataShape.primaryAxis[i];
          if (mtype === undefined || mtype === null) {
            mtype = _props.defaultShape;
          }
          tm = _module[mtype];
          tm.currentM1Index ++;
          for (j=0; j<colorAxisDataNum; j++) {
            if (_props.MNDInner) {
              color = valueAxis1ColorPalette[(i+j*measure1Num ) % valueAxis1ColorPalette.length];
              tm.colorPaletteY1[tm.currentM1Index+j*tm.m1Num] = color;
              _shapePalette[i+j*measureNum] = getShape(mtype);
              _colorPalette[i+j*measureNum] = color;
            } else {
              color = valueAxis1ColorPalette[(i*colorAxisDataNum+j) % valueAxis1ColorPalette.length];
              _module[mtype].colorPaletteY1.push(color);
              _shapePalette.push(getShape(mtype));
              _colorPalette.push(color);
            }
          }
        }

        if (dva2) {
          for (i=0; i<measure2Num; i++) {
            mtype = _props.dataShape.secondAxis[i];
            if (mtype === undefined || mtype === null) {
              mtype = _props.defaultShape;
            }
            tm = _module[mtype];
            tm.currentM2Index ++;
            for (j=0; j<colorAxisDataNum; j++) {
              if (_props.MNDInner) {
                color = valueAxis2ColorPalette[(i+j*measure2Num ) % valueAxis2ColorPalette.length];
                tm.colorPaletteY2[tm.currentM2Index+j*tm.m2Num] = color;
                _shapePalette[measure1Num+i+j*measureNum] = getShape(mtype);
                _colorPalette[measure1Num+i+j*measureNum] = color;
              } else {
                color = valueAxis2ColorPalette[(i*colorAxisDataNum+j) % valueAxis2ColorPalette.length];
                _module[mtype].colorPaletteY2.push(color);
                _shapePalette.push(getShape(mtype));
                _colorPalette.push(color);
              }
            }
          }
        }
      } // _props.MNDOnCategory
    }
    function moduleSortHelp(a, b) {
      return (_props.priorityMap[b] - _props.priorityMap[a]);
    }
    function prepareModule() {
      var tempA = [],i;
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
          tempA.push(i);
        }
      }
      tempA.sort(moduleSortHelp);
      
      _d3root.selectAll('.module').remove(); //TODO: should not always remove all
      var d3modules = _d3root.selectAll('.module').data(tempA);
      d3modules.enter().append('svg:g').attr('class', 'module');
      d3modules.exit().remove();
      
      d3modules.each(function(d) {
        _module[d].d3root = d3.select(this);
      });
      
      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            _module[i].module = getModule(i); //TODO: should not always new module instance
            var hasAnimation = false;
            if(isDataLoading){
              hasAnimation = _props.animation.dataLoading;
            }else if(isDatasetChanged){
              hasAnimation = _props.animation.dataUpdating;
            }else if(isSizeChanged){
              hasAnimation = _props.animation.resizing;
            }
            var props = {
              colorPalette : _module[i].colorPaletteY1,
              primaryValuesColorPalette : _module[i].colorPaletteY1,
              tooltip : {enabled : false},
              animation : {
                dataLoading: hasAnimation
              },
              drawingEffect: _props.drawingEffect
            };
            if (_module[i].colorPaletteY2) {
              props.secondaryValuesColorPalette = _module[i].colorPaletteY2;
            }
            switch (i) {
            case 'line' :
              props.hoverline = { visible : false };
              ObjUtils.extend(props, _props.line);
              break;
            case 'bar' :
              ObjUtils.extend(props, _props.bar);
              break;
            default :
              break;
            }
            _module[i].props = props;
            _module[i].module.dispatch(new dummyDispatch(i));
        }
      }
    }

    function redraw() {
      var i;
      prepareModule();

      for (i in _module) {
        if (_module.hasOwnProperty(i)) {
            var m = _module[i];
            m.module.width(_width).height(_height).data(m.data)
                .properties(m.props).primaryScale(_valueAxis1.scale)
                .categoryScale(_xScale);
            var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
            if (dva2) {
              switch(i) {
              case 'bar' :
                m.module.secondScale(_valueAxis2.scale); break;
              case 'line' :
                m.module.secondaryScale(_valueAxis2.scale); break;
              default:
                break;
              }
            }
            m.d3root.call(m.module);
            m.dataPointElements = [];
            m.d3root.selectAll('.v-datapoint').each(function(){m.dataPointElements.push(this);});
        }
      }
    }

    function getCategoryIndex(val)
    {
      var categoryNum = _xScale.domain().length;
      var index = val / _xScale.rangeBand();
        index = Math.floor(index);
       
      return categoryNum - 1 - index;
    }

      function computeScales() {
          var domain = [];
          var categoryNum = 0;
          if (_props.MNDOnCategory) {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum += _valueAxis1.data[0].length;
            }
            if (_valueAxis2.data && _valueAxis2.data.length > 0) {
              categoryNum += _valueAxis2.data[0].length;
            }        
          } else {
            if (_valueAxis1.data && _valueAxis1.data.length > 0) {
              categoryNum = _valueAxis1.data[0].length;
            } else {
              categoryNum = _valueAxis2.data[0].length;  
            }
          }
          for (var i=0; i < categoryNum; i++) {
             domain.push(i);
          }      
          _xScale.domain(domain).rangeBands([_height, 0]);

          calculateScale(_valueAxis1, _valueAxis1.scale);
          calculateScale(_valueAxis2, _valueAxis2.scale);

          if (_valueAxis1.data && _valueAxis1.data.length > 0 &&
              _valueAxis2.data && _valueAxis2.data.length > 0 ) {
          if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([0,_width]); 
            _valueAxis2.scale.domain([0, 1]).range ([0,_width]); 
          } else if(_valueAxis1.scale.domain().length === 0 && _valueAxis2.scale.domain().length !== 0){
            _valueAxis1.scale.domain(_valueAxis2.scale.domain()).range(_valueAxis2.scale.range());
          } else if(_valueAxis1.scale.domain().length !== 0 && _valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain(_valueAxis1.scale.domain()).range(_valueAxis1.scale.range());
          }

          if (!_valueAxis1.manualRange && !_valueAxis2.manualRange) {
              Scaler.perfectDual(_valueAxis1.scale, _valueAxis2.scale);
          } else if (!_valueAxis1.manualRange) {
              Scaler.perfect(_valueAxis1.scale);
              Scaler.getRoughTickNum(_valueAxis2.scale);
          } else if (!_valueAxis2.manualRange) {
              Scaler.perfect(_valueAxis2.scale);
              Scaler.getRoughTickNum(_valueAxis1.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis1.scale);
            Scaler.getRoughTickNum(_valueAxis2.scale);
          }
        } else if (_valueAxis1.data && _valueAxis1.data.length > 0) {
          if(_valueAxis1.scale.domain().length === 0){
            _valueAxis1.scale.domain([0, 1]).range ([0,_width]);
          }
          if (!_valueAxis1.manualRange) {
            Scaler.perfect(_valueAxis1.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis1.scale);
          }
        } else if (_valueAxis2.data && _valueAxis2.data.length > 0) {
          if(_valueAxis2.scale.domain().length === 0){
            _valueAxis2.scale.domain([0, 1]).range ([0,_width]);
          }
          if (!_valueAxis2.manualRange) {
            Scaler.perfect(_valueAxis2.scale);
          } else {
            Scaler.getRoughTickNum(_valueAxis2.scale);
          }
        }
      }

    function calculateScale(axisValue, scale) {
        if(axisValue.data && axisValue.data.length > 0) {
            if(axisValue.topValue === undefined) {
              var minMax = calculateMinMax(axisValue);
              if(!minMax || ( minMax.min === 0 && minMax.max === 0)) {
                scale.domain([]).range ([]); 
              } else {
                scale.domain([minMax.min, minMax.max]).range ([0, _width]);
              }
            } else {
              scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([0, _width]);
            }
        } else {
          scale.domain([0,0]).range(0,0);
        }
      }

    function getProperty() {
      var temp = {};
      temp.tooltip = {enabled: _props.tooltip.enabled};
      temp.primaryValuesColorPalette = _props.primaryValuesColorPalette;
      temp.secondaryValuesColorPalette = _props.secondaryValuesColorPalette;
      temp.colorPalette = _props.colorPalette;
      temp.drawingEffect = _props.drawingEffect;
      temp.animation = {};
      ObjUtils.extend(true, temp.animation, _props.animation);
      temp.dataShape = {};
      ObjUtils.extend(true, temp.dataShape, _props.dataShape);
      temp.bar = {};
      ObjUtils.extend(true, temp.bar, _props.bar);
      temp.line = {};
      ObjUtils.extend(true, temp.line, _props.line);
  
      return temp;
    }

    function setProperty (props) {
      _props.tooltip = {enabled: props.tooltip.enabled};
      _props.primaryValuesColorPalette = props.primaryValuesColorPalette;
      _props.secondaryValuesColorPalette = props.secondaryValuesColorPalette;
      _props.drawingEffect = props.drawingEffect;
      _props.colorPalette = props.colorPalette;
      _props.animation = {};
      ObjUtils.extend(true, _props.animation, props.animation);
      _props.dataShape = {};
      ObjUtils.extend(true, _props.dataShape, props.dataShape);
      _props.bar = {};
      ObjUtils.extend(true, _props.bar, props.bar);
      _props.line = {};
      ObjUtils.extend(true, _props.line, props.line);

      return _props;
    }

    function getModule(mtype) {
      var result;
      switch (mtype) {
      case 'bar':
        result = Manifest.module.get("sap.viz.modules.bar"); break;
      case 'line':
        result = Manifest.module.get("sap.viz.modules.horizontalline"); break;
      default:
        break;
      }
      return result.fn(result, ctx);
    }
    
    function getShape(mtype) {
      var result;
      switch (mtype) {
      case 'line':
        result = _props.line.marker.shape;
        break;
      case 'bar':
        result = 'squareWithRadius'; break;
      default:
        break;
      }
      return result;
    }

    function isExist(ao, element) {
      for (var n=0; n<ao.length; n++) {
        if (ao[n] === element) {
          return true;
        }
      }
      return false;
    }

    function calculateMinMax(axisValue)
    {
      if(!axisValue.data || axisValue.data.length === 0) {
        return null;
      }
      var minMax = {
          min: null,
          max: null
      };
      minMax.max = d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      });
      minMax.min = d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      });
      if(NumberUtils.isNoValue(minMax.max )) {
        return null;
      }
      if(minMax.min >= 0) {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / _width;
      } else if(minMax.max <= 0) {
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ _width;
      } else {
        var temp = (minMax.max - minMax.min) * 5 / _width;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }
    setProperty(manifest.props(null));
    return module;
  };
  return combination;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.horizontalcombination',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.2'
}
],
function Setup(Manifest, fn) {

  var module = {
    base : "sap.viz.modules.combination",
    'id' : 'sap.viz.modules.horizontalcombination',
    'name' : 'horizontalcombination',
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.line',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(dataUtil, dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, ObjectUtils, Objects,UADetector,BoundUtil, defaultSelUtil) 
{
  return function(manifest, ctx) 
  {
    var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint";
    var width, height;
    var data_ = null, props;
    //alistar zhu
    var randomSuffix = ObjectUtils.guid();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";

    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgLinesGroup, svgLightLinesGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized','startToInit');
    var hasMND;
    var bMNDOnColor;
    var bMNDInner;
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };

    var valueAxis2Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };
    var colorPalette = [];
    var PREFIXAXIS1 = 'v-axis1';
    var PREFIXAXIS2 = 'v-axis2';

    var bAnimationComplete = false;
    var hasDefaultSelection = false;
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    var selectedMarkerNum = 0;
    var gSelection = null;

    // clip defs for enimation

    var clipRect;
    var OPACITY = 0.4;

    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(isDataLoading){
        hasAnmation = props.animation.dataLoading;
      }else if(isDatasetChanged){
        hasAnmation = props.animation.dataUpdating;
      }else if(isSizeChanged){
        hasAnmation = props.animation.resizing;
      }
      return hasAnmation;
    }

    function line(selection) {
      BoundUtil.drawBound(selection, width, height);
      //selection.each(generate);
      
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return line;
    }

  
    


    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return null;
      }
      minMax.max = Number(d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      }));
      minMax.min = Number(d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      }));
      
      if(NumberUtils.isNoValue(minMax.max )) { 
          return null;
        }
      
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / height ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ height;
      }else{
        var temp = (minMax.max - minMax.min) * 5 / height;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
        valueAxis1Data.colorPalette = props.primaryValuesColorPalette;
      } else {
        valueAxis1Data.colorPalette = props.colorPalette;
      }

      valueAxis2Data.colorPalette = props.secondaryValuesColorPalette;
      
      if (hasMND && bMNDOnColor && bMNDInner) {
        var dva1 = data_.getMeasureValuesGroupDataByIdx(0);
        var dva2 = data_.getMeasureValuesGroupDataByIdx(1);
        var mg1mNum=0, mg2mNum=0, mNum=0, colorAxisDataNum=0;
        if (dva1 && dva1.values.length>0) { 
          mg1mNum = dva1.values.length;
          colorAxisDataNum = dva1.values[0].rows.length;
        }
        if (dva2 && dva2.values.length>0) {
          mg2mNum = dva2.values.length;
          colorAxisDataNum = dva2.values[0].rows.length;
        }

        for (i=0; i<colorAxisDataNum; i++) {
          for (j=0; j<mg1mNum; j++) {
            colorPalette.push(valueAxis1Data.colorPalette[i*mg1mNum+j % valueAxis1Data.colorPalette.length]);
          }
          for (j=0; j<mg2mNum; j++){
            colorPalette.push(valueAxis2Data.colorPalette[i*mg2mNum+j % valueAxis2Data.colorPalette.length]);
          }
        }
      } else {
        for(i = 0; i < valueAxis1Data.data.length; ++i){
          colorPalette.push(valueAxis1Data.colorPalette[i % valueAxis1Data.colorPalette.length]);
        }
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        {
          for(i = 0; i < valueAxis2Data.data.length; ++i){
            colorPalette.push(valueAxis2Data.colorPalette[i % valueAxis2Data.colorPalette.length]);
          }
        }
      }
    }

    function calculateScale(axisValue)
    {
      if(axisValue.data && axisValue.data.length > 0)
      {
        if(axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          //when all data is 0 or null ,we make axisValue.scale.domain(0,1)
          if(!minMax || (minMax.min === 0 && minMax.max === 0)) {
            axisValue.scale.domain([]).range ([]);
          }
          else  {
            axisValue.scale.domain([minMax.min, minMax.max]).range ([height, 0]);
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([height, 0]);
        }

      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      var domain = [];
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([0, width]);
      calculateScale(valueAxis1Data);
      calculateScale(valueAxis2Data);

      if (valueAxis1Data.data && valueAxis1Data.data.length > 0 &&
            valueAxis2Data.data && valueAxis2Data.data.length > 0 ) {
        if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([height, 0]); 
          valueAxis2Data.scale.domain([0, 1]).range ([height, 0]); 
        } else if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length !== 0){
          valueAxis1Data.scale.domain(valueAxis2Data.scale.domain()).range(valueAxis2Data.scale.range());
        } else if(valueAxis1Data.scale.domain().length !== 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain(valueAxis1Data.scale.domain()).range(valueAxis1Data.scale.range());
        }
        
        if (!valueAxis1Data.manualRange && !valueAxis2Data.manualRange) {
            Scaler.perfectDual(valueAxis1Data.scale, valueAxis2Data.scale);
        } else if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        } else if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
            Scaler.getRoughTickNum(valueAxis1Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis1Data.scale);
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        }
      } else if (valueAxis1Data.data && valueAxis1Data.data.length > 0) {
        if(valueAxis1Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([height, 0]);
        }
        if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis1Data.scale);
        }
      } else if (valueAxis2Data.data && valueAxis2Data.data.length > 0) {
        if(valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain([0, 1]).range ([height, 0]);
        }
        if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        }
      }
    }

    function changeGroupMarker(groupIndex, visible, className)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }
      
      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis1Data);
        }
      }  

      if(!valueAxis2Data.data) {return;}

      for(seriesIndex = 0; seriesIndex < valueAxis2Data.data.length; ++seriesIndex)
      {
        if(!valueAxis2Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis2Data);
        }
      }
    }
   
    function lightLine(seriesIndex, xIndex, visible, valueAxis)
    {
      if(!valueAxis.highLines[seriesIndex])
      {
        valueAxis.highLines[seriesIndex] = [];
      }
      if(!valueAxis.highLines[seriesIndex][xIndex] && visible === "visible")
      {
        var d1 = valueAxis.data[seriesIndex][xIndex].val;
        var d2 = valueAxis.data[seriesIndex][xIndex + 1].val;
        valueAxis.highLines[seriesIndex][xIndex] = svgLightLinesGroup.append("svg:line").attr("class", "v-lightLine")
           .attr("x1",  xScale(xIndex) + xScale.rangeBand() / 2).attr("y1",valueAxis.scale(d1))
           .attr("x2",xScale(xIndex + 1) + xScale.rangeBand() / 2).attr("y2", valueAxis.scale(d2))
           .attr("stroke-width", props.width).attr("stroke",  
                 valueAxis.colorPalette[seriesIndex %  valueAxis.colorPalette.length]).attr("visibility", "hidden");
       }
       if(valueAxis.highLines[seriesIndex][xIndex])
       {
         valueAxis.highLines[seriesIndex][xIndex].attr("visibility", visible);
       }
    }

    function changeOneMarker(seriesIndex, xIndex, className, valueAxis)
    {
      var stroke, tempOpacity;

      if (className === CLASSMARKERSELECTED) {
        stroke = selectedColor;
        tempOpacity = 1;
        if(xIndex > 0 && valueAxis.selectedMarkers[seriesIndex][xIndex - 1]){
           lightLine(seriesIndex, xIndex - 1, "visible", valueAxis);
        }
        if(xIndex < valueAxis.markers[0].length - 1 && valueAxis.selectedMarkers[seriesIndex][xIndex + 1]) {
           lightLine(seriesIndex, xIndex, "visible", valueAxis);
        }
        valueAxis.selectedMarkers[seriesIndex][xIndex] = true;
      } else {
        if(xIndex > 0 && valueAxis.selectedMarkers[seriesIndex][xIndex - 1]) {
           lightLine(seriesIndex, xIndex - 1, "hidden", valueAxis);
        }
        if(xIndex < valueAxis.markers[0].length - 1 && valueAxis.selectedMarkers[seriesIndex][xIndex + 1]){
           lightLine(seriesIndex, xIndex, "hidden", valueAxis);
        }
        valueAxis.selectedMarkers[seriesIndex][xIndex] = false;
        if(selectedMarkerNum > 0) {
            tempOpacity = OPACITY;
        } else {
            tempOpacity = 1;
        }
        
        if (className === CLASSMARKERHOVER) {
            stroke = bgColor;
        } else {
            stroke = "transparent";
            if (props.marker.visible === false) {
                tempOpacity = 0;
            }
        }
      }
  
      d3.select(valueAxis.markers[seriesIndex][xIndex])
        .attr("class", CLASSDATAPOINT + ' ' + className).attr("stroke", stroke).attr("opacity", tempOpacity);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      if(index > categoryNum - 1) {index = categoryNum - 1;}
      if(index < 0) { index = 0;}
      return index;
    }

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }
      ++selectedMarkerNum;
      changeOneMarker(yi, xi, CLASSMARKERSELECTED, valueAxis);
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, CLASSMARKERHOVER, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, "", valueAxis);
      }

    }

    
    function processNullValue(axisValue)
    {
      var result = {
          data:[],
          color:[]
      };
      var arr = [], obj, k;

      for(var i = 0; i < axisValue.length; ++i)
      {
        var preIndex = 0;
        for(var j = 0; j < axisValue[i].length; ++j)
        {
          if(NumberUtils.isNoValue(axisValue[i][j].val))
          {
            if(j > preIndex)
            {
              arr = [];
              for(k = preIndex; k < j; k++)
              {
                obj = axisValue[i][k];
                obj.x = k;  
                arr.push(obj);
              }
              result.data.push(arr);
              result.color.push(i);
            }
            preIndex = j + 1;
          }
        }
        
        if(preIndex < axisValue[i].length)
        {
          arr = [];
          for(k = preIndex; k <  axisValue[i].length; k++)
          {
            obj = axisValue[i][k];
            obj.x = k;
            arr.push(obj);
          }
          result.data.push(arr);
          result.color.push(i);
        }
      }
      return result;
    }
    
    function processOneAxis(axisValue, prefix)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var axisGroup = svgLinesGroup.select("g." + prefix);
      if(axisGroup.empty())
      {
        axisGroup = svgLinesGroup.append("svg:g").attr("class", prefix);
      }
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      var result = processNullValue(axisValue.data);
      
      var lines = axisGroup.selectAll("." + "v-lines").data(result.data);
      
      lines.enter().append("path").attr('class', "v-lines")
        .attr("stroke-width", props.width).attr("stroke-linejoin", "round");
      lines.exit().remove();
      lines.attr("stroke-width", props.width);//@Alex: add this line to update attributes. 
      var line = d3.svg.line().x(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).
      y(function(d) {  return NumberUtils.isNoValue(axisValue.scale(d.val)) ? null : axisValue.scale(d.val); });
      
      
      lines.attr("transform", 
          function(d, i) {
            d3.select(this).attr("d", line(d))
            .attr("stroke",  function (){
                var para = { graphType:"line", 
                fillColor:axisValue.colorPalette[result.color[i] %  axisValue.colorPalette.length]};
                return effectManager.register(para);
                });
      });
      
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
      var markerGroup = svgMarkersGroup.select("g." + prefix);
      if(markerGroup.empty()){
        markerGroup = svgMarkersGroup.append("svg:g").attr("class", prefix);
      }
      groups = markerGroup.selectAll("g.v-marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "v-marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible){
        visible  = "visible";
      }
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".v-datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','v-datashape');
        DrawUtil.createElements(datashape,{shape: props.marker.shape, className: CLASSDATAPOINT} );
        seriesMarkers.exit().remove();
        var markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(d3.select(this).selectAll('path').node());
        
          var parameter = {
              drawingEffect:props.drawingEffect,
              graphType: props.marker.shape,
              fillColor : axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction : 'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              node:d3.select(this).select('path'),
              visibility: visible
          };

          DrawUtil.drawGraph(parameter, effectManager);
          return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val) + ")";  
        });

        axisValue.markers.push(markerArr); 
      });
    }

    function processOneAxisDeselectAll(valueAxis, xIndex)
    {
      if(!valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }

      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}
          
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERHOVER, valueAxis);
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, "", valueAxis);
          }
        }
      }
    }
    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }
    function deselectedAllHandler()
    {
      var event = getCurrentEvent();
      var xpoint = (event ? event.clientX : 0) - g.node().getBoundingClientRect().left;
      var xIndex = getCategoryIndex(xpoint);
      selectedMarkerNum = 0;
      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      processOneAxisDeselectAll(valueAxis2Data, xIndex);
 
    }

    
    function renderChart(selection)
    {
      gSelection = selection;
      getCSSStyle();
      eDispatch.startToInit();
      if(!g) {
        g = selection.append("svg:g");
      }

      if(!mouseMoveLine){
        mouseMoveLine = g.append("svg:line").attr("stroke", hoverColor).attr("class", "v-hoverline viz-plot-hoverline");
      }
      mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", height)
      .attr("stroke-width", 1)
      .attr("visibility", "hidden").attr("shape-rendering", "crispEdges");


      if(!svgLinesGroup)
      {
        svgLinesGroup = g.append("svg:g").attr("class", "v-datalines");
        svgLightLinesGroup = g.append("svg:g").attr("class", "v-lightLines");
        svgMarkersGroup = g.append("svg:g").attr("class", "v-markers v-datashapesgroup");
      }
      selectedMarkerNum = 0;
      lightAll();
      

      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
      clipRect
      .attr("x", 0).attr("y", 0).attr("height", height).attr("width", 0);
    
      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLightLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLightLinesGroup.selectAll(".v-lightLine").remove();
      //[21-Jan-2013 Nick] FIX BUG. Draw chart before 'initialized' event is fired out.
      processOneAxis(valueAxis1Data, PREFIXAXIS1);
      processOneAxis(valueAxis2Data, PREFIXAXIS2);
      if(enableAnimation()){
        clipRect
          .attr("x", 0).attr("y", 0).attr("height", height).attr("width", 0).transition().duration(1000).attr("width", width).each("end", function(){
          eDispatch.initialized();});
         
        }else{
          clipRect
          .attr("x", 0).attr("y", 0).attr("height", height).attr("width", width);
          eDispatch.initialized();
         }


    }

    function lightAll() {
      svgLightLinesGroup.selectAll(".v-lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", 1);
      if(UADetector.isIE()){
        svgLinesGroup.selectAll(".v-lines").attr("visibility", "visible");
      }
      
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = 1;
      } else {
        tempopacity = 0;
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class",  CLASSDATAPOINT);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class", CLASSDATAPOINT);
    }

    function grayAll() {
      svgLightLinesGroup.selectAll(".v-lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", OPACITY);
      if(UADetector.isIE()) {
        svgLinesGroup.selectAll(".v-lines").attr("visibility", "visible");
      }
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = OPACITY;
      } else {
        tempopacity = 0;
      }      
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class",  CLASSDATAPOINT);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class", CLASSDATAPOINT);
    }
    
    function getCSSStyle() {
      if (!props.style){
        props.style = {};
      } 
      var cssDef;
      if (!props.style.marker){
        props.style.marker = {};
      }
      props.style.marker.stroke = "transparent";
      cssDef = ctx.styleManager.queryDefault('v-hoverline');
      if(cssDef)
      {
        if (cssDef['stroke']){
          hoverColor = cssDef['stroke'];
        }
      }
    }
    
    function resetDataRange(){
      valueAxis1Data.topValue = null;
      valueAxis1Data.bottomValue = null;
      valueAxis2Data.topValue = null;
      valueAxis2Data.bottomValue = null;
    }
    
    line.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    line.width = function(value) {
      if (!arguments.length){
        return width;
      }
      isSizeChanged = (!isSizeChanged && (value === width)) ? false : true;
      width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };

    line.height = function(value) {
      if (!arguments.length){
        return height;
      }
      isSizeChanged = (!isSizeChanged && (value === height)) ? false : true;
      height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };
    

    /*;
     * get/set properties
     */
    line.properties = function(_) {
      if (!arguments.length){
        return props;
      }
        
      Objects.extend(true, props, _);
      if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
      if(props.width < 1 || props.width > 7) { props.width = 2; }

      createColorPalette();
      return line;
    };
    
     line.primaryAxisColor = function(){
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
          return effectManager.register({graphType:"line", fillColor: valueAxis1Data.colorPalette[0]});
        }else{
          return null;
        }
      };
        
      line.secondAxisColor = function(){
        return effectManager.register({graphType:"line", fillColor:  valueAxis2Data.colorPalette[0]});
      };     
        
    /**
     * get/set your event dispatch if you support event
     */
    line.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return line;
    };
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    line.data = function(value){
      if (!arguments.length){
        return data_;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(data_, value)){
        isDataSchemaChanged = true;
      }
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      valueAxis2Data.data = obj["MG2"];
      resetDataRange();
      
      var dataInfo = (valueAxis1Data.data.length === 0 ? valueAxis2Data.data[0][0] : valueAxis1Data.data[0][0]);
      if(dataInfo.info &&  dataInfo.info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      hasMND = obj["hasMND"];
      bMNDOnColor = obj["MNDOnColor"];
      bMNDInner = obj["MNDInner"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      createColorPalette();
      return line;        
    };
    
    line.dataLabel = function(_){};
      
      line.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      line.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
     
    /**
     * get color palette
     */
    line.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };

    line.shapePalette = function(){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return line;
    };

    line.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return line;
    };

    line.secondaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis2Data.scale;
      }
      valueAxis2Data.scale = scale;
      return line;
    };

    line.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return line;

    };

    line.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis1Data.scale.domain()[0],
          max: valueAxis1Data.scale.domain()[1]
        };
      }
      
      if (range !== null) {
          valueAxis1Data.topValue = range.max;
          valueAxis1Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis1Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis1Data);
          }
      }
      return line;
    };

    line.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis2Data.scale.domain()[0],
          max: valueAxis2Data.scale.domain()[1]
        };
      }
      if (range !== null) {
          valueAxis2Data.topValue = range.max;
          valueAxis2Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis2Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis2Data);
          }
      }
      return line;
    };
    line.parent = function() { 
      return gSelection;
    };

    /**
     * get/set size
     */
    line.size = function(w, h) {
      if (arguments.length === 0){
        return {
          width : line.width(),
          height : line.height()
        };
      }
      line.width(w).height(h);
      return line;
    };
    
    line.clear = function (gray) {
      deselectedAllHandler();
      var markers = [];
      if (gray === null || gray === undefined || gray === false){
        lightAll();
        markers.push(svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+CLASSDATAPOINT));
        markers.push(svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+CLASSDATAPOINT));
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gSelection, false, markers);
        }
      } else {
        grayAll();
      }
    };

    line.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        if(!processOneAxisSelect(valueAxis1Data, marker )){
          processOneAxisSelect(valueAxis2Data, marker );
        }
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker")
      .selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker")
      .selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, true, elementArray);
      }
    };

    line.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      selectedMarkerNum -= elementArray.length;
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];

        if(!processOneAxisDeselect(valueAxis1Data, marker)){
          processOneAxisDeselect(valueAxis2Data, marker);
        }
      }
      if(selectedMarkerNum === 0)
      {
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker")
        .selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker")
        .selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
      }
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, false, elementArray);
      }
    };
    
    line.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if(point0 < 0 || point0 > width){
        return;
      }

      var xIndex = getCategoryIndex(point0);
      if(preHighLightIndex === xIndex) { return; }
      var xCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", "");
      changeGroupMarker(xIndex, "visible", CLASSMARKERHOVER);  

      preHighLightIndex = xIndex;


      if (props.hoverline.visible) {
        mouseMoveLine.attr("x1", xCoord).attr("x2", xCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }

      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        pt.x = xScale(xIndex) + xScale.rangeBand() / 2 + matrix.e;
        pt.y = height / 4 + matrix.f;
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
          x : matrix.e,
          y : matrix.f,
          width : width,
          height : height
        };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }

    };

    line.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", "");
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    props = manifest.props(null);
    return line;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.line',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.line',
    'name' : 'line',
     base : 'sap.viz.modules.xy.base',
    'properties' : {
    'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'width' : {
        'name' : 'width',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 2,
        'min' : '1',
        'max' : '7',
        'description' : 'Set width of line, range[1,7]. When beyond the range, the line width is default size 2.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation related properties.'
     },
      'hoverline' : {
          'name' : 'hoverline',
          'supportedValueType' : 'Object',
          'description' : 'Settings for hoverline properties.',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set to enabled/disabled hoverline or not.',
            },
          },
      },
      'marker' : {
        'name' : 'marker',
      'description': 'Settings for marker/data point graphics',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set show marker or not.'
          },
          'shape' : {
            'name' : 'shape',
            'supportedValueType' : 'List',
        'supportedValues' : ['circle', 'diamond', 'triangleUp', 'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection'],
            'defaultValue' : 'circle',
            'description' : 'Set marker shapes for chart.'
          },
          'size' : {
            'name' : 'size',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : "6",
            'min' : '4',
            'max' : '32',
            'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 6.'
          }
        }
      }
    },
    'css' : {     
      '.viz-plot-hoverline.v-hoverline': {
          'description' : 'Define style for hoverline in line.',
          'value' : {
            'stroke' : '#cccccc'
          }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalline',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(dataUtil, dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, ObjectUtils, Objects,UADetector,BoundUtil, defaultSelUtil) 
{
  return function(manifest, ctx) 
  {
    var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint";

    var width, height;
    var data_ = null, props;
    var randomSuffix = ObjectUtils.guid();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";

    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgLinesGroup, svgLightLinesGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var hasMND;
    var bMNDOnColor;
    var bMNDInner;
    var effectManager = ctx.effectManager;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };

    var valueAxis2Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };
    var colorPalette = [];
    var PREFIXAXIS1 = 'v-axis1';
    var PREFIXAXIS2 = 'v-axis2';

    var bAnimationComplete = false;
    var hasDefaultSelection = false;
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    var selectedMarkerNum = 0;
    var gSelection = null;

    // clip defs for enimation

    var clipRect;    
    var OPACITY = 0.4;

    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(isDataLoading){
        hasAnmation = props.animation.dataLoading;
      }else if(isDatasetChanged){
        hasAnmation = props.animation.dataUpdating;
      }else if(isSizeChanged){
        hasAnmation = props.animation.resizing;
      }
      return hasAnmation;
    }

    function horizontalline(selection) {
      BoundUtil.drawBound(selection, width, height);
      //selection.each(generate);
      
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
      return horizontalline;
    }

   
    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length === 0){
        return null;
      }
      minMax.max = Number(d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      }));
      minMax.min = Number(d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      }));
      if(NumberUtils.isNoValue(minMax.max )) {
        return null;
      }
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / width ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5 / width;
      }else{
        var temp = (minMax.max - minMax.min) * 5 / width;
        minMax.min -= temp;
        minMax.max += temp;
      }
      
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      var i = 0, j = 0;
      if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
        valueAxis1Data.colorPalette = props.primaryValuesColorPalette ;
      } else { 
        valueAxis1Data.colorPalette = props.colorPalette;
      }

      valueAxis2Data.colorPalette = props.secondaryValuesColorPalette;
      
      if (hasMND && bMNDOnColor && bMNDInner) {
        var dva1 = data_.getMeasureValuesGroupDataByIdx(0);
        var dva2 = data_.getMeasureValuesGroupDataByIdx(1);
        var mg1mNum=0, mg2mNum=0, mNum=0, colorAxisDataNum=0;
        if (dva1 && dva1.values.length>0) { 
          mg1mNum = dva1.values.length;
          colorAxisDataNum = dva1.values[0].rows.length;
        }
        if (dva2 && dva2.values.length>0) {
          mg2mNum = dva2.values.length;
          colorAxisDataNum = dva2.values[0].rows.length;
        }

        for (i=0; i<colorAxisDataNum; i++) {
          for (j=0; j<mg1mNum; j++) {
            colorPalette.push(valueAxis1Data.colorPalette[i*mg1mNum+j % valueAxis1Data.colorPalette.length]);
          }
          for (j=0; j<mg2mNum; j++){
            colorPalette.push(valueAxis2Data.colorPalette[i*mg2mNum+j % valueAxis2Data.colorPalette.length]);
          }
        }
      } else {
        for(i = 0; i < valueAxis1Data.data.length; ++i){
          colorPalette.push(valueAxis1Data.colorPalette[i % valueAxis1Data.colorPalette.length]);
        }
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        {
          for(i = 0; i < valueAxis2Data.data.length; ++i){
            colorPalette.push(valueAxis2Data.colorPalette[i % valueAxis2Data.colorPalette.length]);
          }
        }
      }
    }

    function calculateScale(axisValue)
    {
      if(axisValue.data && axisValue.data.length > 0 )
      {
        if( axisValue.topValue === null || axisValue.topValue === undefined)
        {
          var minMax = calculateMinMax(axisValue);
          if(!minMax || (minMax.min === 0 && minMax.max === 0)){
            axisValue.scale.domain([]).range ([]);
          } else {
            axisValue.scale.domain([minMax.min, minMax.max]).range ([0, width]);
          }
        }
        else{
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([0, width]);
        }
      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    }

    function computeScales()
    {
      var domain = [];
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([height, 0]);
      calculateScale(valueAxis1Data);
      calculateScale(valueAxis2Data);
      if (valueAxis1Data.data && valueAxis1Data.data.length > 0 &&
            valueAxis2Data.data && valueAxis2Data.data.length > 0 ) {
        
        if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([0, width]); 
          valueAxis2Data.scale.domain([0, 1]).range ([0, width]); 
        } else if(valueAxis1Data.scale.domain().length === 0 && valueAxis2Data.scale.domain().length !== 0){
          valueAxis1Data.scale.domain(valueAxis2Data.scale.domain()).range(valueAxis2Data.scale.range());
        } else if(valueAxis1Data.scale.domain().length !== 0 && valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain(valueAxis1Data.scale.domain()).range(valueAxis1Data.scale.range());
        }
        
        if (!valueAxis1Data.manualRange && !valueAxis2Data.manualRange) {
            Scaler.perfectDual(valueAxis1Data.scale, valueAxis2Data.scale);
        } else if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        } else if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
            Scaler.getRoughTickNum(valueAxis1Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis1Data.scale);
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        }
      } else if (valueAxis1Data.data && valueAxis1Data.data.length > 0) {
        if(valueAxis1Data.scale.domain().length === 0){
          valueAxis1Data.scale.domain([0, 1]).range ([0, width]);
        }
        if (!valueAxis1Data.manualRange) {
            Scaler.perfect(valueAxis1Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis1Data.scale);
        }
      } else if (valueAxis2Data.data && valueAxis2Data.data.length > 0) {
        if(valueAxis2Data.scale.domain().length === 0){
          valueAxis2Data.scale.domain([0, 1]).range ([0, width]);
        }
        if (!valueAxis2Data.manualRange) {
            Scaler.perfect(valueAxis2Data.scale);
        } else {
            Scaler.getRoughTickNum(valueAxis2Data.scale);
        }
      }
    }

    function changeGroupMarker(groupIndex, visible, className)
    {
      if(groupIndex === undefined || groupIndex === null){
        return;
      }

      var seriesIndex = 0;
      for(seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis1Data);
        }
      }  

      if(!valueAxis2Data.data) {return;}

      for(seriesIndex = 0; seriesIndex < valueAxis2Data.data.length; ++seriesIndex)
      {
        if(!valueAxis2Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, className, valueAxis2Data);
        }
      }
    }
   
    function lightLine(seriesIndex, xIndex, visible, valueAxis)
    {
      if(!valueAxis.highLines[seriesIndex])
      {
        valueAxis.highLines[seriesIndex] = [];
      }
      if(!valueAxis.highLines[seriesIndex][xIndex] && visible === "visible")
      {
             var d1 = valueAxis.data[seriesIndex][xIndex].val;
             var d2 = valueAxis.data[seriesIndex][xIndex + 1].val;
             valueAxis.highLines[seriesIndex][xIndex] = svgLightLinesGroup.append("svg:line").attr("class", "v-lightLine")
            .attr("x1", valueAxis.scale(d1)).attr("y1", xScale(xIndex) + xScale.rangeBand() / 2)
            .attr("x2", valueAxis.scale(d2)).attr("y2", xScale(xIndex + 1) + xScale.rangeBand() / 2)
                 .attr("stroke-width", props.width).attr("stroke",  
                 valueAxis.colorPalette[seriesIndex %  valueAxis.colorPalette.length]).attr("visibility", "hidden");
       }
       if(valueAxis.highLines[seriesIndex][xIndex])
       {
         valueAxis.highLines[seriesIndex][xIndex].attr("visibility", visible);
       }
    }

    function changeOneMarker(seriesIndex, xIndex, className, valueAxis)
    {
      var stroke, tempOpacity;

      if (className === CLASSMARKERSELECTED) {
        stroke = selectedColor;
        tempOpacity = 1;
        if(xIndex > 0 && valueAxis.selectedMarkers[seriesIndex][xIndex - 1]){
           lightLine(seriesIndex, xIndex - 1, "visible", valueAxis);
        }
        if(xIndex < valueAxis.markers[0].length - 1 && valueAxis.selectedMarkers[seriesIndex][xIndex + 1]) {
           lightLine(seriesIndex, xIndex, "visible", valueAxis);
        }
        valueAxis.selectedMarkers[seriesIndex][xIndex] = true;
      } else {
        if(xIndex > 0 && valueAxis.selectedMarkers[seriesIndex][xIndex - 1]) {
           lightLine(seriesIndex, xIndex - 1, "hidden", valueAxis);
        }
        if(xIndex < valueAxis.markers[0].length - 1 && valueAxis.selectedMarkers[seriesIndex][xIndex + 1]){
           lightLine(seriesIndex, xIndex, "hidden", valueAxis);
        }
        valueAxis.selectedMarkers[seriesIndex][xIndex] = false;
        if(selectedMarkerNum > 0) {
            tempOpacity = OPACITY;
        } else {
            tempOpacity = 1;
        }
        
        if (className === CLASSMARKERHOVER) {
            stroke = bgColor;
        } else {
            stroke = "transparent";
            if (props.marker.visible === false) {
                tempOpacity = 0;
            }
        }
      }
  
      d3.select(valueAxis.markers[seriesIndex][xIndex])
        .attr("class", CLASSDATAPOINT + ' ' + className).attr("stroke", stroke).attr("opacity", tempOpacity);
    }

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (valueAxis1Data.data.length !== 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      if(index > categoryNum - 1) { index = categoryNum - 1;}
      if(index < 0){ index = 0;}
      return categoryNum - 1 - index;
    }

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }
      ++selectedMarkerNum;
      changeOneMarker(yi, xi, CLASSMARKERSELECTED, valueAxis);
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] === marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi === preHighLightIndex){
        changeOneMarker(yi, xi, CLASSMARKERHOVER, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, "", valueAxis);
      }

    }

    
    function processNullValue(axisValue)
    {
      var result = {
          data:[],
          color:[]
      };
      var arr = [], obj, k;

      for(var i = 0; i < axisValue.length; ++i)
      {
        var preIndex = 0;
        for(var j = 0; j < axisValue[i].length; ++j)
        {
          if(NumberUtils.isNoValue(axisValue[i][j].val))
          {
            if(j > preIndex)
            {
              arr = [];
              for(k = preIndex; k < j; k++)
              {
                obj = axisValue[i][k];
                obj.x = k;  
                arr.push(obj);
              }
              result.data.push(arr);
              result.color.push(i);
            }
            preIndex = j + 1;
          }
        }
        
        if(preIndex < axisValue[i].length)
        {
          arr = [];
          for(k = preIndex; k <  axisValue[i].length; k++)
          {
            obj = axisValue[i][k];
            obj.x = k;
            arr.push(obj);
          }
          result.data.push(arr);
          result.color.push(i);
        }
      }
      return result;
    }
    
    function processOneAxis(axisValue, prefix)
    {
      if(!axisValue.data || axisValue.data.length === 0){
        return;
      }
      var axisGroup = svgLinesGroup.select("g." + prefix);
      if(axisGroup.empty())
      {
        axisGroup = svgLinesGroup.append("svg:g").attr("class", prefix);
      }
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      var result = processNullValue(axisValue.data);
      
      var lines = axisGroup.selectAll("." + "v-lines").data(result.data);
      
      lines.enter().append("path").attr('class', "v-lines")
        .attr("stroke-width", props.width).attr("stroke-linejoin", "round");
      lines.exit().remove();
      lines.attr("stroke-width", props.width);//@Alex: add this line to update attributes.       
      var line = d3.svg.line().y(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).x(function(d) {  return axisValue.scale(d.val); });
      lines.attr("transform", 
          function(d, i) {
            d3.select(this).attr("d", line(d))
            .attr("stroke",  function (){
                var para = { graphType:"line", 
                fillColor:axisValue.colorPalette[result.color[i] %  axisValue.colorPalette.length]};
                return effectManager.register(para);
                });
      });
      
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
      var markerGroup = svgMarkersGroup.select("g." + prefix);
      if(markerGroup.empty()){
        markerGroup = svgMarkersGroup.append("svg:g").attr("class", prefix);
      }
      groups = markerGroup.selectAll("g.v-marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "v-marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible){
        visible  = "visible";
      }
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".v-datashape").data(d);
        var datashape = seriesMarkers.enter().append('g').attr('class','v-datashape');
        DrawUtil.createElements(datashape,{shape: props.marker.shape, className: CLASSDATAPOINT} );
        seriesMarkers.exit().remove();
        var markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(d3.select(this).selectAll('path').node());
          
          var parameter = {
              drawingEffect: props.drawingEffect,
              graphType: props.marker.shape,
              fillColor: axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction :'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              node:d3.select(this).select('path'),
              visibility: visible
          };
          DrawUtil.drawGraph(parameter, effectManager);
          return "translate(" + axisValue.scale(point.val)+ "," + (xScale(index) + xScale.rangeBand() / 2)  + ")"; 
        });

        axisValue.markers.push(markerArr);
      });
    }

    function processOneAxisDeselectAll(valueAxis,  xIndex)
    {
      if(!valueAxis.selectedMarkers || valueAxis.selectedMarkers.length === 0){
        return;
      }
      
      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) {continue;}
          
          if(groupIndex === xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, CLASSMARKERHOVER, valueAxis);
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, "", valueAxis);
          }

          valueAxis.selectedMarkers[seriesIndex][groupIndex] = false;
        }
      }
    }
    function getCurrentEvent() {
        if (d3.event) {
            return d3.event;
        } else {
            return window.event;
        }
    }
    function deselectedAllHandler()
    {
      var event = getCurrentEvent();
      var ypoint =  (event ? event.clientY : 0) - g.node().getBoundingClientRect().top ;
      var xIndex = getCategoryIndex(ypoint);
      selectedMarkerNum = 0;
      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      processOneAxisDeselectAll(valueAxis2Data, xIndex);
    }

    
    
    function renderChart(selection)
    {
      gSelection = selection;
      getCSSStyle();
      eDispatch.startToInit();
      if(!g) {
        g = selection.append("svg:g");  
      }

      if(!mouseMoveLine){
        mouseMoveLine = g.append("svg:line").attr("stroke", hoverColor).attr("class", "v-hoverline viz-plot-hoverline");
      }

      mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", width).attr("y2", 0)
      .attr("stroke-width", 1)
      .attr("visibility", "hidden").attr("shape-rendering", "crispEdges");
      if(!svgLinesGroup)
      {
        svgLinesGroup = g.append("svg:g").attr("class", "v-datalines");
        svgLightLinesGroup = g.append("svg:g").attr("class", "v-lightLines");
        svgMarkersGroup = g.append("svg:g").attr("class", "v-markers v-datashapesgroup");
      }
      selectedMarkerNum = 0;
      lightAll();

      if(!clipRect){
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      }
      
      clipRect.attr("x", 0).attr("y",  height).attr("height",  0 ).attr("width", width);

      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLightLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLightLinesGroup.selectAll(".v-lightLine").remove();
      //[21-Jan-2013 Nick] FIX BUG. Draw chart before 'initialized' event is fired out.
      processOneAxis(valueAxis1Data, PREFIXAXIS1);
      processOneAxis(valueAxis2Data, PREFIXAXIS2);
      
      if(enableAnimation()){
        clipRect
          .attr("x", 0).attr("y", height).attr("height", 0).attr("width", width).transition().duration(1000)
          .attr("height", height).attr("y", 0).each("end", function(){
          eDispatch.initialized();});
         
        }else{
          clipRect
          .attr("x", 0).attr("y", 0).attr("height", height).attr("width", width);
          eDispatch.initialized();
         }

    }

    function lightAll() {
      svgLightLinesGroup.selectAll(".v-lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", 1);
      if(UADetector.isIE()){
        svgLinesGroup.selectAll(".v-lines").attr("visibility", "visible");
      }
      
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = 1;
      } else {
        tempopacity = 0;
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class",  CLASSDATAPOINT);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class", CLASSDATAPOINT);
    }

    function grayAll() {
      svgLightLinesGroup.selectAll(".v-lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", OPACITY);
      if(UADetector.isIE()) {
        svgLinesGroup.selectAll(".v-lines").attr("visibility", "visible");
      }
      var tempopacity;
      if (props.marker.visible === true) {
        tempopacity = OPACITY;
      } else {
        tempopacity = 0;
      }      
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class",  CLASSDATAPOINT);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERSELECTED)
      .attr("opacity", tempopacity).attr("class", CLASSDATAPOINT);
    }
    
    function getCSSStyle() {
        if (!props.style){
          props.style = {};
        } 
        var cssDef;
        if (!props.style.marker){
          props.style.marker = {};
        }
        props.style.marker.stroke = "transparent";
        cssDef = ctx.styleManager.queryDefault('v-hoverline');
        if(cssDef)
        {
          if (cssDef['stroke']){
            hoverColor = cssDef['stroke'];
          }
        }
      }
      function resetDataRange(){
        valueAxis1Data.topValue = null;
        valueAxis1Data.bottomValue = null;
        valueAxis2Data.topValue = null;
        valueAxis2Data.bottomValue = null;
      }
    
    horizontalline.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    horizontalline.width = function(value) {
      if (!arguments.length){
        return width;
      }
      isSizeChanged = (!isSizeChanged && (value === width)) ? false : true;
      width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };

    horizontalline.height = function(value) {
      if (!arguments.length){
        return height;
      }
      isSizeChanged = (!isSizeChanged && (value === width)) ? false : true;
      height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };
    
    /*;
     * get/set properties
     */
    horizontalline.properties = function(_) {
      if (!arguments.length){
        return props;
      }
        
      Objects.extend(true, props, _);
      if(props.marker.size < 4 || props.marker.size > 32) { props.marker.size = 6;}
      if(props.width < 1 || props.width > 7) {props.width = 2;}
      createColorPalette();
      return horizontalline;
    };
    
    horizontalline.primaryAxisColor = function(){
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
          return effectManager.register({graphType:"line", fillColor: valueAxis1Data.colorPalette[0]});
        }else{
          return null;
        }
      };
        
      horizontalline.secondAxisColor = function(){
        return effectManager.register({graphType:"line", fillColor:  valueAxis2Data.colorPalette[0]});
      };     
    /**
     * get/set your event dispatch if you support event
     */
    horizontalline.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return horizontalline;
    };
          
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    horizontalline.data = function(value){
      if (!arguments.length){
        return data_;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if (! dataUtil().hasSameSchema(data_, value)){
        isDataSchemaChanged = true;
      }
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      valueAxis2Data.data = obj["MG2"];
      resetDataRange();
      
      var dataInfo = (valueAxis1Data.data.length === 0 ? valueAxis2Data.data[0][0] : valueAxis1Data.data[0][0]);
      if(dataInfo.info &&  dataInfo.info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      hasMND = obj["hasMND"];
      bMNDOnColor = obj["MNDOnColor"];
      bMNDInner = obj["MNDInner"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      createColorPalette();
      return horizontalline;        
    };

    horizontalline.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      horizontalline.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
            }
          }
          return title.join('/');
        }
        return this;
      };
    /**
     * get color palette
     */
    horizontalline.getColorPalette = function() {
      if(colorPalette.length === 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };


    horizontalline.shapePalette = function(_){
      if(!arguments.length){
        return [props.marker.shape];
      }
      return horizontalline;
    };


    horizontalline.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return horizontalline;
    };

    horizontalline.secondaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis2Data.scale;
      }
      valueAxis2Data.scale = scale;
      return horizontalline;
    };

    horizontalline.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return horizontalline;

    };

    horizontalline.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis1Data.scale.domain()[0],
          max: valueAxis1Data.scale.domain()[1]
        };
      }
      if (range !== null) {
          valueAxis1Data.topValue = range.max;
          valueAxis1Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis1Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis1Data);
          }
      }
      return horizontalline;
    };

    horizontalline.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis2Data.scale.domain()[0],
          max: valueAxis2Data.scale.domain()[1]
        };
      }
      if (range !== null) {
          valueAxis2Data.topValue = range.max;
          valueAxis2Data.bottomValue = range.min;
          if (range.from === 'axis') {
            valueAxis2Data.manualRange = true;
          }
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            calculateScale(valueAxis2Data);
          }
      }
      return horizontalline;
    };
    
    horizontalline.parent = function() { 
      return gSelection;
    };
    
    horizontalline.dataLabel = function(_){
     
    }
    /**
     * get/set size
     */
    horizontalline.size = function(w, h) {
      if (arguments.length === 0){
        return {
          width : horizontalline.width(),
          height : horizontalline.height()
        };
      }
      horizontalline.width(w).height(h);
      return horizontalline;
    };
    
    horizontalline.clear = function (gray) {
      deselectedAllHandler();
      var markers = [];
      if (gray === null || gray === undefined || gray === false){
        lightAll();
        markers.push(svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+CLASSDATAPOINT));
        markers.push(svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+CLASSDATAPOINT));
        if(hasDefaultSelection){
          defaultSelUtil.clearSelectionInfo(gSelection, false, markers);
        }
      } else {
        grayAll();
      }
    };

    horizontalline.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        if(!processOneAxisSelect(valueAxis1Data, marker )){
          processOneAxisSelect(valueAxis2Data, marker );
        }
      }
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERHOVER).attr("opacity", OPACITY);
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, true, elementArray);
      }
      
    };
    
    horizontalline.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      selectedMarkerNum -= elementArray.length;
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];

        if(!processOneAxisDeselect(valueAxis1Data, marker)){
          processOneAxisDeselect(valueAxis2Data, marker);
        }
      }
      if(selectedMarkerNum === 0)
      {
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.v-marker").selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
        svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.v-marker").selectAll("."+ CLASSMARKERHOVER).attr("opacity", 1);
      }
      if(hasDefaultSelection){
        defaultSelUtil.clearSelectionInfo(gSelection, false, elementArray);
      }
    };
    horizontalline.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if(point1 < 0 || point1 > height){
        return;
      }

      var xIndex = getCategoryIndex(point1);
      if(preHighLightIndex === xIndex) { return; }
      var yCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", "");
      changeGroupMarker(xIndex, "visible", CLASSMARKERHOVER);  

      preHighLightIndex = xIndex;
      if (props.hoverline.visible) {
        mouseMoveLine.attr("y1", yCoord).attr("y2", yCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }
      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        pt.x = width * 3 / 4 + matrix.e;
        pt.y = yCoord + matrix.f;
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
            x : matrix.e,
            y : matrix.f,
            width : width,
            height : height
          };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
    };
    
    horizontalline.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", "");
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    props = manifest.props(null);
    return horizontalline;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.horizontalline',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.horizontalline',
    'name' : 'horizontalline',
    base : 'sap.viz.modules.line',
    
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.2'
}
],
function Setup (Manifest) {
  var chart={
    base : 'riv/basehorizontalchart',
    id:'viz/horizontal_combination',
    name:'IDS_HORIZONTALCOMBINATIONCHART',
    modules:{
      root : {
        modules : {
          tooltip : {
            configure : {
            properties : {
              chartType : 'horizontalline',
              orientation : 'left'
            }
            }
          },
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.horizontalcombination',
                configure:{
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory:'plotArea',
                  propertiesOverride : {
                    dataShape:{
                      secondAxis : { isExported: false }
                    }
                  }
                }
              },
              
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : { position : 'outside' }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
        secondaryValues: null
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
          targetModule:'root.legends.legend',
          target:'shapes',
          sourceModule:'root.main.plot',
          source:'shapePalette'
        },{
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'root.legends.legend',
            type : 'highlightedByLegend'
        }, {
                targetModule : 'root.legends.legend',
              listener : 'deselectLegend',
              sourceModule : 'root.interaction',
              type : 'deselectLegend'
        } , {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        } 
      ]      
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualHorizontalCombinationChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.2'
}
],
 function Setup (Manifest, Constants) {
  var chart={
    id:'viz/dual_horizontal_combination',
    name:'IDS_DUALHORIZONTALCOMBINATIONCHART',
    base : 'viz/horizontal_combination',
    modules:{
      root : {
        modules : {
          main : {
            modules : {
              plot : {
                configure : {
                  propertiesOverride : {
                    primaryValuesColorPalette : { isExported: true },
                    secondaryValuesColorPalette : { isExported: true },
                    dataShape : {
                      secondAxis : { isExported: true }
                    }
                  }
                }
              },
              xAxis:{
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              'xAxis2' : {
                'id' : 'sap.viz.modules.axis',
                'configure' : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                'propertyCategory' : 'xAxis2',
                'properties' : {
                  'type' : 'value',
                  'position' : 'top',
                  'gridline' : { 'visible' : false }
                },
                propertiesOverride:{
                  title:{
                    applyAxislineColor:{
                      isExported: true
                    }
                  }
                }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues: { min: 1, max: Number.POSITIVE_INFINITY  }
    },
    
    dependencies:{
      attributes:[
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondaryScale'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        },
        {
          targetModule : 'root.main.xAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },
        {
          targetModule : 'root.main.xAxis2',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'secondAxisTitle'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },
        {
          targetModule:'root.legends.legend',
          target:'shapes',
          sourceModule:'root.main.plot',
          source:'shapePalette'
        }
      ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'
}
],
function Setup (Manifest) {
  var chart={
    base : 'riv/baseverticalchart',
    id:'viz/combination',
    name:'IDS_COMBINATIONCHART',
    modules:{
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : { chartType : 'line', orientation : 'left' }
            }
          },
          main:{    
            modules:{
              plot:{
                id:'sap.viz.modules.combination',
                configure:{
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory:'plotArea',
                  propertiesOverride : {
                    dataShape:{
                      secondAxis : { isExported: false }
                    }
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : { position : 'outside' }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : { secondaryValues: null },
    
    dependencies:{
      attributes:[
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        },{
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'root.main.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
          targetModule:'root.legends.legend',
          target:'shapes',
          sourceModule:'root.main.plot',
          source:'shapePalette'
        },{
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'root.legends.legend',
            type : 'highlightedByLegend'
        }, {
                targetModule : 'root.legends.legend',
              listener : 'deselectLegend',
              sourceModule : 'root.interaction',
              type : 'deselectLegend'
        },{
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }
      ]      
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualCombinationChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.2'
}
],
 function Setup (Manifest, Constants) {
  var chart={
    id:'viz/dual_combination',
    name:'IDS_DUALCOMBINATIONCHART',
    base : 'viz/combination',
    modules:{
      root : {
        modules : {
          main : {
            modules :{
              plot : {
                configure : {
                  propertiesOverride : {
                    primaryValuesColorPalette:{ isExported: true },
                    secondaryValuesColorPalette: { isExported: true },
                    dataShape:{
                      secondAxis : { isExported: true }
                    }
                  }
                }
              },
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'yAxis2',
                  properties : {
                    type : 'value',
                    position : 'right',
                    gridline : { visible : false }
                  },
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              }    
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues: { min: 1, max: Number.POSITIVE_INFINITY }
    },
    
    dependencies:{
      attributes:[
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        },
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        },
        {
          targetModule : 'root.main.plot',
          target : 'secondDataRange',
          sourceModule : 'root.main.yAxis2',
          source : 'range'
        },
        {
          targetModule : 'root.main.yAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondaryScale'
        },
        {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },
        {
          targetModule : 'root.main.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        }, 
        {
          targetModule : 'root.main.yAxis2',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'secondAxisTitle'
        },
        {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        },
        {
          targetModule : 'root.main.yAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },
        {
          targetModule:'root.legends.legend',
          target:'shapes',
          sourceModule:'root.main.plot',
          source:'shapePalette'
        }
      ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup ( Manifest ) {
  var chart = {
    id : 'viz/line',
    name : 'IDS_LINECHART',
    base: 'riv/baseverticalchart',
    
    modules : {
      root : {
        modules : {
          tooltip : {
          configure : {
            properties : {
              chartType : 'line',
              orientation : 'left'
            }
          }
        },

      main : {
        'modules' : {
          dataLabel : {
            id : 'sap.viz.modules.datalabel',
            configure : {
              propertyCategory : 'dataLabel',
              properties : {
                position : 'outside',
                automaticInOutside : false,
                positionPreference : true
              }
            }
          },
          plot : {
            id : 'sap.viz.modules.line',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
        }
      }

     
    },
    feeds:{
      secondaryValues: null
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'root.main.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main.yAxis',
        source : 'range'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'root.main.yAxis',
      target : 'title',
      sourceModule : 'root.main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
            }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
            targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'root.main.plot',
            type : 'initialized.datalabel'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'root.main.plot',
            type : 'startToInit.datalabel'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualLineChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_line',
    name : 'IDS_DIUALLINECHART',
    base: 'viz/line',
    'modules' : {
      root : {
        modules : {
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction'
            }
          },
           main : {
            modules : {
              plot : {
                configure : {
                  propertiesOverride : {
                    primaryValuesColorPalette : { isExported: true },
                    secondaryValuesColorPalette : { isExported: true }
                  }
                }
              },
              yAxis:{
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'yAxis2',
                  properties : {
                    type : 'value',
                    position : 'right',
                    gridline : { visible : false }
                  },
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues : { min : 1, max : Number.POSITIVE_INFINITY },
       axisLabels : { acceptMND : -1, max: 1 },
       regionColor : { acceptMND : 0 }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : 
      [ 
        {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'getColorPalette'
        }, 
        {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, 
        {
          targetModule : 'root.main.plot',
          target : 'secondDataRange',
          sourceModule : 'root.main.yAxis2',
          source : 'range'
        }, 
        {
          targetModule : 'root.main.yAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondaryScale'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        }, 
        {
          targetModule : 'root.main.yAxis2',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'secondAxisTitle'
        },
        {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, 
        {
          targetModule : 'root.main.yAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot',
          source : 'shapePalette'
        } 
      ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_line',
    name : 'IDS_HORIZONTALLINECHART',
    base : 'riv/basehorizontalchart',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left'
              }
            }
          },

          'main' : {
            'modules' : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    position : 'outside',
                    automaticInOutside : false,
                    positionPreference : true
                  }
                }
              },
              'plot' : {
                'id' : 'sap.viz.modules.horizontalline',
                'configure' : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  'propertyCategory' : 'plotArea'
                }
              }
            }
          }
        }
      }
 
    },
    feeds:{
      secondaryValues: null
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapePalette'
      } , {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
      }  , {
            targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
            targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'root.main.plot',
            type : 'initialized.datalabel'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'root.main.plot',
            type : 'startToInit.datalabel'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          }]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualHorizontalLineChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    'id' : 'viz/dual_horizontal_line',
    'name' : 'IDS_DUALHORIZONTALLINECHART',
    'base' : 'viz/horizontal_line',
     'modules' : {
       root : {
        modules : {
          'main' : {
            'id' : 'sap.viz.modules.xycontainer',
            'modules' : {
              plot : {
                 configure : {
                  propertiesOverride : {
                    primaryValuesColorPalette:{ isExported: true },
                    secondaryValuesColorPalette: { isExported: true }
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              'xAxis2' : {
                'id' : 'sap.viz.modules.axis',
                'configure' : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  },
                  'propertyCategory' : 'xAxis2',
                  'properties' : {
                    'type' : 'value',
                    'position' : 'top',
                    'gridline' : { 'visible' : false }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues : { min : 1, max : Number.POSITIVE_INFINITY },
      axisLabels : { acceptMND : -1, max: 1 },
      regionColor : { acceptMND: 0 }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : 
      [ 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'getColorPalette'
        }, 
        {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, 
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondaryScale'
        }, 
        {
          targetModule : 'root.main.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        }, 
        {
          targetModule : 'root.main.xAxis2',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'secondAxisTitle'
        }, 
        {
          targetModule : 'root.main.xAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, 
        {
          targetModule : 'root.main.xAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        },
        {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot',
          source : 'shapePalette'
        } 
      ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.stackedwaterfall',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, langManager, NumberUtils, Scaler, ColorSeries, Objects, TooltipDataHandler, boundUtil, Objects2, defaultSelUtil) {
  var stackedwaterfall = function(manifest, ctx) {
	var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint";
    var CSSCLASS_HOVERLINE = 'v-hovershadow';

    var options, width, height, originData, chartData, tooltipData, primaryAxisMinValue, primaryAxisMaxValue, categoryLen, measureLength, 
        tooltipVisible, decorativeShape, barInfo, isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false,
        lastHovered = null, dimensionData, measureData, isShowTotal, isShowSubtotal, hasDefaultSelection = false,
        eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
    var defaultString = langManager.get('IDS_ISNOVALUE'),
        colorPalette = ColorSeries.sap32().range(), 
        shapePalette = ['squareWithRadius'],
        totalIntervalTime = 1200, sWrapper;
    var style = {};
    var _TooltipDataHandler = TooltipDataHandler();

    var effectManager = ctx.effectManager, drawingEffect = 'normal';
    
    var categoryScale = d3.scale.ordinal(), primaryScale = d3.scale.linear();

    var chart = function(selection) {
      boundUtil.drawBound(selection, width, height);
      
      if(!TypeUtils.isExist(primaryScale)){
        return;
      }
      eDispatch.startToInit();
      
      selection.each(function(){
        //calculate information
        barInfo = _getBarInfo();
        var barSize = barInfo.barSize;
        //TODO start from zero. Do we support start from certain position? 
        var intialValue = 0;
        var interval = totalIntervalTime / categoryLen;
        
        sWrapper = d3.select(this);
        
        // append decorativeShape bar
        if (decorativeShape === undefined) {
          decorativeShape = sWrapper.append('rect').attr('visibility', 'hidden').attr('fill', style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE);
          //set decorative shape info.
          if(options.isHorizontal === false){
            decorativeShape.attr('width', categoryScale.rangeBand() - barInfo.barGap).attr('height', height);
          }else{
            decorativeShape.attr('height', categoryScale.rangeBand() - barInfo.barGap).attr('width', width);
          }
        } else {
          //set decorative shape info.
          if(options.isHorizontal === false){
            decorativeShape.attr('width', categoryScale.rangeBand() - barInfo.barGap).attr('height', height).attr('visibility', 'hidden');
          }else{
            decorativeShape.attr('height', categoryScale.rangeBand() - barInfo.barGap).attr('width', width).attr('visibility', 'hidden');
          }
        }
        
       
        if(isDataSchemaChanged === true){
          //Data structure changed. reset. 
          sWrapper.selectAll('g.v-waterfallgroup').remove();
          sWrapper.selectAll('g.v-datashapesgroup').remove();
        }
        //create stacked waterfall group
        var mainShapesWrapper = sWrapper.selectAll('g.v-datashapesgroup');
        if(mainShapesWrapper.empty()){
          mainShapesWrapper = sWrapper.append('g').attr('class', 'v-datashapesgroup');
        }
        var wrap = mainShapesWrapper.selectAll('g.v-waterfallgroup').data(chartData);
        wrap.enter().append('g').attr('class', 'v-waterfallgroup');
        wrap.exit().remove();
        
        var hasAnmation = false;
        if(isDataLoading){
          hasAnmation = options.animation.dataLoading;
        }else if(isDatasetChanged){
          hasAnmation = options.animation.dataUpdating;
        }else if(isSizeChanged){
          hasAnmation = options.animation.resizing;
        }
        
        var dataShape = wrap.selectAll('g.v-datashape').data(function(d,i){
          return d.items;
        });
        var dataShapeEnter = dataShape.enter().append('g').attr('class','v-datashape');
        dataShapeEnter.append('rect').attr('class', 'v-datapoint');
        
        if(!hasAnmation){
          dataShape.exit().remove();
          if(options.isHorizontal === false){
            //vertical
            wrap.attr('transform', function(d, i){
              var categoryPos = categoryScale(i) + barInfo.barGap;
              return 'translate('+categoryPos+','+0+')';
            });
            
            dataShape.attr('transform', function(d){
              var y=(d.val > 0) ? primaryScale(intialValue + d.after) : primaryScale(intialValue + d.before);
              return 'translate('+0+','+y+')';
            });
            
            dataShape.select('rect').attr('fill',function(d){
                  var parameters = {
                  drawingEffect : drawingEffect,
                  fillColor : colorPalette[d.index % colorPalette.length],
                  direction : 'horizontal'
                };
                return effectManager.register(parameters);
              })
              .attr('width', barSize)
              .attr('height', function(d){
                return Math.abs(primaryScale(d.after)-primaryScale(d.before));
              }).attr('fill-opacity', 1).attr('stroke','none');
          }else{
            //horizontal
            wrap.attr('transform', function(d, i){
              var categoryPos = categoryScale(i) + barInfo.barGap;
              return 'translate('+0+','+categoryPos+')';
            });
            
            dataShape.attr('transform', function(d, i){
              var x= (d.val > 0) ? primaryScale(intialValue + d.before) : primaryScale(intialValue + d.after);
              return 'translate('+x+','+0+')';
            });
            
            dataShape.select('rect').attr('fill',function(d, i){
                  var parameters = {
                  drawingEffect : drawingEffect,
                  fillColor : colorPalette[d.index % colorPalette.length],
                  direction : 'vertical'
                };
                return effectManager.register(parameters);
              })
              .attr('height', barSize)
              .attr('width', function(d, i){
                return Math.abs(primaryScale(d.after)-primaryScale(d.before));
              }).attr('fill-opacity', 1).attr('stroke','none');
          }
          eDispatch.initialized();
        }else{
          //remove data shape
          dataShape.exit().transition().duration(interval)
            .attr('height', 0)
            .attr('width', 0)
            .remove();
          var ds, m, mLen;
          if(options.isHorizontal === false){
            //Vertical
            dataShapeEnter.selectAll('rect').attr('height', 0);
            dataShapeEnter.attr('transform', function(d){
              var y = primaryScale(intialValue + d.before); 
              return 'translate('+0+','+y+')';
            });
            
            wrap.attr('transform', function(d, i){
              var categoryPos = categoryScale(i) + barInfo.barGap;
              return 'translate('+categoryPos+','+0+')';
            });
            
            for(m = 0, mLen = dataShape.length; m<mLen; m++){
              ds = d3.selectAll(dataShape[m]);
              ds.transition()
                .duration(interval)
                .delay(function(d, i){
                  return m*interval;
                })
                .attr('transform', function(d){
                  var y = (d.val > 0) ? primaryScale(intialValue + d.after) : primaryScale(intialValue + d.before);
                  return 'translate('+0+','+y+')';
                });
              ds.select('rect').attr('fill',function(d){
                var parameters = {
                    drawingEffect : drawingEffect,
                    fillColor : colorPalette[d.index % colorPalette.length],
                    direction : 'horizontal'
                  };
                  return effectManager.register(parameters);
                })
                .attr('width', barSize).attr('fill-opacity', 1).attr('stroke','none')
                .transition()
                  .duration(interval)
                  .delay(function(){
                    return m*interval;
                  })
                  .attr('height', function(d){
                    return Math.abs(primaryScale(d.after)-primaryScale(d.before));
                  })
                  .each('end', function(d, i){
                    if(d.isLastItem !== undefined && d.isLastItem === true){
                      eDispatch.initialized();
                    }
                  });
            }
          }else{
            dataShapeEnter.selectAll('rect').attr('width', 0);
            dataShapeEnter.attr('transform', function(d){
              var x = primaryScale(intialValue + d.before);
              return 'translate('+x+','+0+')';
            });
            
            wrap.attr('transform', function(d, i){
              var categoryPos = categoryScale(i) + barInfo.barGap;
              return 'translate('+0+','+categoryPos+')';
            });
            
            for(m = 0, mLen = dataShape.length; m<mLen; m++){
              ds = d3.selectAll(dataShape[m]);
              ds.transition()
              .duration(interval)
              .delay(function(){
                return m*interval;
              })
              .attr('transform', function(d){
                var x = (d.val > 0) ? primaryScale(intialValue + d.before) : primaryScale(intialValue + d.after);
                return 'translate('+x+','+0+')';
              });
              ds.select('rect').attr('fill',function(d){
                var parameters = {
                    drawingEffect : drawingEffect,
                    fillColor : colorPalette[d.index % colorPalette.length],
                    direction : 'vertical'
                  };
                  return effectManager.register(parameters);
              })
                .attr('height', barSize).attr('fill-opacity', 1).attr('stroke','none')
                .transition()
                  .duration(interval)
                  .delay(function(){
                    return m*interval;
                  })
                  .attr('width', function(d){
                    return Math.abs(primaryScale(d.after)-primaryScale(d.before));
                  })
                  .each('end', function(d, i){
                    if(d.isLastItem !== undefined && d.isLastItem === true){
                      eDispatch.initialized();
                    }
                  });
            }
          }
        }
        //reset flags
        isDataLoading = false;
        isSizeChanged = false;
        isDatasetChanged = false;
      });
    };
    chart.afterUIComponentAppear = function(){
      eDispatch.initialized(); 
    };
    
    chart.hoverOnPoint = function(point) {
      var xOnModule = point.x, yOnModule = point.y;
      var posModule;
      if(options.isHorizontal === false){
        //vertical stacked waterfall bar chart
        posModule = xOnModule;
      }else{
        //horizontal stacked waterfall bar chart
        posModule = yOnModule;
      }
      // find the closet dimension
      var i = -1;
      var groupCount = chartData.length;
      while (i < groupCount) {
        if (Math.abs(posModule - categoryScale.rangeBand() * i - 0.5 * categoryScale.rangeBand()) <= 0.5 * categoryScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (groupCount - 1) || i < 0) {
        decorativeShape.style('visibility', 'hidden');
        return;
      }
      if(options.isHorizontal === false){
        decorativeShape.attr('x', categoryScale.rangeBand() * i + barInfo.barGap / 2);
      }else{
        decorativeShape.attr('y', categoryScale.rangeBand() * i + barInfo.barGap / 2 );
      }
      decorativeShape.style('visibility', 'visible');
      
      if (lastHovered !== i) {
        if (tooltipVisible) {
          lastHovered = i;
          // this.parentNode point to plot graphic. it is different from bar
          // chart as in bar chart it should get the yoffset which can get it
          // from mian graphic element
          var transform = sWrapper.node().getTransformToElement(sWrapper.node().ownerSVGElement);
          var tData = _TooltipDataHandler.generateTooltipData(originData, tooltipData, i, colorPalette, shapePalette);
          if (options.isHorizontal === false) {
            // vertical stacked waterfall bar chart
            tData.point = {
              x : categoryScale.rangeBand() * i + 0.5 * categoryScale.rangeBand() + transform.e,
              y : point.y
            };
          } else {
            // horizontal stacked waterfall bar chart
            tData.point = {
              x : point.x,
              y : categoryScale.rangeBand() * i + 0.5 * categoryScale.rangeBand() + transform.f
            };
          }
          
          eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
        }
      }

    };

    chart.blurOut = function() {
      decorativeShape.style('visibility', 'hidden');
      lastHovered = null;
      if (tooltipVisible) {
        eDispatch.hideTooltip();
      }
    };
  
    chart.highlight = function(elems) {		
		if (elems instanceof Array) {
			for ( var i = 0, len = elems.length; i < len; i++) {
				elems[i].setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
				elems[i].setAttribute('fill-opacity', 1);
				elems[i].setAttribute('stroke', '#333333');
			}
		} else {
			elems.setAttribute('class',CLASSDATAPOINT+ ' ' + CLASSMARKERSELECTED);
			elems.setAttribute('fill-opacity', 1);
			elems.setAttribute('stroke', '#333333');      
		}
		if(hasDefaultSelection){
			defaultSelUtil.clearSelectionInfo(sWrapper, true, elems);
		}
    };

    chart.unhighlight = function(elems) {
		if (elems instanceof Array) {
			for ( var i = 0, len = elems.length; i < len; i++) {
				elems[i].setAttribute('class',CLASSDATAPOINT);
				elems[i].setAttribute('fill-opacity', 0.4);
				elems[i].setAttribute('stroke', 'none');
			}
		} else {
			elems.setAttribute('class',CLASSDATAPOINT);
			elems.setAttribute('fill-opacity', 0.4);
			elems.setAttribute('stroke', 'none');
		}
		if (hasDefaultSelection) {
			defaultSelUtil.clearSelectionInfo(sWrapper, false, elems);
		}
    };

    chart.clear = function(gray) {
      if (gray === null || gray === false || gray === undefined) {
        var rects = sWrapper.selectAll('.v-datapoint');
        rects.attr('fill-opacity', 1).attr('stroke', 'none');
        if (hasDefaultSelection) {
          defaultSelUtil.clearSelectionInfo(sWrapper, false, rects);
        }
      } else {
        sWrapper.selectAll('.v-datapoint').attr('fill-opacity', 0.4).attr('stroke', 'none');
      }
    };

    chart.parent = function() {
      return sWrapper;
    };
    
    chart.data = function(_) {
      if (!arguments.length) {
        return originData;
      }
      originData = _;
      _parseOriginData(_);
      
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        _makeScale();
      }
      return chart;
    };

    chart.properties = function(props) {
      if (!arguments.length) {
        return options;
      }
      
      Objects.extend(true, options, props);
      colorPalette = options.colorPalette;
      drawingEffect = options.drawingEffect;
      tooltipVisible = options.tooltip.enabled;
      
      if(isShowTotal !== options.isShowTotal || isShowSubtotal !== options.subtotal.visible){
        //isShowTotal is changed, update dataset.
        isShowTotal = options.isShowTotal;
        isShowSubtotal = options.subtotal.visible;
        _parseOriginData(originData);
      }
      return chart;
    };

    chart.width = function(_) {
      if (!arguments.length) {
        return width;
      }
      isSizeChanged = (!isSizeChanged && (_ === width)) ? false : true;
      width = _;
      if(TypeUtils.isExist(originData) && TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        _makeScale();
      }
      return chart;
    };

    chart.height = function(_) {
      if (!arguments.length) {
        return height;
      }
      isSizeChanged = (!isSizeChanged && (_ === height)) ? false : true;
      height = _;
      if(TypeUtils.isExist(originData) && TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        _makeScale();
      }
      return chart;
    };

    chart.primaryAxisTitle = function(_) {
      if(!arguments.length){
        var titles =  originData.getMeasureValuesGroupDataByIdx(0), title = [];
        if(titles){
          for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
          }
        }
        return title.join('/');
      }
      return chart;
    };

    chart.secondAxisTitle = function(_) {
      if(!arguments.length){
        var titles =  originData.getMeasureValuesGroupDataByIdx(1), title = [];
        if(titles){
          for(var i=0, len =titles.values.length; i< len;i++ ){
                if (titles.values[i].col !== null && titles.values[i].col !== undefined)
                {
                    title.push(titles.values[i].col);
                }
                else
                {
                    title.push(langManager.get('IDS_ISNOVALUE'));
                }
          }
        }
        return title.join('/');
      }
      return chart;
    };

    chart.categoryScale = function(scale) {
      if (!arguments.length) {
        return categoryScale;
      }
      categoryScale = scale;
      return chart;
    };

    chart.primaryScale = function(scale) {
      if (!arguments.length) {
        return primaryScale;
      }
      primaryScale = scale;
      return chart;
    };
    
    chart.colorPalette = function(_){
      if(!arguments.length){
        return colorPalette;
      }
      colorPalette = _;
      return this;
    };

    chart.dispatch = function(_) {
      if (!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return chart;
    };

    chart.dataLabel = function(_) {
      return chart;
    };
    
    chart.dimensionData = function(_){
      if (!arguments.length) {
        return [dimensionData];
      }
      dimensionData = _;
    };
    
    var _getBarInfo = function(){
      //Calculate bar size and bar gap.
      var defaultBarSize = 2 * (categoryScale.rangeBand()) / 3;
      var defaultBarGap = defaultBarSize / 2;
      var customizeBarGap = options.barGap;
      var barGap = defaultBarGap, barSize = defaultBarSize;
      
      if(customizeBarGap !== undefined){
        var customizeBarSize = categoryScale.rangeBand() - customizeBarGap;
        if(!(customizeBarGap < 5 || customizeBarSize < 0)){
          barSize = customizeBarSize;
          barGap = customizeBarGap;
        }
      }
      
      //bar gap = single side gap width
      return {
        'barSize': barSize,
        'barGap' : barGap/2
      };
    };
      
    var _makeScale = function(){
      var domain = [];
      for (var i=0; i < categoryLen; i++){
           domain.push(i);
      }
      //when all data is 0 or null, we make primaryScale.domain from 0 to 1
      if(options.isHorizontal === true){
        categoryScale.domain(domain).rangeBands([0, height]);
        if( primaryAxisMinValue === 0 && primaryAxisMaxValue === 0){
          primaryScale.domain([0, 1]).range([0, width]).nice();
        }else{
          primaryScale.domain([primaryAxisMinValue, primaryAxisMaxValue]).range([0, width]).nice();
        }
      }else{
        categoryScale.domain(domain).rangeBands([0, width]);
        if( primaryAxisMinValue === 0 && primaryAxisMaxValue === 0){
          primaryScale.domain([0, 1]).range([height, 0]).nice();
        }else{
          primaryScale.domain([primaryAxisMinValue, primaryAxisMaxValue]).range([height, 0]).nice();
        }
        
      }
      Scaler.perfect(primaryScale);
    };
    
    var _parseOriginData = function(data){
      //set dimension data for category axis
      dimensionData = {};
      measureData = {};
      if((isShowTotal === true) || (options.subtotal.visible === true)){
        Objects2.extend(true, dimensionData, data.getAnalysisAxisDataByIdx(0));
        Objects2.extend(true, measureData, data.getMeasureValuesGroupDataByIdx(0));
      }else{
        dimensionData = data.getAnalysisAxisDataByIdx(0);
        measureData = data.getMeasureValuesGroupDataByIdx(0);
      }
      
      var obj = MNDHandler(data);
      
      //Init tooltip data
      tooltipData = TooltipDataHandler.dataTransform(obj);
      
      var mgData = obj["MG1"], start = options.initialValue;  //default start position is 0
      isDataSchemaChanged = false;
      
      if( mgData[0] && mgData[0][0].info && mgData[0][0].info.defaultSelection){
        hasDefaultSelection = true;
      }else{
        hasDefaultSelection = false;
      }
      
      //Check update type: update dataset, data schema or data loading
      if(categoryLen===undefined && measureLength===undefined){
        //Data loading
        isDataLoading = true;
      }else{
        isDatasetChanged = true;
      }
      //Check new dataset structure. 
      if((categoryLen!==undefined && measureLength!==undefined) && (categoryLen !== mgData[0].length || measureLength !== mgData.length)){
        isDataSchemaChanged = true;
      }
      
      var positive_start, negative_start, subStart, totals = [], subTotals = [], totalValue = 0, eachValueItem = {}, items = [], itemValue, isTotal, before, after, sum = 0, subGroupIndex, subGroupValidIndex = 0; //total is for each bar group, sum means total value of all value 
      var infos, totalSum = 0, hasTotal = false;
      positive_start = negative_start = start;
      chartData = [], primaryAxisMinValue = primaryAxisMaxValue = options.initialValue;
      
      categoryLen = mgData[0].length;
      measureLength = mgData.length;
      
      //check sub-group and add sub-total value
      var subIndex, tmpCategoryLen, subGroups;
      if(options.subtotal.visible === true){
        subIndex = 0;
        tmpCategoryLen = categoryLen;
        subGroups = options.subtotal.subGroups;
      }
      
      for ( var i = 0; i < categoryLen; i++) {
        //positive and negative start from the same position.
        positive_start = negative_start = start;
        //reset
        items = [], totalValue = totalSum = 0, isTotal = false;
        
        if(subStart === undefined) {
          subStart = start;
        }

        for ( var j = 0; j < measureLength; j++) {
          //Handle each value
          itemValue = _handleNullValue(mgData[j][i].val);
          infos = mgData[j][i].info;
          if(infos){
            isTotal = (infos.valueinfo === undefined) ? false : infos.valueinfo.isTotal;
            if(isTotal && (j === 0)){
              positive_start = negative_start = 0;
              hasTotal = true;
            }
          }
          
          if(itemValue !== defaultString){
            if(isTotal){
              if(itemValue > 0){
                before = positive_start;
                after = positive_start + itemValue;
                positive_start = after;
              } else {
                before = negative_start;
                after = negative_start + itemValue;
                negative_start = after;
              }
              totalSum = totalSum + itemValue;
            }else{
              subTotals[j] = (subTotals[j] ? subTotals[j] + itemValue : itemValue);
              
              //except Null value
              totalValue = totalValue + itemValue;
              
              //adjust before and after value
              if(itemValue > 0){
                before = positive_start;
                after = positive_start + itemValue;
                positive_start = after;
              } else {
                before = negative_start;
                after = negative_start + itemValue;
                negative_start = after;
              }
              totals[j] = (totals[j] ? totals[j] + itemValue : itemValue);
            }
            //Set primaryAxisMinValue, primaryAxisMaxValue
            if(after > primaryAxisMaxValue){
              primaryAxisMaxValue = after;
            }
            if(after < primaryAxisMinValue){
              primaryAxisMinValue = after;
            }
            
            eachValueItem = {
                "index" : j,
                "val": mgData[j][i].val,
                "info": mgData[j][i].info,
                "before": before,
                "after": after,
                "ctx": mgData[j][i].ctx
            };
            items.push(eachValueItem);
          }
        }
        if(isTotal){
          chartData.push({
            "total": totalSum,
            "start": 0,
            "items": items
          });
        }else{
          chartData.push({
            "total": totalValue,
            "start": start,
            "items": items
          });
        }
        
        //reset sum
        sum = sum + totalValue;
        
        if(options.subtotal.visible === true){
          //Add sub-total value
          subGroupIndex = subGroups[subIndex];
          while((subIndex < subGroups.length) && (subGroupIndex < 0 || subGroupIndex > categoryLen - 1 )){
            subIndex++;
            subGroupIndex = subGroups[subIndex];
          }
          if(i === subGroupIndex){
            //last category bar in this bar group. And add sub-total
            if(options.subtotal.isSubgroupTotal){
              _addTotalItemToChartData(i+subGroupValidIndex+1, start, subTotals, "Sub-Total-"+subGroupValidIndex);
            }else{
              _addTotalItemToChartData(i+subGroupValidIndex+1, 0, totals, "Sub-Total-"+subGroupValidIndex);
            }
            subStart = undefined;
            subTotals = [];
            subIndex++;
            subGroupValidIndex ++;
            tmpCategoryLen++;
          }
        }
        //reset start position.
        start = start + totalValue;
      }
      
      if(hasTotal){
        //Re-check axis max and min value
        if(primaryAxisMinValue > 0){
          primaryAxisMinValue = 0;
        }else if(primaryAxisMaxValue < 0){
          primaryAxisMaxValue = 0;
        }
      }
      
      if(tmpCategoryLen !== undefined){
        categoryLen = tmpCategoryLen;
      }
      
      if(isShowTotal){
        _addTotalItemToChartData(categoryLen, 0, totals, "Total");
        categoryLen++;
      }
      //Add last item flag to send initialized
      if(categoryLen > 0){
        var lastItems = chartData[categoryLen - 1].items;
        if(lastItems.length > 0){
          lastItems[lastItems.length - 1].isLastItem = true;
        }
      }
    };

    var _addTotalItemToChartData = function(index, start, sumArr, dimensionName){
      var positive_start, negative_start, before, after, eachValueItem, items = [], sum = 0, itemValue;
      positive_start = negative_start = start;
      
      for(var i = 0, iLen = sumArr.length; i < iLen; i++){
        itemValue = sumArr[i];
        sum = sum + itemValue;
        if(itemValue > 0){
          before = positive_start;
          after = positive_start + itemValue;
          positive_start = after;
        } else {
          before = negative_start;
          after = negative_start + itemValue;
          negative_start = after;
        }
        eachValueItem = {
            "index" : i,
            "val": itemValue,
            "before": before,
            "after": after,
            "ctx": {
              "path" : {
                "mg" : itemValue,
                "mi" : i
              }
            }
        };
        items.push(eachValueItem);
        measureData.values[0].rows[i].splice(index, 0, {val: sumArr[i]});
      }
      chartData.push({
        "total": sum,
        "start": start,
        "items": items
      });
      
      dimensionData.values[0].rows.splice(index, 0, {val: dimensionName});
    };
    
    var _handleNullValue = function(value){
      return (value === null || value === undefined) ? defaultString : value;
    };

    function getCSSStyle() {
      style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
    }

    getCSSStyle();
    options = manifest.props(null);
    return chart;
  };
  return stackedwaterfall;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.stackedwaterfall',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedwaterfall',
      'name' : 'stackedwaterfall',
      base : "sap.viz.modules.xy.bar.base",
      'properties' : {
        'isRoundCorner' : null,
        'primaryValuesColorPalette' : { 'isExported' : false },
        'secondaryValuesColorPalette' : { 'isExported' : false },
        'isHorizontal' : {
          'name' : 'isHorizontal',
          'supportedValueType' : 'Boolean',
          'defaultValue' : false,
          'description' : 'Set stacked waterfall orientaion.',
          'isExported' : false
        },
        'isShowTotal' : {
          'name' : 'isShowTotal',
          'supportedValueType' : 'Boolean',
          'defaultValue' : false,
          'description' : 'Set stacked waterfall show/hide total value.',
          'isExported' : false
        },
        'subtotal' : {
          'name' : 'subtotal',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set visibility of subtotal.'
            }, 
            'isSubgroupTotal' : {
              'name' : 'isSubgroupTotal',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set isRuntimeTotal of subtotal.'
            },
            'subGroups' : {
              'name' : 'subGroups',
              'supportedValueType' : 'StringArray',
              'defaultValue' : [],
              'description' : 'Set bar groups.',
                'isExported' : false
            }
          },
          'isExported' : false,
          'description' : 'Settings for subtotal related properties.'
        },
        'barGap': {
          'name' : 'barGap',
          'supportedValueType' : 'PositiveInt',
          'defaultValue' : undefined,
          'min' : '5',
          'description': "Set the distance between bars. Default value is the same as bar size.",
          'isExported' : true
        },
        'initialValue': {
          'name' : 'initialValue',
          'supportedValueType' : 'PositiveInt',
          'defaultValue' : 0,
          'description': "Set initial value of waterfall.",
          'isExported' : true
        }
      },
      fn : fn,
      'feeds' : {
        configure : {
          'secondaryValues' : null,
          'regionColor': {
            acceptMND : -1,
            min : 1,
            max : 1
          },
          'axisLabels' : {
            max : 1,
            acceptMND : -1
          },
          'primaryValues' : {
            max : 1
          }
        }
      }
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.StackedWaterfallChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
    var chart = {
      id : 'viz/stacked_waterfall',
      name : 'IDS_STACKEDWATERFALLCHART',
      base : 'riv/baseverticalchart',
      modules : {
        root : {
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                }
              }
            },
             main : {
              modules : {
                plot : {
                  id : 'sap.viz.modules.stackedwaterfall',
                  configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                  }
                },
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      showZero : false
                    },
                    propertiesOverride : {
                      position : {
                        isExported : false
                      }
                    }
                  }
                }
              }
            }
          }
        }
       
      },
      feeds:{
        primaryValues : {
          'max' : constants.Constraints.INF
        },
        regionColor : {
          'acceptMND' : 1,
          'max' : 2
        },
        axisLabels : {
          max : 1,
          acceptMND : 0,
          maxStackedDims : 1
        }
      },
      dependencies : {
        attributes : [ undefined, undefined, undefined,
         {
          targetModule : 'root.main.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'root.main.xAxis',
          target : 'independentData',
          sourceModule : 'root.main.plot',
          source : 'dimensionData'
        } ],
       events : [ {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        } ]
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalStackedWaterfallChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.StackedWaterfallChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_stacked_waterfall',
    name : 'IDS_HORIZONTALSTACKEDWATERFALL',
    base : "viz/stacked_waterfall",
    modules : {
      root : {
        modules : {
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'bar'
              }
            }
          },
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedwaterfall',
                configure : {
                  propertyCategory : 'plotArea',
                  properties : {
                    'isHorizontal' : true
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description' : 'Settings for the value axis of an XY chart.',
                  propertyCategory : 'xAxis',
                  properties : {
                    type : 'value',
                    position : 'bottom',
                    gridline : {
                      visible : true
                    }
                  }
                }
              },
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description' : 'Settings for the category axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    gridline : {
                      visible : false
                    },
                    isIndependentMode : true
                  },
                  propertiesOverride : {
                    gridline : {
                      isExported : false
                    },
                    label : {
                      isExported : false
                    },
                    axisline : {
                      isExported : false
                    }
                  }
                }
              },
              background : {
                id: 'sap.viz.modules.background',
                configure : {
                  propertyCategory : 'background',
                  properties : {
                    direction : 'horizontal'
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false,
                    orientation : 'horizontal'
                  },
                  propertiesOverride : {
                    position : {
                      isExported : false
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      axisLabels : {
        maxStackedDims : 1
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      }, undefined, {
        targetModule : 'root.main.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'primaryAxisTitle'
      },{
        targetModule : 'root.main.yAxis',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.WaterfallChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/waterfall',
      name : 'IDS_WATERFALLCHART',
      base : 'riv/baseverticalchart',
      modules : {
        root : {
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                }
              }
            },
            legends : null,
            main : {
              modules : {
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      showZero : false,
                      outsideVisible : false
                    }
                  }
                },
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                }, 
                plot : {
                    id : 'sap.viz.modules.stackedwaterfall',
                    configure : {
                        'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea',
                        propertiesOverride : {
                          isShowTotal : {
                            isExported : false
                          }
                        }
                    }
                }
              }
          }
          }
        }

      },
      feeds:{
        'regionColor' : null
      },
      dependencies : {
          attributes : [ {
            targetModule : 'root.main.yAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'primaryScale'
          },{
            targetModule : 'root.main.xAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'categoryScale'
          },null,{
      targetModule : 'root.main.yAxis',
            target : 'title',
            sourceModule : 'root.main.plot',
            source : 'primaryAxisTitle'
      },{
        targetModule : 'root.main.xAxis',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
      }],
           events : [ {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'root.interaction',
            listener : 'registerEvent',
            sourceModule : 'root.main.plot',
            type : 'initialized.interaction'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'showLabel',
            sourceModule : 'root.main.plot',
            type : 'initialized.datalabel'
          },{
            targetModule : 'root.main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'root.main.plot',
            type : 'startToInit.datalabel'
          }, {
            targetModule : 'root.main.dataLabel',
            listener : 'removeLabel',
            sourceModule : 'root.main.plot',
            type : 'startToInit.datalabel'
          }, {
            targetModule : 'root.interaction',
            listener : 'defaultSelection',
            sourceModule : 'root.main.plot',
            type : 'initialized.defaultSelection'
          } ]
        }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalWaterfallChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedWaterfall',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/horizontal_waterfall',
      name : 'IDS_HORIZONTALWATERFALLCHART',
      base : 'riv/basehorizontalchart',
      modules : {
        root : {
          modules : {
            interaction : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                clientID : 'main',
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                }
              }
            },
            legends : null,
            main : {
                modules : {
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        showZero : false,
                        outsideVisible : false
                      }
                    }
                  },
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      properties : {
                        isIndependentMode : true
                      }
                    }
                  }, 
                  plot : {
                      id : 'sap.viz.modules.stackedwaterfall',
                      configure : {
                          'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                          propertyCategory : 'plotArea',
                          properties : {
                            'isHorizontal' : true
                          },
                          propertiesOverride : {
                            isShowTotal : {
                              isExported : false
                            }
                          }
                      }
                  }
                }
             }
          }
        }
        
      },
      feeds:{
        'regionColor' : null
      },
      dependencies : {
          attributes : [ {
            targetModule : 'root.main.xAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'primaryScale'
          },{
            targetModule : 'root.main.yAxis',
            target : 'scale',
            sourceModule : 'root.main.plot',
            source : 'categoryScale'
          },null,{
        targetModule : 'root.main.xAxis',
            target : 'title',
            sourceModule : 'root.main.plot',
            source : 'primaryAxisTitle'
      },{
        targetModule : 'root.main.yAxis',
        target : 'independentData',
        sourceModule : 'root.main.plot',
        source : 'dimensionData'
      }],
          events : [ {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main.plot',
            type : 'hideTooltip'
          }, {
              targetModule : 'root.interaction',
              listener : 'registerEvent',
              sourceModule : 'root.main.plot',
              type : 'initialized.interaction'
           }, {
             targetModule : 'root.main.dataLabel',
             listener : 'showLabel',
             sourceModule : 'root.main.plot',
             type : 'initialized.datalabel'
           }, {
             targetModule : 'root.main.dataLabel',
             listener : 'removeLabel',
             sourceModule : 'root.main.plot',
             type : 'startToInit.datalabel'
           }, {
             targetModule : 'root.main.dataLabel',
             listener : 'removeLabel',
             sourceModule : 'root.main.plot',
             type : 'startToInit.datalabel'
           } ]
        }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.ImageBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/image_bar',
    name : 'IDS_IMAGEBARCHART',
    base : 'viz/bar',
    'isExported':false,
    modules : {
      root : {
        modules : {
          main : {
            modules : {
              dataLabel: {
                configure: {
                  properties : {
                    visible: true,
                    position: "outside"
                  }
                }
              },
              plot: {
                configure: {
                  properties : {
                    imageFill: true
                  },                
                  propertiesOverride:{
                    imagePalette: { isExported: true }
                  }
                }
              }
            }
          }
        }
      }
    },
      dependencies : {
        attributes : [ undefined, undefined, undefined,undefined,undefined, undefined, 
        {
          targetModule : 'root.legends.legend',
          target : 'imageInfo',
          sourceModule : 'root.main.plot',
          source : 'imageInfo'
        }, {
          targetModule : 'root.tooltip',
          target : 'imageInfo',
          sourceModule : 'root.main.plot',
          source : 'imageInfo'
        } ]
      }         

  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_bar',
    name : 'IDS_DUALBARCHART',
    base : 'viz/bar',
    modules : {
      root : {
        modules : {
          main : {
            modules : {
              plot: {
                configure: {
                  propertiesOverride:{
                    primaryValuesColorPalette:{ isExported: true },
                    secondaryValuesColorPalette: { isExported: true }
                  }
                }
              },
              xAxis:{
                id : 'sap.viz.modules.axis',
                configure:{
                  'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              },
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'xAxis2',
                  properties : {
                    type : 'value',
                    position : 'top',
                    gridline : { visible : false }
                  },
                  propertiesOverride:{
                    title:{
                      applyAxislineColor:{
                        isExported: true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      secondaryValues: { min : 1, max : Number.POSITIVE_INFINITY /* or null */  }
    },
    
    dependencies : {
      attributes : [ 
      {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'primaryScale'
      }, 
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'secondScale'
      }, 
      {
        targetModule : 'root.main.xAxis',
        target : 'color',
        sourceModule : 'root.main.plot',
        source : 'primaryAxisColor'
      }, 
      {
        targetModule : 'root.main.xAxis2',
        target : 'color',
        sourceModule : 'root.main.plot',
        source : 'secondAxisColor'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScale'
      },
      {
      targetModule : 'root.main.xAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
      }, 
      {
        targetModule : 'root.main.xAxis2',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'colorPalette'
      }, 
      {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_column',
    name : 'IDS_DUALVERTICALBARCHART',
    base : 'viz/column',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
              yAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.',
                    propertiesOverride:{
                      title:{
                        applyAxislineColor:{
                          isExported: true
                        }
                      }
                    }
                  }
                },
                yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                        'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'yAxis2',
                        properties : {
                            type : 'value',
                            position : 'right',
                            gridline : { visible : false }
                        },
                        propertiesOverride:{
                          title:{
                            applyAxislineColor:{
                              isExported: true
                            }
                          }
                        }
                    }
                }
              }
            }
          }
        }
          
      },
    feeds:{
      secondaryValues: {
        min : 1,
        max : Number.POSITIVE_INFINITY 
      }
    },
      dependencies : {
        attributes : [ {
          targetModule : 'root.main.plot',
          target : 'primaryDataRange',
          sourceModule : 'root.main.yAxis',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'root.main.plot',
          target : 'secondDataRange',
          sourceModule : 'root.main.yAxis2',
          source : 'range'
        }, {
          targetModule : 'root.main.yAxis2',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'secondScale'
        }, {
          targetModule : 'root.main.yAxis',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'root.main.yAxis2',
          target : 'color',
          sourceModule : 'root.main.plot',
          source : 'secondAxisColor'
        }, {
          targetModule : 'root.main.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot',
          source : 'categoryScale'
        }, {
      targetModule : 'root.main.yAxis2',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'secondAxisTitle'
    },{
      targetModule : 'root.main.yAxis',
       target : 'title',
       sourceModule : 'root.main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
        } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_column',
      name : 'IDS_STACKEDVERTICALBARCHART',
      base : 'viz/column',
      feeds : { secondaryValues: null },
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                plot : {
                  id : 'sap.viz.modules.stackedverticalbar',
                  configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                  }
                },
                
                dataLabel : {
                  id : 'sap.viz.modules.datalabel',
                  configure : {
                    properties : {
                      automaticInOutside : false,
                      isStackMode : true,
                      showZero : false
                    },
                    propertiesOverride : {
                      position : {
                        isExported : false
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.2'
}
],
function Setup ( Manifest,Constants ) {
    var chart = {
      id : 'viz/dual_stacked_column',
      name : 'IDS_DUALSTACKEDVERTICALBARCHART',
      base : 'viz/dual_column',
      modules : {
        root : {
          modules : {
            main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
            }
          }
        }
          
      }
    };
    
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualPercentageStackedVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/100_dual_stacked_column',
      name : 'IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART',
      base : 'viz/dual_stacked_column',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  },
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          isPercentMode : true,
                          showZero : true
                        }
                      }
                    },
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  },
                  yAxis2 : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                      'description': 'Settings for the value axis of an XY chart.',
                        propertyCategory : 'yAxis2',
                        properties : {
                          isPercentMode : true
                        }
                      }
                    }
                  }
              },
              tooltip : {
                  id : 'sap.viz.modules.tooltip',
                  configure : {
                    propertyCategory : 'tooltip',
                    properties : {
                      chartType : '100_dual_stacked_column',
                      orientation : 'bottom',
                    formatString: [["0.00%"],["0.00%"]]
                  }
                }
              }
          }
        }
      }    
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_bar',
      name : 'IDS_STACKEDBARCHART',
      base : 'viz/bar',
      feeds:{
        secondaryValues: null
      },
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      properties : {
                        automaticInOutside : false,
                        isStackMode : true,
                        showZero : false
                      },
                      propertiesOverride : {
                        position : {
                          isExported : false
                        }
                      }
                    }
                  }
              }
          }
          }
        }
          
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/dual_stacked_bar',
      name : 'IDS_DUALSTACKEDBARCHART',
      base : 'viz/dual_bar',
      modules : {
        root : {
          modules : {
            main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false,
                    isStackMode : true,
                    showZero : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
          }
          }
        }
          
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualPercentageStackedBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/100_dual_stacked_bar',
      name : 'IDS_DUALPERCENTAGESTACKEDBARCHART',
      base : 'viz/dual_stacked_bar',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                plot : {
                  id : 'sap.viz.modules.stackedbar',
                  configure : {
                      properties : {
                           mode : 'percentage'
                      }
                  }
                },
                dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        isPercentMode : true,
                        showZero : true
                      }
                    }
                  },
                  xAxis : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                      'description': 'Settings for the value axis of an XY chart.',
                        propertyCategory : 'xAxis',
                        properties : {
                          isPercentMode : true
                        }
                      }
                    },  
                    xAxis2 : {
                        id : 'sap.viz.modules.axis',
                        configure : {
                        'description': 'Settings for the value axis of an XY chart.',
                          propertyCategory : 'xAxis2',
                          properties : {
                            isPercentMode : true
                          }
                        }
                      }
                  }
              },
              tooltip : {
                id : 'sap.viz.modules.tooltip',
                configure : {
                  propertyCategory : 'tooltip',
                  properties : {
                    chartType : '100_dual_stacked_bar',
                    orientation : 'left',
                    formatString: [["0.00%"],["0.00%"]]
                  }
                }
              }
          }
        }
      }  
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageStackedBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_stacked_bar',
      name : 'IDS_PERCENTAGESTACKEDBARCHART',
      base : 'viz/stacked_bar',
      modules : {
        root : {
          modules : {
             main : {
                modules : {
                    plot : {
                      id : 'sap.viz.modules.stackedbar',
                      configure : {
                          properties : {
                               mode : 'percentage'
                          }
                      }
                    },            
                    xAxis : {
                      id : 'sap.viz.modules.axis',
                      configure : {
                      'description': 'Settings for the value axis of an XY chart.',
                        propertyCategory : 'xAxis',
                        properties : {
                          isPercentMode : true
                        }
                      }
                    },
                    dataLabel : {
                        id : 'sap.viz.modules.datalabel',
                        configure : {
                          propertyCategory : 'dataLabel',
                          properties : {
                            type : 'value',
                            isPercentMode: true,
                            showZero : true
                          }
                        }
                      }
                }
            },
           
            tooltip : {
                id : 'sap.viz.modules.tooltip',
                configure : {
                  propertyCategory : 'tooltip',
                  properties : {
                    chartType : '100_stacked_bar',
                    orientation : 'left',
                    formatString: [["0.00%"],["0.00%"]]
                  }
                }
            }
          }
        }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageStackedVerticalBarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_stacked_column',
      name : 'IDS_PERCENTAGESTACKEDVERTICALBARCHART',
      base : 'viz/stacked_column',
      modules : {
        root : {
          modules : {
            main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  } ,
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        isPercentMode : true
                      }
                    }
                  },
                  dataLabel : {
                      id : 'sap.viz.modules.datalabel',
                      configure : {
                        propertyCategory : 'dataLabel',
                        properties : {
                          type : 'value',
                          isPercentMode: true,
                          showZero : true
                        }
                      }
                    }
                  }
              },
              tooltip : {
                  id : 'sap.viz.modules.tooltip',
                  configure : {
                    propertyCategory : 'tooltip',
                    properties : {
                      chartType : '100_stacked_column',
                      orientation : 'bottom',
                      formatString: [["0.00%"],["0.00%"]]
                    }
                  }
              }
              
          }
        }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.tooltip',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
}
],
function Setup( TextUtils, UADetector, ObjectUtils ) {
  var wrapperClass = "v-pie-tooltip", caretClass = "v-pie-tooltip-caret", minRadius = 8.9 * 14 / 2;
  var caretAngle = 60, textsVSpacing = 8;

  var oldTextsClassNames = ["viz-pie-tooltip-label-dimensions", "viz-pie-tooltip-label-value",
      "viz-pie-tooltip-label-percentage"];
  var textClassNames = ["v-tooltip-label", "v-tooltip-value", "v-tooltip-percentage"];

  function renderCaret( p ) {
    var c = p.append("svg:path").attr("class", caretClass).attr("d", "M 0 0 Z").attr("fill", "#fff");
    if ( UADetector.isSafari() ) {
      c.style("-webkit-svg-shadow", "0 0 10px rgba(0, 0, 0, 0.25)");
    } else {
      var shadowFilterId = "tooltip-caret-shadow-" + ObjectUtils.guid();
      p.append("defs").call(createShadowFilterDef, shadowFilterId);
      c.attr("filter", "url(#" + shadowFilterId + ")");
    }
  }

  function createShadowFilterDef( defs, id ) {
    var shadowFilter = defs.append("filter").attr("id", id);

    shadowFilter.append("feGaussianBlur").attr("in", "SourceAlpha").attr("stdDeviation", 3).attr("result", "blur");
    var feMerges = shadowFilter.append("feMerge");
    feMerges.append("feMergeNode").attr("in", "blur");
    feMerges.append("feMergeNode").attr("in", "SourceGraphic");
  }

  function renderTexts( p, styleManager ) {
    for ( var i = 0; i < 3; i++) {
      var className = textClassNames[i];

      var text = p.append("svg:text").attr("dominant-baseline", "central").attr("text-anchor", "middle");

      styleManager.queryDefault(className).toAttrs(text);

      text.attr("class", oldTextsClassNames[i] + " " + className).datum(function( d ) {
        return {
          text : ""
        };
      });
    }
  }

  function texts( p ) {
    return p.selectAll("text");
  }

  function adjustTexts( texts, styleManager ) {
    var textClass1 = textClassNames[1];
    var text1Height;
    texts.each(function( d ) {
      d.r = d3.select(this.parentNode).datum().r;
    }).filter("." + textClass1).attr("dy", function( d ) {
      var dy = 0, txt = d.text;
      if ( UADetector.isIE() ) {
        dy = TextUtils.verticalCentralOffset(txt, this);
      }

      TextUtils.ellipsisInCircle(txt, this, d.r, 0, styleManager.cssText(textClass1));
      text1Height = this.getBBox().height;

      return dy;
    });
    texts.filter(":not(." + textClass1 + ")").attr("dy", function( d, i ) {
      var txt = d.text;
      var txtHeight = TextUtils.measure(txt, this).height;

      var dy = (UADetector.isIE() ? (i === 0 ? 0 : txtHeight) : (txtHeight / 2)) + text1Height / 2 + textsVSpacing;

      var maxLength = Math.sqrt(Math.pow(d.r, 2) - Math.pow(txtHeight + text1Height / 2 + textsVSpacing, 2)) * 2;

      TextUtils.ellipsis(txt, this, maxLength, styleManager.cssText(textClassNames[i === 0 ? 0 : 2]));
      if ( i === 0 ) {
        dy = -dy;
      }

      return dy;
    });
  }

  function normalizeAngle( a ) {
    a %= 360;

    if ( a < 0 ) {
      a += 360;
    }
    return a;
  }

  function caretRotateTween( el, endAngle ) {
    var transformList = el.transform.baseVal;
    var startAngle = transformList.numberOfItems === 0 ? 0 : normalizeAngle(transformList.getItem(0).angle);

    var endAngles = [];
    endAngles[0] = normalizeAngle(endAngle);
    endAngles[1] = endAngles[0] - 360;
    endAngles[2] = endAngles[0] + 360;

    var minRange = 360, index = null;
    for ( var i = 0; i < endAngles.length; i++) {
      var range = Math.abs(endAngles[i] - startAngle);
      if ( range < minRange ) {
        minRange = range;
        index = i;
      }
    }

    var interpolator = d3.interpolateNumber(startAngle, endAngles[index]);
    return function( t ) {
      return "rotate(" + interpolator(t) + ")";
    };
  }

  function computeCaretSize( or ) {
    if ( or >= 12 * 14 ) {
      return 14;
    }

    if ( or >= 8 * 14 ) {
      return 0.8 * 14;
    }

    return 0.5 * 14;
  }

  return function() {
    function tooltip( p, styleManager ) {
      var wrapper = p.selectAll("g." + wrapperClass).data(function( d, i ) {
        var data;
        if ( d.or > minRadius ) {
          data = [{
            r : d.ir,
            caretSize : computeCaretSize(d.or)
          }];
        } else {
          data = new Array(0);
        }
        return data;
      });
      wrapper.exit().remove();

      texts(wrapper).call(adjustTexts, styleManager);

      wrapper.enter().append("svg:g").attr("class", wrapperClass).style("opacity", 0).attr("visibility", "hidden")
          .attr("pointer-events", "none").call(renderCaret).call(renderTexts, styleManager);
    }

    tooltip.select = function( p, dispatch ) {
      var wrapper = p.selectAll("g." + wrapperClass);
      if ( wrapper.empty() ) {
        return null;
      }

      return {
        show : function() {
          wrapper.attr("visibility", null).transition().duration(200).style("opacity", 1);
          dispatch.showTooltip();
          return this;
        },
        hide : function() {
          wrapper.transition().each("end", function() {
            wrapper.attr("visibility", "hidden");
          }).duration(200).style("opacity", 0);
          dispatch.hideTooltip();
          return this;
        },
        texts : function() {
          var values = arguments;
          texts(wrapper).each(function( d, i ) {
            d.text = values[i];
          }).call(adjustTexts, values[3]);
          return this;
        },
        caret : function() {
          var caret = wrapper.select("." + caretClass);

          return {
            show : function() {
              caret.attr("d", function( d ) {
                var x = Math.tan(caretAngle * Math.PI / 360) * d.caretSize;
                var y = Math.sqrt(d.r * d.r - x * x);
                return "M 0 " + -(y + d.caretSize) + " L " + x + " " + -y + " A " + d.r + " " + d.r + " 0 1 1 " + -x +
                    " " + -y + " Z";
              });
              return this;
            },
            hide : function() {
              caret.attr("d", function( d ) {
                return "M 0 " + d.r + " A " + d.r + " " + d.r + " 0 1 1 0 " + -d.r + " A " + d.r + " " + d.r +
                    " 0 1 1 0 " + d.r + " Z";
              });
              return this;
            },
            rotateTo : function( angle ) {
              caret.transition().duration(200).attrTween("transform", function() {
                return caretRotateTween(this, angle * 180 / Math.PI);
              });

              return this;
            }
          };
        }
      };
    };

    return tooltip;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
}
],
function Setup( Constants, NumberUtils ) {
  var pieLayout = d3.layout.pie().sort(null).value(function( d ) {
    return d.v;
  });

  function SectorData( mvObject, dimValueObjects, color, r, value, startAngle, endAngle, p ) {
    this.dimValueObjects = dimValueObjects;
    this.color = color;
    this.r = r;
    this._value = value;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.p = p;
    this.decoras = [];

    for ( var i in mvObject) {
      if ( mvObject.hasOwnProperty(i) ) {
        this[i] = mvObject[i];
      }
    }
  }

  SectorData.prototype = {
    midAngle : function() {
      return (this.endAngle + this.startAngle) / 2;
    },

    dimValues : function() {
      return this.dimValueObjects.map(function( o ) {
        var ret;
        if ( o.info ) {
          var clobj = o.info.customlabel;
          if ( clobj ) {
            if ( clobj.type === 'url' ) {
              ret = o.val;
            } else if ( clobj.type === 'string' ) {
              ret = clobj.val;
            }
          } else {
            ret = o.val;
          }
        } else {
          ret = o.val;
        }
        return ret;
      });
    },

    value : function( format ) {
      var v = this._value;
      if ( format ) {
        return d3.format(format)(v);
      }
      return v;
    },

    proportion : function( format ) {
      var v = (this.endAngle - this.startAngle) / (2 * Math.PI);
      if ( format ) {
        return d3.format(format)(v);
      }
      return v;
    }
  };

  function sectorDatas( d, effectManager ) {
    var mvs = d.measure.rows[0];
    var dimensions = d.dimensions;

    var domain = [];
    var datas = mvs.map(function( mv, i ) {
      domain.push(i);
      return {
        v : mv.val,
        i : i
      };
    }).filter(function( o ) {
      var v = o.v;
      return (!NumberUtils.isNoValue(v)) && v > 0;
    });

    var color = d.color.domain(domain);
    var r = d.or;
    var result = pieLayout(datas).map(function( data ) {
      var index = data.data.i;
      var fillID = effectManager.register({
        drawingEffect : d.drawingEffect,
        graphType : 'sector',
        fillColor : color(index),
        direction : 'vertical',
        radius : r
      });
      return new SectorData(mvs[index], dimensions.map(function( dimVs ) {
        return dimVs.rows[index];
      }), fillID, r, data.value, data.startAngle, data.endAngle, d.p);
    });
    return result;
  }

  var module = function() {
    function sector( sectorGroup, effectManager, styleManager ) {
      var sectors = module.all(sectorGroup).data(function( d ) {
        return sectorDatas(d, effectManager);
      });
      sectors.exit().remove();
      var newSectors = sectors.enter().append('svg:g').attr('class', 'v-datashape').append('svg:path').attr("class",
          Constants.CSS.CLASS.DATAPOINT + ' ' + "viz-pie-sector v-sector");
      styleManager.queryDefault("v-sector").toAttrs(newSectors);
      sectors.select('g.v-datashape path').attr("fill", function( d ) {
        return d.color;
      }).attr("d", d3.svg.arc().outerRadius(function( d ) {
        return d.r;
      }));
    }

    return sector;
  };

  module.all = function( sectorGroup ) {
    return sectorGroup.selectAll("g.v-datashape");
  };

  return module;
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.selection',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.2'
}
],
function Setup( sectorModule ) {
  var selectedSectorClass = "v-selectedSector";
  var selectedClass = "v-selected";
  var selectedDataLabel;
  function select( sect, flag, noAnimation ) {
    sect.classed(selectedSectorClass, flag).attr("fill-opacity", flag ? "1" : null);
    var dx = 0, dy = 0;
    if ( !noAnimation ) {
      sect = sect.transition().duration(200);
    }
    sect.each(function( d ) {
      dx = 0, dy = 0;
      if ( flag ) {
        if ( this.parentNode.parentNode.childNodes.length !== 1 ) {
          var a = d.midAngle();
          var r = d.r;
          var sectorMoveOffset;
          if ( r >= 96 ) {
            sectorMoveOffset = 6;
          } else if ( r >= 24 ) {
            sectorMoveOffset = 4;
          } else {
            sectorMoveOffset = 2;
          }
          dx = sectorMoveOffset * Math.sin(a);
          dy = -sectorMoveOffset * Math.cos(a);
        }
      }

      d3.select(this.parentNode).attr('transform', "translate(" + dx + "," + dy + ")");
    });
    sect.each('start', function( d ) {
      var transformStr = d3.select(this.parentNode).attr('transform');
      d.decoras.forEach(function( element, index, array ) {
        selectedDataLabel = d3.select(element);
        /**
         * we can't get the value in the start of the animation d3.select(this).attr('transform')
         */
        selectedDataLabel.transition().attr('transform', transformStr);
        if ( selectedDataLabel[0][0] !== null ) {
          if ( dx === 0 && dy === 0 ) {
            selectedDataLabel.attr('fill-opacity', null);
          } else {
            selectedDataLabel.attr('fill-opacity', '1');
          }
        } else {
          selectedDataLabel.attr('fill-opacity', '1');
        }
      }, this);
    });
  }

  function selected( sect ) {
    return sect.classed(selectedSectorClass);
  }

  return function() {
    return {
      allSelected : function( sectorGroup ) {
        return sectorGroup.selectAll("." + selectedSectorClass);
      },

      select : function( s, flag ) {
        select(s, flag);
      },

      clear : function( g, flag ) {
        g.attr("fill-opacity", flag ? "0.4" : null);
      },

      selected : function( sect ) {
        return sect.classed(selectedSectorClass);
      },

      clearAll : function( sectorGroup ) {
        this.clear(sectorGroup, false);
        this.allSelected(sectorGroup).call(select, false, true);
      }
    };
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.piewithdepth',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.pie.selection',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.pie.tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
}
],
function Setup(sectorModule, selectionModule, tooltip, TextUtils,
    ColorSeriesGenerator, dispatch, UADetector, FunctionUtils, TypeUtils,
    ObjectUtils, Objects, formatManager, langManager, BoundUtil, tooltipDataHandler) {

    var fn = function(manifest) {
        var width = 500, height = 300, padding = 0;
        var data = null, props = {};
        var zAngle = Math.PI / 4;
        var rx = 0, ry = 0, drx = 0, dry = 0, baseHeight = 0, bottomCX = 0, bottomCY = 0;
        var sum = 0, maxDepthVal = 0;
        var heightScale = d3.scale.linear();
        var color = ColorSeriesGenerator.sap32().range();
        var isDonut = false, number;
        var _selection, _transform;
        var rotationAngle = 0;
        var _dispatch = dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
        
        var CLASS_MARKER_SELECTED = "v-datapoint-selected",
            CLASS_MARKER_UNSELECTED = "v-datapoint-unselected",
            CLASS_DATAPOINT = "v-datashape v-datapoint",
            OPACITY = 1,
            OPACITY_UNSELECTED = '0.4';
        var markerStyle = {
            'stroke' : '#ffffff',
            'stroke-width' : 1
        };
        var selectedMarkerStyle = {
            'stroke' : '#333333',
            'stroke-width' : 1
        };

        function pie(selection) {
            BoundUtil.drawBound(selection, width, height);
            _selection = selection;
            renderChart(selection);
            return pie;
        }


        pie.width = function(value) {
            if (!arguments.length) {
                return width;
            }
            width = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
                if (_selection) {
                    renderChart(_selection);
                }
            }
            return pie;
        };

        pie.height = function(value) {
            if (!arguments.length) {
                return height;
            }
            height = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
                if (_selection) {
                    renderChart(_selection);
                }
            }
            return pie;
        };

        pie.padding = function(value) {
            if (!arguments.length) {
                return padding;
            }
            padding = value;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                getPieLayout();
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
                if (_selection) {
                    renderChart(_selection);
                }
            }
            return pie;
        };

        pie.properties = function(_) {
            if (!arguments.length) {
                return props;
            }
            Objects.extend(true, props, _);
            parseOptions();
            return pie;
        };

        pie.parent = function() {
            return _selection;
        };
        
        pie.dispatch = function(_) {
            return _dispatch;
        };
        
        pie.afterUIComponentAppear = function(){
          _dispatch.initialized(); 
        };
        
        pie.dataLabel = function(_) {
        };

        pie.data = function(value) {
            if (!arguments.length) {
                return data;
            }
            data = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
                sum = 0;
                maxDepthVal = 0;
                calculateBoundaryValues();
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
            }
            return pie;
        };
        
        pie.colorPalette = function(_) {
            if (arguments.length === 0) {
                return color;
            }
            color = _;
            return pie;
        }; 
        
        pie.rotate = function(_) {
            if (number == 1) return pie; // no need rotate if only one sector
            if (arguments.length === 0) {
                return {
                    xAngle : 0,
                    yAngle : rotationAngle * 180 / Math.PI
                };
            }
            rotationAngle = _.yAngle * Math.PI / 180;
            renderChart(_selection);
            return pie;
        };
        
        pie.hoverOnPoint = function(_) {
            var item = _.target;
            if (item.parentNode) {
                item = d3.select(item.parentNode);
                if (item.attr('class') && item.attr('class').indexOf('v-datapoint') >= 0) {
                    var pos = {
                        x : _.x + _transform.e + 3, // workaround for Safari, since it cannot bubble event on tooltip
                        y : _.y + _transform.f
                    };
                    showTooltip(item.datum(), pos);
                    return;
                }
            }
            hideTooltip();
        };
        
        pie.highlight = function(elems) {
            var item;
            elems = parseHighlightElems(elems);
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    item = d3.select(elems[i]);
                    item.attr('class', CLASS_MARKER_SELECTED+' '+CLASS_DATAPOINT);
                    item.selectAll('*').attr('opacity', OPACITY).attr('stroke', selectedMarkerStyle['stroke']).attr('stroke-width', selectedMarkerStyle['stroke-width']);
                }
            } else {
                item = d3.select(elems);
                item.attr('class', CLASS_MARKER_SELECTED+' '+CLASS_DATAPOINT);
                item.selectAll('*').attr('opacity', OPACITY).attr('stroke', selectedMarkerStyle['stroke']).attr('stroke-width', selectedMarkerStyle['stroke-width']);
            }
        };
        
        pie.unhighlight = function(elems) {
            var item;
            elems = parseHighlightElems(elems);
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    item = d3.select(elems[i]);
                    item.attr('class', CLASS_DATAPOINT);
                    item.selectAll('*').attr('opacity', OPACITY_UNSELECTED).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                }
            } else {
                item = d3.select(elems);
                item.attr('class', CLASS_DATAPOINT);
                item.selectAll('*').attr('opacity', OPACITY_UNSELECTED).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            }
        };
        
        pie.clear = function(gray) {
            var item = _selection.selectAll('.v-datapoint').attr('class', CLASS_DATAPOINT).each(function(s) {
                d3.select(this).selectAll('*').attr('stroke', markerStyle['stroke'])
                        .attr('stroke-width', markerStyle['stroke-width'])
                        .attr('opacity', gray ? OPACITY_UNSELECTED : OPACITY);
            });
        };
        
        pie.heightDataRange = function(range) {
            if (!arguments.length) {
                return {
                    min : 0,
                    max : maxDepthVal
                };
            }
            maxDepthVal = range.max;
            if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
                heightScale.domain([0, maxDepthVal]).range([0, baseHeight]);
            }
            return pie;
        }; 

        
        function parseHighlightElems(elems) {
            var item, result, separate = false;
            if (TypeUtils.isArray(elems)) {
                result = elems.concat();
                for (var i = 0, len = elems.length; i < len; i++) {
                    item = d3.select(elems[i]);
                    if (item.datum().part >= 0) {
                        separate = true;
                        break;
                    }
                }
            } else {
                result = [].concat(elems);
                item = d3.select(elems);
                if (item.datum().part >= 0) {
                    separate = true;
                }
            }
            
            if (separate) {
                _selection.selectAll('.v-datapoint').each(function(s) {
                    if (d3.select(this).datum().part >= 0) {
                        result.push(d3.select(this).node());
                    }
                }); 
            }
            return result;
        };
        
        function showTooltip(d, pos) {
            var sectorFeed = data.getMeasureValuesGroupDataByIdx(0);
            var depthFeed = data.getMeasureValuesGroupDataByIdx(1);
            var colorFeed = data.getAnalysisAxisDataByIdx(0);
            var tooltipData = {
                body: [],
                footer: []
            };
            
            tooltipData.body.push({
              name : !TypeUtils.isExist(sectorFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : sectorFeed.values[0].col,
              val : [{
                color : d.colorValue,
                shape : 'circle',
                value : !TypeUtils.isExist(d.val[0]) ? langManager.get('IDS_ISNOVALUE') : d.val[0]
              }]
            });
            
            tooltipData.body.push({
              name : !TypeUtils.isExist(depthFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : depthFeed.values[0].col,
              val :[{
                color : d.colorValue,
                shape : 'circle',
                value : !TypeUtils.isExist(d.val[1]) ? langManager.get('IDS_ISNOVALUE') : d.val[1]
              }]
            });
            
            for (var i = 0; i < colorFeed.values.length; i++) {
                tooltipData.footer.push({
                    label : colorFeed.values[i].col.val,
                    value : colorFeed.values[i].rows[d.index].val
                });
            }
            
            tooltipData.point = {
               x : pos.x,
               y : pos.y
            };
            
            tooltipData.plotArea = {
               x : _transform.e,
               y : _transform.f,
               width : width,
               height : height
            };

            _dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        };
        
        function hideTooltip() {
             _dispatch.hideTooltip();
        };

        function parseOptions() {
            color = props.colorPalette;
            isDonut = props.isDonut;
        };

        function getPieLayout() {
            var base = Math.min(width, height);
            rx = base / 2;
            ry = rx * Math.cos(zAngle);
            drx = rx / 2.414;
            dry = ry / 2.414;
            bottomCX = width / 2;
            bottomCY = height / 2 + base / 2 - ry;
            baseHeight = base - 2 * ry;
        };

        function renderChart(selection) {
            selection.select('.v-datashapesgroup').remove();
            var sectors = prepareData();
            var g = selection.append('g').attr('class', 'v-datashapesgroup');
            renderSectors(sectors, g);
            _transform = _selection[0][0].getTransformToElement(_selection[0][0].ownerSVGElement);
        };
        
        function calculateBoundaryValues() {
            var sectorFeed = data.getMeasureValuesGroupDataByIdx(0);
            var depthFeed = data.getMeasureValuesGroupDataByIdx(1);
            number = 0;
            
            for (var i = 0; i < sectorFeed.values[0].rows[0].length; i++) {
                var sv = TypeUtils.isNaN(sectorFeed.values[0].rows[0][i].val) ? 0 : Math.abs(sectorFeed.values[0].rows[0][i].val);
                var sd = TypeUtils.isNaN(depthFeed.values[0].rows[0][i].val) ? 0 : Math.abs(depthFeed.values[0].rows[0][i].val);
                sum += sv;
                maxDepthVal = Math.max(maxDepthVal, sd);
                if (sv > 0) {
                    number++;
                }
            }
        };

        function prepareData() {
            var sectorFeed = data.getMeasureValuesGroupDataByIdx(0);
            var depthFeed = data.getMeasureValuesGroupDataByIdx(1);

            var result = [];
            for (var i = 0, lastAngle = rotationAngle - Math.PI / 2; i < sectorFeed.values[0].rows[0].length; i++) {
                if (TypeUtils.isNaN(sectorFeed.values[0].rows[0][i].val) || sectorFeed.values[0].rows[0][i].val === 0) {
                    continue;            
                }
                
                var depthVal = TypeUtils.isNaN(depthFeed.values[0].rows[0][i].val) ? 0 : Math.abs(depthFeed.values[0].rows[0][i].val);
                var obj = {
                    startAngle : lastAngle,
                    endAngle : lastAngle + Math.abs(sectorFeed.values[0].rows[0][i].val) / sum * Math.PI * 2,
                    cy : bottomCY - heightScale(depthVal),
                    colorValue : color[i % color.length],
                    val : [
                        sectorFeed.values[0].rows[0][i].val,
                        depthFeed.values[0].rows[0][i].val
                    ],
                    ctx : [
                        sectorFeed.values[0].rows[0][i].ctx,
                        depthFeed.values[0].rows[0][i].ctx
                    ],
                    index : i
                };
                obj.topPoint1 = [bottomCX + rx * Math.cos(obj.startAngle), obj.cy + ry * Math.sin(obj.startAngle)];
                obj.topPoint2 = [bottomCX + rx * Math.cos(obj.endAngle), obj.cy + ry * Math.sin(obj.endAngle)];
                obj.bottomPoint1 = [bottomCX + rx * Math.cos(obj.startAngle), bottomCY + ry * Math.sin(obj.startAngle)];
                obj.bottomPoint2 = [bottomCX + rx * Math.cos(obj.endAngle), bottomCY + ry * Math.sin(obj.endAngle)];
                
                if (isDonut) {
                    obj.topPoint4 = [bottomCX + drx * Math.cos(obj.startAngle), obj.cy + dry * Math.sin(obj.startAngle)];
                    obj.topPoint3 = [bottomCX + drx * Math.cos(obj.endAngle), obj.cy + dry * Math.sin(obj.endAngle)];
                    obj.bottomPoint4 = [bottomCX + drx * Math.cos(obj.startAngle), bottomCY + dry * Math.sin(obj.startAngle)];
                    obj.bottomPoint3 = [bottomCX + drx * Math.cos(obj.endAngle), bottomCY + dry * Math.sin(obj.endAngle)];
                }

                result.push(obj);
                lastAngle = obj.endAngle;
            }
            return result;
        };

        function renderSectors(sectors, g) {
            var s = processSpecialSector(sectors);
            
            // sort sectors to handle cover relationship
            s.sort(function(a, b) {
                if (TypeUtils.isDefined(a.part) && TypeUtils.isDefined(b.part)) {
                    return a.part - b.part;
                }
                
                var asa = getSimpleAngle(a.startAngle);
                var aea = getSimpleAngle(a.endAngle);
                var bsa = getSimpleAngle(b.startAngle);
                var bea = getSimpleAngle(b.endAngle);
                
                if (asa < Math.PI / 2 && aea > Math.PI / 2) {
                    return 1;
                }
                if (bsa < Math.PI / 2 && bea > Math.PI / 2) {
                    return -1;
                }
                if (aea < asa) {
                    return -1;   
                }
                if (bea < bsa) {
                    return 1;
                }
                return Math.max(a.bottomPoint1[1], a.bottomPoint2[1]) - Math.max(b.bottomPoint1[1], b.bottomPoint2[1]);
            });
            

            for (var i = 0; i < s.length; i++) {
                var sectorWrapper = g.append('g').attr('class', CLASS_DATAPOINT);
                sectorWrapper.datum(s[i]);
                renderSingleSector(s[i], sectorWrapper);
            }
            
            _dispatch.initialized({
                name : 'initialized'
            });
        };
        
        function getSimpleAngle(angle) {
            if (angle >= - Math.PI / 2 && angle <= Math.PI / 2 * 3) {
                return angle;
            } else if (angle < - Math.PI / 2) {
                return getSimpleAngle(2 * Math.PI + angle);
            } else if (angle > Math.PI / 2 * 3) {
                return getSimpleAngle(angle - 2 * Math.PI);
            }
        };
        
        function getDarkColor(color) {
            var hsl = d3.rgb(color).hsl();
            return d3.hsl(hsl.h, hsl.s, hsl.l * 0.9).rgb().toString();
        };
        
        function processSpecialSector(sectors) {
            var special = sectors.filter(function(element, index, array) {
                var sa = getSimpleAngle(element.startAngle);
                var ea = getSimpleAngle(element.endAngle);
                return ((sa < Math.PI / 2 || ea > Math.PI / 2) && ea < sa);
            });
            
            if (special.length > 0) {
                special[0].part = 0;
                var sa = getSimpleAngle(special[0].startAngle);
                var sector1 = {
                    startAngle : sa < Math.PI / 2 ? Math.PI : special[0].startAngle,
                    endAngle : sa < Math.PI / 2 ? special[0].endAngle : 0,
                    cy : special[0].cy,
                    colorValue : special[0].colorValue,
                    val : special[0].val,
                    ctx : special[0].ctx,
                    index : special[0].index,
                    part : sa < Math.PI / 2 ? 1 : 2
                };
                var sector2 = {
                    startAngle : sa < Math.PI / 2 ? special[0].startAngle : 0,
                    endAngle : sa < Math.PI / 2 ? Math.PI : special[0].endAngle,
                    cy : special[0].cy,
                    colorValue : special[0].colorValue,
                    val : special[0].val,
                    ctx : special[0].ctx,
                    index : special[0].index,
                    part : sa < Math.PI / 2 ? 3 : 4
                };
                special = [sector1, sector2];
                for (var i = 0; i < special.length; i++) {
                    special[i].topPoint1 = [bottomCX + rx * Math.cos(special[i].startAngle), special[i].cy + ry * Math.sin(special[i].startAngle)];
                    special[i].topPoint2 = [bottomCX + rx * Math.cos(special[i].endAngle), special[i].cy + ry * Math.sin(special[i].endAngle)];
                    special[i].bottomPoint1 = [bottomCX + rx * Math.cos(special[i].startAngle), bottomCY + ry * Math.sin(special[i].startAngle)];
                    special[i].bottomPoint2 = [bottomCX + rx * Math.cos(special[i].endAngle), bottomCY + ry * Math.sin(special[i].endAngle)];
                    if (isDonut) {
                        special[i].topPoint4 = [bottomCX + drx * Math.cos(special[i].startAngle), special[i].cy + dry * Math.sin(special[i].startAngle)];
                        special[i].topPoint3 = [bottomCX + drx * Math.cos(special[i].endAngle), special[i].cy + dry * Math.sin(special[i].endAngle)];
                        special[i].bottomPoint4 = [bottomCX + drx * Math.cos(special[i].startAngle), bottomCY + dry * Math.sin(special[i].startAngle)];
                        special[i].bottomPoint3 = [bottomCX + drx * Math.cos(special[i].endAngle), bottomCY + dry * Math.sin(special[i].endAngle)];
                    }
                }
                return sectors.concat(special);
            }
            return sectors;
        };
        
        function renderSingleSector(sector, g) {
            if (isDonut) {
                if (TypeUtils.isUndefined(sector.part)) {
                    renderDonutBottom(sector, g);
                    renderInvisibleSectorCylinder(sector, g);
                    renderDonutSide(sector, g);
                    renderSectorCylinder(sector, g);
                    renderDonutTop(sector, g);
                } else if (sector.part === 0) {
                    renderDonutBottom(sector, g);
                    renderInvisibleSectorCylinder(sector, g);
                    renderDonutCylinder(sector, g);
                } else if (sector.part > 0) {
                    renderSpecialSectorSide(sector, g);
                    renderSectorCylinder(sector, g);
                    renderDonutTop(sector, g);
                }
                
            } else {
                if (TypeUtils.isUndefined(sector.part)) {
                    renderSectorBottom(sector, g);
                    renderInvisibleSectorCylinder(sector, g);
                    renderSectorSide(sector, g);
                    renderSectorCylinder(sector, g);
                    renderSectorTop(sector, g);
                } else if (sector.part === 0) {
                    renderSectorBottom(sector, g);
                    renderInvisibleSectorCylinder(sector, g);
                } else if (sector.part > 0) {
                    renderSpecialSectorSide(sector, g);
                    renderSectorCylinder(sector, g);
                    renderSectorTop(sector, g);
                }
            }
        };

        
        function renderSectorSide(sector, g) {
            if (number == 1) {
                return;
            }
            var topPoint1, bottomPoint1, topPoint2, bottomPoint2;
            if (sector.bottomPoint1[1] >= sector.bottomPoint2[1]) {
                topPoint1 = sector.topPoint2;
                bottomPoint1 = sector.bottomPoint2;
                topPoint2 = sector.topPoint1;
                bottomPoint2 = sector.bottomPoint1;
            } else {
                topPoint1 = sector.topPoint1;
                bottomPoint1 = sector.bottomPoint1;
                topPoint2 = sector.topPoint2;
                bottomPoint2 = sector.bottomPoint2;
            }
            var def = 'M' + bottomCX + ',' + bottomCY
                    + 'L' + bottomCX + ',' + sector.cy
                    + 'L' + topPoint1[0] + ',' + topPoint1[1]
                    + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);

            def = 'M' + bottomCX + ',' + bottomCY
                    + 'L' + bottomCX + ',' + sector.cy
                    + 'L' + topPoint2[0] + ',' + topPoint2[1]
                    + 'L' + bottomPoint2[0] + ',' + bottomPoint2[1] + 'z';
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
        };
        
        function renderSpecialSectorSide(sector, g) {
            var topPoint1, topPoint2, bottomPoint1, bottomPoint2;
            if (sector.part === 1 || sector.part === 4) {
                topPoint1 = sector.topPoint2;
                bottomPoint1 = sector.bottomPoint2;
                topPoint2 = sector.topPoint3;
                bottomPoint2 = sector.bottomPoint3;
            } else if (sector.part === 2 || sector.part === 3) {
                topPoint1 = sector.topPoint1;
                bottomPoint1 = sector.bottomPoint1;
                topPoint2 = sector.topPoint4;
                bottomPoint2 = sector.bottomPoint4;
            }
            
            var def;
            if (isDonut) {
                def = 'M' + topPoint1[0] + ',' + topPoint1[1]
                        + 'L' + topPoint2[0] + ',' + topPoint2[1]
                        + 'L' + bottomPoint2[0] + ',' + bottomPoint2[1]
                        + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';
            } else {
                def = 'M' + bottomCX + ',' + bottomCY
                        + 'L' + bottomCX + ',' + sector.cy
                        + 'L' + topPoint1[0] + ',' + topPoint1[1]
                        + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';
            }
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);

        }
        
        function renderDonutSide(sector, g) {
            if (number == 1) {
                renderDonutCylinder(sector, g);
                return;
            }
            var topPoint1, topPoint2, topPoint3, topPoint4, bottomPoint1, bottomPoint2, bottomPoint3, bottomPoint4;
            if (sector.bottomPoint1[1] >= sector.bottomPoint2[1]) {
                topPoint1 = sector.topPoint2;
                topPoint2 = sector.topPoint3;
                topPoint3 = sector.topPoint1;
                topPoint4 = sector.topPoint4;
                bottomPoint1 = sector.bottomPoint2;
                bottomPoint2 = sector.bottomPoint3;
                bottomPoint3 = sector.bottomPoint1;
                bottomPoint4 = sector.bottomPoint4;
            } else {
                topPoint1 = sector.topPoint1;
                topPoint2 = sector.topPoint4;
                topPoint3 = sector.topPoint2;
                topPoint4 = sector.topPoint3;
                bottomPoint1 = sector.bottomPoint1;
                bottomPoint2 = sector.bottomPoint4;
                bottomPoint3 = sector.bottomPoint2;
                bottomPoint4 = sector.bottomPoint3;
            }
            var def1 = 'M' + topPoint1[0] + ',' + topPoint1[1]
                    + 'L' + topPoint2[0] + ',' + topPoint2[1]
                    + 'L' + bottomPoint2[0] + ',' + bottomPoint2[1]
                    + 'L' + bottomPoint1[0] + ',' + bottomPoint1[1] + 'z';

            var def2 = 'M' + topPoint3[0] + ',' + topPoint3[1]
                    + 'L' + topPoint4[0] + ',' + topPoint4[1]
                    + 'L' + bottomPoint4[0] + ',' + bottomPoint4[1]
                    + 'L' + bottomPoint3[0] + ',' + bottomPoint3[1] + 'z';
            
            var sa = getSimpleAngle(sector.startAngle);
            var ea = getSimpleAngle(sector.endAngle);
            if (sa <= 0 && (ea >= Math.PI || ea < sa) || sa >= Math.PI && ea >= Math.PI && ea < sa) {
                g.append('path').attr('d', def1).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                g.append('path').attr('d', def2).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                renderDonutCylinder(sector, g);
            } else if (sa > 0 && sa < Math.PI && ea > 0 && ea < sa) {
                renderDonutCylinder(sector, g);
                g.append('path').attr('d', def1).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                g.append('path').attr('d', def2).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            } else {
                g.append('path').attr('d', def1).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                renderDonutCylinder(sector, g);
                g.append('path').attr('d', def2).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            }
        };

        function renderSectorCylinder(sector, g) {
            var sa = getSimpleAngle(sector.startAngle);
            var ea = getSimpleAngle(sector.endAngle);
            
            if (sa >= 0 && ea > sa && ea <= Math.PI) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            } else if ((sa <= 0 || sa >= Math.PI) && ea <= Math.PI && ea >= 0) {
                var def = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            } else if (sa >= 0 && sa <= Math.PI && (ea >= Math.PI || ea <= 0)) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue));
            } else if (sa <= 0 && (ea >= Math.PI || ea < sa) || sa >= Math.PI && ea >= Math.PI && ea < sa) {
                var def = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            } else if (sa >= 0 && sa <= Math.PI && ea >= 0 && ea < sa) {
                var def1 = 'M' + (bottomCX + rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX + rx) + ',' + bottomCY + 'z';
                var def2 = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX - rx) + ',' + sector.cy
                    + 'L' + (bottomCX - rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def1).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                g.append('path').attr('d', def2).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
           }
        };
        
        function renderInvisibleSectorCylinder(sector, g) {
            var sa = getSimpleAngle(sector.startAngle);
            var ea = getSimpleAngle(sector.endAngle);
            
            if (sa < 0 && ea < 0 && ea > sa 
                || sa > Math.PI && (ea > sa || ea < 0)) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            } else if ((sa < 0 || sa > Math.PI) && ea < Math.PI && ea > 0) {
                var def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX + rx) + ',' + sector.cy
                    + 'L' + (bottomCX + rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            } else if (sa > 0 && sa < Math.PI && (ea > Math.PI || ea < 0)) {
                var def = 'M' + (bottomCX - rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX - rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            } else if (sa <= 0 && (ea >= Math.PI || ea < sa) || sa >= Math.PI && ea >= Math.PI && ea < sa) {
                var def1 = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX + rx) + ',' + sector.cy
                    + 'L' + (bottomCX + rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] + 'z';
                var def2 = 'M' + (bottomCX - rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                    + 'L' + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX - rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def1).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                g.append('path').attr('d', def2).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            } else if (sa > 0 && sa < Math.PI && ea > 0 && ea < sa) {
                var def = 'M' + (bottomCX - rx) + ',' + sector.cy
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,1 '
                    + (bottomCX + rx) + ',' + sector.cy
                    + 'L' + (bottomCX + rx) + ',' + bottomCY
                    + 'A' + rx + ',' + ry + ' 0 ' + '0,0 '
                    + (bottomCX - rx) + ',' + bottomCY + 'z';
                g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            }
        };
        
        function renderDonutCylinder(sector, g) {
            var largeAngle = sector.endAngle - sector.startAngle > Math.PI ? '1' : '0';
            var def;
            if (number == 1) {
                def = 'M' + (bottomCX - drx) + ',' + sector.cy 
                        + 'A' + drx + ',' + dry + ' 0 1,1 '
                        + (bottomCX + drx) + ',' + sector.cy 
                        + 'L' + (bottomCX + drx) + ',' + bottomCY
                        + 'A' + drx + ',' + dry + ' 0 1,0 '
                        + (bottomCX - drx) + ',' + bottomCY;
            } else {
                def = 'M' + sector.topPoint4[0] + ',' + sector.topPoint4[1]
                    + 'A' + drx + ',' + dry + ' 0 ' + largeAngle + ',1 '
                    + sector.topPoint3[0] + ',' + sector.topPoint3[1]
                    + 'L' + sector.bottomPoint3[0] + ',' + sector.bottomPoint3[1]
                    + 'A' + drx + ',' + dry + ' 0 ' + largeAngle + ',0 '
                    + sector.bottomPoint4[0] + ',' + sector.bottomPoint4[1] + 'z';
            }
            g.append('path').attr('d', def).attr('fill', getDarkColor(sector.colorValue)).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
        };


        function renderSectorTop(sector, g) {
            if (number == 1) {
                g.append('ellipse').attr('cx', bottomCX).attr('cy', sector.cy)
                        .attr('rx', rx).attr('ry', ry).attr('fill', sector.colorValue)
                        .attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                return;
            }
            
            var def;
            if (TypeUtils.isUndefined(sector.part)) {
                def = 'M' + bottomCX + ',' + sector.cy 
                        + 'L' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1] + 'z';
            } else if (sector.part === 1 || sector.part === 4) {
                def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                        + 'L' + bottomCX + ',' + sector.cy;
            } else if (sector.part === 2 || sector.part === 3) {
                def = 'M' + bottomCX + ',' + sector.cy 
                        + 'L' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1];
            }
            g.append('path').attr('d', def).attr('fill', sector.colorValue).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
        };
        
        function renderSectorBottom(sector, g) {
            if (number == 1) {
                g.append('ellipse').attr('cx', bottomCX).attr('cy', bottomCY)
                        .attr('rx', rx).attr('ry', ry).attr('fill', sector.colorValue)
                        .attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                return;
            }
            var def = 'M' + bottomCX + ',' + bottomCY 
                    + 'L' + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] 
                    + 'A' + rx + ',' + ry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                    + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1] + 'z';
            g.append('path').attr('d', def).attr('fill', sector.colorValue).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
        };
        
        function renderDonutTop(sector, g) {
            var def;
            if (number == 1) {
                def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 1,1 ' 
                        + (sector.topPoint2[0] - 1) + ',' + sector.topPoint2[1]
                        + 'M' + (sector.topPoint3[0] - 1) + ',' + sector.topPoint3[1]
                        + 'A' + drx + ',' + dry + ' 0 1,0 ' 
                        + sector.topPoint4[0] + ',' + sector.topPoint4[1];
            } else if (TypeUtils.isUndefined(sector.part)) {
                def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                        + 'L' + sector.topPoint3[0] + ',' + sector.topPoint3[1]
                        + 'A' + drx + ',' + dry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                        + sector.topPoint4[0] + ',' + sector.topPoint4[1] + 'z';
            } else if (sector.part === 1 || sector.part === 4) {
                def = 'M' + sector.topPoint1[0] + ',' + sector.topPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint2[0] + ',' + sector.topPoint2[1]
                        + 'L' + sector.topPoint3[0] + ',' + sector.topPoint3[1]
                        + 'A' + drx + ',' + dry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                        + sector.topPoint4[0] + ',' + sector.topPoint4[1];
            } else if (sector.part === 2 || sector.part === 3) {
                def = 'M' + sector.topPoint2[0] + ',' + sector.topPoint2[1] 
                        + 'A' + rx + ',' + ry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                        + sector.topPoint1[0] + ',' + sector.topPoint1[1]
                        + 'L' + sector.topPoint4[0] + ',' + sector.topPoint4[1]
                        + 'A' + drx + ',' + dry + ' 0 ' 
                        + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 ' 
                        + sector.topPoint3[0] + ',' + sector.topPoint3[1];
            }
            g.append('path').attr('d', def).attr('fill', sector.colorValue).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
        };
        
        function renderDonutBottom(sector, g) {
            var def;
            if (number == 1) {
                def = 'M' + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] 
                        + 'A' + rx + ',' + ry + ' 0 1,1 ' 
                        + (sector.bottomPoint2[0] - 1) + ',' + sector.bottomPoint2[1]
                        + 'M' + (sector.bottomPoint3[0] - 1) + ',' + sector.bottomPoint3[1]
                        + 'A' + drx + ',' + dry + ' 0 1,0 ' 
                        + sector.bottomPoint4[0] + ',' + sector.bottomPoint4[1];
            } else {
                def = 'M' + sector.bottomPoint1[0] + ',' + sector.bottomPoint1[1] 
                    + 'A' + rx + ',' + ry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',1 '
                    + sector.bottomPoint2[0] + ',' + sector.bottomPoint2[1]
                    + 'L' + sector.bottomPoint3[0] + ',' + sector.bottomPoint3[1]
                    + 'A' + drx + ',' + dry + ' 0 ' 
                    + (sector.endAngle - sector.startAngle > Math.PI ? '1' : '0') + ',0 ' 
                    + sector.bottomPoint4[0] + ',' + sector.bottomPoint4[1] + 'z';
            }
            g.append('path').attr('d', def).attr('fill', sector.colorValue).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
        };
        
        props = manifest.props(null);
        return pie;
    };
  return fn;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.PieWithDepth',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.piewithdepth',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.piewithdepth',
    'name' : 'piewithdepth',
    'type' : Constants.Module.Type.Chart,
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set the color palette for sectors.'
      },
      'isDonut' : {
        'name' : 'isDonut',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether is a donut or pie.'
      }
    },
    'events' : {
      'initialized' : Constants.Module.Event.Initialized.desc,
      'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc
    },
    'feeds' : {
      id : "pie",
      configure : null
    },
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPieWithDepthChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.PieWithDepth',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var multiChart = {
    id : 'viz/multi_pie_with_depth',
    name : 'IDS_MULTIPIEWITHDEPTHCHART',
    base : 'riv/base/multiple',
    'isExported':false,
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 2 ] }
              }
            }
          },
          
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : { orientation : 'left' }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                selectability: {
                  mode: 'multiple',
                  selectWithCtrlKey: true
                },
                preserveSelectionWhenDragging: true
              }
            }
          },
          
          main : {
            configure : {
              properties : { 
                  'cellPadding' : 5,
                  'mergeDataRange' : ['height'] 
              }
            },

            modules : {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.piewithdepth',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : {
                        valign : "center"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        acceptMND : -1,
        max : 2
      },
      pieDepthSize : { 
        max : constants.Constraints.INF 
      },
      pieSectorSize : {
        max : constants.Constraints.INF
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }, {
          targetModule : 'root.main',
          target : 'heightDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'heightDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'heightDataRange',
          sourceModule : 'root.main',
          source : 'heightDataRange'
        }],
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      },{
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main',
        type : 'hideTooltip'
      }]
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDonutWithDepthChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.PieWithDepth',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiPieWithDepthChart',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var multiChart = {
    id : 'viz/multi_donut_with_depth',
    name : 'IDS_MULTIDONUTWITHDEPTHCHART',
    base : 'viz/multi_pie_with_depth',
    'isExported':false,
    modules : {
      root : {
        modules : {
          main : {
            configure : {
              properties : { 'cellPadding' : 5 }
            },

            modules : {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.piewithdepth',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : {
                        valign : "center",
                        isDonut : true
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Pie',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "pie",
    feeds : [ {
      'id' : 'pieSectorColor',
      'name' : 'IDS_PIESECTORCOLORNAME',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1
    }, {
      'id' : 'pieSectorSize',
      'name' : 'IDS_PIESECTORSIZE',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'pieDepthSize',
      'name' : 'IDS_PIEDEPTHSIZE',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 2
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.pie.selection',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.pie.tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup( sectorModule, selectionModule, tooltip, TextUtils, ColorSeriesGenerator, dispatch, UADetector,
    FunctionUtils, TypeUtils, ObjectUtils, Objects, formatManager, langManager, BoundUtil, dataUtil, defaultSelUtil ) {
  var horizontalMarginRatio = 2.414;

  var innerRadiusRatio = function( outerRadius ) {
    // 12em
    // return outerRadius >= 12 * 14 ? horizontalMarginRatio : 1.618;
    return horizontalMarginRatio;
  };
  
  var defaultPaddingValue = 6;

  var hasDefaultSelection = false;

  var loadingAnimationDuration = 600;
  var defaultColorPalette = ColorSeriesGenerator.sap32();

  var id = "v-pie";

  var clipPathIdPrefix = id + "-clipPath-";
  var wrapperClass = id, mainshapeClass = 'v-datashapesgroup', donutTitleClass = "v-donut-title", hoverSectorClass = "v-hoverSector", sectorGroupClass = "v-sectorgroup";

  var selection = selectionModule();

  var tooltipFunc = tooltip();

  var sectorFunc = sectorModule();

  function rotateTootltipBySector( d, tip, caret, styleManager ) {
    if ( !caret ) {
      caret = tip.caret();
    }
    caret.show().rotateTo(d.midAngle());
    var tipValue, tipPercentage;
    tipValue = d.value();
    tipPercentage = d.proportion();
    if ( TypeUtils.isExist(d.p.tooltip.formatString) ) {
      tipValue = formatManager.format(tipValue, d.p.tooltip.formatString[0]);
      tipPercentage = formatManager.format(tipPercentage, d.p.tooltip.formatString[1]);
    } else {
      tipValue = d.value(d.p.tooltip.valueFormat);
      tipPercentage = d.proportion(d.p.tooltip.percentageFormat);
    }

    tip.texts(d.dimValues().map(function( s ) {
      return s === null ? langManager.get('IDS_ISNOVALUE') : s;
    }).filter(function( a ) {
      return a !== '';
    }).join(" - "), tipValue, tipPercentage, styleManager).show();
  }

  function donutTitle( wrapper ) {
    var text = wrapper.selectAll("text." + donutTitleClass).data(function( d ) {
      if ( d.p.isDonut ) {
        var title = d.measure.col;
        if ( title === null ) {
          title = langManager.get('IDS_ISNOVALUE');
        }

        return [{
          width : d.ir,
          title : title
        }];
      }

      return [];
    });
    text.exit().remove();
    text.enter().insert("svg:text", "." + sectorGroupClass).attr("class", donutTitleClass).attr("font-family",
        "'Open Sans',Arial,Helvetica,sans-serif").attr("text-anchor", "middle").attr("font-weight", "bold").attr(
        "font-size", "16px").attr("fill", "#333").attr("dominant-baseline", "middle");

    text.each(function( d ) {
      TextUtils.ellipsisInCircle(d.title, this, d.width, 0);
    });
  }

  function calculateOuterRadiusByHeight( h , padding) {
    return h / 2 - padding;
  }

  function calculateOuterRadiusByWidth( w , padding) {
    return Math.max(w / 2 / (1 + 1 / horizontalMarginRatio), padding * horizontalMarginRatio);
  }

  function calculateOuterRadius( w, h, maxRadius , padding) {
    if ( maxRadius ) {
      return Math.min(h / 2, w / 2);
    }
    return Math.min(calculateOuterRadiusByHeight(h,padding), calculateOuterRadiusByWidth(w,padding));
  }

  function calculateInnerRadius( outerRadius ) {
    return outerRadius / innerRadiusRatio(outerRadius);
  }

  var clipPathArc = d3.svg.arc();

  function clipPathTween( d ) {
    var clipPathInterpolate = d3.interpolateNumber(d.startAngle, d.endAngle);
    return function( t ) {
      d.endAngle = clipPathInterpolate(t);
      return clipPathArc(d);
    };
  }

  function highlight( el, flag, onSector, tip, sectorGroup, styleManager ) {
    selection.select(TypeUtils.isArray(el) ? d3.selectAll(el) : d3.select(el), flag);
    if ( onSector === false ) {
      refreshTooltip(tip, sectorGroup, styleManager);
    }
  }

  function refreshTooltip( tip, sectorGroup, styleManager ) {
    if ( !tip ) {
      return;
    }
    var selectedSectors = selection.allSelected(sectorGroup);

    if ( selectedSectors.empty() ) {
      tip.hide();
    } else if ( !UADetector.isMobile() ) {
      // currently, to keep behavior consistent with other charts, we do not show aggregate value;
      var d = sectorGroup.datum();
      if ( !d.p.tooltip.visible ) {
        tip.hide();
      } else {
        var sum = 0;
        var proportionSum = 0;
        var numer = 0;
        selectedSectors.each(function( d ) {
          sum += d.val;
          proportionSum += d.proportion();
          numer++;
        });
        var caret = tip.caret();
        if ( numer === 1 ) {
          rotateTootltipBySector(selectedSectors.datum(), tip, caret, styleManager);
        } else {
          tip.texts(numer + " selected", d3.format(d.p.tooltip.valueFormat)(sum), d3.format(
              d.p.tooltip.percentageFormat)(proportionSum), styleManager);
          caret.hide();
        }
      }
    }
  }

  var fn = function( manifest, ctx ) {
    var width = null, height = null, data = null, props = manifest.props(null), colorPalette;
    var plotScale = props.plotScale;
    var effectManager = ctx.effectManager;
    var styleManager = ctx.styleManager;
    var widthFunctor, heightFunctor, propsFunctor = FunctionUtils.noop;

    var parent, sectorGroup, wrapper, tip;

    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false;

    // @Alex Su, judge whether we should enable animation

    function enableAnimation( p ) {
      var hasAnmation = false;
      if ( isDataLoading ) {
        hasAnmation = p.animation.dataLoading;
      } else if ( isDatasetChanged ) {
        hasAnmation = p.animation.dataUpdating;
      } else if ( isSizeChanged ) {
        hasAnmation = p.animation.resizing;
      }
      return hasAnmation;
    }

    var _dispatch = dispatch("selectData", "deselectData", "initialized", 'startToInit', "showTooltip", "hideTooltip");

    function pie() {
      parent = this;
      BoundUtil.drawBound(parent, width, height);

      _dispatch.startToInit();

      wrapper = this.selectAll("g." + wrapperClass).data(pieWrapperData(data));
      wrapper.exit().each(function( d ) {
        document.documentElement.removeEventListener("keydown", d.keydownListener);
        delete d.keydownListener;
      }).remove();

      var enterWrapper = wrapper.enter().append("g").attr("class", wrapperClass);

      enterWrapper.append("g").attr("class", sectorGroupClass + (props.isGeoPie ? "" : " " + mainshapeClass));

      wrapper.attr("transform", function( d ) {
        if ( d.p.alignCenter ) {
          return null;
        }
        return "translate(" + d.w / 2 + "," + (d.p.valign === "center" ? d.h / 2 : (d.or + d.padding)) + ")" + 'scale(' +
            plotScale + ')';
      });

      var clipPath = wrapper.selectAll(function() {
        var result = [];
        Array.prototype.forEach.call(this.childNodes, function( node ) {
          if ( node.tagName === 'clipPath' ) {
            result.push(node);
          }
        });
        return result;
      }).data(function( d ) {
        var result = [];
        var isDonut = d.p.isDonut;
        var animation = d.animation = enableAnimation(d.p);
        if ( isDonut || animation ) {
          result.push({
            innerRadius : isDonut ? d.ir : 0,
            outerRadius : d.or + d.padding,
            startAngle : 0,
            endAngle : Math.PI * 2,
            animation : animation
          });
        }
        return result;
      });

      clipPath.exit().remove();
      clipPath.enter().append("svg:clipPath").attr("id", function() {
        var id, k = 0;
        while (true) {
          id = clipPathIdPrefix + (k++);
          if ( !document.getElementById(id) ) {
            break;
          }
        }
        this.parentNode.querySelector("." + sectorGroupClass).setAttribute("clip-path", "url(#" + id + ")");
        return id;
      }).append("svg:path").attr("clip-rule", "evenodd").attr("d", clipPathArc);

      wrapper.call(donutTitle);
      sectorGroup = wrapper.select("g." + sectorGroupClass).call(sectorFunc, effectManager, styleManager);

      selection.clearAll(sectorGroup);

      wrapper.call(tooltipFunc, styleManager);
      tip = tooltipFunc.select(wrapper, _dispatch);
      if ( tip ) {
        tip.hide();
      }
      clipPath.filter(function( d ) {
        return d.animation;
      }).select(":first-Child").transition().duration(loadingAnimationDuration).each("end", function( d ) {
        var clipPathNode = this.parentNode;
        var wrapperNode = clipPathNode.parentNode;
        if ( wrapperNode ) {
          if ( d.innerRadius === 0 ) {
            wrapperNode.removeChild(clipPathNode);
            wrapperNode.querySelector("." + sectorGroupClass).removeAttribute("clip-path");
          }
          var wrapperData = d3.select(wrapperNode).datum();
          wrapperData.animationEnd = true;
          fireInitializedEvent(wrapperData);
        }
      }).attrTween("d", clipPathTween);

      clipPath.filter(function( d ) {
        return !d.animation;
      }).select(":first-Child").attr("d", clipPathArc);

      wrapper.each(function( d ) {
        d.domInitialized = true;
        fireInitializedEvent(d);
      });
      isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;
    }

    function pieWrapperData( d ) {
      var parentNode = this.parentNode;
      var p = propsFunctor.apply(parentNode, arguments);
      var w = widthFunctor.apply(parentNode, arguments);
      var h = heightFunctor.apply(parentNode, arguments);
      var padding = calculatePadding(w, h);
      var or = calculateOuterRadius(w, h, p.maxRadius, padding);
      var colorRange = d3.functor(colorPalette).apply(parentNode, arguments);

      var result = {
        padding: padding,
        w : w,
        h : h,
        p : p,
        or : or,
        ir : calculateInnerRadius(or),
        color : colorRange ? d3.scale.ordinal().range(colorRange) : defaultColorPalette.copy(),
        measure : d.getMeasureValuesGroupDataByIdx(0).values[0],
        dimensions : d.getAnalysisAxisDataByIdx(0).values
      };
      result.drawingEffect = result.p.drawingEffect;

      return [result];
    }

    function fireInitializedEvent( d ) {
      if ( d.domInitialized && (!d.animation || d.animationEnd) ) {
        var init = function() {
          _dispatch.initialized({
            name : 'initialized'
          });
        };
        setTimeout(init, 0);
      }
    }

    function hoverSector( s, flag ) {
      s.attr("fill-opacity", flag ? "1" : (selection.selected(s) ? "1" : null));
    }

    pie.afterUIComponentAppear = function() {
      _dispatch.initialized();
    };

    pie.dataLabel = function( _ ) {
    };

    pie.parent = function() {
      return parent;
    };

    pie.clear = function( flag ) {
      selection.clear(sectorGroup, flag);
      if ( hasDefaultSelection && !flag ) {
        defaultSelUtil.clearSelectionInfo(parent, false, sectorGroup);
      }
      return pie;
    };

    pie.highlight = function( el, onSector ) {
      highlight(el, true, onSector, tip, sectorGroup, styleManager);
      if ( hasDefaultSelection ) {
        defaultSelUtil.clearSelectionInfo(parent, true, el);
      }
      return pie;
    };

    pie.unhighlight = function( el, onSector ) {
      highlight(el, false, onSector, tip, sectorGroup, styleManager);
      if ( hasDefaultSelection ) {
        defaultSelUtil.clearSelectionInfo(parent, false, el);
      }
      return pie;
    };

    pie.mouseover = function( el ) {
      var s = d3.select(el);
      s.classed(hoverSectorClass, true);
      hoverSector(s, true);
      var d = s.datum();
      if ( d.p.tooltip.visible ) {
        if ( tip ) {
          rotateTootltipBySector(d, tip, undefined, styleManager);
        }
      } else {
        if ( tip ) {
          tip.hide();
        }
      }
      return pie;
    };

    pie.mouseout = function( el ) {
      if ( el ) {
        var sect = d3.select(el);
        if ( UADetector.isIE() ) {
          window.setTimeout(function() {
            hoverSector(sect, false);
          }, 0);
        } else {
          hoverSector(sect, false);
        }
      }
      if ( !tip ) {
        return;
      }

      refreshTooltip(tip, sectorGroup, styleManager);
      return pie;
    };
    
    var calculatePadding = function(w, h)
    {
        var padding;
        var boundary = Math.min(w, h);
        if(boundary < defaultPaddingValue*2)
        {
            if(boundary < (defaultPaddingValue/4)*2)
            {
                if(boundary < (defaultPaddingValue/8)*2)
                {
                    padding = 0;
                }
                else
                {
                    padding = defaultPaddingValue/8;
                }
            }
            else
            {
                padding = defaultPaddingValue/4;
            }
        }
        else
        {
            padding = defaultPaddingValue;
        }
        return padding;
    };

    /**
     * get/set width
     */
    pie.width = function( _ ) {
      if ( arguments.length === 0 ) {
        return width;
      }
      isSizeChanged = (!isSizeChanged && (_ === width)) ? false : true;
      width = _;
      widthFunctor = d3.functor(width);
      return pie;
    };

    /**
     * get/set height
     */
    pie.height = function( _ ) {
      if ( arguments.length === 0 ) {
        return height;
      }
      isSizeChanged = (!isSizeChanged && (_ === height)) ? false : true;
      height = _;
      heightFunctor = d3.functor(height);
      return pie;
    };
    
    /**
     * get/set size
     */
    pie.size = function( w, h ) {
      if ( arguments.length === 0 ) {
        return {
          width : this.width(),
          height : this.height()
        };
      }
      pie.width(w).height(h);
      return pie;
    };

    /**
     * get/set data
     */
    pie.data = function( _ ) {
      if ( arguments.length === 0 ) {
        return data;
      }
      isDatasetChanged = true;
      isDataSchemaChanged = false;
      if ( !dataUtil().hasSameSchema(data, _) ) {
        isDataSchemaChanged = true;
      }
      data = _;

      var info = data.getMeasureValuesGroupDataByIdx(0).values[0].rows[0][0].info;
      if ( info && info.defaultSelection ) {
        hasDefaultSelection = true;
      } else {
        hasDefaultSelection = false;
      }

      return pie;
    };

    /**
     * get event dispath
     */
    pie.dispatch = function( _ ) {
      return _dispatch;
    };

    /**
     * get/set properties
     */
    pie.properties = function( _ ) {
      if ( arguments.length === 0 ) {
        return props;
      }
      Objects.extend(true, props, _);
      plotScale = props.plotScale;
      propsFunctor = d3.functor(props);

      if ( typeof (props) === "function" ) {
        colorPalette = function( d, i ) {
          return propsFunctor.apply(this, arguments).colorPalette;
        };
      } else if ( props.colorPalette ) {
        colorPalette = props.colorPalette;
      }
      return pie;
    };

    /**
     * get/set color palette
     */
    pie.colorPalette = function( _ ) {
      if ( arguments.length === 0 ) {
        return colorPalette || defaultColorPalette.range();
      }
      colorPalette = _;
      return pie;
    };
    return pie;
  };

  return fn;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.pie',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.Pie',
  version : '4.0.2'
}
],
function Setup( Manifest, Constants, fn ) {
  var module = {
    'id' : 'sap.viz.modules.pie',
    'type' : Constants.Module.Type.Chart,
    'name' : 'pie',
    'properties' : {
      'animation' : {
        'name' : 'animation',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'dataLoading' : {
            'name' : 'dataLoading',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data loading animation of plot area.'
          },
          'dataUpdating' : {
            'name' : 'dataUpdating',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data updating animation of plot area.'
          },
          'resizing' : {
            'name' : 'resizing',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable resizing animation of plot area.'
          }
        },
        'description' : 'Settings for animation of plot area.'
      },
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set the color palette for sectors.'
      },
      'isDonut' : {
        'name' : 'isDonut',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether is a donut or pie.'
      },
      'isGeoPie' : {
        'name' : 'isGeoPie',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether is a geo pie.',
        'isExported' : false
      },
      'valign' : {
        'name' : 'valign',
        'supportedValueType' : 'List',
        'supportedValues' : ['top', 'center'],
        'defaultValue' : "top",
        'description' : 'Set vertical aligment.',
        'isExported' : false
      },
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set whether tooltip is enabled.'
          },
          'valueFormat' : {
            'name' : 'valueFormat',
            'supportedValueType' : 'String',
            'defaultValue' : 'n',
            'description' : 'Set the number format of measure value in tooltip.'
          },
          'percentageFormat' : {
            'name' : 'percentageFormat',
            'supportedValueType' : 'String',
            'defaultValue' : ".0%",
            'description' : 'Set the number format of percentage label in tooltip.'
          },
          'formatString' : {
            'name' : 'formatString',
            'supportedValueType' : 'StringArray',
            'defaultValue' : null,
            'description' : 'Set format string of tooltip. The first string is applied to value and the second is applied to percentage. '
          }
        },
        'description' : 'Settings for tooltip related properties.'
      },
      'drawingEffect' : {
        'name' : 'drawingEffect',
        'supportedValueType' : 'List',
        'supportedValues' : ['normal', 'glossy'],
        'defaultValue' : 'normal',
        'description' : 'Set drawing effect of Pie.',
        'isExported' : true
      },
      'plotScale' : {
        'name' : 'plotScale',
        'supportedValueType' : 'PositiveFloat',
        'defaultValue' : 1,
        'description' : 'Set plot scale of Pie.',
        'isExported' : false,
        'isExperimental' : true
      }
    },
    'events' : {
      'initialized' : Constants.Module.Event.Initialized.desc,
      'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc,
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "pie",
      configure : {
        pieDepthSize : null
      }
    },
    'css' : {
      '.v-tooltip-label.viz-pie-tooltip-label-dimensions' : {
        'description' : 'Define style for the first label(dimension values) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal',
          'fill' : '#000000'
        }
      },
      '.v-tooltip-value.viz-pie-tooltip-label-value' : {
        'description' : 'Define style for the second label(measure value) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '13px',
          'font-weight' : 'bold',
          'fill' : '#000000'
        }
      },
      '.v-tooltip-percentage.viz-pie-tooltip-label-percentage' : {
        'description' : 'Define style for the third label(percentage) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '10.5px',
          'font-weight' : 'normal',
          'fill' : '#333333'
        }
      },
      '.v-sector.viz-pie-sector' : {
        'description' : 'Define style for sector in pie.',
        'value' : {
          'stroke' : '#FFFFFF'
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var multiChart = {
    id : 'viz/multi_pie',
    name : 'IDS_MULTIPIECHART',
    base : 'riv/base/multiple',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 2 ] }
              }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout', 'touchstart' ]
              }
            }
          },
          
          main : {
            configure : {
              properties : { 'cellPadding' : 5 }
            },

            modules : {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.pie',
                    configure : {
                      'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : {
                        valign : "center"
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        paintingMode : 'polarCoordinate',
                        visible : false,
                        formatString : [['0.00%'],[]],
                        automaticInOutside : false,
                        outsideVisible : true,
                        type : 'label and value'
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        acceptMND : 0,
        max : 2
      },
      pieSectorSize : {
        max : constants.Constraints.INF
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      } , {
        targetModule : 'root.main.plot.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.plot.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot.plot',
        type : 'startToInit.datalabel'
      }]
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDonutChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiChart = {
    id : 'viz/multi_donut',
    name : 'IDS_MULTIDONUTCHART',
    base : 'viz/multi_pie',
    modules : {
      root : {
        modules : {
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    id : 'sap.viz.modules.pie',
                    configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea',
                      properties : { 'isDonut' : true }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : { isDonut : true }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.datatransform',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
}
],
function Setup(TypeUtils, Manifest, Objects, NumberUtils, dispatch) {
  var datatransform = function(manifest) {
    var _props = manifest.props(null);
    var _data;
    var _autoBinning = {
          displayString : 'Others'
        },
        _dataSampling = {}; 
    var wMax,wMin,hMax,hMin,xMax,xMin,yMax,yMin;
    
    //currently we don't need initialized for this module
	  //var d = dispatch('initialized');
	
    function transformation (){
	  }
    
    transformation.data = function(data) {
      if (!arguments.length){
        return _data;
      }
      _data = data;
      return transformation;
    };
    
    transformation.properties = function(properties){
      if (!arguments.length){
        return _props;
      }
      Objects.extend(true, _props, properties);
      parseOptions();
      if (_data) {
        dataTransformer(_data);
      }
      return transformation;
    };
    
    transformation.parent = function(){};
    
    function resetBoundaryValues() {
      wMax = 0; wMin = Number.MAX_VALUE;
      hMax = 0; hMin = Number.MAX_VALUE;
      xMax = 0; // max value for xAxis
      xMin = 0; // min value for xAxis
      yMax = 0; // max value for yAxis
      yMin = 0; // max value for yAxis  
    }

    function calculateBoundaryValues(data) {
      resetBoundaryValues();
      var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
      var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
      var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
      var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
      distinctValuesObj = {};
      
      for (var i = 0; i < measureFeed1.values[0].rows.length; i++) {
        for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
            var x = measureFeed1.values[0].rows[i][j].val;
            var y = measureFeed2.values[0].rows[i][j].val;
            
            if (NumberUtils.isNoValue(x) || NumberUtils.isNoValue(y)) {
                continue;
            }
            
            var w = bubbleWidthFeed && bubbleWidthFeed.values.length && TypeUtils.isExist(bubbleWidthFeed.values[0].rows[i][j].val) ? Math.abs(bubbleWidthFeed.values[0].rows[i][j].val) : null;
            var h;
            if (bubbleHeightFeed && bubbleHeightFeed.values.length) {
                if (TypeUtils.isExist(bubbleHeightFeed.values[0].rows[i][j].val)) {
                    h = Math.abs(bubbleHeightFeed.values[0].rows[i][j].val);
                } else {
                    h = null;
                }
            } else {
                h = w;
            }

            if (!NumberUtils.isNoValue(w)) {
                distinctValuesObj[w] = '';
            } 
            xMax = x > xMax ? x : xMax;
            xMin = x < xMin ? x : xMin;
            yMax = y > yMax ? y : yMax;
            yMin = y < yMin ? y : yMin;
            wMax = w > wMax ? w : wMax;
            wMin = w < wMin ? w : wMin;
            hMax = h > hMax ? h : hMax;
            hMin = h < hMin ? h : hMin;
        }
      }
    }
 
    function fillGridBox (gridBoxArray, obj) {
      var isFind = false;
      for (var i = 0; i < _dataSampling.grid.column; i++) {
        var pos = 0;
        if (isFind) {
          break;
        }
        pos = i*_dataSampling.grid.row;
        if (obj.x >= gridBoxArray[pos].xRange.x1 && obj.x < gridBoxArray[pos].xRange.x2 || obj.x === xMax) {
          for (var j = 0; j < _dataSampling.grid.row; j++) {
            if (obj.y >= gridBoxArray[pos + j].yRange.y1 && obj.y < gridBoxArray[pos + j].yRange.y2 || obj.y === yMax) {
              gridBoxArray[pos + j].indexArray.push(obj.index);
              gridBoxArray[pos + j].refArray.push(obj.ref);
              isFind = true;
              break;
            }
          }
        }
      }
    }
    
    function scatterDataSampling (data) {
      var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
      var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
      var dataPointNum = measureFeed1.values[0].rows.length * measureFeed1.values[0].rows[0].length;
      if (_dataSampling.sizeFactor > 0 && 
          _dataSampling.sizeFactor < 1 && 
          _dataSampling.numberPrecondition > 0 && 
          _dataSampling.grid.row > 0 && 
          _dataSampling.column > 0)
        {
          if (dataPointNum && dataPointNum > _dataSampling.numberPrecondition) {
            calculateBoundaryValues(data);
            var gridBoxArray = [];
            var xStep = (xMax - xMin) / _dataSampling.grid.column, yStep = (yMax - yMin) / _dataSampling.grid.row, xStart = xMin, yStart = yMin;
            for (var i = 0; i < _dataSampling.grid.column; i++) {
              var xRange = {};
              xRange.x1 = xStart;
              xRange.x2 = xStart + xStep;
              for (var j = 0; j < _dataSampling.grid.row; j++) {
                var yRange = {}, gridBox = {};
                yRange.y1 = yStart;
                yRange.y2 = yStart + yStep;
                gridBox.xRange = xRange;
                gridBox.yRange = yRange;
                gridBox.indexArray = [];
                gridBox.refArray = [];
                gridBoxArray.push(gridBox);
                yStart += yStep;
              }
              xStart += xStep;
              yStart = yMin;
            }
            
            for (var i = 0; i < measureFeed1.values[0].rows.length; i++) {
              for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
                var obj = {};
                obj.x = measureFeed1.values[0].rows[i][j].val;
                obj.y = measureFeed2.values[0].rows[i][j].val;
                obj.index = j;
                obj.ref = {
                    x : measureFeed1.values[0].rows,
                    y :  measureFeed2.values[0].rows,
                    xIndex : i,
                    yIndex : j
                };
                fillGridBox(gridBoxArray, obj);
              }
            }
            
            for (var m = 0; m < gridBoxArray.length; m++) {
              var refLen = gridBoxArray[m].refArray.length;
              if (refLen > 0) {
                var deletePos = Math.round(refLen * _dataSampling.sizeFactor);
                if (!((refLen & 1) == 0)) {
                  deletePos++;
                }
                for (; deletePos < refLen; deletePos++) {
                  var xIndex = gridBoxArray[m].refArray[deletePos].xIndex, yIndex =  gridBoxArray[m].refArray[deletePos].yIndex;
                  gridBoxArray[m].refArray[deletePos].x[xIndex][yIndex].val = null;
                  gridBoxArray[m].refArray[deletePos].y[xIndex][yIndex].val = null;
                }
              }
            }
          }
        }
    }
    
    function parseOptions() {
      if (_props.autoBinning.enable) {
        _autoBinning.enable = _props.autoBinning.enable;
        _autoBinning.binNumber = _props.autoBinning.binNumber;
      } else if (_props.dataSampling.enable) {
        _dataSampling.enable = _props.dataSampling.enable;
        _dataSampling.grid = _props.dataSampling.grid;
        _dataSampling.sizeFactor = _props.dataSampling.sizeFactor;
        _dataSampling.numberPrecondition = _props.dataSampling.numberPrecondition;        
      }
    }
    
    function dataTransformer(data) {
      if (_props && _data) {
        if (_autoBinning.enable) {
          pieAutoBinning(data); 
        }
        
        if (_dataSampling.enable) {
          scatterDataSampling(data);
        }
      }
    };
 
    function objCompare(a, b) {
      return b.val - a.val;
    }
    
    function pieDataSort(data) {
      var measure = data.getMeasureValuesGroupDataByIdx(0).values[0];
      for (var i = 0; i < measure.rows[0].length; i++) {
        measure.rows[0][i].index = i;
      }
      
      measure.rows[0].sort(objCompare);
      var dimensions = data.getAnalysisAxisDataByIdx(0).values;
      for (var m = 0; m < dimensions.length; m++) {
        var tmpArray = [];
        for (var n = 0; n < dimensions[m].rows.length; n++) {
          var measurePos = measure.rows[0][n].index;
          if (measurePos !== n) {
            tmpArray.push(dimensions[m].rows[measurePos]);
          } else {
            tmpArray.push(dimensions[m].rows[n]);
          }
        }
        dimensions[m].rows = tmpArray;
      }
    }
    
    function pieAutoBinning(data) {
      var measure = data.getMeasureValuesGroupDataByIdx(0).values[0];
      var binNumber = _props.autoBinning.binNumber;
      var measuresNum = measure.rows[0].length;
      if (binNumber > 0 && binNumber <  measuresNum) {
        for (var i = 0; i < measure.rows[0].length; i++) {
          measure.rows[0][i].index = i;
        }
        
        measure.rows[0].sort(objCompare);
        var dimensions = data.getAnalysisAxisDataByIdx(0).values;
        for (var m = 0; m < dimensions.length; m++) {
          var tmpArray = [];
          for (var n = 0; n < dimensions[m].rows.length; n++) {
            var measurePos = measure.rows[0][n].index;
            if (measurePos !== n) {
              tmpArray.push(dimensions[m].rows[measurePos]);
            } else {
              tmpArray.push(dimensions[m].rows[n]);
            }
          }
          dimensions[m].rows = tmpArray;
        }
        
        var deletedNum = 0;
        for (var j = measure.rows[0].length - 1; j >= 0; j--) {
          if (measure.rows[0][j].val < 0) {
            measure.rows[0].pop();
            deletedNum++;
          }
        }
        measuresNum = measure.rows[0].length;
        
        for (var x = 0; x < dimensions.length; x ++) {
          var dimensionLen = dimensions[x].rows.length;
          for (var y = dimensions[x].rows.length - 1; y > dimensionLen - deletedNum - 1; y--) {
            dimensions[x].rows.pop();
          }
        }
        
        var othersPos = binNumber - 1;
        for (var k = othersPos + 1; k < measuresNum; k++) {
          measure.rows[0][othersPos].val += measure.rows[0][k].val;
        }
        for (var j = measuresNum - 1; j > othersPos; j--) {
          measure.rows[0].pop();
        }
        
        for (var q = 0; q < dimensions.length; q++) {
          if (q === 0) {
            var othersNum = measuresNum - binNumber + 1;
            dimensions[q].rows[othersPos].val = _autoBinning.displayString;
            dimensions[q].rows[othersPos].dataTransformInfo = {autoBinning : {'othersNum' : othersNum}};
          } else {
            dimensions[q].rows[othersPos].val = '';
          }
          for (var r = dimensions[q].rows.length - 1; r > othersPos; r--) {
            dimensions[q].rows.pop();
          }
        }
      }
    }
    

    return transformation;
  };
  return datatransform;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.DataTransform',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.datatransform',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.datatransform',
    'type' : Constants.Module.Type.Controller,
    'name' : 'dataTransform',
    'renderto' : Constants.Module.RenderTo.NONE,
    'properties' : {
       'autoBinning' : {
         'name' : 'autoBinning',
         'supportedValueType' : 'Object',
         'supportedValues' : {
           'enable': {
             'name' : 'enable',
             'supportedValueType' : 'Boolean',
             'defaultValue' : false,
             'description' : 'Set whether to enable data auto binning.'
            },
            'binNumber': {
              'name' : 'binNumber',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : 10,
              'description' : 'Set bin number.'
             }
        },
        'isExported' : true,
        'description' : 'Settings for auto-binning algorithm'
       },
       'dataSampling' : {
         'name' : 'dataSampling',
         'supportedValueType' : 'Object',
         'supportedValues' : {       
           'enable': {
             'name' : 'enable',
             'supportedValueType' : 'Boolean',
             'defaultValue' : false,
             'description' : 'Set whether to enable data sampling.'
            },
            'sizeFactor': {
              'name' : 'sizeFactor',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : 1,
              'description' : 'Set data point percentage in original dataset'
             },
             'numberPrecondition': {
               'name' : 'numberPrecondition',
               'supportedValueType' : 'PositiveInt',
               'defaultValue' : 3000,
               'description' : 'if data point is larger than this value, data sampling will be triggered.'
              },
             'grid' : {
               'name' : 'grid',
               'supportedValueType' : 'Object',
               'supportedValues' : {
                 'row' : {
                   'name' : 'row',
                   'supportedValueType' : 'PositiveInt',
                   'defaultValue' : 3,
                   'description' : 'The row number of grid'
                 },
                 'column' : {
                   'name' : 'column',
                   'supportedValueType' : 'PositiveInt',
                   'defaultValue' : 3,
                   'description' : 'The column number of grid',
                  } 
               }
             }
       },
       'isExported' : true,
       'description' : 'Settings for data sampling algorithm'
       }
     },
    configure: null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.legend.Common',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var pieChart = {
    id : 'riv/base/single',
    name : 'IDS_BASESINGLECHART',
    base : 'riv/base',
    'abstract' : true,
    modules : {
      root : {
        configure : { propertyCategory : 'general' },
        modules : {
          main : {
            id : 'sap.viz.modules.xycontainer',
            configure : {
              propertyCategory : 'xyContainer',
              properties : {
                layout : {
                  position : 'center',
                  priority : 10
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(pieChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.DataTransform',
  version : '4.0.2'
}
],
function Setup ( Manifest ) {
  var pieChart = {
    id : 'viz/pie',
    name : 'IDS_PIECHART',
    base : 'riv/base/single',
    modules : {
      dataTransform : {
        id : 'sap.viz.modules.datatransform',
        configure : {
          propertyCategory : 'dataTransform',
          properties : {
            autoBinning : {
              enable : false     
            },
            dataSampling : {
              enable : null
            }
          },
          propertiesOverride : {
            dataSampling : {
              isExported : false
            }
          }
        }
      },
      root : {
        modules : {
          legends : {
            modules : {
               legend : {
                data : { aa : [ 1 ] }
              }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout', 'touchstart' ]
              }
            }
          },
          
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.pie',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'polarCoordinate',
                    visible : false,
                    type : 'label and value',
                    formatString : [['0.00%'],[]],
                    automaticInOutside : false,
                    outsideVisible : true    
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      } , {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
    }
  };

  Manifest.register(pieChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.PieWithDepthChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.PieWithDepth',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.DataLabel',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Rotate',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/pie_with_depth',
    name : 'IDS_PIEWITHDEPTHCHART',
    base : "riv/base/single",
    'isExported':false,
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 1 ] }
              }
            }
          },
          
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : { 
                  chartType : 'pie_with_depth', 
                  orientation : 'left' 
              }
            }
          },
          
          rotate : {
            id : 'sap.viz.modules.controller.rotate',
            configure : {
              clientID : 'main',
              propertyCategory: 'rotate'
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                selectability: {
                  mode: 'multiple',
                  lassoWithCtrlKey: true
                },
                preserveSelectionWhenDragging: true
              }
            }
          },
          
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.piewithdepth',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'colorPalette'
      }],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
      }, {
          targetModule : 'root.rotate',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.rotate'
      },{
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
      }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.DonutWithDepthChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.pie.PieWithDepthChart',
  version : '4.0.2'
}
],
function Setup ( Manifest ) {
  var donutChart = {
    'id' : 'viz/donut_with_depth',
    'name' : 'IDS_DONUTWITHDEPTHCHART',
    base : 'viz/pie_with_depth',
    'modules' : {
      root : {
        modules : {
          'main' : {
            'modules' : {
              'plot' : {
                'configure' : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  'propertyCategory' : 'plotArea',
                  'properties' : {
                    'isDonut' : true
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(donutChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.DonutChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.2'
}
],
function Setup ( Manifest ) {
  var donutChart = {
    'id' : 'viz/donut',
    'name' : 'IDS_DONUTCHART',
    base : 'viz/pie',
    'modules' : {
      root : {
        modules : {
          'main' : {
            'modules' : {
              'plot' : {
                'configure' : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  'propertyCategory' : 'plotArea',
                  'properties' : {
                    'isDonut' : true
                  }
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    isDonut : true
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(donutChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_line',
    name : 'IDS_MULTILINECHART',
    base : 'riv/base/multiple/xy',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {              
              legend : {
                data : { aa : [ 3 ] }
              }
            }
          },
          tooltip : {
            configure : {
              properties : {
                chartType : 'line',
                orientation : 'left'
              }
            }
          },
        
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction'
            }
          },
        
          main : {
            configure : {
              properties : { 'mergeDataRange' : ['primary'] }
            },

            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    data : { aa : [ 1 ] },
                    configure : {
                      'description':'Settings for the category axis of an XY chart.',
                      propertyCategory : 'xAxis',
                      properties : {
                        title : { visible : false },
                        gridline : { visible : false },
                        type : 'category',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : { isExported : false },
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false }
                      }
                    }
                  },
                  /**
                   * 'xAxis2' : { },
                   */
        
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis of an XY chart.',
                      propertyCategory : 'yAxis',
                      properties : {
                        type : 'value',
                        position : 'left'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        position : 'outside',
                        automaticInOutside : false,
                        orientation : 'vertical',
                        outsidePosition : 'up',
                        positionPreference : true
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.line',
                    configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }  
    },
    
    feeds : {
      multiplier : { max:1 },
      secondaryValues : null,
      axisLabels : { max:1 }
    },
    
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }
      ],
      events : 
      [  
        {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main',
          type : 'showTooltip'
        }, 
        {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main',
          type : 'hideTooltip'
        },
        {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, 
        {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'initialized.datalabel'
        }, 
        {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'startToInit.datalabel'
        }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_horizontal_line',
    name : 'IDS_MULTIHORIZONTALLINECHART',
    base : 'viz/multi_line',
    modules : {
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'horizontalline',
                orientation : 'left'
              }
            }
          },  
          main : {
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  background : {
                    configure : {
                      properties : {
                        direction : 'horizontal'
                      }
                    }
                  },
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    data : null,
                    configure : {
                      'description':'Settings for the value axis of an XY chart.',
                      properties : {
                        type : 'value',
                        gridline : {
                          visible : true
                        }
                      },
                      propertiesOverride : {                   
                        gridline : {
                  isExported : true
                  },
                  label : {
                        isExported : true
                        },
                        axisline : {
                        isExported : true
                       }
                      }
                    }
                  },
                  /**
                   * 'xAxis2' : { },
                   */
        
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    data : {
                      aa : [ 1 ]
                    }, 
                    configure : {
                         'description':'Settings for the category axis of an XY chart.',
                      properties : {
                        type : 'category',
                        gridline : {
                          visible : false
                        }
                      },
                      propertiesOverride : {                   
                        gridline : { isExported : false },
                        label : { isExported : false },
                        axisline : { isExported : false }
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        position : 'outside',
                        automaticInOutside : false,
                        orientation : 'horizontal',
                        outsidePosition : 'right',
                        positionPreference : true
                      }
                    }
                  },
                  plot : {
                    id : 'sap.viz.modules.horizontalline',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },{
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, 
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      } ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualHorizontalLineChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var multiBarChart = {
    id : 'viz/multi_dual_horizontal_line',
    name : 'IDS_MULTIDUALHORIZONTALLINECHART',
    base : 'viz/multi_horizontal_line',
    modules : {
      root : {
        modules : {
          main : {
            configure : {
              properties : { 'mergeDataRange' : ['primary', 'second'] }
            },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  plot : {
                    configure : {
                      propertiesOverride : {
                        primaryValuesColorPalette : { isExported: true },
                        secondaryValuesColorPalette: { isExported: true }
                      }
                    }
                  },
                  xAxis:{
                    id : 'sap.viz.modules.axis',
                    configure:{
                      description : 'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                  },
                  xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      description : 'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                      propertyCategory : 'xAxis2',
                      properties : {
                        title : { visible : false },
                        type : 'value',
                        position : 'top'
                      },
                      propertiesOverride : {
                        title : { isExported : false }                    
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    
    feeds : {
      multiplier:{ max:1 },
      secondaryValues: { min: 1, max : Number.POSITIVE_INFINITY },
      axisLabels : { max:1, acceptMND: -1 },
      regionColor : { acceptMND: 1 }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.main.plot.xAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'secondaryScale'
      },{
        targetModule : 'root.main.plot.xAxis2',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'root.main.plot.xAxis2',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      }, 
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualLineChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.2'
}
],
function Setup(Manifest,Constants) {
  var multiVBarChart = {
    id : 'viz/multi_dual_line',
    name : 'IDS_MULTIDUALLINECHART',
    base : 'viz/multi_line',
    modules : {
      root : {
        modules : {
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : { 
              clientID : 'main',
              propertyCategory : 'selectability'
            }
          },
           main : {
            configure : {
              properties : {
                'mergeDataRange' : ['primary', 'second']
              }
            },

            modules: {              
              plot : {
                modules : {
                  plot : {
                    configure : {
                      propertiesOverride : {
                        primaryValuesColorPalette : { isExported: true },
                        secondaryValuesColorPalette: { isExported: true }
                    }
                  }
                },
                
                yAxis:{
                  id : 'sap.viz.modules.axis',
                  configure:{
                    description : 'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                  }
                },
                
                yAxis2 : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                    propertyCategory : 'yAxis2',
                    properties : {
                      title : { visible : false },
                      gridline : { visible : false },
                      type : 'value',
                      position : 'right'
                    },
                    propertiesOverride : {
                      title : { isExported : false }                    
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
     
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       min: 1,
    max : Number.POSITIVE_INFINITY 
     },
    axisLabels:{
      max:1,
      acceptMND: -1
    },
    regionColor:{
      acceptMND: 1
    }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'primaryDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'root.main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'root.main',
        target : 'secondDataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'root.main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'root.main.plot.yAxis2',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'secondaryScale'
      }, {
        targetModule : 'root.main.plot.yAxis2',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisTitle'
      },
      
      {
        targetModule : 'root.main.plot.yAxis',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'root.main.plot.yAxis2',
        target : 'color',
        sourceModule : 'root.main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'categoryScale'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapePalette'
      }
      ],
      events : [  {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main',
            type : 'showTooltip'
        }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main',
            type : 'hideTooltip'
        } ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Scatter',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "scatter",
    feeds : [ {
      'id' : 'regionColor',
      'name' : 'IDS_REGIONCOLOR',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1
    }, {
      'id' : 'regionShape',
      'name' : 'IDS_REGIONSHAPE',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 2,
      'acceptMND': -1
    }, {
      'id' : 'primaryValues',
      'name' : 'IDS_PRIMARYVALUES',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'secondaryValues',
      'name' : 'IDS_SECONDARYVALUES',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 2
    }, {
      'id' : 'bubbleWidth',
      'name' : 'IDS_BUBBLEWIDTH',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 3
    }, {
      'id' : 'bubbleHeight',
      'name' : 'IDS_BUBBLEHEIGHT',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 4
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.bubble',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.format.FormatManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(dispatch, ColorSeries, ShapeSeries, TypeUtils, ObjectUtils, TextUtils, lassoSelection, Scaler, NumberUtils, DrawUtil, langManager, tooltipDataHandler, Objects,formatManager, langManager, BoundUtil, dataUtil, defaultSelUtil) 
{
    return function(manifest, ctx) 
    {
    var CLASSMARKERSELECTED = "v-datapoint-selected",
        CLASSMARKERHOVER = "v-datapoint-hover",
        CLASSDATAPOINT = "v-datapoint",
        CLASSTOOLTIP = 'v-m-tooltip',
        OPACITY1 = '0.4',
        OPACITY2 = '0.8';

        var width = 500, height = 300, padding = 0;
        var data = null, props = {};
        var xScale = d3.scale.linear();
        var yScale = d3.scale.linear();
        var wScale, hScale;
        var wMax,wMin,hMax,hMin,xMax,xMin,yMax,yMin;
        //zhu alistar
        var randomSuffix = ObjectUtils.guid();
        function resetBoundaryValues(){
          wMax = 0; wMin = Number.MAX_VALUE;
          hMax = 0; hMin = Number.MAX_VALUE;
          xMax = 0; // max value for xAxis
          xMin = 0; // min value for xAxis
          yMax = 0; // max value for yAxis
          yMin = 0; // max value for yAxis  
        }
        resetBoundaryValues();
        var distinctValuesObj;
        var bubbleScale = 1/6;
        var color = ColorSeries.sap32().range(), shape = ShapeSeries.sapShapes().range();
        var markers = [];
        var g, defs, tooltipX, tooltipY, crossX, crossY;
        var selectionStatus = [];
        var tooltipVisible = true, hoverlineVisible = true;
        var markerStyle = {
            'stroke' : '#ffffff',
            'stroke-width' : 1
        };
        var selectedMarkerStyle = {
            'stroke' : '#333333',
            'stroke-width' : 1
        };
        var animateTime = 1000;
        var bFirstCreation = true;
        var eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized', 'startToInit');
        var _selection;
        var sizeLegendTitle = null;
        var drawingEffect = 'normal';
        var effectManager = ctx.effectManager;
        var markerSize = 10;
        var animationComplete = false;
        var hasDefaultSelection = false;
        var formatString ;
        
        var isDataSchemaChanged = false,  isSizeChanged = false, isDatasetChanged = false;
        
        var formerWidth, formerHeight;
        //@Alex Su, judge whether we should enable animation
        
        function isAnimationEnabled(){
          var hasAnmation = false;
          if(bFirstCreation){
            hasAnmation = props.animation.dataLoading;
          }else if(isDatasetChanged){
            hasAnmation = props.animation.dataUpdating;
          }else if(isSizeChanged){
            hasAnmation = props.animation.resizing;
          }
          return hasAnmation;
        }
        
        function updateFormerSize(width, height){
          formerWidth = width;
          formerHeight = height;
        }
        
        function bubble(selection) {
            if (formerWidth !== undefined && formerHeight !== undefined){
              if (!isSizeChanged){
                isSizeChanged = formerWidth !== width || formerHeight !== height;
              }
            }
            updateFormerSize(width, height);
            BoundUtil.drawBound(selection, width, height);
            _selection = selection;
            renderChart(selection);
            bFirstCreation = false;
            isDataSchemaChanged = false, isSizeChanged = false, isDatasetChanged = false;
            return bubble;
        }

        bubble.width = function(value) {
            if (!arguments.length){
                return width;
            }
            width = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
               computeScales();
            }
            return bubble;
        };

        bubble.height = function(value) {
            if (!arguments.length){
                return height;
            }
            height = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
              computeScales();
            }
            return bubble;
        };
        
        bubble.afterUIComponentAppear = function(){
          eDispatch.initialized(); 
        };
        
        
        bubble.padding = function(value){
            if(!arguments.length){
                return padding;
            }
            padding = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
              computeScales();
            }
            return bubble;
        };
        bubble.valueAxis1Scale = function(value){
          if(!arguments.length){
                return xScale;
          }
          xScale = value;
          return bubble;
        };
        bubble.valueAxis2Scale = function(value){
          if(!arguments.length){
            return yScale;
          }
          yScale = value;
          return bubble;
        };
        
        bubble.valueAxis1DataRange = function(range){
          if (!arguments.length){
            return {
              min: xMin,
              max: xMax
            };
          }
          xMax = range.max;
          xMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.valueAxis2DataRange = function(range){
          if (!arguments.length){
            return {
              min: yMin,
              max: yMax
            };
          }
          yMax = range.max;
          yMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.bubbleWidthDataRange = function(range){
          if (!arguments.length){
            return {
              distinctValuesObj : distinctValuesObj,
              min: wMin,
              max: wMax
            };
          }
          wMax = range.max;
          wMin = range.min;
          distinctValuesObj = range.distinctValuesObj;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.bubbleHeightDataRange = function(range){
          if (!arguments.length){
            return {
              min: hMin,
              max: hMax
            };
          }
          hMax = range.max;
          hMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.colorPalette = function(value){
        if(!arguments.length){
          return color;
        }
        color = value;
        return bubble;
      };
      bubble.shapes = function(value){
        if(!arguments.length){
          return shape;
        }
        shape = value;
        return bubble;
      };
      bubble.sizeLegend = function() {
           var heightFeed = data.getMeasureValuesGroupDataByIdx(3);
           var hasHeightFeed = (TypeUtils.isExist(heightFeed) && heightFeed.values.length > 0);
          return {      
              bubbleScale : bubbleScale,
              space : padding,
              scale : wScale,
              data : sizeData(),
              title : sizeLegendTitle,
              hasHeightFeed : hasHeightFeed
          };
      };
        bubble.dispatch = function(_){
            if(!arguments.length){
                return eDispatch;
            }
            eDispatch = _;
            return this;
        };
        
        bubble.dataLabel = function(_){
          
        };
        

         /**
            * set/get data, for some modules like Title, it doesn't need data
            */
        bubble.data = function(value){
            if (!arguments.length){
                return data;
            }
            isDatasetChanged = true;
            isDataSchemaChanged = false;
            if (! dataUtil().hasSameSchema(data, value)){
              isDataSchemaChanged = true;
            }
            data = value;
            
            var info = data.getMeasureValuesGroupDataByIdx(0).values[0].rows[0][0].info;
            if(info && info.defaultSelection){
              hasDefaultSelection = true;
            }else{
              hasDefaultSelection = false;
            }
            
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
              calculateBoundaryValues();
              computeScales();
            }
            return bubble;            
        };

        bubble.valueAxis1Title = function(_){
          if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              if (titles.values[i].col !== null && titles.values[i].col !== undefined)
              {
                  title.push(titles.values[i].col);
              }
              else
              {
                  title.push(langManager.get('IDS_ISNOVALUE'));
              }
            }
          }
          return title.join('/');
        }
        return this;
        };
        
        bubble.valueAxis2Title = function(_){
          if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              if (titles.values[i].col !== null && titles.values[i].col !== undefined)
              {
                  title.push(titles.values[i].col);
              }
              else
              {
                  title.push(langManager.get('IDS_ISNOVALUE'));
              }
            }
          }
          return title.join('/');
        }
        return this;
        };
        /**
        * set/get properties
        */
        bubble.properties = function(_){
            if (!arguments.length){
                return props;
            }
            Objects.extend(true, props, _);
            parseOptions();
            return bubble;            
        };
     
     function parseOptions() {
       color = props.colorPalette;
       shape = props.shapePalette;
       tooltipVisible = props.axisTooltip.visible;
       hoverlineVisible = props.hoverline.visible;
       drawingEffect = props.drawingEffect;
       formatString = props.axisTooltip.formatString;
       // necessary to check, since markerSize is N/A for bubble chart
       var _markerSize = props.markerSize;
       markerSize = TypeUtils.isExist(_markerSize) && _markerSize <= 32 && _markerSize >= 4 ? _markerSize : markerSize;
       if(props.xScaleType && props.xScaleType === "log") {
         xScale = d3.scale.log();
       }
     }
        
      function calculateBoundaryValues() {
          resetBoundaryValues();
          var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
          var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
          var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
          var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
          distinctValuesObj = {};
          
          for (var i = 0; i < measureFeed1.values[0].rows.length; i++) {
              for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
                  var x = measureFeed1.values[0].rows[i][j].val;
                  var y = measureFeed2.values[0].rows[i][j].val;
                  
                  if (NumberUtils.isNoValue(x) || NumberUtils.isNoValue(y)) {
                      continue;
                  }
                  
                  var w = bubbleWidthFeed && bubbleWidthFeed.values.length && TypeUtils.isExist(bubbleWidthFeed.values[0].rows[i][j].val) ? Math.abs(bubbleWidthFeed.values[0].rows[i][j].val) : null;
                  var h;
                  if (bubbleHeightFeed && bubbleHeightFeed.values.length) {
                      if (TypeUtils.isExist(bubbleHeightFeed.values[0].rows[i][j].val)) {
                          h = Math.abs(bubbleHeightFeed.values[0].rows[i][j].val);
                      } else {
                          h = null;
                      }
                  } else {
                      h = w;
                  }
      
                  if (!NumberUtils.isNoValue(w)) {
                      distinctValuesObj[w] = '';
                  } 
                  xMax = x > xMax ? x : xMax;
                  xMin = x < xMin ? x : xMin;
                  yMax = y > yMax ? y : yMax;
                  yMin = y < yMin ? y : yMin;
                  wMax = w > wMax ? w : wMax;
                  wMin = w < wMin ? w : wMin;
                  hMax = h > hMax ? h : hMax;
                  hMin = h < hMin ? h : hMin;
              }
          }
          
          
      }
    
        function computeScales() {

          var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
          var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
          if(props.xScaleRange){
            xScale.domain([props.xScaleRange.min, props.xScaleRange.max]).range([padding, width - padding]).nice();
          }else{
            //when xmax and xmin are 0, we make the xscale.domain(0,1)
            if( xMax === 0 && xMin === 0 ){
              xScale.domain([0, 1]).range([padding, width - padding]).nice();
            }else{
              xScale.domain([xMin * (1 + bubbleScale), xMax * (1 + bubbleScale)]).range([padding, width - padding]).nice();
            }
          }
          Scaler.perfect(xScale);
          //when ymin and ymax are 0 ,we make the yscale.domain(0,1)
          if( yMax === 0 && yMin === 0){
            yScale.domain([0,1]).range([height - padding, padding]).nice();  
          }else{
            yScale.domain([yMin * (1 + bubbleScale), yMax * (1 + bubbleScale)]).range([height - padding, padding]).nice();
          }
          Scaler.perfect(yScale);
          

          var rMax;
          //[Jimmi/8/17/2012]here we means if you don't feed data for width and height, we won't change the scale even if the data range
          //has been passed by  bubbleWidthDataRange and bubbleHeightDataRange
          if (bubbleWidthFeed && bubbleWidthFeed.values.length && wMax !== wMin) {
              if(props.wScaleMax){
                wScale = bubbleSizeScale(props.wScaleMax, true, bubbleHeightFeed);
              }
              else{
                wScale = bubbleSizeScale(wMax, true, bubbleHeightFeed);
              }
              sizeLegendTitle = bubbleWidthFeed.values[0].col;
          } else {
              wScale = function(value) {
                  return markerSize;
              };
          }
          
          if (bubbleHeightFeed && bubbleHeightFeed.values.length && hMax !== hMin) {
              hScale = bubbleSizeScale(hMax, false);
          } else {
            if(wScale && hMax > hMin){
              hScale = wScale;
            }else{
              hScale = function(value) {
                  return markerSize;
              };
            }
          }
        }
        
        function renderChart(selection) {
            // TODO: avoid repeat drawing data when re-draw
            if (g) {
                g.remove();
            }
            if (defs) {
                defs.remove();
            }
            
            eDispatch.startToInit();
            
            var i;//for iteration
            
            //we will share tooltip-x and tooltip-y between modules in a same chart
            var parent = d3.select(selection.node().ownerSVGElement.parentNode);
            if (tooltipVisible && parent.select('svg.sc-tooltip-x').node() === null) {
              parent.append('svg').style('position', 'absolute').attr('class', 'sc-tooltip-x ' + CLASSTOOLTIP).attr('pointer-events', 'none').attr('width', '0').attr('height', 0);
            }
            tooltipX = parent.select('svg.sc-tooltip-x');
            if (tooltipVisible && parent.select('svg.sc-tooltip-y').node() === null) {
              parent.append('svg').style('position', 'absolute').attr('class', 'sc-tooltip-y ' + CLASSTOOLTIP).attr('pointer-events', 'none').attr('width', '0').attr('height', 0);
            }
            tooltipY = parent.select('svg.sc-tooltip-y');
            
        //    getThemeStyleDef();
            
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var colorFeed = data.getAnalysisAxisDataByIdx(0);
            var shapeFeed = data.getAnalysisAxisDataByIdx(1);
            
           
            var clipPathId = 'edge-clip-' + randomSuffix;
            defs = selection.append('defs');
            defs.append('clipPath').attr('id', clipPathId).append('rect').attr('width', width).attr('height', height);
            
            g = selection.append('g').attr('class','v-datashapesgroup');  
            g.attr('clip-path', 'url(#' + clipPathId + ')');  
            
            g.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill-opacity', 0)
                    .attr('id', 'event-rect' + randomSuffix);
            var hoverlineStyle = ctx.styleManager.queryDefault('v-hoverline');
            crossX = g.append('line').attr('id', 'cross-x-' + randomSuffix).attr('class', 'v-hoverline').attr('stroke-width', 1).attr('stroke', hoverlineStyle['stroke']).attr('shape-rendering','crispEdges').attr('visibility', 'hidden');
            crossY = g.append('line').attr('id', 'cross-y-' + randomSuffix).attr('class', 'v-hoverline').attr('stroke-width', 1).attr('stroke', hoverlineStyle['stroke']).attr('shape-rendering','crispEdges').attr('visibility', 'hidden');
            
            var colorIndex = 0;
            var colorContainer = {};
            
            function renderByShape(i, renderShape, renderArray) {
                for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
                    // Currently just group by the first dimension in hierarchy
                    var colorFeedVal = (colorFeed && colorFeed.values.length  > 0) ? colorFeed.values[0].rows[j].val : 0;
                    var colorValue;
                    if (colorContainer[colorFeedVal]) {
                        colorValue = colorContainer[colorFeedVal];
                    } else {
                        colorValue = color[colorIndex % color.length];
                        colorContainer[colorFeedVal] = colorValue;
                        colorIndex++;
                    }
                    var x = measureFeed1.values[0].rows[i][j].val;
                    var y = measureFeed2.values[0].rows[i][j].val;
                    var w = bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].val : null;
                    var h = bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].val : null;
                    
                    var renderData = {
                        x : x,
                        y : y,
                        w : w, 
                        h : h,
                        colorIndex : j,
                        shapeIndex : i,
                        colorValue : colorValue,
                        shapeValue : renderShape,
                        val : [x, y, w, h],
                        ctx : [
                            measureFeed1.values[0].rows[i][j].ctx, 
                            measureFeed2.values[0].rows[i][j].ctx,
                            bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].ctx : null,
                            bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].ctx : null
                        ],
                        info : [
                                 measureFeed1.values[0].rows[i][j].info, 
                                 measureFeed2.values[0].rows[i][j].info,
                                 bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].info : null,
                                 bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].info : null
                        ]
                    };
                    
                    if (!NumberUtils.isNoValue(x) && !NumberUtils.isNoValue(y)) {
                        renderArray.push(renderData);
                    }
                }
            }
            
            
            
            
            var renderArray = [];
            var renderShape;
            if (shapeFeed && shapeFeed.values.length > 0) {
                i = 0;
                for (var shapeIndex = 0, shapeContainer = {}; i < shapeFeed.values[0].rows.length; i++) {
                    // Currently just group by the first dimension in hierarchy
                    var shapeFeedVal = shapeFeed.values[0].rows[i].val;
                    if (shapeContainer[shapeFeedVal]) {
                        renderShape = shapeContainer[shapeFeedVal];
                    } else {
                        renderShape = shape[shapeIndex % shape.length];
                        shapeContainer[shapeFeedVal] = renderShape;
                        shapeIndex++;
                    }
                    renderByShape(i, renderShape, renderArray);
                }
            } else {
                renderByShape(0, shape[0], renderArray);
            }

            // sort to draw big shape first
            renderArray.sort(function(a, b) {
                var ah = a.h === null ? a.w : a.h;
                var bh = b.h === null ? b.w : b.h;
                return Math.abs(b.w * bh) - Math.abs(a.w * ah);
            });
            
            var completedArray = 0;
            animationComplete = false;
            hideTooltip();
            function checkAnimationCompleted(d, m) {
                completedArray++;
                if (completedArray === renderArray.length) {
                  animationComplete = true;
                    eDispatch.initialized();
                }
            }
 
            var enableAnimation = isAnimationEnabled();
            for (i = 0; i < renderArray.length; i++) {
                var x = renderArray[i].x, 
                    y = renderArray[i].y, 
                    w = renderArray[i].w, 
                    h = bubbleHeightFeed && bubbleHeightFeed.values.length ? renderArray[i].h : w, 
                    colorValue = renderArray[i].colorValue; 
                renderShape = renderArray[i].shapeValue;
                    
                    
                var markerShape;
                
                var rx = wScale(w) / 2,
                  ry = hScale(h) / 2;
                var aniTime = 0;
                if (enableAnimation){
                  aniTime = animateTime;
                }
                var newG = g.append('g').attr('class', 'v-datashape').attr('transform', 'translate(' + xScale(x) + ',' + yScale(y) + ')');
                var element = DrawUtil.createElements(newG, {shape: renderShape, className: CLASSMARKERHOVER+" "+CLASSDATAPOINT} );
                var parameter = {
                  drawingEffect: drawingEffect,
                  fillColor: colorValue,
                  graphType: renderShape,
                  direction: 'vertical',
                  rx: rx,
                  ry: ry,
                  borderWidth:  markerStyle['stroke-width'],
                  borderColor: markerStyle['stroke'],
                  node:element,
                  visibility: "visible",
                  animateTime: aniTime,
                  endFunc: checkAnimationCompleted
                };

                DrawUtil.drawGraph(parameter, effectManager).attr('opacity', OPACITY2);
            }
            selection.selectAll('.'+CLASSMARKERHOVER).data(renderArray);
            
            if (!enableAnimation) {
              animationComplete = true;
                eDispatch.initialized();
            }
        }
        
        function bubbleSizeScale(vMax, wh, heightFeed) {
            // even 0 value for bubble size, still render a small size shape
            return function(value) {
                if (NumberUtils.isNoValue(value)) {
                    return 4;
                }
                var range;
                if (wh) {
                    range = !heightFeed && height < width ? height : width;
                } else {
                    range = height;
                }
                var r = Math.pow(Math.abs(value) / vMax, 0.5) * (range - padding) * bubbleScale;
                return r > 4 ? r : 4;
            };
        }
        
//        function getThemeStyleDef() {
//            var markerThemeStyle = ctx.styleManager.query(CLASSMARKERHOVER);
//            if(markerThemeStyle){
//                if(markerThemeStyle['stroke']){
//                    markerStyle['stroke'] = markerThemeStyle['stroke'];
//                }
//                if(markerThemeStyle['stroke-width']){
//                    markerStyle['stroke-width'] = markerThemeStyle['stroke-width'];
//                }
//            }
//            var selectedMarkerThemeStyle = ctx.styleManager.query(CLASSMARKERSELECTED);
//            if(selectedMarkerThemeStyle){
//                if(selectedMarkerThemeStyle['stroke']){
//                    selectedMarkerStyle['stroke'] = selectedMarkerThemeStyle['stroke'];
//                }
//                if(selectedMarkerThemeStyle['stroke-width']){
//                    selectedMarkerStyle['stroke-width'] = selectedMarkerThemeStyle['stroke-width'];
//                }
//            }
//        }
        
        function sizeData() {
            var wDistinctValues = 0;
            for (var i in distinctValuesObj) {
              if(distinctValuesObj.hasOwnProperty(i)){
                wDistinctValues++;
              }
            }
            if (wDistinctValues === 0) {
                return [];
            } else if (wDistinctValues === 1) {
                return [wMax];
            } else if (wDistinctValues === 2) {
                return [wMax, wMin];
            } else {
                return [wMax, (wMax + wMin) / 2, wMin];
            }
        }
        
        bubble.parent = function() {
            return _selection;
        };

        bubble.mouseover = function(target) {
            var item = d3.select(target);
            if(item === undefined || item.node() === null || !animationComplete){
              return;
            }
            if (item.attr('id') !== null && (item.attr('id') === ('event-rect' + randomSuffix) 
                || item.attr('id').indexOf('cross-x-') >= 0
                || item.attr('id').indexOf('cross-y-') >= 0)) {
                return;
            }
            var val = item.datum();
            item.attr('opacity', '1');
            if (hoverlineVisible) {
                crossX.attr('visibility', 'visible')
                    .attr('x1', 0)
                    .attr('y1', yScale(val.y))
                    .attr('x2', width)
                    .attr('y2', yScale(val.y));
                crossY.attr('visibility', 'visible')
                    .attr('x1', xScale(val.x))
                    .attr('y1', 0)
                    .attr('x2', xScale(val.x))
                    .attr('y2', height);
            }
            
            showTooltip(val, _selection[0][0].getTransformToElement(_selection[0][0].ownerSVGElement));
            
        };
        
        bubble.mouseout = function(target, isHighlighted) {
            var item = d3.select(target);
            if(item === undefined || item.node() === null || !animationComplete) {return;}
            if (item.attr('id') === ('event-rect' + randomSuffix)) {
                return;
            }

            if (isHighlighted) {
                item.attr('opacity', OPACITY2);
            } else {
                item.attr('opacity', OPACITY1);
            }
            
            crossX.attr('visibility', 'hidden');
            crossY.attr('visibility', 'hidden');
            
            hideTooltip();
        };
        
        function showTooltip(val, transform) {
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var colorFeed = data.getAnalysisAxisDataByIdx(0);
            var shapeFeed = data.getAnalysisAxisDataByIdx(1);
            
            var tooltipData = {
                body: [],
                footer: []
            };
            var footer;//for iteration
            //push color footer to tooltipData
            for (var i = 0, len = (colorFeed ? colorFeed.values.length : 0); i < len; i++) {
              footer = {};
              footer.label = colorFeed.values[i].col.val;
              footer.value = colorFeed.values[i].rows[val.colorIndex].val;
              tooltipData.footer.push(footer);
            }
            //push shape footer to tooltipData
            for (var j = 0, jlen = (shapeFeed ? shapeFeed.values.length : 0); j < jlen; j++) {
              footer = {};
              footer.label = shapeFeed.values[j].col.val;
              footer.value = shapeFeed.values[j].rows[val.shapeIndex].val;
              tooltipData.footer.push(footer);
            }
            
            tooltipData.body.push({
              name : !TypeUtils.isExist(measureFeed1.values[0].col) ? langManager.get('IDS_ISNOVALUE') : measureFeed1.values[0].col,
              val : [{
                color : val.colorValue,
                shape : val.shapeValue,
                value : val.x
              }]
            });
            
            tooltipData.body.push({
              name : !TypeUtils.isExist(measureFeed2.values[0].col) ? langManager.get('IDS_ISNOVALUE') : measureFeed2.values[0].col,
              val :[{
                color : val.colorValue,
                shape : val.shapeValue,
                value : val.y
              }]
            });
            
            if (bubbleWidthFeed && bubbleWidthFeed.values.length > 0) {
              tooltipData.body.push({
                  name : !TypeUtils.isExist(bubbleWidthFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : bubbleWidthFeed.values[0].col,
                  val : [{
                    color : val.colorValue,
                    shape : val.shapeValue,
                    value : NumberUtils.isNoValue(val.w) ? langManager.get('IDS_ISNOVALUE') : val.w
                  }]
                });
            }
            if (bubbleHeightFeed && bubbleHeightFeed.values.length > 0) {
              tooltipData.body.push({
                  name : !TypeUtils.isExist(bubbleHeightFeed.values[0].col) ? langManager.get('IDS_ISNOVALUE') : bubbleHeightFeed.values[0].col,
                  val : [{
                    color : val.colorValue,
                    shape : val.shapeValue,
                    value : NumberUtils.isNoValue(val.h) ? langManager.get('IDS_ISNOVALUE') : val.h
                  }]
                });
            }

            tooltipData.point = {
               x : xScale(val.x),
               y : yScale(val.y) + transform.f
            };
            tooltipData.plotArea = {
               x : transform.e,
               y : transform.f,
               width : width,
               height : height
            };
            
            eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
            
            if (tooltipVisible) {
                var xAxisValue, yAxisValue;
                if (TypeUtils.isExist(formatString)) {
                    xAxisValue = formatManager.format(val.x, formatString[0]);
                    yAxisValue = formatManager.format(val.y, formatString[1]);
                } else {
                    xAxisValue = val.x;
                    yAxisValue = val.y;
                }
                drawXYTooltip(xAxisValue, tooltipX, {
                    x : xScale(val.x),
                    y : yScale(val.y)
                }, transform, 'x');
                drawXYTooltip(yAxisValue, tooltipY, {
                    x : xScale(val.x),
                    y : yScale(val.y)
                }, transform, 'y');
            }

        }
        
        function hideTooltip() {
            eDispatch.hideTooltip();
            if (tooltipVisible) {
                tooltipX.selectAll('g').remove();
                tooltipY.selectAll('g').remove();
            }
        }
        
        function drawXYTooltip(value, container, point, transform, axis) {
            var font = {
                size : '12px',
                weight : 'bold',
                family : '"Open Sans", Arial, Helvetica, sans-serif'
            };
            var valueSize = TextUtils.fastMeasure(value, font.size, font.weight, font.family);
            container.attr('width', valueSize.width + 20).attr('height', valueSize.height + 10);
            container.wrapper = container.append('g');
            container.wrapper.append('rect')
                    .attr('x', 1)
                    .attr('y', 1)
                    .attr('rx', 4)
                    .attr('ry', 4)
                    .attr('width', valueSize.width + 18)
                    .attr('height', valueSize.height + 8)
                    .attr('fill', '#ffffff')
                    .attr('stroke', '#000000')
                    .attr('stroke-width', 1)
                    .attr('class', 'v-background');
            container.wrapper.append('text')
                    .attr('x', 10)
                    .attr('y', valueSize.height + 3)
                    .attr('fill', '#000000')
                    .style('font', font.weight + ' ' + font.size + ' ' + font.family)
                    .attr('class', 'v-body-value')
                    .text(value);
            if ('y' === axis) {
                var left = transform.e - container.attr('width') + 1;
                container.style('left', (left < 0 ? 0 : left) + 'px').style('top',( point.y + transform.f - container.attr('height') / 2 ) + 'px');
            } else if ('x' === axis) {
                container.style('left', point.x + transform.e -  container.attr('width') / 2 + 'px').style('top', transform.f + height - 1 + 'px');
            }
        }

        function getChangedValues(changedArray) {
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var result = [];
            for (var i = 0; i < changedArray.length; i++) {
                var colorIndex = changedArray[i].colorIndex;
                var shapeIndex = changedArray[i].shapeIndex;
                
                result.push([
                    measureFeed1.values[0].rows[shapeIndex][colorIndex],
                    measureFeed2.values[0].rows[shapeIndex][colorIndex],
                    bubbleWidthFeed && bubbleWidthFeed.values.length > 0 ? bubbleWidthFeed.values[0].rows[shapeIndex][colorIndex] : null,
                    bubbleHeightFeed && bubbleHeightFeed.values.length > 0 ? bubbleHeightFeed.values[0].rows[shapeIndex][colorIndex] : null
                ]);
            }
            return result;
        }
        
        bubble.highlight = function(elems) {
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    d3.select(elems[i]).attr('class', CLASSMARKERSELECTED+' '+CLASSDATAPOINT).attr('opacity', OPACITY2).attr('stroke', selectedMarkerStyle['stroke']).attr('stroke-width', selectedMarkerStyle['stroke-width']);
                }
            } else {
                d3.select(elems).attr('class', CLASSMARKERSELECTED+' '+CLASSDATAPOINT).attr('opacity', OPACITY2).attr('stroke', selectedMarkerStyle['stroke']).attr('stroke-width', selectedMarkerStyle['stroke-width']);
            }
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(_selection, true, elems);
            }
        };
        
        bubble.unhighlight = function(elems) {
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    d3.select(elems[i]).attr('class', CLASSMARKERHOVER+' '+CLASSDATAPOINT).attr('opacity', OPACITY1).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
                }
            } else {
                d3.select(elems).attr('class', CLASSMARKERHOVER+' '+CLASSDATAPOINT).attr('opacity', OPACITY1).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            }
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(_selection, false, elems);
            }
        };
        
        bubble.clear = function(gray) {
            var allMarks = _selection.selectAll('.'+CLASSDATAPOINT).attr('class', CLASSMARKERHOVER+' '+CLASSDATAPOINT).attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            if (gray) {
                allMarks.attr('opacity', OPACITY1);
            } else {
                if(hasDefaultSelection){
                  defaultSelUtil.clearSelectionInfo(_selection, false, allMarks);
                }
                allMarks.attr('opacity', OPACITY2);
            }
            
        };
        
        props = manifest.props(null);
        return bubble;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.bubble',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.Scatter',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.bubble',
    'type' : Constants.Module.Type.Chart,
    'name' : 'bubble',
    'data' : 'DATA STRUCTURE DOC',
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set marker color of bubble.'
      },
      'shapePalette' : {
        'name' : 'shapePalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : [ 'circle', 'square', 'diamond', 'triangleUp',
            'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection' ],
        'supportedValues' : [ 'circle', 'square', 'diamond', 'triangleUp',
              'triangleDown', 'triangleLeft', 'triangleRight', 'cross', 'intersection' ],
        'description' : 'Set marker shape of bubble.'
      },
      'axisTooltip' : {
        'name' : 'axisTooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'enabled/disabled tooltip.'
          },
          'formatString': {
      		'name' : 'formatString',
      		'supportedValueType': 'StringArray',
      		'defaultValue' : null,
      		'description' : 'Set format string for small tooltip.The first one is applied to xAxis and the second one is applied to yAxis'
          }
        },
        'description' : 'Set tooltip related properties.'
      },
      'hoverline' : {
        'name' : 'hoverline',
        'supportedValueType' : 'Object',
        'description' : 'Settings for hoverline properties.',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set to enabled/disabled hoverline or not.'
          }
        }
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Set animation of bubble/scatter.'
        },
        'drawingEffect':{
          'name' : 'drawingEffect',
           'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Drawing effect of bubble marker.',
            'isExported' : true
        }
    },
    'css' : {
        '.v-hoverline' : {
            'description' : 'Define style for hover line color.',
            'value' : {
                'stroke' : '#cccccc'
            }
        }
    },
    'events' : {
      'initialized': Constants.Module.Event.Initialized.desc,
        'selectData' : Constants.Module.Event.SelectData.desc,
        'deselectData' : Constants.Module.Event.DeSelectData.desc,
        'showTooltip' : Constants.Module.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "scatter",
      configure : {
        bubbleWidth:
        {
          min:1
        }
      }
    },
  
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.scatter',
    base : 'sap.viz.modules.bubble',
    'name' : 'scatter',
    'properties' : {
        'markerSize' : {
            'name' : 'markerSize',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : "10",
              'description' : 'Set marker size of data point. The available range is from 4 to 32.'
        }
    },
    'feeds' : {
      configure : {
        bubbleWidth : null,
        bubbleHeight : null
      }
    }
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.ScatterInMatrix',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants) {
    var module = {
      'id' : 'sap.viz.modules.scatterInMatrix',
      base : 'sap.viz.modules.scatter',
      'name' : 'scatterInMatrix',
      'feeds' : null
    };
    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.ScatterMatrix',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
    var feeds = {
      id : "scattermatrix",
      feeds : [ {
        'id' : 'regionColor',
        'name' : 'IDS_REGIONCOLOR',
        'type' : constants.Type.Dimension,
        'min' : 0,
        'max' : 1,
        'aaIndex' : 1,
        'acceptMND': -1
      }, {
        'id' : 'regionShape',
        'name' : 'IDS_REGIONSHAPE',
        'type' : constants.Type.Dimension,
        'min' : 0,
        'max' : 1,
        'aaIndex' : 2,
        'acceptMND': -1
      }, {
        'id' : 'primaryValues',
        'name' : 'IDS_PRIMARYVALUES',
        'type' : constants.Type.Measure,
        'min' : 2,
        'max' : constants.Constraints.INF,
        'mgIndex' : 1
      }]
    };
    Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.scattermatrixcontainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ignite',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.fn.createContext',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.dataUtil',
  version : '4.0.2'
}
],
function Setup(TypeUtils, Objects, Functions, layout, MultiChartDataHandler, Manifest, TextUtils, dispatch, langManager, boundUtil, ignite, createContext, dataUtil) {

    return function(manifest, ctx) {
        var CSSCLASS_SUBTITLE = 'v-subtitle';

        var width = 0, height = 0, subWidth = 0, subHeight = 0,
        properties = {}, data = {}, config = {}, modules = {}, selections = {}, parent = null, // a d3 selection
        dataHandler = null, plotLabels = [];
        var plotTitleVisible = true;
        var isTitleHidden = false;
        var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0;
        var font = {};
        var defaultTitleStyle;
        var innerProperties = manifest.props(null);
        var initializedPlots = 0;
        var plotManifest, plotContext;

        var handleNull = function(_) {
          if (_ === null || _ === undefined) {
            return langManager.get('IDS_ISNOVALUE');
          } else {
            return _;
          }
        };
    
        //Alex Su: we need to hold a copy of animation flag settings to control animation flow.
        var plotAnimation = {
          dataLoading: true,
          dataUpdating:true,
          resizing:true
        };
        var bFirstCreation = true, bDataChanged = false;
        
        var PLOTAREAPROPCATE = 'plotArea';
        
        function setAnimationFlag(back){
          //Alex Su: FIXME hard coded here, need to be resolved in the future.
          var props = {};
          var propcate = (props[PLOTAREAPROPCATE] = {});
          var animation = (propcate.animation = {});
          Objects.extend(animation, plotAnimation);
          if (!back && bDataChanged){
            animation.dataLoading = plotAnimation.dataUpdating;
          }
          var plots = modules.plot;
          for(var i = 0, len = plots.length; i < len; i++){
            plots[i].properties(props);
          }      
        }
        function getThemeStyleDef() {
            var titleStyle = ctx.styleManager.query(CSSCLASS_SUBTITLE);
            if(titleStyle) {
                if(titleStyle['fill']){
                    font.fill = titleStyle['fill'];
                }
                if(titleStyle['font-family']){
                    font.family = titleStyle['font-family'];
                }
                if(titleStyle['font-size']){
                    font.size = titleStyle['font-size'];
                }
                if(titleStyle['font-weight']){
                    font.weight = titleStyle['font-weight'];
                }
            }
            defaultTitleStyle = ctx.styleManager.queryDefault(CSSCLASS_SUBTITLE);
        };
        
        function initializePlot() {
          var plotConfig = config.modules.plot;
          if (!plotConfig)
              return;
          delete modules.plot;
          modules.plot = [];
          
          if ( plotContext ) {
            plotContext.styleManager.cleanChildren();
          }
          
          var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
          for (var colI = 0; colI < measureNum; colI++) {
              for (var rowI = 0; rowI < measureNum; rowI++) {
                  var i = rowI * measureNum + colI;
                  
                  if ( !plotManifest || !plotContext ) {
                    plotManifest = Manifest.get(plotConfig.id);
                    plotContext = createContext(plotManifest, ctx, "v-m-plot");
                  }
                  
                  var plotI = modules.plot[i] = ignite(plotManifest, plotContext);
                  plotI.config(plotConfig);
                  avaPlotCount++;
                  if(plotI.dispatch){
                      var dis =  plotI.dispatch();
                        if(dis.initialized) dis.on('initialized.scattermatrixcontainer', initialized);
                        if(dis.showTooltip) dis.on('showTooltip.scattermatrixcontainer', showTooltip);
                        if(dis.hideTooltip) dis.on('hideTooltip.scattermatrixcontainer', hideTooltip);
                   }
              }
          }
        }
        
        function updatePlotProperties() {
          if (TypeUtils.isExist(properties.multiLayout) && TypeUtils.isExist(properties.multiLayout.plotTitle) && TypeUtils.isExist(properties.multiLayout.plotTitle.visible)) {
            plotTitleVisible = properties.multiLayout.plotTitle.visible;
            innerProperties.plotTitle.visible = properties.multiLayout.plotTitle.visible;              
          }
          
          var plots = modules.plot;
          if(plots){
            var plotConfig = config.modules.plot;
            if (!plotConfig)
                return;
            var props;
            if (plotConfig.configure) {
                if (plotConfig.configure.propertyCategory) {
                  props = Objects.extend(true, {}, properties[ plotConfig.configure.propertyCategory ]);
               }
            } else {
                props = properties;
            }

            for(var i = 0, len = plots.length; i < len; i++){
              if (props) {
                plots[i].properties(props);
              }
            }
          }
          getThemeStyleDef();
        }
        
        function updatePlotData() {
          //Alex Su: delete Dom for matrix labels
          if (plotLabels){
            for (var i = 0; i < plotLabels.length; ++i){
              var shape = plotLabels[i].shape;
              if (shape){
                shape.remove();
              }
            }
          }
          plotLabels = [];//can we split data label updating outside?
          dataHandler = new MultiChartDataHandler(data, "measures");
          var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
          for (var colI = 0; colI < measureNum; colI++) {
              for (var rowI = 0; rowI < measureNum; rowI++) {
                  var dataI = dataHandler.getSubDataAdapterByMeasures({
                      row : rowI,
                      col : colI
                  });
                  var plotI = modules.plot[rowI * measureNum + colI];
                  plotI.data(dataI);
                  
                  var plotLabel = plotLabels[rowI * measureNum + colI];
                  if(!plotLabel) plotLabel = plotLabels[rowI * measureNum + colI] = {};
                  //we may already have other members here in plotLabel, do not remove them while updating
                  plotLabel.empty = (colI == rowI);
                  plotLabel.label = (colI == rowI 
                          ? handleNull(dataI.getMeasureValuesGroupDataByIdx(0).values[0].col) 
                          : handleNull(dataI.getMeasureValuesGroupDataByIdx(0).values[0].col) + ' - ' + handleNull(dataI.getMeasureValuesGroupDataByIdx(1).values[0].col));
              }
          }
        }
        
        function initializePlotElements() {
          delete selections.plot;
          parent.select('.v-m-plot').remove();
          if (modules.plot && !selections.plot) {
            var splots = selections.plot = [];
            var plotRoot = selections.plotRoot = parent.append('g').attr('class', 'v-m-plot');
            for (var i = 0, len = modules.plot.length; i < len; i++) {
                splots[i] = plotRoot.append('g').attr('class', 'v-m-plot' + i);

                var plotI = modules.plot[i];
                var subModules = plotI.parent(splots[i]).modules();

                for (var m in subModules )
                if (subModules.hasOwnProperty(m))
                    modules['plot[' + i + ']' + '.' + m] = subModules[m];
            }
          }
        }

        function initialize() {
            if (TypeUtils.isEmptyObject(config))
                Functions.error('Container configuration missing');

            avaPlotCount = 0;
            initializePlot();
            updatePlotProperties();
            updatePlotData();
            initializePlotElements();
        };
        
        function relayout() {
            if (TypeUtils.isEmptyObject(modules) || !width || !height)
                return;
            
            getThemeStyleDef();
            var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
            subWidth = width / measureNum;
            subHeight = height / measureNum;
            var labelSize = getMaxLabelSize();
            var labelHeight = labelSize.height;
            if (!plotTitleVisible || labelSize.width > subWidth || labelSize.height > subHeight / 3) {
                labelSize.height = 0;
                isTitleHidden = true;
            }
            for (var colI = 0; colI < measureNum; colI++) {
                for (var rowI = 0; rowI < measureNum; rowI++) {
                    
                    var plotI = modules.plot[rowI * measureNum + colI];
                    var splotI = selections.plot[rowI * measureNum + colI];
                    plotI.width(subWidth).height(subHeight - labelHeight);
                    splotI.attr('transform', 'translate(' + (subWidth * colI) + ',' + (subHeight * rowI) + ')');
                }
            }
        };

        function container(selection) {
            selection.each(function(data) {
              //Alex Su: if detected data changing, we set sub plot's dataLoading with container's dataUpdating to control its animation
              if (!bFirstCreation && bDataChanged){
                setAnimationFlag();
              }

              initializedPlots = 0;
              parent = selection;
              boundUtil.drawBound(selection, width, height);
              if (TypeUtils.isEmptyObject(modules)){
                  initialize();
              }
              relayout();
              render();
              //Alex Su: and set animation flags back after rendering.
              if (!bFirstCreation && bDataChanged){
                setAnimationFlag(true);
              }

            });
            bFirstCreation = false, bDataChanged = false;
            return container;
        }


        container.width = function(_) {
            if (!arguments.length)
                return width;
            if (width !== _) {
                width = _;
                relayout();
            }
            return container;
        };

        container.height = function(_) {
            if (!arguments.length)
                return height;
            if (height !== _) {
                height = _;
                relayout();
            }
            return container;
        };

        container.size = function(_) {
            if (!arguments.length)
                return {
                    'width' : width,
                    'height' : height
                };
            if (height !== _.height || width !== _.width) {
                height = _.height;
                width = _.width;
                relayout();
            }
            return container;
        };

        container.data = function(_) {
            if (!arguments.length)
                return data;
            bDataChanged = true;
            var bDataSchmaChanged = false;
            if (! dataUtil().hasSameSchema(data, _)){
              bDataSchmaChanged = true;
            }
            data = _;
            if(!TypeUtils.isEmptyObject(modules)){
              //TODO Jimmy/9/11/2012 currently we can't know
              //whether it's a data change only (without schema change)
              //but we do have chance in new data model. for now, we just
              //update everything

              if (bDataSchmaChanged){
                avaPlotCount = 0;
                initializePlot();
                updatePlotProperties();
                updatePlotData();
                initializePlotElements();
              } else {
                updatePlotData();
              }
            }
            return container;
        };

        container.properties = function(_) {
            if (!arguments.length)
                return innerProperties;
            properties = $.extend(true, {}, properties, _);
            Objects.extend(true, innerProperties, properties["multiLayout"]);
            
            if (properties[PLOTAREAPROPCATE]){
              Objects.extend(plotAnimation, properties[PLOTAREAPROPCATE].animation);
            }
            if(!TypeUtils.isEmptyObject(modules)){
              updatePlotProperties();
            }
            return container;
        };

        container.config = function(_) {
            if (!arguments.length)
                return config;
            config = _;
            return container;
        };

        container.modules = function(_) {
            if (!arguments.length) {
                if (TypeUtils.isEmptyObject(modules)) {
                    initialize();
                }
                return modules;
            }
            modules = _;
            return container;
        };

        container.parent = function(_) {
            if (!arguments.length)
                return parent;
            parent = _;
            return container;
        };

        container.dispatch = function(_){
          if( !arguments.length){
            return eDispatch;
          }
          eDispatch = _;
          return container;
        };
        
        function render() {

            if (selections.plot) {
                for (var i = 0, len = selections.plot.length; i < len; i++) {
                    if (plotLabels[i].empty) {
                        renderLabel(selections.plot[i], plotLabels[i], subHeight / 2);
                        initialized();
                    } else {
                        modules.plot[i].width(subWidth);
                        selections.plot[i].datum(modules.plot[i].data()).call(modules.plot[i]);
                        renderLabel(selections.plot[i], plotLabels[i], subHeight);
                    }
                    
                }
            }
            isTitleHidden = false;
        };
        
        function renderLabel(plot, labelObj, ybaseline) {
            if (labelObj.shape) {
                labelObj.shape.remove();
            }
            
            if (isTitleHidden) {
                return;
            }
            
            var labelSize = TextUtils.fastMeasure(labelObj.label, font.size, font.weight, font.family);
            
            labelObj.shape = plot.append('text').attr('class', CSSCLASS_SUBTITLE + ' ' + 'viz-matrix-sub-title')
                    .attr('text-anchor', 'middle')
                    .attr('x', subWidth / 2)
                    .attr('y', jQuery.browser.msie ? ybaseline : ybaseline - labelSize.height / 2)
                    .attr('dominant-baseline', 'middle')
                    .style('cursor', 'default');
            defaultTitleStyle.toAttrs(labelObj.shape);
            TextUtils.ellipsis(labelObj.label, labelObj.shape.node(), subWidth - 5 /* leave some padding */, "font:" + font.weight + ' ' + font.size + ' ' + font.family);
        };
        
        function getMaxLabelSize() {
            var maxWidth = 0, maxHeight = 0;
            for (var i = 0, len = plotLabels.length; i < len; i++) {
                var size = TextUtils.fastMeasure(plotLabels[i].label, font.size, font.weight, font.family);
                maxHeight = size.height > maxHeight ? size.height : maxHeight;
                maxWidth = size.width > maxWidth ? size.width : maxWidth;
            }
            return {
                width : maxWidth,
                height : maxHeight
            };
        }
        
        function initialized(){
          if(++initializedPlots == avaPlotCount){
            initializedPlots = 0;
            eDispatch.initialized();
          }
        }
        
        function showTooltip(evt){
          eDispatch.showTooltip(evt);
        };
        
        function hideTooltip(evt){
          eDispatch.hideTooltip(evt);
        };
        
        return container;
    };

});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.ScatterMatrixContainer',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.scattermatrixcontainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.ScatterMatrix',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
    
    var module = {
      'id' : 'sap.viz.modules.scattermatrixcontainer',
        'type' : Constants.Module.Type.Container,
        'name' : 'Scatter Matrix Container',
        'description': 'Settings for the subcharts layout of Scatter Matrix chart.',
        'properties' : {
            'plotTitle' : {
              'name' : 'plotTitle',
        'description': 'Settings for plot title.',
              'supportedValueType' : 'Object',
              'supportedValues' : {
                'visible' : {
                  'name' : 'visible',
                  'supportedValueType' : 'Boolean',
                  'defaultValue' : true,
                  'description' : 'Set visibility of sub plot title.'
                }
              }
            }
        },
        'css' : {
            '.viz-matrix-sub-title.v-subtitle' : {
                'description' : 'Define style for the sub plot title.',
                'value' : {
                    'fill' : '#000000',
                    'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
                    'font-size' : '12px',
                    'font-weight' : 'bold'
                }
            }
        },
        'feeds' : { 
            id : 'scattermatrix'
        },
    'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
        'fn' : fn
    };
    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.ScatterMatrixChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.ScatterMatrixContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.ScatterInMatrix',
  version : '4.0.2'
}
],
function Setup(Manifest) {
    var scatterMatrix = {
        id : 'viz/scatter_matrix',
        name : 'IDS_SCATTERMATRIXCHART',
        base : 'riv/base',
        modules : {
          root : {
            modules : {
              legends : {
                modules : {
                  legend : {
                    data : { aa : [1, 2] }, 
                    configure : { 
                      properties : { type :'BubbleColorLegend' }
                    }
                  }
                }
              },
  
              tooltip : { 
                id : 'sap.viz.modules.tooltip',
                configure : { 
                  propertyCategory : 'tooltip',
                  properties : { 
                    chartType: 'scattermatrix',
                    orientation :'left'
                  }
                }
              },
  
              interaction : { 
                id : 'sap.viz.modules.controller.interaction',
                configure : { 
                  clientID : 'main',
                  propertyCategory :'interaction'
                }
              },
  
              main : {
                id : 'sap.viz.modules.scattermatrixcontainer',
                configure : {
                  propertyCategory : 'multiLayout',
                  properties : {
                    layout : {
                      position : 'center',
                      priority : 10
                    }
                  }
                },
                
                modules : {
                  plot : {
                    id : 'sap.viz.modules.xycontainer',
                    modules : {
                      xAxis : {
                        id : 'sap.viz.modules.axis',
                        data : { mg : [1] },
                        configure : {
                          description : 'Settings for the x axis of a normal bubble or scatter plot.',
                          propertyCategory : 'xAxis',
                          properties : {
                            type : 'value',
                            position : 'bottom',
                            gridline : { visible : false }
                          }
                        }
                      },

                      yAxis : {
                        id : 'sap.viz.modules.axis',
                        data : { mg : [2] },
                        configure : {
                          description : 'Settings for the y axis of a normal bubble or scatter plot.',
                          propertyCategory : 'yAxis',
                            properties : {
                              type : 'value',
                              position : 'left',
                              gridline : { visible : false }
                            }
                        }
                      },
                
                      background : {
                        id: 'sap.viz.modules.background',
                        configure : {
                          propertyCategory : 'background',
                          properties : {
                            direction : 'vertical'
                          }
                        }
                      },
                      
                      dataLabel : {
                        id : 'sap.viz.modules.datalabel',
                        configure : {
                          propertyCategory : 'dataLabel',
                          properties : {
                    paintingMode : 'rectCoordinate',
                            visible : false,
                            position : 'outside',
                            automaticInOutside : false
                          }
                        }
                      },
                
                      plot : {
                        id : 'sap.viz.modules.scatterInMatrix',
                        configure : {
                          description : 'Settings regarding the chart area and plot area as well as general chart options.',
                          propertyCategory : 'plotArea'
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        },
        
        dependencies : {
            attributes : [{
                targetModule : 'root.main.plot.yAxis',
                target : 'scale',
                sourceModule : 'root.main.plot.plot',
                source : 'valueAxis2Scale'
            }, {
                targetModule : 'root.main.plot.xAxis',
                target : 'scale',
                sourceModule : 'root.main.plot.plot',
                source : 'valueAxis1Scale'
            }, {
                targetModule : 'root.main.plot.xAxis',
                target : 'title',
                sourceModule : 'root.main.plot.plot',
                source : 'valueAxis1Title'
            }, {
                targetModule : 'root.main.plot.yAxis',
                target : 'title',
                sourceModule : 'root.main.plot.plot',
                source : 'valueAxis2Title'
            }, {
                targetModule : 'root.legends.legend',
                target : 'colorPalette',
                sourceModule : 'root.main.plot.plot',
                source : 'colorPalette'
            }, {
                targetModule : 'root.legends.legend',
                target : 'shapes',
                sourceModule : 'root.main.plot.plot',
                source : 'shapes'
            }, {
              targetModule : 'root.legends.legend',
              target : 'setSelectionMode',
              sourceModule : 'root.interaction',
              source : 'getSelectionMode'
            }],

            events :[{
                targetModule : 'root.tooltip',
                listener : 'showTooltip',
                sourceModule : 'root.main',
                type : 'showTooltip'
            }, {
                targetModule : 'root.tooltip',
                listener : 'hideTooltip',
                sourceModule : 'root.main',
                type : 'hideTooltip'
            }, {
                targetModule : 'root.interaction',
                listener : 'registerEvent',
                sourceModule : 'root.main',
                type : 'initialized.interaction'
            }, {
              targetModule : 'root.interaction',
              listener : 'highlightedByLegend',
              sourceModule : 'root.legends.legend',
              type : 'highlightedByLegend'
            }, {
                    targetModule : 'root.legends.legend',
                  listener : 'deselectLegend',
                  sourceModule : 'root.interaction',
                  type : 'deselectLegend'
            }, {
              targetModule : 'root.main.plot.dataLabel',
              listener : 'showLabel',
              sourceModule : 'root.main.plot.plot',
              type : 'initialized.datalabel'
            }, {
              targetModule : 'root.main.plot.dataLabel',
              listener : 'removeLabel',
              sourceModule : 'root.main.plot.plot',
              type : 'startToInit.datalabel'
            } ]
        }
    };

    Manifest.register(scatterMatrix);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_scatter',
    name : 'IDS_MULTISCATTERCHART',
    base : 'riv/base/multiple/xy',
   
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 2,3 ] },
                configure : {
                  properties : { type : 'BubbleColorLegend' }
                } 
              }
            }
          },
          tooltip : {
            configure : {
              properties : {
                chartType : 'scatter',
                orientation : 'left'
              }
            }
          },
          
          interaction : { 
            id : 'sap.viz.modules.controller.interaction',
            configure : { 
              clientID : "main",
              propertyCategory : 'interaction'
            }
          },
          
          main : {              
            configure : {
              properties : {
                'mergeDataRange' : ['valueAxis1', 'valueAxis2']
              }
            },
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  xAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the x axis of a normal bubble or scatter plot.',
                     propertyCategory : 'xAxis',
                      properties : {
                        title : {
                          visible : false
                        },
                        type : 'value',
                        position : 'bottom'
                      },
                      propertiesOverride : {
                        title : {
                          isExported : false
                        }                    
                      }
                    }
                  },
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : {
                        automaticInOutside : false,
                        orientation : 'vertical',
                        position : 'outside',
                        outsideVisible : true
                      }
                    }
                  },
                  /**
                   * 'xAxis2' : { },
                   */
        
                  yAxis : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                    'description': 'Settings for the y axis of a normal bubble or scatter plot.',
                      propertyCategory : 'yAxis',
                      properties : {
                        title : {
                          visible : false
                        },
                        type : 'value',
                        position : 'left'
                      },
                      propertiesOverride : {
                        title : {
                          isExported : false
                        }                    
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.scatter',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    },
    feeds:{
      multiplier:{
        acceptMND:-1
       }
   },
    dependencies : {
      attributes : [
      {
        targetModule : 'root.main.xAxis2',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'root.main',
        target : 'valueAxis1DataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'valueAxis1DataRange',
        sourceModule : 'root.main',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'root.main',
        target : 'valueAxis2DataRange',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'root.main.plot.plot',
        target : 'valueAxis2DataRange',
        sourceModule : 'root.main',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'root.main.plot.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'root.main.plot.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'root.main.plot.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot.plot',
        source : 'shapes'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
    }
      ],
      events : [  {
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'root.tooltip',
            listener : 'showTooltip',
            sourceModule : 'root.main',
            type : 'showTooltip'
        }, {
            targetModule : 'root.tooltip',
            listener : 'hideTooltip',
            sourceModule : 'root.main',
            type : 'hideTooltip'
        },{
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.plot.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot.plot',
          type : 'startToInit.datalabel'
        }]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiBubbleChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_bubble',
    name : 'IDS_MULTIBUBBLECHART',
    base : 'viz/multi_scatter',
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                data : { aa : [ 2, 3 ] },
                configure : {properties : {layout :{order : 1}},propertiesOverride :{isHierarchical : { isExported : false }}}
              },
              sizeLegend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  description: "The size legend is a box mapping the charts data shapes's size to the value by some typical symbols and associated indication values.",
                  propertyCategory : 'sizeLegend',
                  properties : { type : 'SizeLegend',layout : { order : 0 } }
                }
              }
            }
          },
          
          tooltip : {
            configure : {
              properties : { chartType : 'bubble', orientation : 'left' }
            }
          },
          
          main : {
            configure : {
              properties : {
                'mergeDataRange' : ['valueAxis1', 'valueAxis2', 'bubbleWidth', 'bubbleHeight']
              }
            },
            
            modules: {
              plot : {
                id : 'sap.viz.modules.xycontainer',
                modules : {
                  dataLabel : {
                    id : 'sap.viz.modules.datalabel',
                    configure : {
                      propertyCategory : 'dataLabel',
                      properties : { 
                        automaticInOutside : true,
                        position : 'inside'
                      }
                    }
                  },
                  
                  plot : {
                    id : 'sap.viz.modules.bubble',
                    configure : {
                    description : 'Settings regarding the chart area and plot area as well as general chart options.',
                      propertyCategory : 'plotArea'
                    }
                  }
                }
              }
            }
          }
        }
      }
      
    },
    feeds:{
      multiplier : { acceptMND : -1 },
      secondaryValues: { max: 1 } // or null
    },
    
    dependencies : {
      attributes : [
        {
          targetModule : 'root.main.xAxis2',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'xCategoryScale'
        }, 
        {
          targetModule : 'root.main.yAxis',
          target : 'scale',
          sourceModule : 'root.main',
          source : 'yCategoryScale'
        },
        {
          targetModule : 'root.main',
          target : 'valueAxis1DataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis1DataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'valueAxis1DataRange',
          sourceModule : 'root.main',
          source : 'valueAxis1DataRange'
        },
        {
          targetModule : 'root.main',
          target : 'valueAxis2DataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis2DataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'valueAxis2DataRange',
          sourceModule : 'root.main',
          source : 'valueAxis2DataRange'
        },
        {
          targetModule : 'root.main',
          target : 'bubbleWidthDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'bubbleWidthDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'bubbleWidthDataRange',
          sourceModule : 'root.main',
          source : 'bubbleWidthDataRange'
        },
        {
          targetModule : 'root.main',
          target : 'bubbleHeightDataRange',
          sourceModule : 'root.main.plot.plot',
          source : 'bubbleHeightDataRange'
        },
        {
          targetModule : 'root.main.plot.plot',
          target : 'bubbleHeightDataRange',
          sourceModule : 'root.main',
          source : 'bubbleHeightDataRange'
        },
        {
          targetModule : 'root.main.plot.xAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis1Scale'
        },
        {
          targetModule : 'root.main.plot.yAxis',
          target : 'scale',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis2Scale'
        }, 
        {
          targetModule : 'root.main.plot.xAxis',
          target : 'title',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis1Title'
        }, 
        {
          targetModule : 'root.main.plot.yAxis',
          target : 'title',
          sourceModule : 'root.main.plot.plot',
          source : 'valueAxis2Title'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'colorPalette',
          sourceModule : 'root.main.plot.plot',
          source : 'colorPalette'
        }, 
        {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot.plot',
          source : 'shapes'
        }, 
        {
            targetModule : 'root.legends.sizeLegend',
            target : 'sizeLegendInfo',
            sourceModule : 'root.main.plot.plot',
            source : 'sizeLegend'
        }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/scatter/single/base',
    name : 'IDS_BASEBUBBLECHART',
    'abstract' : true,
    base : 'riv/base/single',
    modules : {
      root : {
        modules : {
          legends : {
            configure : {
              properties : {
                layout : {
                  position : 'right',
                  priority : 1,
                  alignment : 'right'
                }
              }
            },
            modules : {
              legend : {
                data : { aa : [ 1, 2 ] },
                configure : {
                  properties : {
                    type : 'BubbleColorLegend',
                    layout : { order : 1 }
                  },
                  propertiesOverride : {
                    isHierarchical : { isExported: false }
                  }
                }
              }
            }
          },
          
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : { orientation : 'left' }
            }
          },
          
          interaction : { 
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main', 
              propertyCategory :'interaction'
            }
          },
          
          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    orientation : 'vertical',
                    visible : false,
                    position : 'outside',
                    outsideVisible : true,
                    positionPreference : true
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  mg : [ 1 ]
                },
                configure : {
                  'description': 'Settings for the x axis of a normal bubble or scatter plot.',
                  propertyCategory : 'xAxis',
                  properties : {
                    type : 'value',
                    position : 'bottom',
                    gridline : {
                      visible : false
                    }
                  }
                }
              },
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : { mg : [ 2 ] },
                configure : {
                  description : 'Settings for the y axis of a normal bubble or scatter plot.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'value',
                    position : 'left',
                    gridline : {
                      visible : true
                    }
                  }
                }
              },
            
            background : {
            id: 'sap.viz.modules.background',
            configure : {
              propertyCategory : 'background',
              properties : {
                direction : 'vertical'
              }
            }
            }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'root.main.xAxis',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'title',
        sourceModule : 'root.main.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'root.legends.legend',
        target : 'colorPalette',
        sourceModule : 'root.main.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'root.legends.legend',
        target : 'shapes',
        sourceModule : 'root.main.plot',
        source : 'shapes'
      }, {
        targetModule : 'root.legends.legend',
        target : 'setSelectionMode',
        sourceModule : 'root.interaction',
        source : 'getSelectionMode'
      }],
      events : [{
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      },{
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
        }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        },  {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.ScatterChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.DataTransform',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/scatter',
    name : 'IDS_SCATTERCHART',
    base : "viz/scatter/single/base",
    modules : {
      dataTransform : {
        id : 'sap.viz.modules.datatransform',
        configure : {
          propertyCategory : 'dataTransform',
          properties : {
            dataSampling : {
              enable : false,
              sizeFactor : 0.5     
            },
            autoBinning : {
              enable: null
            }
          },
          propertiesOverride : {
            autoBinning : {
              isExported : false
            }
          }
        }
      },
      root : {
        modules : {
          tooltip : {
            configure : {
              properties : {
                chartType : 'scatter'
              }
            }
          },
          main : {
            modules : {
              plot : {
                id : 'sap.viz.modules.scatter',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : false
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.BubbleChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.2'
}
],
function Setup ( Manifest, Constants ) {
  var chart = {
    id : 'viz/bubble',
    name : 'IDS_BUBBLECHART',
    base : "viz/scatter/single/base",
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.APPROXIMATE }
          }
        },
        modules : {
          legends : {
            modules : {
              sizeLegend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  description : 'The size legend is a box mapping the charts data shapes\' size to the value by some typical symbols and associated indication values.',
                  propertyCategory : 'sizeLegend',
                  properties : {
                    type : 'SizeLegend',
                    layout : { order : 0 }
                  },
                  propertiesOverride  : {
                    isHierarchical : { isExported : false },
                    formatString: { isExported: true }
                  }
                }
              }
            }
          },

          tooltip : {
            configure : {
              properties : { chartType : 'bubble' }
            }
          },
          
          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  properties : {
                    automaticInOutside : true,
                    position : 'inside'
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.bubble',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [  
        undefined, undefined, undefined, undefined, undefined, undefined, undefined,
     {
        targetModule : 'root.legends.sizeLegend',
        target : 'sizeLegendInfo',
        sourceModule : 'root.main.plot',
        source : 'sizeLegend'
      } ],
      events : [ {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'root',
        listener : 'relayout',
        sourceModule : 'root.legends',
        type : 'relayout'
      },{
          targetModule : 'root.interaction',
          listener : 'registerEvent',
          sourceModule : 'root.main.plot',
          type : 'initialized.interaction'
        }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
        }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        },  {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.TreeMap',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var rectangleTitleFeed = {
    'id' : 'rectangleTitle',
    'name' : 'IDS_RECTANGLETITLE',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND': -1,
    'maxStackedDims' : 6
  };

  var rectangleWeightFeed = {
    'id' : 'rectangleWeight',
    'name' : 'IDS_RECTANGLEWEIGHT',
    'type' : constants.Type.Measure,
    'min' : 1,
    'max' : 1,
    'mgIndex' : 1
  };

  var rectangleColorFeed = {
    'id' : 'rectangleColor',
    'name' : 'IDS_RECTANGLECOLOR',
    'type' : constants.Type.Measure,
    'min' : 0,
    'max' : 1,
    'mgIndex' : 2
  };
  var feeds = {
    id : "treeMap",
    feeds : [ rectangleTitleFeed, rectangleColorFeed, rectangleWeightFeed ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.2'},
[

],
function Setup() {
  var MeasureBasedColoring = {
    getScale : function(minVal, maxVal, ticksCount, startColor, endColor) {
      var colorScale = d3.scale.linear().domain([ minVal, maxVal ])
        .range([ startColor, endColor ]).nice();
     
      var colorScaleNice = colorScale.domain(); 
      var t1 = getAccFormat(colorScaleNice[0]), t2 = getAccFormat(colorScaleNice[1]);
      var totalPrecision = t1 > t2 ? t1 : t2;
      totalPrecision++;
      
      var niceDomain = colorScale.domain();
      niceDomain = formatRange(niceDomain, totalPrecision);
      
      minVal = niceDomain[0];
      maxVal = niceDomain[1];
      
      if(minVal === maxVal){
        //only one value in range.
        ticksCount = 1;
      }
      var span = maxVal - minVal, ticks = [], step, precision = 0;
      if(span / ticksCount > 1){
        if (span % ticksCount === 0) {
          // divied properly
          step = format(span / ticksCount, totalPrecision + 1);
          precision = getAccFormat(step);
          
          for ( var i = 0; i < ticksCount + 1; i++) {
            ticks.push(minVal + format(i * step, precision));
          }
        } else {
          step = Math.ceil(span / ticksCount);
          precision = getAccFormat(step);
          var start = Math.floor(minVal / step) * step;
          if(start === 0 || (start + step*ticksCount < maxVal)) {
            start = minVal;
          }
          
          for ( var i = 0; i < ticksCount + 1; i++) {
            ticks.push(start + format(i * step, precision));
          }
        }
      }else{
        //Can't be divided with integrate. 
        start = minVal, step = format(span / ticksCount, totalPrecision + 1);
        precision = getAccFormat(step);
        
        for(var i = 0; i < ticksCount; i++){
          ticks.push(start + format(i * step, precision));
        }
        ticks.push(format(maxVal, precision));
      }
      
      //format all values
      for(var i = 0, len = ticks.length; i < len; i++){
        ticks[i] = format(ticks[i], precision);
      }
      
      //reset color scale
      colorScale = d3.scale.linear().domain([ 0, ticksCount-1 ]).range([ startColor, endColor ]);
      
      var domainRg = [], rangeRg = [];
      for ( var i = 0, len = ticks.length - 1; i < len; i++) {
        domainRg.push([ ticks[i], ticks[i + 1] ]);
        rangeRg.push(colorScale(i));
      }

      var fontColorScale = d3.scale.ordinal().domain(domainRg).range(rangeRg);
      return fontColorScale;
    }
  };
  
  var formatRange = function(range, precision){
    for(var i = 0, len = range.length; i < len; i++){
      range[i] = format(range[i], precision);
    }
    return range;
  };
  
  var getAccFormat = function(value){
    var t = value.toString().split(".");
    return t.length > 1 ? t[1].length : 0;
  };
  
  var format = function(value, precision){
    return Math.round(Math.pow(10, precision) * value) / Math.pow(10, precision);
  };
  
  return MeasureBasedColoring;
});sap.riv.module(
{
  qname : 'sap.viz.modules.treemap',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(dispatch, ColorSeries, tooltipDataHandler, NumberUtils, 
               TypeUtils, NumberUtils, TextUtils, MeasureBasedColoring, langManager, 
               ObjectUtils, Objects, boundUtil,defaultSelUtil) {
    //treemap has no MND
    var treeMap = function(manifest, ctx) {

//--------------------------start of internal vars-----------------------------
        var randomSuffix = ObjectUtils.guid();              //diff all the id
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };      

        var m_selectionList = [];

        var m_width, m_height;
        var m_props =
        {
            "emptycolor":"#e0e0e0",
            'animation': {
                dataLoading : true,
                dataUpdating : true,
                resizing : true,
            },
            'colornumber': 5,
            'discretecolor' : false,
            'colorPalette': [],
            tooltip: {
                enabled: true,
            }
        };
        
        m_props = extendObj(m_props, manifest.props(null));

        var m_propsOutput = manifest.props(null);

        var m_styleTooltipFont = "'Open Sans', Arial, Helvetica, sans-serif";

        var m_data;

        var m_HLElement;

        var m_redrawAll = true;

        //it has 3 states: dataLoading, dataUpdating, resizing
        var m_drawState = "dataLoading";

        var m_className = "v-treemap";
        var m_classNameItem = "v-treemapitem";

        var m_padding;

        var m_xScale = d3.scale.ordinal();
        var m_yScale = d3.scale.ordinal();

        var m_dispatch = new dispatch('selectData', 'deselectData', 'initialized', 'showTooltip', 'hideTooltip', 'startToInit');

        var m_styleLineColor = "#ffffff";
        
        var m_dataDimensions;
        var m_dataRectWeight;
        var m_dataRectColor;

        var m_dataRects;

        var m_selection = null;

        var m_tooltipElement = null;
        var m_guidline = null;

        var m_effectManager = ctx.effectManager;
        var m_maxDimensionLevel = 6;

        var m_colorScale = null;
        var hasDefaultSelection = false;
        
        var m_defaultString = langManager.get('IDS_ISNOVALUE');

        var m_styleLabel = {};
        m_styleLabel.fontSize = "12px";
        m_styleLabel.fontWeight = "normal";
        m_styleLabel.fontFamily = "'Open Sans', Arial, Helvetica, sans-serif";
        m_styleLabel.fill = "#ffffff";

//--------------------------end of internal vars-------------------------------
//--------------------------start of internal functions------------------------
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var stringNoValueHandler = function(str)
        {
            if(str === null || str === undefined)
            {
                str = langManager.get('IDS_ISNOVALUE');
            }
            return str;
        }

        var generateTooltipData = function(dataIndex){

            var tooltipData = {
                body:[],
                footer:[]
            };
            var dataItem = m_dataRects[dataIndex];
            var weightValue = {
                    'name': stringNoValueHandler(dataItem.weight.col),
                    val:[{
                        value: NumberUtils.isNoValue(dataItem.weight.row.val)?m_defaultString:dataItem.weight.row.val
                    }]
            };
            
            tooltipData.body.push(weightValue);

            if(m_dataRectColor)
            {
                var colorValue = {
                        'name': stringNoValueHandler(dataItem.color.col),
                        val:[{
                            value: NumberUtils.isNoValue(dataItem.color.row.val)?m_defaultString:dataItem.color.row.val
                        }]
                };
                
                tooltipData.body.push(colorValue);
            }

            if(TypeUtils.isExist(m_dataDimensions)){
                for(var tval = m_dataDimensions.values, len = tval.length, i = len -1; i  >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndex%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
                        
            return tooltipData;
        };

        var HLCell = function(item)
        {
            if(!NumberUtils.isNoValue(item.datum().val))
            {
                m_HLElement.attr("visibility", "visible");

                var iLeft = item.datum().left+m_padding;
                var iRight = item.datum().left + item.datum().width-m_padding;
                var iTop = item.datum().top+m_padding;
                var iBottom = item.datum().top + item.datum().height-m_padding;

                m_HLElement.select(".HLLeft").attr("x1",iLeft).attr("y1",iTop).attr("x2",iLeft).attr("y2",iBottom);
                m_HLElement.select(".HLRight").attr("x1",iRight).attr("y1",iTop).attr("x2",iRight).attr("y2",iBottom);
                m_HLElement.select(".HLTop").attr("x1",iLeft).attr("y1",iTop).attr("x2",iRight).attr("y2",iTop);
                m_HLElement.select(".HLBottom").attr("x1",iLeft).attr("y1",iBottom).attr("x2",iRight).attr("y2",iBottom);
            }
        };

        var unHLCell = function(item)
        {
            m_HLElement.attr("visibility", "hidden");
        };

        var endAnimation = function(d, i)
        {   
            if(  (d && d.level === 0 && d.index === 0 ) 
               || (m_dataRects.length === 0) //no data
               || (d === undefined && i === undefined) //not in "each"
              )
            {
                //When the endAnimation is called, animation may not be end. 
                //(it looks like a bug of d3 or browsers) 
                //So the opacity is 0.9999 or something, and then it will be changed to 1
                //We have to use setTimeout here in case defaultselection changes opacity again. 
                //not use m_dispatch.initialized();            
                setTimeout(m_dispatch.initialized, 0);
            }
        };

        var drawTreeMapItems = function(treeLevelRoot, rectObjs, redrawAll, iLevel)
        {
            if(rectObjs.length <= 0)
            {
                return;
            }

            //rectObjs.length > 0
            var isLeafItem = (rectObjs[0].children.length === 0);
            
            //draw this level
            if(redrawAll)
            {
                treeLevelRoot = treeLevelRoot.append("g").attr("class", m_className + "level" + rectObjs[0].level);
            }
            else
            {
                treeLevelRoot = treeLevelRoot.select("." + m_className + "level" + rectObjs[0].level);
            }

            var rectObjArrayToDraw = [];
            for(var i = 0; i < rectObjs.length; i++)
            {
                if(rectObjs[i].level === iLevel)
                {
                    rectObjArrayToDraw.push(rectObjs[i]);
                }
            }

            var rootClassName = treeLevelRoot.attr("class");
            var items = treeLevelRoot.selectAll("." + rootClassName + " > ." + m_classNameItem);

            items = items.data(rectObjArrayToDraw,function(d){return d.index;});
                                 
            var toDrawItems = items.enter();
            var toDeleteItems = items.exit();

            var gItems;//items of this level

            //help functions
            var textLength = function(data)
            {
                var style = {};
                style['font-size'] = m_styleLabel.fontSize;
                style['font-weight'] = m_styleLabel.fontWeight;
                style['font-family'] = m_styleLabel.fontFamily;

                var textHeight = fastMeasure(data.label, style).height;
                var textLength = 0;
                if(textHeight > data.height)
                {
                    textLength = -1;//do not show text
                }
                else
                {
                    textLength = data.width - 6;
                }
                return textLength;
            }

            var xLocation = function(d)
            {
//                return d.left+d.width/2;
              return (isLeafItem)?(d.width/2):(d.left+d.width/2);
            }

            var yLocation = function(d)
            {
                var style = {};
                style['font-size'] = m_styleLabel.fontSize;
                style['font-weight'] = m_styleLabel.fontWeight;
                style['font-family'] = m_styleLabel.fontFamily;
                var labelHeight = fastMeasure(d.label, style).height;

                if(d.children.length === 0)
                {
//                    return d.top + d.height/2 + labelHeight/2 - labelHeight/10;
                  return (isLeafItem)?(d.height/2 + labelHeight/2 - labelHeight/10):(d.top + d.height/2 + labelHeight/2 - labelHeight/10);
                }
                else
                {
                    return d.top + labelHeight - labelHeight/10;
                }
            }

            var getText = function(d)
            {
                var styleStr = "font-size:" + m_styleLabel.fontSize;
                styleStr += "font-weight:" + m_styleLabel.fontWeight;
                styleStr += "font-family:" + m_styleLabel.fontFamily;

                var text = "";
                if(d.showLabel)
                {
                    text = TextUtils.ellipsis(d.label, this, textLength(d), styleStr);
                }
                return text;
            }

            var textLocation = function(d)
            {
                return "middle";
            }

            var textColor = function(d)
            {
                var tColor;
                if(d.children.length === 0)
                {
                    tColor = "white";
                }
                else
                {
                    if(d.level === (d.levelNum -1))//leaf
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 6)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 5)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 4)
                    {
                        tColor = "white";
                    }
                    else if((d.levelNum - d.level) === 3)
                    {
                        tColor = "#595959";
                    }
                    else//((d.levelNum - d.level) === 2)
                    {
                        tColor = "#464646";
                    }
                }

                return tColor;
            }

            var drawRect = function(rect)
            {
                var rectRes = rect.attr("x", function(d){return (isLeafItem)?(0):(d.left+m_padding);})
                .attr("y", function(d){return (isLeafItem)?(0):(d.top+m_padding);})
                .attr("width", function(d){return d.width-2*m_padding>0?d.width-2*m_padding:0;})
                .attr("height",function(d){return d.height-2*m_padding>0?d.height-2*m_padding:0;})
                .attr("fill",function(d){
                    var parameter = {
                        drawingEffect:'normal',
                        fillColor : d.color};
                    return m_effectManager.register(parameter);
                    })
                .attr("shape-rendering", "crispEdges");

                return rectRes;
            }

            var drawLabels = function(labels)
            {
              var labelsRes = null;
              
              if (isLeafItem) {
                labelsRes = labels.attr("x", xLocation)
                .attr("y", yLocation)
                .attr('class', 'v-treemapdatalabel')
                //ie does not support this property
                //.attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                .attr("text-anchor", textLocation) // text-align
                .attr("fill", textColor)
                .attr("font-size", m_styleLabel.fontSize)
                .attr("font-family", m_styleLabel.fontFamily)
                .attr('pointer-events', 'none');
               } else {
                 labelsRes = labels.attr("x", xLocation)
                 .attr("y", yLocation)       
                  //ie does not support this property
                  //.attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                 .attr("text-anchor", textLocation) // text-align
                 .attr("fill", textColor)
                 .attr("font-size", m_styleLabel.fontSize)
                 .attr("font-family", m_styleLabel.fontFamily)
                 .attr('pointer-events', 'none');
               } 
              
              labelsRes.text(getText);
              return labelsRes;
            };

            if(redrawAll)
            {
              var className = m_classNameItem;
              if(isLeafItem) {
                className += ' v-datashape';
              }
              
              gItems = toDrawItems.append("g").attr('class', className);
              if (isLeafItem) {
                gItems.attr('transform', function(d) {return 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';});
               }
                //add rect
                var rects = gItems.append("rect");
                drawRect(rects);

                if(isLeafItem)
                {
                    rects.attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                         .attr('class', 'v-datapoint');
                }

                //add labels
                var labels = gItems.append("text");
                drawLabels(labels);

            }
            else
            {
                gItems = items;

                //move rects and labels
                var rect = items.select("rect");
                var labels = items.select("text");

                var resizeTime = 0;
                if(m_drawState === "resizing" && m_props.animation.resizing)
                {
                    resizeTime = 500;
                }

                if(resizeTime > 0)
                {
                    rect = rect.transition();
                    labels = labels.transition();
                }
                
                if (isLeafItem) {
                    if(resizeTime > 0)
                    {
                        gItems = gItems.transition();

                        gItems = gItems.attr('transform', function(d) {
                            var transformStr = 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';
                            return transformStr;
                        });

                        gItems = gItems.delay(0).duration(resizeTime);
                    }
                    else
                    {
                      gItems.attr('transform', function(d) {
                        var transformStr = 'translate(' + (d.left+m_padding) + ',' + (d.top+m_padding) + ')';
                        return transformStr;
                        });
                    }
                }
                
                rect = drawRect(rect);
                labels = drawLabels(labels);
                        
                if(resizeTime > 0)
                {
                    rect.delay(0).duration(resizeTime).each('end',endAnimation);
                    labels.delay(0).duration(resizeTime);
                }
                else
                {
                    endAnimation();
                }
            }
            
            //draw children recursively
            var eachSubFun = function(thisObj, d, i)
            {
                var thisItem = d3.select(thisObj);
                var da = thisItem.datum().children;

                drawTreeMapItems(thisItem, thisItem.datum().children, redrawAll, iLevel + 1);
            }

            gItems.each(function(d, i)
                {
                    eachSubFun(this, d, i);
                }
            );

            //animation
            gItems = treeLevelRoot.selectAll("." + m_classNameItem);
            if(redrawAll)
            {
                var fadeInTime = 0;
                if(m_drawState === "dataLoading" && m_props.animation.dataLoading)
                {
                    fadeInTime = 1000;
                }
                else if(m_drawState === "dataUpdating" && m_props.animation.dataUpdating)
                {
                    fadeInTime = 500;
                }
                
                if(fadeInTime > 0)
                {
                    gItems.attr('opacity', 0);
                    gItems.transition()
                        .delay(0)
                        .duration(fadeInTime).attr('opacity', 1).each('end',endAnimation);
                }
                else
                {
                    gItems.attr('opacity', 1);
                    endAnimation();
                }
            }
            else
            {
                endAnimation();
            }

            return gItems;
        };

        var drawTreeMap = function(selection, rectObjs)
        {
            m_drawState = "resizing";
            if(m_redrawAll)
            {
                if(selection.selectAll("*").empty())
                {
                    m_drawState = "dataLoading";
                }
                else
                {
                    m_drawState = "dataUpdating";
                }      
                selection.selectAll("*").remove();
            }

            boundUtil.drawBound(selection, m_width, m_height);

            var treeLevelRoot = selection;
            
            var datashapesgroup = selection.selectAll('g.v-datashapesgroup');
            if(!TypeUtils.isExist(datashapesgroup[0][0])){
              datashapesgroup = selection.append('g').attr('class', 'v-datashapesgroup');
            }
            drawTreeMapItems(datashapesgroup, rectObjs, m_redrawAll, 0);
        
            //the HLCell Rectange
            if(m_redrawAll)
            {
                m_HLElement = selection.append('g').attr('class', 'v-element').attr("visibility", "hidden");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
            }
            else
            {
                if(m_HLElement)
                {
                    m_HLElement.attr("visibility", "hidden");
                }
            }

            m_redrawAll = false;
        }

        var buildColorScale = function()
        {
            //return a color scale like
            //var domainRg = [ [10,40], [40, 100] ];
            //var rangeRg = ['#ff0000', '#00ff00' ];
            //d3.scale.ordinal().domain(domainRg).range(rangeRg);
            if(m_dataRectColor)
            {
                var colorObjArray = [];

                var hData = m_dataRectColor.values[0].rows[0];
                //add the data to heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < hData.length; i++)
                {
                    colorObjArray.push(hData[i]);
                }

                //count the max and min value of heatObjArray[i].val
                var maxVal = -Number.MAX_VALUE;
                var minVal = Number.MAX_VALUE;

                for(var iObj = 0; iObj < colorObjArray.length; iObj++)
                {
                    if(!NumberUtils.isNoValue(colorObjArray[iObj].val))
                    {
                        if(maxVal < colorObjArray[iObj].val)
                        {
                            maxVal = colorObjArray[iObj].val;
                        }

                        if(minVal > colorObjArray[iObj].val)
                        {
                            minVal = colorObjArray[iObj].val;
                        }
                    }
                }
                //has "novalue" or not
                var hasNullValue = false;
                for(var i = 0; i < colorObjArray.length; i++)
                {
                    if( NumberUtils.isNoValue(colorObjArray[i].val))
                    {
                        hasNullValue = true;
                    }
                }
            }
            
            var numS = m_props.colornumber;

            var fontColorScale;
            if(minVal === Number.MAX_VALUE && maxVal === -Number.MAX_VALUE
                || (!m_dataRectColor)    
            ){
                //do not show the scale if there is no color measure, or there are just "No values"
                fontColorScale = undefined;
            } else {
                var fontColorScale = MeasureBasedColoring.getScale(minVal, maxVal, numS, m_props.startColor, m_props.endColor);
                if(hasNullValue){
                    var domains = fontColorScale.domain();
                    var ranges = fontColorScale.range();
                    domains.push([]);
                    ranges.push(m_props.emptycolor);
                }
            }

            return fontColorScale;
        }

//----------------layout function: squarifiedTreeMapLayout-----------------------------------------------
        //please refer to http://www.win.tue.nl/~vanwijk/stm.pdf
        var squarifiedTreeMapLayout = function(rectObjs)
        {
            var squarifiedLayout = function (rectObjs, baseRect, isCurrentLevelShowLabel)
            {
                //the function will set 
                //item.left
                //item.top
                //item.height
                //item.width
                //item.labelHeight
                //item.labelWidth
                //item.showLabel
                //item.needMoreHeightToShowLabel
                //for all rectObjs items, and may change items order
                var allWeight = 0;
                for(var i = 0; i < rectObjs.length; i++)
                {
                    allWeight += rectObjs[i].val;
                }

                //to make the sort stable, we must use a stable sort. But Javascript sort may not stable in 
                //Chrome. So using bubble sort here (do not use rectObjs.sort)
                //sort it!
                var weightOrder = function(objA, objB)
                {
                    var compareObjs = 0; 
                    if(objB.val !== objA.val)
                    {
                        compareObjs = objA.val - objB.val;
                    }
                    return compareObjs;
                }
                var tmpObj;
                for (var time = 0; time < rectObjs.length - 1; time++)
                {
                    for (var i = rectObjs.length - 1; i> time; i--)
                    {
                        if (weightOrder(rectObjs[i], rectObjs[i - 1]) > 0)
                        {
                            tmpObj = rectObjs[i - 1];
                            rectObjs[i - 1] = rectObjs[i];
                            rectObjs[i] = tmpObj;
                        }
                    }
                }

                //the current row rectangle
                var currentRowRect = {
                        left:0,
                        top:0,
                        width:0,
                        height:0,
                        weight:0,
                        items:[],//indexs of items
                        worstRadio:0, 
                    };

                //currentRow rect + space rect
                var currentLiveRect = {
                        left:0,
                        top:0,
                        width:0,
                        height:0,
                        weight:0,
                        vertical:false,
                    };
                
                //layout this level
                for(var i = 0; i < rectObjs.length; i++)
                {
                    squarify(rectObjs, i, allWeight, currentRowRect, currentLiveRect, baseRect);
                }

                //Now some additional work.
                for(var itemIndex = 0; itemIndex < rectObjs.length; itemIndex++)
                {
                    //make sure no "NaN"
                    if(!rectObjs[itemIndex].left)
                    {
                        rectObjs[itemIndex].left = 0;
                    }

                    if(!rectObjs[itemIndex].top)
                    {
                        rectObjs[itemIndex].top = 0;
                    }

                    if(!rectObjs[itemIndex].width || rectObjs[itemIndex].width < 0)
                    {
                        rectObjs[itemIndex].width = 0;
                    }

                    if(!rectObjs[itemIndex].height || rectObjs[itemIndex].height < 0)
                    {
                        rectObjs[itemIndex].height = 0;
                    }

                    //draw label or not
                    var miniLabel = "";
                    if(rectObjs[itemIndex].label && rectObjs[itemIndex].label.length && rectObjs[itemIndex].label.length > 0)
                    {
                        var strBegin = rectObjs[itemIndex].label[0];
                        miniLabel = strBegin.concat("...");
                    }

                    var style = {};
                    style['font-size'] = m_styleLabel.fontSize;
                    style['font-weight'] = m_styleLabel.fontWeight;
                    style['font-family'] = m_styleLabel.fontFamily;

                    rectObjs[itemIndex].labelHeight = fastMeasure(miniLabel, style).height;
                    rectObjs[itemIndex].labelWidth = fastMeasure(miniLabel, style).width;

                    rectObjs[itemIndex].needMoreHeightToShowLabel = false;

                    if((rectObjs[itemIndex].labelHeight < rectObjs[itemIndex].height)
                        && (rectObjs[itemIndex].labelWidth < rectObjs[itemIndex].width))
                    {
                        rectObjs[itemIndex].showLabel = true;
                    }
                    else
                    {
                        rectObjs[itemIndex].showLabel = false;
                        if(rectObjs[itemIndex].labelHeight >= rectObjs[itemIndex].height && rectObjs[itemIndex].val > 0)
                        {
                            rectObjs[itemIndex].needMoreHeightToShowLabel = true;
                        }
                    }
                }
                
                var isLeafNodeNeedMoreHeight = true;
                //check each leaf
                for(var itemIndex = 0; itemIndex < rectObjs.length; itemIndex++)
                {
                    if(rectObjs[itemIndex].level === (rectObjs[itemIndex].levelNum - 1))
                    {
                        if(!rectObjs[itemIndex].needMoreHeightToShowLabel)
                        {
                            isLeafNodeNeedMoreHeight = false;
                            break;
                        }
                    }
                    else
                    {
                        isLeafNodeNeedMoreHeight = false;
                    }
                }

                var hideLabelFun = function(i)
                {
                    if(rectObjs[i].level !== (rectObjs[i].levelNum - 1))
                    {
                        rectObjs[i].showLabel = false;
                    }

                    //adjust base rect for children
                    baseRectForChild.top = rectObjs[i].top + m_padding*2;
                    baseRectForChild.left = rectObjs[i].left + m_padding*2;
                    baseRectForChild.width = rectObjs[i].width - m_padding*2 - m_padding;
                    baseRectForChild.height = rectObjs[i].height - m_padding*2 - m_padding;
                }

                if(!isLeafNodeNeedMoreHeight)
                {
                    for(var i = 0; i < rectObjs.length; i++)
                    {
                        if(rectObjs[i].children.length > 0)
                        {
                            var showLabelForChildren = true;
                            if(!isCurrentLevelShowLabel)
                            {
                                showLabelForChildren = false;
                            }

                            var labelHeight = rectObjs[i].labelHeight;

                            var baseRectForChild = {};
                            baseRectForChild.top = rectObjs[i].top + m_padding*2 + labelHeight;
                            baseRectForChild.left = rectObjs[i].left + m_padding*2;
                            baseRectForChild.width = rectObjs[i].width - m_padding*2 - m_padding;
                            baseRectForChild.height = rectObjs[i].height - m_padding*2 - m_padding - labelHeight;

                            if(!showLabelForChildren)
                            {
                                hideLabelFun(i);
                            }

                            isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs[i].children, baseRectForChild, showLabelForChildren);
                            if((isLeafNodeNeedMoreHeight || !rectObjs[i].showLabel) && showLabelForChildren)//relayout
                            {
                                hideLabelFun(i);
                                isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs[i].children, baseRectForChild, false);
                            }
                        }
                    }
                }
                
                return isLeafNodeNeedMoreHeight;
            }

            var rectAspectRatio = function(rect)
            {
                //radio >= 1
                var radio;
                if(rect.height > rect.width)
                {
                    radio = rect.height/rect.width;
                }
                else
                {
                    radio = rect.width/rect.height;
                }

                radio = Math.floor(radio*1000);
                return radio;
            }

            var worstAspectRatio = function(rectObjs, newItemWeight, isInCurrentRow, currentRowRect, currentLiveRect)
            {
                //return the worst AspectRatio in the (changed) currentRow and the new item. 
                var worstRadio = 0;

                var newItemRect = {};
                if(isInCurrentRow)
                {
                    //if currentLiveRect is vertical, 
                    //it means items in currentRow is horizontal.
                    if(currentLiveRect.vertical)
                    {
                        newItemRect.width = currentLiveRect.width * (newItemWeight / (currentRowRect.weight + newItemWeight));
                        newItemRect.height = currentLiveRect.height * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                    }
                    else
                    {
                        newItemRect.height = currentLiveRect.height * (newItemWeight / (currentRowRect.weight + newItemWeight));
                        newItemRect.width = currentLiveRect.width * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                    }

                    worstRadio = rectAspectRatio(newItemRect);

                    //adjust items in currentRowRect, count the worstRadio
                    for(var i = 0; i < currentRowRect.items.length; i++)
                    {
                        var objIndex = currentRowRect.items[i];
                        var currentItemRect = {};
                        if(currentLiveRect.vertical)
                        {
                            currentItemRect.width = currentRowRect.width * (rectObjs[objIndex].val / (currentRowRect.weight + newItemWeight));
                            currentItemRect.height = currentLiveRect.height * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                        }
                        else
                        {
                            currentItemRect.height = currentRowRect.height * (rectObjs[objIndex].val / (currentRowRect.weight + newItemWeight));
                            currentItemRect.width = currentLiveRect.width * ((currentRowRect.weight + newItemWeight) / currentLiveRect.weight);
                        }

                        //current item radio
                        var currentItemRadio = rectAspectRatio(currentItemRect);

                        //update the worst
                        if(worstRadio < currentItemRadio)
                        {
                            worstRadio = currentItemRadio;
                        }
                    }
                }
                else
                {
                    worstRadio = currentRowRect.worstRadio;
                }

                return worstRadio;
            }

            var getCurrentSpaceRect = function(currentRowRect, currentLiveRect)
            {
                var currentSpaceRect = {};
                currentSpaceRect.weight = currentLiveRect.weight - currentRowRect.weight;

                if(currentLiveRect.width === currentRowRect.width)
                {
                    currentSpaceRect.left = currentLiveRect.left;
                    currentSpaceRect.top = currentRowRect.top + currentRowRect.height;
                    currentSpaceRect.width = currentLiveRect.width;
                    currentSpaceRect.height = currentLiveRect.height - currentRowRect.height;
                }
                else
                {
                    currentSpaceRect.left = currentRowRect.left + currentRowRect.width;
                    currentSpaceRect.top = currentLiveRect.top;
                    currentSpaceRect.width = currentLiveRect.width - currentRowRect.width;
                    currentSpaceRect.height = currentLiveRect.height;
                }

                return currentSpaceRect;
            }

            var squarify = function (rectObjs, itemIndex, allWeight, currentRowRect, currentLiveRect, baseRect)
            {
                //itemIndex : const
                //allWeight : const
                //currentRowRect : be changed
                //currentLiveRect : be changed
                if(itemIndex === 0)
                {
                    rectObjs[itemIndex].left = baseRect.left;
                    rectObjs[itemIndex].top = baseRect.top;

                    if(baseRect.width > baseRect.height)
                    {
                        //layout the item
                        rectObjs[itemIndex].height = baseRect.height;
                        rectObjs[itemIndex].width = baseRect.width * (rectObjs[itemIndex].val / allWeight);
                        currentLiveRect.vertical = false;
                    }
                    else
                    {
                        //layout the item
                        rectObjs[itemIndex].width = baseRect.width;
                        rectObjs[itemIndex].height = baseRect.height * (rectObjs[itemIndex].val / allWeight);
                        currentLiveRect.vertical = true;
                    }
                    
                    //adjust currentRowRect
                    currentRowRect.left = baseRect.left;
                    currentRowRect.top = baseRect.top;
                    currentRowRect.width = rectObjs[itemIndex].width;
                    currentRowRect.height = rectObjs[itemIndex].height;
                    currentRowRect.weight = rectObjs[itemIndex].val;
                    currentRowRect.items.push(itemIndex);
                    currentRowRect.worstRadio = rectAspectRatio(currentRowRect);

                    //adjust currentLiveRect
                    currentLiveRect.left = baseRect.left;
                    currentLiveRect.top = baseRect.top;
                    currentLiveRect.width = baseRect.width;
                    currentLiveRect.height = baseRect.height;
                    currentLiveRect.weight = allWeight;
                }
                else if(itemIndex === (rectObjs.length -1))
                {
                    //just put it into the space
                    var currentSpaceRect = getCurrentSpaceRect(currentRowRect, currentLiveRect);
                    rectObjs[itemIndex].left = currentSpaceRect.left;
                    rectObjs[itemIndex].top = currentSpaceRect.top;
                    rectObjs[itemIndex].width = currentSpaceRect.width;
                    rectObjs[itemIndex].height = currentSpaceRect.height;
                }
                else
                {                
                    var inRowWorstRadio = (worstAspectRatio(rectObjs, rectObjs[itemIndex].val, true, currentRowRect, currentLiveRect));
                    var newRowWorstRadio = (worstAspectRatio(rectObjs, rectObjs[itemIndex].val, false, currentRowRect, currentLiveRect));

                    if(inRowWorstRadio < newRowWorstRadio)
                    {
                        //update the worstRadio
                        currentRowRect.worstRadio = inRowWorstRadio;

                        //adjust currentRowRect
                        currentRowRect.items.push(itemIndex);
                        currentRowRect.weight += rectObjs[itemIndex].val;

                        if(currentLiveRect.vertical)
                        {
                            currentRowRect.height = currentLiveRect.height * (currentRowRect.weight / currentLiveRect.weight);
                        }
                        else
                        {
                            currentRowRect.width = currentLiveRect.width * (currentRowRect.weight / currentLiveRect.weight);
                        }

                        //adjust items in currentRowRect
                        for(var i = 0; i < currentRowRect.items.length; i++)
                        {
                            var objIndex = currentRowRect.items[i];
                            if(currentLiveRect.vertical)
                            {
                                rectObjs[objIndex].width = currentRowRect.width * (rectObjs[objIndex].val / currentRowRect.weight);
                                rectObjs[objIndex].height = currentLiveRect.height * (currentRowRect.weight / currentLiveRect.weight);

                                rectObjs[objIndex].top = currentRowRect.top;
                                
                                if(i === 0)//for the first item in the row
                                {
                                    rectObjs[objIndex].left = currentRowRect.left;
                                }
                                else
                                {
                                    rectObjs[objIndex].left = rectObjs[objIndex-1].left + rectObjs[objIndex-1].width;
                                }
                            }
                            else
                            {
                                rectObjs[objIndex].height = currentRowRect.height * (rectObjs[objIndex].val / currentRowRect.weight);
                                rectObjs[objIndex].width = currentLiveRect.width * (currentRowRect.weight / currentLiveRect.weight);

                                rectObjs[objIndex].left = currentRowRect.left;
                                
                                if(i === 0)//for the first item in the row
                                {
                                    rectObjs[objIndex].top = currentRowRect.top;
                                }
                                else
                                {
                                    rectObjs[objIndex].top = rectObjs[objIndex-1].top + rectObjs[objIndex-1].height;
                                }
                            }
                        }

                        //do not need to adjust currentLiveRect.
                    }
                    else
                    {
                        //make a new currentLiveRect
                        var newCurrentLiveRect = getCurrentSpaceRect(currentRowRect, currentLiveRect);
                        
                        currentLiveRect.left = newCurrentLiveRect.left;
                        currentLiveRect.top = newCurrentLiveRect.top;
                        currentLiveRect.width = newCurrentLiveRect.width;
                        currentLiveRect.height = newCurrentLiveRect.height;
                        currentLiveRect.weight = newCurrentLiveRect.weight;

                        if(currentLiveRect.width > currentLiveRect.height)
                        {
                            currentLiveRect.vertical = false;
                        }
                        else
                        {
                            currentLiveRect.vertical = true;
                        }

                        //make a new currentRowRect
                        currentRowRect.left = currentLiveRect.left;
                        currentRowRect.top = currentLiveRect.top;
                        currentRowRect.weight = rectObjs[itemIndex].val;
                        if(currentLiveRect.vertical) 
                        {
                            currentRowRect.width = currentLiveRect.width;
                            currentRowRect.height = currentLiveRect.height * (rectObjs[itemIndex].val / currentLiveRect.weight);
                        }
                        else
                        {
                            currentRowRect.height = currentLiveRect.height;
                            currentRowRect.width = currentLiveRect.width * (rectObjs[itemIndex].val / currentLiveRect.weight);
                        }

                        currentRowRect.worstRadio = rectAspectRatio(currentRowRect);        
                        currentRowRect.items = [];
                        currentRowRect.items.push(itemIndex);

                        //layout the item
                        rectObjs[itemIndex].width = currentRowRect.width;
                        rectObjs[itemIndex].height = currentRowRect.height;
                        rectObjs[itemIndex].top = currentRowRect.top;
                        rectObjs[itemIndex].left = currentRowRect.left;
                    }
                }
            }
            //the entry of squarifiedTreeMapLayout
            var baseRect = {};
            baseRect.top = 0;
            baseRect.left = 0;
            baseRect.width = m_width;
            baseRect.height = m_height;
            
            var isLeafNodeNeedMoreHeight = squarifiedLayout(rectObjs, baseRect, true);
            if(isLeafNodeNeedMoreHeight)//relayout
            {
                squarifiedLayout(rectObjs, baseRect, false);
            }
        }

        var mergeWeightColorInfo = function(weightInfo, colorInfo)
        {            
            var infoRe = {};
            Objects.extend(true, infoRe, weightInfo);
            if(colorInfo && colorInfo.defaultSelection)
            {
                if(colorInfo.defaultSelection.isSelected)
                {
                    var tempSelObj = {};
                    Objects.extend(true, tempSelObj, colorInfo.defaultSelection);
                    infoRe.defaultSelection = tempSelObj;
                }
            }
            return infoRe;
        };

//----------------end of layout function: squarifiedTreeMapLayout-----------------------------------------------
        var buildTreeData = function(m_dataRects, iLevel, levelNum, startIndex, endIndex)
        {
            if(iLevel >= levelNum)
            {
                return [];
            }

            var rectObjArray = [];

            //each item:
            //color:#333333
            //colorValue:2
            //ctx:(color m ctx)
            //label:
            //val:(the weight) (if it is a negative value, we set it to 0)
            //children: a rectObjArray or []
            //level: leaf is 0
            //levelNum
            //index (id)
            var lastDimensionName = undefined;
            
            var childrenStartIndex = startIndex;
            var childrenEndIndex = childrenStartIndex + 1;

            for(var i = startIndex; i < endIndex; i++)
            {
                var rectObjItem = {};
                var currentDimensionName = m_dataRects[i].dimensions[iLevel].row.val;
                if(currentDimensionName !== lastDimensionName || 
                    iLevel === levelNum - 1) //for leaf items, we do not merge
                {
                    //set rectObjItem.color and rectObjItem.colorValue
                    var color = setItemColor(i, iLevel, levelNum, rectObjItem);

                    rectObjItem.label = m_dataRects[i].dimensions[iLevel].row.val;
                    rectObjItem.level = iLevel;
                    rectObjItem.levelNum = levelNum;
                    rectObjItem.isTreeMap = true;
                    
                    if(iLevel === levelNum - 1)//leaf node
                    {
                        var colorInfo = null;
                        if(m_dataRects[i].color && m_dataRects[i].color.row)
                        {
                            colorInfo = m_dataRects[i].color.row.info;
                        }
                        rectObjItem.ctx = m_dataRects[i].weight.row.ctx;//legned is for weight
                        rectObjItem.info = mergeWeightColorInfo(m_dataRects[i].weight.row.info, 
                                           colorInfo);
                    }
                    else
                    {
                        rectObjItem.ctx = null;
                    }
                    rectObjItem.index = i;
                    
                    if(m_dataRects[i].weight.row.val >= 0)
                    {
                        rectObjItem.val = m_dataRects[i].weight.row.val;
                    }
                    else
                    {
                        //https://tipjira.pgdev.sap.corp/browse/BITVIZA-137 "Treat negative value as zero."
                        rectObjItem.val = 0;
                    }

                    //we should update the children of previous item
                    if(rectObjArray.length >0)
                    {
                        rectObjArray[rectObjArray.length -1].children = buildTreeData(m_dataRects,
                                       (iLevel + 1), levelNum, childrenStartIndex, childrenEndIndex);

                        childrenStartIndex = i;
                        childrenEndIndex = childrenStartIndex + 1;
                    }

                    //add new item and update childrenIndexs
                    rectObjArray.push(rectObjItem);
                }
                else
                {
                    //update the last item
                    if(m_dataRects[i].weight.row.val >= 0)
                    {
                        rectObjArray[rectObjArray.length -1].val += m_dataRects[i].weight.row.val;
                    }
                    
                    childrenEndIndex++;
                }
                lastDimensionName = currentDimensionName;

                if(i === endIndex - 1)
                {
                    //we should update the children of previous item
                    if(rectObjArray.length >0)
                    {
                        rectObjArray[rectObjArray.length -1].children = buildTreeData(m_dataRects,
                                       (iLevel + 1), levelNum, childrenStartIndex, childrenEndIndex);
                    }
                }
            }

            return rectObjArray;
        }

        var setItemColor = function(index, iLevel, levelNum, rectObjItem)
        {
            if(iLevel !== (levelNum - 1))//not leaf
            {
                //set rectObjItem.color
                var level = (levelNum -1 - iLevel);
                if(level === 1)
                {
                    rectObjItem.color = "#f9f9f9";
                }
                else if(level === 2)
                {
                    rectObjItem.color = "#e3e3e3";
                }
                else if(level === 3)
                {
                    rectObjItem.color = "#bfbfbf";
                }
                else if(level === 4)
                {
                    rectObjItem.color = "#989898";
                }
                else if(level === 5)
                {
                    rectObjItem.color = "#717171";
                }
                //set rectObjItem.colorValue
                rectObjItem.colorValue = Number.MAX_VALUE;
            }
            else
            {
                if(m_dataRects[index].color)
                {
                    //set colorValue
                    rectObjItem.colorValue = m_dataRects[index].color.row.val;

                    //set rectObjItem.color. m_colorScale is set
                    if(m_colorScale)
                    {
                        var domainArray = m_colorScale.domain();

                        if(NumberUtils.isNoValue(rectObjItem.colorValue))
                        {
                            rectObjItem.color = m_props.emptycolor;
                        }
                        else
                        {
                            var domainValue;
                            for( var j = 0; j<domainArray.length; j++)
                            {
                                var tdv = domainArray[j];
                                if ((j == domainArray.length-1) || (domainArray[j+1].length == 0)) {
                                    domainValue = tdv;
                                    break;
                                }
                                if ((rectObjItem.colorValue >= tdv[0]) && (rectObjItem.colorValue < tdv[1])) {
                                    domainValue = tdv;
                                    break;
                                }
                            }
                            rectObjItem.color = m_colorScale(domainValue);
                        }
                    }
                    else
                    {
                        rectObjItem.color = m_props.emptycolor;
                    }
                }
                else
                {
                    rectObjItem.colorValue = Number.MAX_VALUE;

                    //set rectObjItem.color
                    var colorArray = ColorSeries.sap32().range();
                    rectObjItem.color = colorArray[0];
                }
            }
        }

//--------------------------end of internal functions--------------------------
//--------------------------external functions---------------------------------

        function chart(selection) {
            m_selection = selection;
            m_dispatch.startToInit();
            if(m_props.border && m_props.border.visible)
            {
                m_padding = 1;
            }
            else
            {
                m_padding = 0;
            }
            //build color scale
            m_colorScale = buildColorScale();

            //prepare tree data, and draw the treeMap level by level
            var levelNum = m_dataRects[0].dimensions.length;

            var rectObjArray = buildTreeData(m_dataRects, 0, levelNum, 0, m_dataRects.length);

            //existing data is read-only in layout and draw functions
            //layout it recursively
            squarifiedTreeMapLayout(rectObjArray);

            //draw the treemap recursively (update it, or redraw it)
            drawTreeMap(selection, rectObjArray);

            return chart;
        };

        chart.dataLabel = function(_){
          
        };
        
        chart.afterUIComponentAppear = function(){
          m_dispatch.initialized(); 
        };
        
        
        chart.mouseover = function(elem){
            var item = d3.select(elem);
            var clickedItemID = item.attr('id');
            if(clickedItemID && m_props.tooltip.enabled)
            {
              var tmpLength = clickedItemID.toString().length - randomSuffix.toString().length - 2;
                var dataIndex = clickedItemID.toString().substr(2 , tmpLength);
                
                var transform = m_selection.node().getTransformToElement(m_selection.node().ownerSVGElement);
                var svgBoundingBox = m_selection.node().ownerSVGElement.getBoundingClientRect();
                var rectBoundingBox =  elem.getBoundingClientRect();
                //showTooltip(dataIndex);
                var tooltipData = generateTooltipData(dataIndex);
                tooltipData.point = {
                        x : rectBoundingBox.left - svgBoundingBox.left + rectBoundingBox.width/2,
                        y : (rectBoundingBox.height > 16) ? rectBoundingBox.top - svgBoundingBox.top + 8 : rectBoundingBox.top - svgBoundingBox.top + rectBoundingBox.height/2
                };
                tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : m_width,
                        height : m_height
                };
                m_dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
                HLCell(item);
            }

        };
        
        chart.mouseout = function(item){
            if(m_props.tooltip.enabled)
            {
                m_dispatch.hideTooltip();
            }
            unHLCell(item);
        };

        /*
         * Add mouse interaction functions.
         */
        chart.parent = function(){
            return m_selection;
        };

        chart.highlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 1);
                }
            }else{
                elems.setAttribute('opacity', 1);
            }
            
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, true, elems);
            }
        };
        
        chart.unhighlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 0.4);
                }
            }else{
                elems.setAttribute('opacity', 0.4);
            }
            
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, false, elems);
            }
        };
        
        chart.clear = function(gray){
          if( gray == null || gray == false){
            var rects = m_selection.selectAll('.v-datapoint');
                rects.attr('opacity', 1);
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, false, rects);
            }
          }else{
            m_selection.selectAll('.v-datapoint').attr('opacity', 0.4);
          }
      };
        
        chart.width = function(_width){
            if (!arguments.length){
              return m_width;
            }
            m_width = _width;
            return chart;
        };

        chart.height = function(_height){
            if (!arguments.length){
              return m_height;
            }
            m_height = _height;
            return chart;       
        };

        chart.data = function(value){
            if (!arguments.length){
                return m_data;
            }

            m_data = value;
            m_redrawAll = true;
            
            m_dataDimensions = m_data.getAnalysisAxisDataByIdx(0);
            m_dataRectWeight = m_data.getMeasureValuesGroupDataByIdx(0);
            m_dataRectColor = m_data.getMeasureValuesGroupDataByIdx(1);
            
            if(m_dataRectWeight.values[0].rows[0][0].info && m_dataRectWeight.values[0].rows[0][0].info.defaultSelection){
              hasDefaultSelection = true;
            }else{
              hasDefaultSelection = false;
            }
            
            var dataDimensions = m_data.getAnalysisAxisDataByIdx(0);
            var dataRectWeight = m_data.getMeasureValuesGroupDataByIdx(0);
            var dataRectColor = m_data.getMeasureValuesGroupDataByIdx(1);

            //make the rect array which has all datas(not a tree)
            m_dataRects = [];

            //add weight
            var vArray = dataRectWeight.values[0].rows[0];
            for(var i = 0; i < vArray.length; i++)
            {
                var dataRectItem = {};

                var weightObj = {};
                weightObj.col = dataRectWeight.values[0].col;
                weightObj.row = vArray[i];

                dataRectItem.weight = weightObj;

                m_dataRects.push(dataRectItem);
            }

            //add color
            if(dataRectColor)
            {
                var vArray = dataRectColor.values[0].rows[0];
                for(var i = 0; i < m_dataRects.length; i++)
                {
                    var dataRectItem = m_dataRects[i];

                    var colorObj = {};
                    colorObj.col = dataRectColor.values[0].col;
                    colorObj.row = vArray[i];

                    dataRectItem.color = colorObj;
                }
            }

            //add dimensions (6 levels at most)
            var vArray = dataDimensions.values;
            for(var i = 0; i < m_dataRects.length; i++)
            {
                var dataRectItem = m_dataRects[i];

                var dimensionArray = [];
                var levels = vArray.length;
                if(levels > m_maxDimensionLevel)
                {
                    levels = m_maxDimensionLevel;
                }
                for(var j = 0; j < levels; j++)
                {
                    var dimensionItem = {};
                    dimensionItem.col = dataDimensions.values[j].col;
                    dimensionItem.row = dataDimensions.values[j].rows[i];

                    dimensionArray.push(dimensionItem);
                }

                dataRectItem.dimensions = dimensionArray;
            }
            
            return chart;
        };

        chart.properties = function(props){
            if (!arguments.length){
                return m_propsOutput;
            }           
            Objects.extend(true, m_props, props);
            Objects.extend(true, m_propsOutput, props);
            m_redrawAll = true;
            return chart;           
        };

        /**
         * interfaces for MBC legend selection
         * @param {Object} selectedData 
         * <pre>
         * {
         * ctx: {
         *   ranges: {
         *    endValue:100
         *    isLeftOpen:false
         *    isRightOpen:true
         *    startValue:84
         *   }
         * },
         * val: 84   
         * }
         * @returns {Array} d3 selections in the given range  
         */
        chart.getDatapointsByRange = function(selectedData){
          var datapoints = d3.selectAll('.v-datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
          for(var i = 0, len = datapoints.length; i < len; i++){
            data = datapoints[i].__data__.colorValue;
            if(NumberUtils.isNoValue(selectedData.val)){
              if(NumberUtils.isNoValue(data)){
                ctxDatapoints.push(datapoints[i]);
              }
            }else{
              if(data < ranges.endValue && data > ranges.startValue){
                ctxDatapoints.push(datapoints[i]);
              }else{
                if(!ranges.isLeftOpen && data === ranges.startValue) {
                  ctxDatapoints.push(datapoints[i]);
                }else if(!ranges.isRightOpen && data === ranges.endValue){
                  ctxDatapoints.push(datapoints[i]);
                }
              }
            }
          }
          return ctxDatapoints;
        };
         
        /**
         * for MBC legend
         */
        chart.mbcLegendInfo = function(){
            var hColor = buildColorScale();
            var title = "";
            if(m_dataRectColor)
            {
                title = m_dataRectColor.values[0].col;
            }
            return {
                'colorScale' : hColor,
                'title': title,
            };
        };

        /**
         * required by the layout
         */
        chart.getPreferredSize = function(){  
          
        };

        /**
         * get/set your event dispatch if you support event
         */
        chart.dispatch = function(_){
            if(!arguments.length)
                return m_dispatch;
            m_dispatch = _;
            return chart;
        };
        return chart;
    };

    return treeMap;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.TreeMap',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.treemap',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.TreeMap',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn)
{
    var module =
    {
      'id' : 'sap.viz.modules.treemap',
      'type' : Constants.Module.Type.Chart,
      'name' : 'treemap',
      'properties' : {
        'border' : {
          'name' : 'border',
          'description' : 'Settings for border.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
                'name' : 'visible',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set visibility of zone edge.'
            },
          },
        },

        'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
        },
        'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set treeMap startColor.'
        },
      
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set treeMap endColor.'
        },

        'tooltip' : {
          'name' : 'tooltip',
          'description' : 'Settings for tooltip.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
              'visible': {
                    'name' : 'enabled',
                    'supportedValueType' : 'Boolean',
                    'defaultValue' : true,
                    'description' : 'Set enabled/disabled tooltip.'
              },
          },
          'isExported': false
        }
      },
      'events' :
      {
        'initialized': Constants.Module.Event.Initialized.desc,
        'selectData' : Constants.Module.Event.SelectData.desc,
        'deselectData' : Constants.Module.Event.DeSelectData.desc,
        'showTooltip' : Constants.Module.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Module.Event.TooltipHide.desc
      },
      'feeds' :{
          id:"treeMap"
      },
      'css' : {},
      'configure' : null,
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.TreeMapChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TreeMap',
  version : '4.0.2'
}
],
function Setup ( Manifest, Constants ) {
  var chart = {
    id : 'viz/treemap',
    name : 'IDS_TREEMAPCHART',
    base : 'riv/base/single',
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.RELAYOUT }
          }
        },
        modules : {
          legends : {
            modules : {
              legend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
                  properties : { type : 'MeasureBasedColoringLegend' },
                  propertiesOverride : {
                    isHierarchical : { isExported : false },
                    formatString: { isExported: true }
                  }
                }
              }
            }
          },
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : {
                chartType : 'treemap',
                orientation : 'bottom'
              }
            }
          },
          
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
              }
            }
          },
    
          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    visible : false,
                    orientation : 'vertical',
                    position : 'inside',
                    automaticInOutside : false,
                    showZero : true,
                    isStackMode : false,
                    isPercentMode : false,
                    outsideVisible : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
              plot : {
                id : 'sap.viz.modules.treemap',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ 
      {
        targetModule : 'root.legends.legend',
        target : 'mbcLegendInfo',
        sourceModule : 'root.main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
      }],
    
          events : [ {
              targetModule : 'root.interaction',
              listener : 'registerEvent',
              sourceModule : 'root.main.plot',
              type : 'initialized.interaction'
          }, {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'root.legends.legend',
            listener : 'deselectLegend',
            sourceModule : 'root.interaction',
            type : 'deselectLegend'
      }, {
          targetModule : 'root.tooltip',
          listener : 'showTooltip',
          sourceModule : 'root.main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'root.tooltip',
          listener : 'hideTooltip',
          sourceModule : 'root.main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.HeatMap',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var mainLabelAxisFeed = {
      'id' : 'mainLabelAxis',
      'name' : 'IDS_MAINLABELAXISNAME',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
       'acceptMND': -1
    };

    var rectangleColorFeed = {
      'id' : 'rectangleColor',
      'name' : 'IDS_RECTANGLECOLOR',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    };

    var secondLabelAxisFeed = {
      'id' : 'secondaryLabelAxis',
      'name' : 'IDS_SECONDARYAXISLABELNAME',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 2,
       'acceptMND': -1
    };
  var feeds = {
    id : "heatMap",
    feeds : [ mainLabelAxisFeed, rectangleColorFeed, secondLabelAxisFeed ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.heatmap',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.EffectManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(dispatch, ColorSeries, tooltipDataHandler, NumberUtils,EffectManager, TypeUtils, NumberUtils, TextRuler, MeasureBasedColoring, langManager, ObjectUtils, Objects, BoundUtil, defaultSelUtil) {
    //heatmap has no MND
    var heatMap = function(manifest, ctx) {
    
      var randomSuffix = ObjectUtils.guid();              //diff all the id
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };      

        var m_selectionList = [];

        var m_width, m_height;
        var m_props =
        {
            "emptycolor":"#e0e0e0",
            'animation': {
                dataLoading : true,
                dataUpdating : true,
                resizing : true,
            },
            'colornumber': 5,
            'discretecolor' : false,
            'guideline' : 
            {
                visible: false,
                color: "#ffff90",
            },
            'drawemptycell': true,
            'colorPalette': [],
            tooltip: {
                enabled: true,
            }
        };
        
        m_props = extendObj(m_props, manifest.props(null));

        var m_propsOutput = manifest.props(null);
        
        var m_styleTooltipFont = "'Open Sans', Arial, Helvetica, sans-serif";

        var m_data;

        var m_HLElement;

        var m_redrawAll = true;

        var m_className = "v-heatmap";
        var m_classEmptyValue = "v-heatmapemptyvalue";

        var m_padding = 1;

        var m_xScale = d3.scale.ordinal();
        var m_yScale = d3.scale.ordinal();

        var m_dispatch = new dispatch('selectData', 'deselectData', 'initialized', 'showTooltip', 'hideTooltip', 'startToInit');

        var hColor = undefined; //Color Scale

        var m_styleLineColor = "#ffffff";
        
        var m_dataXAxis;
        var m_dataYAxis;
        var m_dataRect;

        var m_heatMapBody;//the root class

        var m_selection = null;

        var m_tooltipElement = null;
        var hasDefaultSelection = false;
        var m_guidline = null;

        //we need to draw some recs. So I will build a obj array, each item is a rec.
        var m_heatObjArray = [];

        var m_effectManager = ctx.effectManager;
        
        var m_defaultString = langManager.get('IDS_ISNOVALUE');
        
        var m_dataShape = null;
        
        function chart(selection){

            BoundUtil.drawBound(selection, m_width, m_height);
            m_dispatch.startToInit();
            m_selection = selection;

            //prepare data, and the draw it
//---------------------prepare data start-------------------------------------
            m_heatObjArray = [];
            
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                //build labels
                var labelArray = [];
                var vArray = m_dataRect.values[0].rows[0];
                //add the data to m_heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < vArray.length; i++)
                {
                    m_heatObjArray.push(vArray[i]);
                }

                //build labelArray
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    var label = "";
                    for(var j = 0; j < m_dataXAxis.values.length; j++)
                    {
                        label += m_dataXAxis.values[j].rows[i].val;
                        if(j != (m_dataXAxis.values.length-1))
                        {
                            label += " / ";
                        }
                    }
                    labelArray.push(label);
                }

                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].label = labelArray[i];
                    m_heatObjArray[i].isOnlyOneCategory = true;
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                for(var i = 0; i < numRow; i++)
                {
                    for(var j = 0; j < numCol; j++)
                    {
                        m_heatObjArray.push(hData[i][j]);
                    }
                }
                
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                  m_heatObjArray[i].isOnlyOneCategory = false;
                }
            }

            // //count the max and min value of m_heatObjArray[i].val
            // var maxVal = -Number.MAX_VALUE;
            // var minVal = Number.MAX_VALUE;

            // for(var iObj = 0; iObj < m_heatObjArray.length; iObj++)
            // {
                // if(!NumberUtils.isNoValue(m_heatObjArray[iObj].val))
                // {
                    // if(maxVal < m_heatObjArray[iObj].val)
                    // {
                        // maxVal = m_heatObjArray[iObj].val;
                    // }

                    // if(minVal > m_heatObjArray[iObj].val)
                    // {
                        // minVal = m_heatObjArray[iObj].val;
                    // }
                // }
            // }

            //var numS = m_props.colornumber;

            hColor = buildColorScale();
            var domainArray = hColor.domain();
            for(var i = 0; i < m_heatObjArray.length; i++)
            {
                var domainValue;
                if(NumberUtils.isNoValue(m_heatObjArray[i].val)) {
                    m_heatObjArray[i].color = m_props.emptycolor;
                } else {
                    for (var j=0; j<domainArray.length; j++) {
                        var tdv = domainArray[j];
                        if ((j == domainArray.length-1) || (domainArray[j+1].length == 0)) {
                            domainValue = tdv;
                            break;
                        }
                        if ((m_heatObjArray[i].val >= tdv[0]) && (m_heatObjArray[i].val < tdv[1])) {
                            domainValue = tdv;
                            break;
                        }
                    }
                    m_heatObjArray[i].color = hColor(domainValue);
                }
                
                
                // for(var j = 0; j < numS; j++)
                // {
                     // if(NumberUtils.isNoValue(m_heatObjArray[i].val))
                    // {
                        // m_heatObjArray[i].color = m_props.emptycolor;
                        // break;
                    // }
                     // else if( m_heatObjArray[i].val == maxVal )
                    // {
                        // m_heatObjArray[i].color = hColor([(minVal + (maxVal-minVal)/numS*(numS-1)), maxVal]);
                        // break;
                    // }
                    // else if(m_heatObjArray[i].val >= (minVal + (maxVal-minVal)/numS*j) && m_heatObjArray[i].val < (minVal + (maxVal-minVal)/numS*(j+1)))
                    // {
                        // m_heatObjArray[i].color = hColor( [(minVal + (maxVal-minVal)/numS*j), (minVal + (maxVal-minVal)/numS*(j+1))]  );
                       
                    // }
                    
                // }
            }

            if(isOnlyOneCategroy)
            {
                //build the rect size. The rule is making the rect width and height have similar values
                var score = -Number.MAX_VALUE;//the bigger the better

                var rHeight;
                var rWidth;
                
                var iRow;
                var iCol;

                var emptyCellNum;

                var scoreArray = [];
                var varianceRec;

                if(m_heatObjArray.length == 1)
                {
                    rHeight = m_height;
                    rWidth = m_width;
                    iCol = 1;
                    iRow = 1;
                }
                else
                {

                    for(iRow = 1; iRow <= m_heatObjArray.length; iRow++)
                    {
                        //count the height
                        rHeight = m_height/iRow;

                        //count the num of one row. 
                        var iCol = Math.ceil(m_heatObjArray.length / iRow);
                        
                        //count the width
                        rWidth = m_width/iCol;

                        emptyCellNum = (iCol * iRow) - m_heatObjArray.length;
                        varianceRec = (rHeight - rWidth)*(rHeight - rWidth);

                        if(varianceRec < 1)
                        {
                            varianceRec = 1; //to avoid 1/varianceRec huge number
                        }

                        var score;
                        if(emptyCellNum == 0 && varianceRec == 0)
                        {
                            score = 1 + 1;
                        }
                        else if(emptyCellNum == 0 && varianceRec != 0)
                        {
                            score = 1 + 1/varianceRec;
                        }
                        else if(emptyCellNum != 0 && varianceRec == 0)
                        {
                            score = 1 + 1;
                        }
                        else
                        {
                            score = 1 + 1/varianceRec;
                        }
                        
                        scoreArray.push(
                        {
                            "iRow":iRow,
                            "iCol":iCol,
                            "rHeight":rHeight,
                            "rWidth":rWidth,
                            "varianceRec":varianceRec,
                            "emptyCellNum":emptyCellNum,
                            "score":score
                        });
                    }
                    //select the best score
                    var maxS = 0;
                    var iChoose = -1;
                    for(var i = 0; i < scoreArray.length; i++)
                    {
                        if(scoreArray[i].score > maxS)
                        {
                            maxS = scoreArray[i].score;
                            iChoose = i;
                        }
                    }

                    rHeight = scoreArray[iChoose].rHeight;
                    rWidth = scoreArray[iChoose].rWidth;
                    iCol = scoreArray[iChoose].iCol;
                    iRow = scoreArray[iChoose].iRow;
                    
                }



                //build the rect height, width, and left, right
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].width = rWidth;
                    m_heatObjArray[i].height = rHeight;

                    m_heatObjArray[i].left = rWidth * (i%iCol);
                    m_heatObjArray[i].top = rHeight * (Math.floor(i/iCol));
                }
            }
            else
            {
                //build the rect height, width, and left, right
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].width = m_width/numCol;
                    m_heatObjArray[i].height = m_height/numRow;

                    m_heatObjArray[i].left = (m_width/numCol) * (i%numCol);
                    //the Y is from the bottom
                    m_heatObjArray[i].top = (m_height-m_height/numRow) - ((m_height/numRow) * (Math.floor(i/numCol)));
                }
            }
//---------------------prepare data end-------------------------------------

            drawHeatMap(selection, isOnlyOneCategroy);
            return chart;
        };

        var drawHeatMap = function(selection, isOnlyOneCategroy)
        {

            var drawState = "resizing";//it has 3 states: dataLoading, dataUpdating, resizing
            if(m_redrawAll)
            {
                if(selection.select("." + m_className).empty())
                {
                    drawState = "dataLoading";
                }
                else
                {
                    drawState = "dataUpdating";
                }      
                selection.select("." + m_className).remove();
            }

            var datashapesgroup = selection.selectAll('g.v-datashapesgroup');
            if(!TypeUtils.isExist(datashapesgroup[0][0])){
              datashapesgroup = selection.append('g').attr('class', 'v-datashapesgroup');
            }

            if(!isOnlyOneCategroy)
            {
                m_padding = 0;
            }
            else
            {
                if(m_props.border.visible)
                {
                    m_padding = 1;
                }
                else
                {
                    m_padding = 0;
                }
            }

            //draw the rects
            if(m_redrawAll)
            {
                m_heatMapBody = datashapesgroup.append("g").attr("class", m_className);
            }
            else
            {
                m_heatMapBody = datashapesgroup.select("." + m_className);
            }

            if(!m_props.drawemptycell)
            {
                //draw a rect
                if(m_redrawAll)
                {
                    m_heatMapBody.append('rect')
                               .attr("x", 0)
                               .attr("y", 0)
                               .attr("width", m_width)
                               .attr("height",m_height)
                               .attr("fill",m_props.emptycolor)
                               .attr("class", m_classEmptyValue)
                               .attr("shape-rendering", "crispEdges");
                }
                else
                {
                    m_heatMapBody.select("." + m_classEmptyValue)
                               .attr("x", 0)
                               .attr("y", 0)
                               .attr("width", m_width)
                               .attr("height",m_height)
                               .attr("fill",m_props.emptycolor)
                               .attr("class", m_classEmptyValue)
                               .attr("shape-rendering", "crispEdges");

                }
            }

            var m_heatObjArrayToDraw = [];
            for(var i = 0; i < m_heatObjArray.length; i++)
            {
                if(!m_props.drawemptycell && !m_heatObjArray[i].val)
                {
                    continue;
                }
                else
                {
                    m_heatObjArray[i].index = i;
                    m_heatObjArrayToDraw.push(m_heatObjArray[i]);
                }
            }
            
            //draw rects 
            var item = m_heatMapBody.selectAll("rect")
                 .data(m_heatObjArrayToDraw,function(d){return d.index;});

            var toDrawItems = item.enter();
            var toDeleteItems = item.exit();

            var rects;
            if(m_redrawAll)
            {
              m_dataShape = toDrawItems.append("g").attr("class","v-datashape");
              m_dataShape.attr('transform', function(d) {return 'translate(' + (d.left + m_padding) + ',' + (d.top + m_padding) + ')';});
              
                rects = m_dataShape.append("rect")
                    .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                    .attr('class', 'v-datapoint')
                    .attr("x", 0)
                    .attr("y", 0)
                    .attr("width", function(d){return d.width-2*m_padding;})
                    .attr("height",function(d){return d.height-2*m_padding;})
                    .attr("fill",function(d){ 
                        var parameter = {
                            drawingEffect:'normal',
                            fillColor : d.color};
                        return m_effectManager.register(parameter);
                        })
                    .attr("shape-rendering", "crispEdges");
            }
            else
            {
                var resizeTime = 0;
                if(drawState === "resizing" && m_props.animation.resizing)
                {
                    resizeTime = 500;
                }

                if (m_dataShape)
                {
                    if(resizeTime > 0)
                    {
                        m_dataShape.transition()
                                   .attr('transform', function(d) {return 'translate(' + (d.left) + ',' + (d.top) + ')';})
                                   .delay(0)
                                   .duration(resizeTime);
                    }
                    else
                    {
                        m_dataShape.attr('transform', function(d) {return 'translate(' + (d.left) + ',' + (d.top) + ')';});
                    }
                }

                rects = item;
                if(resizeTime > 0)
                {
                    rects = item
                        .transition();
                }

                rects = rects.attr("x", 0)
                .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                .attr('class', 'v-datapoint')                            
                .attr("y", 0)
                .attr("width", function(d){return d.width-2*m_padding;})
                .attr("height",function(d){return d.height-2*m_padding;})
                .attr("fill",function(d){ 
                    var parameter = {
                        drawingEffect:'normal',
                        fillColor : d.color};
                    return m_effectManager.register(parameter);
                    })
                .attr("shape-rendering", "crispEdges");

                if(resizeTime > 0)
                {
                    rects.delay(0)
                    .duration(resizeTime).each('end',endAnimation);
                }
                //unselect all of them
                //rects.attr('opacity', 1);
            }

            if(m_props.border.visible)
            {
                if(!isOnlyOneCategroy)
                {
                    rects.attr("stroke",m_styleLineColor)
                           .attr("stroke-width","1");
                }
            }

            if(isOnlyOneCategroy)
            {
                //labels: remove all and append them
                if(!m_redrawAll)
                {
                     m_heatMapBody.selectAll("text").remove();
                     m_heatMapBody.selectAll("rect").data(m_heatObjArrayToDraw,function(d){return d.index;}).enter();                     
                }

                if (m_dataShape)
                {
                    m_dataShape.append("text")
                                .attr("class", "v-heatmapdatalabel")
                                .attr("x", function(d){return d.width/2;})
                                .attr("y", function(d){return d.height/2;})
                                .attr("text-anchor", "middle") // text-align
                                .text(function(d){return d.label;})
                                .attr("fill", "#ffffff")
                                .attr("font-size", "12px")
                                .attr("font-family", "'Open Sans', Arial, Helvetica, sans-serif")
                                .attr('pointer-events', 'none')
                                .each(function(d) {
                                    //Jimmy, BITVIZ-384, add padding before text
                                    TextRuler.ellipsis(d.label, this, d.width - 5, "fill:#ffffff;font-family:'Open Sans', Arial, Helvetica, sans-serif;font-size:12px;");
                                });
                }
            }
            
            //add the animation for redraw
            if(m_redrawAll)
            {
                var fadeInTime = 0;
                if(drawState === "dataLoading" && m_props.animation.dataLoading)
                {
                    fadeInTime = 1000;
                }
                else if(drawState === "dataUpdating" && m_props.animation.dataUpdating)
                {
                    fadeInTime = 500;
                }

                if(fadeInTime > 0)
                {
                    rects.attr('opacity', 0);
                    rects.transition()
                        .delay(0)
                        .duration(fadeInTime).attr('opacity', 1)
                        .each('end',endAnimation);
                }
                else
                {
                    rects.attr('opacity', 1);
                    endAnimation();
                }
            }
            else
            {
                endAnimation();
            }

            //the HLCell Rectange
            if(m_redrawAll)
            {
                m_HLElement = m_heatMapBody.append('g').attr('class', 'v-element').attr("visibility", "hidden");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
            }
            else
            {
                if(m_HLElement)
                {
                    m_HLElement.attr("visibility", "hidden");
                }
            }

            //reset the redraw state
            m_redrawAll = false;
        }
        
        var endAnimation = function(d, i)
        {
            if(  (i === (m_heatObjArray.length - 1))//the last datapoint
               || (m_heatObjArray.length === 0) //no data
               || (d === undefined && i === undefined) //not in "each"
              )
            {
                //When the endAnimation is called, animation may not be end. 
                //(it looks like a bug of d3 or browsers) 
                //So the opacity is 0.9999 or something, and then it will be changed to 1
                //We have to use setTimeout here in case defaultselection changes opacity again. 
                //not use m_dispatch.initialized();            
                setTimeout(m_dispatch.initialized, 0);
            }
        };

        function deregisterEvent(){
            
        };
        
        function registerEvent(){
            
        };

        var showTooltip = function(dataIndex){ 
            var dataItem = m_heatObjArray[dataIndex];
            var valXValue = "";
            var valYValue = "";



           var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                valXValue = m_dataXAxis.values[0].rows[dataIndex].val;
                if(m_dataYAxis)
                {
                    valYValue = m_dataYAxis.values[0].rows[dataIndex].val;
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                valXValue = m_dataXAxis.values[0].rows[dataIndex%numCol].val;
                valYValue = m_dataYAxis.values[0].rows[Math.floor(dataIndex/numCol)].val;
            }

            m_tooltipElement.select("rect").attr("width", 160).attr("height", 78).attr("fill" , "rgb(255,255,255)");
            m_tooltipElement.attr("transform", "translate(" + (dataItem.left + dataItem.width/2 + 5) + "," + (dataItem.top + dataItem.height/2 + 5) + ")");
            if(!NumberUtils.isNoValue(dataItem.val))
            {
                m_tooltipElement.select(".valText").text(dataItem.val);
                m_tooltipElement.select(".valXValue").text(valXValue);
                m_tooltipElement.select(".valYValue").text(valYValue);

                m_tooltipElement.attr('visibility', 'visible');

                //guideline
                if(m_props.guideline.visible)
                {
                    m_guidline.select(".xGuidline").attr("x1", m_heatObjArray[dataIndex].left + m_heatObjArray[dataIndex].width/2).attr("x2", m_heatObjArray[dataIndex].left + m_heatObjArray[dataIndex].width/2);
                    m_guidline.select(".yGuidline").attr("y1", m_heatObjArray[dataIndex].top + m_heatObjArray[dataIndex].height/2).attr("y2", m_heatObjArray[dataIndex].top + m_heatObjArray[dataIndex].height/2);
                    m_guidline.attr('visibility', 'visible');
                }
            }            
        };

        var stringNoValueHandler = function(str)
        {
            if(str === null || str === undefined)
            {
                str = langManager.get('IDS_ISNOVALUE');
            }
            return str;
        }
        
        var generateTooltipData = function(dataIndex){
            //for heatmap, we only have one measure so that the body's length is always 1
            var tooltipData = {
                body:[],
                footer:[]
            };
            var dataItem = m_heatObjArray[dataIndex];
            var body = {
                    'name': stringNoValueHandler(m_dataRect.values[0].col),
                    val:[{
                        color: dataItem.color,
                        value: NumberUtils.isNoValue(dataItem.val)?m_defaultString:dataItem.val
                    }]
            };
            
            tooltipData.body.push(body);
            
            if(TypeUtils.isExist(m_dataXAxis)){
                for(var tval = m_dataXAxis.values, len = tval.length, i = len -1; i  >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndex%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
            
            if(TypeUtils.isExist(m_dataYAxis)){
                var dataIndexInYAxis = Math.floor(dataIndex / m_dataXAxis.values[0].rows.length);
                for(var tval = m_dataYAxis.values, len = tval.length, i = len -1; i >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col;
                    footer.value = tval[i].rows[dataIndexInYAxis%tval[i].rows.length];
                    tooltipData.footer.push(footer);
                }
            }
            
            return tooltipData;
        };
        
        var hideTooltip = function(){
            m_tooltipElement.attr('visibility', 'hidden');
            m_guidline.attr('visibility', 'hidden');
        };

        var HLCell = function(item)
        {
            if(!NumberUtils.isNoValue(item.datum().val))
            {
                m_HLElement.attr("visibility", "visible");

                var iLeft = item.datum().left;
                var iRight = item.datum().left + item.datum().width - m_padding;
                var iTop = item.datum().top;
                var iBottom = item.datum().top + item.datum().height  - m_padding;

                m_HLElement.select(".HLLeft").attr("x1",iLeft).attr("y1",iTop).attr("x2",iLeft).attr("y2",iBottom);
                m_HLElement.select(".HLRight").attr("x1",iRight).attr("y1",iTop).attr("x2",iRight).attr("y2",iBottom);
                m_HLElement.select(".HLTop").attr("x1",iLeft).attr("y1",iTop).attr("x2",iRight).attr("y2",iTop);
                m_HLElement.select(".HLBottom").attr("x1",iLeft).attr("y1",iBottom).attr("x2",iRight).attr("y2",iBottom);
            }
        };

        var unHLCell = function(item)
        {
            m_HLElement.attr("visibility", "hidden");
        };

        chart.mouseover = function(elem){
            var item = d3.select(elem);
            var clickedItemID = item.attr('id');
            if(clickedItemID && m_props.tooltip.enabled)
            {
              var tmpLength = clickedItemID.toString().length - randomSuffix.toString().length - 2;
                var dataIndex = clickedItemID.toString().substr(2 , tmpLength);
                
                var transform = m_selection.node().getTransformToElement(m_selection.node().ownerSVGElement);
                var svgBoundingBox = m_selection.node().ownerSVGElement.getBoundingClientRect();
                var rectBoundingBox =  elem.getBoundingClientRect();
                //showTooltip(dataIndex);
                var tooltipData = generateTooltipData(dataIndex);
                tooltipData.point = {
                        x : rectBoundingBox.left - svgBoundingBox.left + rectBoundingBox.width/2,
                        y : (rectBoundingBox.height > 16) ? rectBoundingBox.top - svgBoundingBox.top + 8 : rectBoundingBox.top - svgBoundingBox.top + rectBoundingBox.height/2
                };
                tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : m_width,
                        height : m_height
                };
                m_dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
                HLCell(item);
            }

        };
        
        chart.afterUIComponentAppear = function(){
          m_dispatch.initialized(); 
        };
        
        
        chart.mouseout = function(elem){
            if(m_props.tooltip.enabled)
            {
                m_dispatch.hideTooltip();
            }

            var item = d3.select(elem);
            unHLCell(item);
        };



        /*
         * Add mouse interaction functions.
         */
        chart.parent = function(){
            return m_selection;
        };

        chart.highlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 1);
                }
            }else{
                elems.setAttribute('opacity', 1);
            }
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, true, elems);
            }
        };
        
        chart.unhighlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 0.4);
                }
            }else{
                elems.setAttribute('opacity', 0.4);
            }
            if(hasDefaultSelection){
              defaultSelUtil.clearSelectionInfo(m_selection, false, elems);
            }
        };
        
        chart.clear = function(gray){
            if( gray == null || gray == false){
              var rects = m_selection.selectAll('.v-datapoint');
                  rects.attr('opacity', 1);
              if(hasDefaultSelection){
                defaultSelUtil.clearSelectionInfo(m_selection, false, rects);
              }
            }else{
              m_selection.selectAll('.v-datapoint').attr('opacity', 0.4);
            }
        };
        
        chart.width = function(_width){
            if (!arguments.length){
              return m_width;
            }
            m_width = _width;

            makeXScale();
            return chart;
        };

        chart.height = function(_height){
            if (!arguments.length){
              return m_height;
            }
            m_height = _height;
            
            makeYScale();
            return chart;       
        };

        chart.data = function(value){
            if (!arguments.length){
                return m_data;
            }

            m_data = value;
            m_redrawAll = true;
            
            m_dataXAxis = m_data.getAnalysisAxisDataByIdx(0);
            m_dataYAxis = m_data.getAnalysisAxisDataByIdx(1);
            m_dataRect = m_data.getMeasureValuesGroupDataByIdx(0);
            
            if(m_dataRect.values[0].rows[0][0].info && m_dataRect.values[0].rows[0][0].info.defaultSelection){
              hasDefaultSelection = true;
            }else{
              hasDefaultSelection = false;
            }
            
            return chart;
        };

        chart.properties = function(props){
            if (!arguments.length){
                return m_propsOutput;
            }           
            Objects.extend(true, m_props, props);
            Objects.extend(true, m_propsOutput, props);
            m_redrawAll = true;
            return chart;           
        };

        /**
         * interfaces for MBC legend selection
         * @param {Object} selectedData 
         * <pre>
         * {
         * ctx: {
         *   ranges: {
         *    endValue:100
         *    isLeftOpen:false
         *    isRightOpen:true
         *    startValue:84
         *   }
         * },
         * val: 84   
         * }
         * @returns {Array} d3 selections in the given range  
         */
        chart.getDatapointsByRange = function(selectedData){
          var datapoints = d3.selectAll('.v-datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
          for(var i = 0, len = datapoints.length; i < len; i++){
            data = datapoints[i].__data__.val;
            if(NumberUtils.isNoValue(selectedData.val)){
              if(NumberUtils.isNoValue(data)){
                ctxDatapoints.push(datapoints[i]);
              }
            }else{
              if(data < ranges.endValue && data > ranges.startValue){
                ctxDatapoints.push(datapoints[i]);
              }else{
                if(!ranges.isLeftOpen && data === ranges.startValue) {
                  ctxDatapoints.push(datapoints[i]);
                }else if(!ranges.isRightOpen && data === ranges.endValue){
                  ctxDatapoints.push(datapoints[i]);
                }
              }
            }
          }
          return ctxDatapoints;
        };
         
        chart.mbcLegendInfo = function(){
            var hColor = buildColorScale();
            return {
                'colorScale' : hColor,
                'title': m_dataRect.values[0].col
            };
        };

        chart.getPreferredSize = function(){
            
        };

        chart.categoryScaleX = function(){
            return m_xScale;
        };
       
        chart.isDrawXaxisBody = function(){
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            return (!isOnlyOneCategroy);
        };

        chart.categoryScaleY = function(){
            return m_yScale;
        };

        chart.dataLabel = function(_){
          
        };
        
        var buildColorScale = function()
        {
            //return a color scale like
            //var domainRg = [ [10,40], [40, 100] ];
            //var rangeRg = ['#ff0000', '#00ff00' ];
            //hColor = d3.scale.ordinal().domain(domainRg).range(rangeRg);

            var hColor = d3.scale.ordinal();

            //we need to draw some recs. So I will build a obj array, each item is a rec.
            var heatObjArray = [];
            
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                var hData = m_dataRect.values[0].rows[0];
                //add the data to heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < hData.length; i++)
                {
                    heatObjArray.push(hData[i]);
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                for(var i = 0; i < numRow; i++)
                {
                    for(var j = 0; j < numCol; j++)
                    {
                        heatObjArray.push(hData[i][j]);
                    }
                }
            }

            //count the max and min value of heatObjArray[i].val
            var maxVal = -Number.MAX_VALUE;
            var minVal = Number.MAX_VALUE;

            for(var iObj = 0; iObj < heatObjArray.length; iObj++)
            {
                if(!NumberUtils.isNoValue(heatObjArray[iObj].val))
                {
                    if(maxVal < heatObjArray[iObj].val)
                    {
                        maxVal = heatObjArray[iObj].val;
                    }

                    if(minVal > heatObjArray[iObj].val)
                    {
                        minVal = heatObjArray[iObj].val;
                    }
                }
            }
            //has "novalue" or not
            var hasNullValue = false;
            for(var i = 0; i < heatObjArray.length; i++)
            {
                if( NumberUtils.isNoValue(heatObjArray[i].val))
                {
                    hasNullValue = true;
                }
            }
            
            var numS = m_props.colornumber;

            var fontColorScale;
            if(minVal === Number.MAX_VALUE && maxVal === -Number.MAX_VALUE){
                fontColorScale = d3.scale.ordinal().domain([[]]).range([m_props.emptycolor]);
            } else {
                var fontColorScale = MeasureBasedColoring.getScale(minVal, maxVal, numS, m_props.startColor, m_props.endColor);
                if(hasNullValue){
                    var domains = fontColorScale.domain();
                    var ranges = fontColorScale.range();
                    domains.push([]);
                    ranges.push(m_props.emptycolor);
                }
            }
            return fontColorScale;
            // //build the color
            // var heatColor = d3.scale.linear()
                // .domain([minVal, maxVal])
                // .range([m_props.startcolor, m_props.endcolor]);

            // //build a d3.scale.ordinal() for legend
            // var domainRg = [];
            // var rangeRg = [];
            // for(var j = 0; j < (numS-1); j++)
            // {
                // domainRg.push( [minVal + (maxVal-minVal)/numS*j, (minVal + (maxVal-minVal)/numS*(j+1))] );
                // rangeRg.push( heatColor(minVal + (maxVal-minVal)/(numS-1)*j) );
            // }

            // domainRg.push( [minVal + (maxVal-minVal)/numS*(numS-1), maxVal] );
            // rangeRg.push( heatColor(maxVal) );



            // if(m_props.discretecolor)
            // {
                // var colorArray;
                // if(m_props.colorPalette.length == 0)
                // {
                    // colorArray = ColorSeries.sap32().range();
                // }
                // else
                // {
                    // colorArray = m_props.colorPalette;
                // }

                // var j = 0;
                // for(var i = 0; i < rangeRg.length; i++)
                // {
                    // rangeRg[i] = colorArray[j];
                    // j = (j+1)%(colorArray.length);
                // }
            // }

            // if(hasNULL) //no value
            // {
                // domainRg.push([]);
                // rangeRg.push(m_props.emptycolor);
            // }


            // hColor = d3.scale.ordinal().domain(domainRg).range(rangeRg);

            // return hColor;
        }

        var makeXScale = function()
        {
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            

            var hCol = m_dataXAxis.values[0].rows;
            var dArray = [];
            for(var i = 0; i < hCol.length; i++)
            {
                dArray.push(i);
            }

            m_xScale = m_xScale.domain(dArray)
                                .rangeBands([0, m_width]);
        };

        var makeYScale = function()
        {
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            
            if(isOnlyOneCategroy)
            {
                //no yAxis
                m_yScale = m_yScale.domain([0,0])
                                .rangeBands([0,0]);
            }
            else
            {
                var hRow = m_dataYAxis.values[0].rows;
                var dArray = [];
                for(var i = 0; i < hRow.length; i++)
                {
                    dArray.push(i);
                }

                //y is from bottom
                m_yScale = m_yScale.domain(dArray)
                                .rangeBands([m_height, 0]);
            }
        };

        /**
         * get/set your event dispatch if you support event
         */
        chart.dispatch = function(_){
            if(!arguments.length)
                return m_dispatch;
            m_dispatch = _;
            return chart;
        };
        
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        return chart;
    };

    return heatMap;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.HeatMap',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.heatmap',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.HeatMap',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {

    var module = {
      'id' : 'sap.viz.modules.heatmap',
      'type' : Constants.Module.Type.Chart,
      'name' : 'heatmap',
      'properties' : {
        'border' : {
          'name' : 'border',
      'description' : 'Settings for border.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
                'name' : 'visible',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set visibility of zone edge.'
            },
          },
        },

        'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
        },
        'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set heatMap startColor.'
        },
      
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set heatMap endColor.'
        },

        'tooltip' : {
          'name' : 'tooltip',
      'description' : 'Settings for tooltip.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
              'visible': {
                    'name' : 'enabled',
                    'supportedValueType' : 'Boolean',
                    'defaultValue' : true,
                    'description' : 'Set enabled/disabled tooltip.'
              },
          },
        'isExported' : false
        }
      },
      'events' : {
        'initialized': Constants.Module.Event.Initialized.desc,
        'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc,
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc

      },
      'feeds' :{
          id:"heatMap"
      },
      'css' : {},
      'configure' : null,
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.HeatMapChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.HeatMap',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.legend.Common',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants) {
  var chart = {
    id : 'viz/heatmap',
    name : 'IDS_HEATMAPCHART',
    base : 'riv/base/single',
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.RELAYOUT }
          }
        },
        modules : {
          legends : {
            id : 'sap.viz.modules.legend',
            configure : {
              properties : {
                layout : {
                  position : 'right',
                  priority : 1
                }
              }
            },
            modules : {
              legend : {
                id : 'sap.viz.modules.legend.common',
                configure : {
                  description : 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
                  properties : { type : 'MeasureBasedColoringLegend' },
                  propertiesOverride : {
                    isHierarchical : { isExported : false },
                    formatString: { isExported: true }
                  }
                }
              }
            }
          },
          
          tooltip : {
            id : 'sap.viz.modules.tooltip',
            configure : {
              propertyCategory : 'tooltip',
              properties : { chartType : 'heatmap', orientation : 'bottom' }
            }
          },

          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : 'main',
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
              }
            }
          },

          main : {
            modules : {
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    visible : false,
                    orientation : 'vertical',
                    position : 'inside',
                    automaticInOutside : false,
                    showZero : true,
                    isStackMode : false,
                    isPercentMode : false,
                    outsideVisible : false
                  },
                  propertiesOverride:{
                    position : {
                      isExported : false
                    }
                  }
                }
              },
              
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : { aa : [ 1 ] },
                configure : {
                  description : 'Settings for the x axis of a normal heatmap.',
                  propertyCategory : 'xAxis',
                  properties : {
                    type : 'category',
                    position : 'bottom',
                    gridline : { visible : false }
                  },
                  propertiesOverride : {
                    gridline : { isExported : false },
                    label : { isExported : false },
                    axisline : { isExported : false }
                  }
                }
              },
              
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : { aa : [ 2 ] },
                configure : {
                  description : 'Settings for the y axis of a normal heatmap.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {
                    gridline : { isExported : false },
                    label : { isExported : false },
                    axisline : { isExported : false }
                  }
                }
              },          
            
              plot : {
                id : 'sap.viz.modules.heatmap',
                configure : {
                  description : 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    
    dependencies : {
      attributes : [ {
        targetModule : 'root.main.xAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScaleX'
      },{
        targetModule : 'root.main.xAxis',
        target : 'isDrawBody',
        sourceModule : 'root.main.plot',
        source : 'isDrawXaxisBody'
      }, {
        targetModule : 'root.main.yAxis',
        target : 'scale',
        sourceModule : 'root.main.plot',
        source : 'categoryScaleY'
      },
      {
        targetModule : 'root.legends.legend',
        target : 'mbcLegendInfo',
        sourceModule : 'root.main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
      }],
    
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'root.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'root.legends.legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'root.legends.legend',
        listener : 'deselectLegend',
        sourceModule : 'root.interaction',
        type : 'deselectLegend'
      }, {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
        }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
        },  {
        targetModule : 'root.main.dataLabel',
        listener : 'showLabel',
        sourceModule : 'root.main.plot',
        type : 'initialized.datalabel'
      }, {
        targetModule : 'root.main.dataLabel',
        listener : 'removeLabel',
        sourceModule : 'root.main.plot',
        type : 'startToInit.datalabel'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.TagCloud',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.2'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "tagCloud",
    feeds : [ {
      'id' : 'tagName',
      'name' : 'IDS_TAGNAME',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1,
      'maxStackedDims' : 1 
      
    }, {
      'id' : 'tagWeight',
      'name' : 'IDS_TAGWEIGHT',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'tagFamily',
      'name' : 'IDS_TAGFAMILY',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 2
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.wordleLayout',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
}
],
function Setup(TextRuler, NumberUtils) {
  var wordleLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';
    var textDirection = 'Mixed';

    var wordle = function() {

    };
    
    wordle.textDirection = function(_) {
      if (!arguments.length) {
        return textDirection;  
      }
        
      textDirection = _;
      return wordle;
    };
    
    wordle.width = function(_) {
      if (!arguments.length) {
        return width;  
      }
        
      width = _;
      return wordle;
    };

    wordle.height = function(_) {
      if (!arguments.length) {
        return height;
      }
        
      height = _;
      return wordle;
    };

    wordle.data = function(_) {
      if (!arguments.length) {
        return chartData; 
      }
       

      _.sort(function(a, b) {
        if (a.wordSize && b.wordSize) {
          return b.wordSize.val - a.wordSize.val;
        }
      });
      chartData = _;
      return wordle;
    };

    wordle.font = function(_) {
      if (!arguments.length) {
        return font;
      }
       
      font = _;
      return wordle;
    };

    wordle.layout = function() {
      var relayout = false, layoutCount = 0;
      while (!relayout) {
        relayout = _layout(++layoutCount);
      }
      return wordle;
    };

    var _layout = function(layoutCount) {
      var tagArr = chartData, textSize, d, root;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];

        if (NumberUtils.isNoValue(d.fontSize)) {
          continue;
        }

        textSize = TextRuler.fastMeasure(tagArr[i].word.val + 'i',
            tagArr[i].fontSize + 'px', 'normal', font);

        d.width = textSize.width;
        d.height = textSize.height;

        d.x = undefined;
        d.y = undefined;

        d.rect = new rect(d.width, d.height);

        var flag;
        if (!root) {
          var rotate;
          switch (textDirection){
            case 'Mixed':
              if (d.width <= width && d.height <= height) {
                rotate = false;
              } else if (d.height <= width && d.width <= height) {
                rotate = true;
              }            
            break;
            case 'Vertical':
              if (d.height <= width && d.width <= height) {
                rotate = true;
              }
            break;
            case 'Horizontal':
              if (d.width <= width && d.height <= height) {
                rotate = false;
              }
            break;            
          }
          if (rotate !== undefined) {
            root = d;
            if (rotate){
              d.rect.rotate();
            }
            d.rect.position(width / 2, height / 2);
            flag = true;
          }

        } else {
          var list = [];
          list.push(root);
          while (list.length !== 0) {
            var parent = list.shift();

            if (parent.child){
              parent.child.forEach(function(c) {
                if (c){
                  list.push(c);
                }
              });
            }

            flag = placeTag(d, parent, root);
            if (flag){
              break;
            }
          }
        }

        if ( flag ) {
          d.x = d.rect.x;
          d.y = d.rect.y;

          var baseLineOffset = -textSize.y - (textSize.height / 2), rotated = d.rect.rotated;
          if ( rotated ) {
            d.x -= baseLineOffset;
            d.rotate = 90;
          } else {
            d.y += baseLineOffset;
            d.rotate = 0;
          }
        }
      }

      tagArr.forEach(function(d) {
        delete d.child;
        delete d.rect;
      });

      return true;
    };

    function placeTag(tag, parent, root) {
      var rect = tag.rect;
      var child = parent.child;
      if (!child) {
        child = [];
        parent.child = child;
      }
      var x, y;
      var i, j;
      switch (textDirection){
        case 'Mixed':
          for (j = 0; j < 2; j++) {
            if (j === 1) {
              rect.rotate();            
            }

            for (i = 0; i < 4; i++) {
              if (child[i]){
                continue;
              }

              switch (i) {
              case 0:
                x = parent.x;
                y = parent.rect.y0 - rect.h / 2;
                break;
              case 1:
                y = parent.y;
                x = parent.rect.x1 + rect.w / 2;
                break;
              case 2:
                x = parent.x;
                y = parent.rect.y1 + rect.h / 2;
                break;
              case 3:
                y = parent.y;
                x = parent.rect.x0 - rect.w / 2;
                break;
              }

              rect.position(x, y);

              if (rect.x0 >= 0 && rect.y0 >= 0 && rect.x1 <= width && rect.y1 <= height) {
                if (validPosition(rect, parent, root)) {
                  child[i] = tag;
                  return true;
                }
              }
            }
          }

        break;
        case 'Vertical':
          rect.rotate();            
          for (i = 0; i < 4; i++) {
            if (child[i]){
              continue;
            }

            switch (i) {
            case 0:
              x = parent.x;
              y = parent.rect.y0 - rect.h / 2;
              break;
            case 1:
              y = parent.y;
              x = parent.rect.x1 + rect.w / 2;
              break;
            case 2:
              x = parent.x;
              y = parent.rect.y1 + rect.h / 2;
              break;
            case 3:
              y = parent.y;
              x = parent.rect.x0 - rect.w / 2;
              break;
            }

            rect.position(x, y);

            if (rect.x0 >= 0 && rect.y0 >= 0 && rect.x1 <= width && rect.y1 <= height) {
              if (validPosition(rect, parent, root)) {
                child[i] = tag;
                return true;
              }
            }
          }
          
          break;
        case 'Horizontal':
          for (i = 0; i < 4; i++) {
            if (child[i]){
              continue;
            }

            switch (i) {
            case 0:
              x = parent.x;
              y = parent.rect.y0 - rect.h / 2;
              break;
            case 1:
              y = parent.y;
              x = parent.rect.x1 + rect.w / 2;
              break;
            case 2:
              x = parent.x;
              y = parent.rect.y1 + rect.h / 2;
              break;
            case 3:
              y = parent.y;
              x = parent.rect.x0 - rect.w / 2;
              break;
            }

            rect.position(x, y);

            if (rect.x0 >= 0 && rect.y0 >= 0 && rect.x1 <= width && rect.y1 <= height) {
              if (validPosition(rect, parent, root)) {
                child[i] = tag;
                return true;
              }
            }
          }
        break;            
      }
      //rotate back if placing failed
      if (textDirection === 'Mixed' || textDirection === 'Vertical'){
        rect.rotate();            
      }
      return false;
    }

    function validPosition(rect, parent, root) {
      if (root !== parent){
        if (!rect.notInterects(root.rect)){
          return false;
        }
      }

      for ( var i = 0, child = root.child, len = child ? child.length : 0; i < len; i++) {
        if (child[i] && !validPosition(rect, parent, child[i])){
          return false;
        }
      }

      return true;
    }

    function rect(w, h) {
      this.w = w;
      this.h = h;
      this.rotated = false;
    }

    rect.prototype = {
      position : function(x, y) {
        this.x = x;
        this.y = y;

        var _x = this.w / 2, _y = this.h / 2;
        this.x0 = x - _x;
        this.x1 = x + _x;
        this.y0 = y - _y;
        this.y1 = y + _y;
      },

      notInterects : function(rect) {
        return this.x1 <= rect.x0 || this.x0 >= rect.x1 || this.y1 <= rect.y0 || this.y0 >= rect.y1;
      },

      rotate : function() {
        this.rotated = !this.rotated;
        var t = this.h;
        this.h = this.w;
        this.w = t;
      }
    };

    return wordle;
  };
  return wordleLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.columnLayout',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
}
],
function Setup(TextRuler, NumberUtils) {
  var columnLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';
    var textDirection = 'Mixed';

    var column = function() {

    };
    column.textDirection = function(_) {
      if (!arguments.length) {
        return textDirection;  
      }
        
      textDirection = _;
      return column;
    };
    
    column.width = function(_) {
      if (!arguments.length) {
          return width;  
      }
        
      width = _;
      return column;
    };

    column.height = function(_) {
      if (!arguments.length) {
          return height;
      }
        
      height = _;
      return column;
    };

    column.data = function(_) {
      if (!arguments.length) {
          return chartData;  
      }
       
      chartData = _;
      return column;
    };

    column.font = function(_) {
      if (!arguments.length) {
          return font;  
      }
        
      font = _;
      return column;
    };

    column.layout = function() {
      _layout();
      return column;
    };

    var _layout = function() {
      var tagArr = chartData;
      var d, textSize;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        textSize = TextRuler.fastMeasure(tagArr[i].word.val+'i', tagArr[i].fontSize+'px', 'normal', font);
        d.width = textSize.width;
        d.height = textSize.height;
      }

      var startX = 0, startY = 0;
      for ( var j = 0, jlen = tagArr.length; j < jlen; j++) {
        d = tagArr[j];
        if((d.width > width) || (d.height > height) || (NumberUtils.isNoValue(tagArr[j].fontSize))) {
          continue;
        }
        startY = startY + d.height;
        d.x = startX;
        d.y = startY;
        d.rotate = undefined;
      }
    };
    return column;
  };
  return columnLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.rowLayout',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
}
],
function Setup(TextRuler, NumberUtils) {
  var rowLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';

    var textDirection = 'Mixed';

    var row = function() {

    };
    
    row.textDirection = function(_) {
      if (!arguments.length) {
        return textDirection;  
      }
        
      textDirection = _;
      return row;
    };
    
    row.width = function(_) {
      if (!arguments.length){
        return width;
      }
      width = _;
      return row;
    };

    row.height = function(_) {
      if (!arguments.length){
        return height;
      }
      height = _;
      return row;
    };

    row.data = function(_) {
      if (!arguments.length){
        return chartData;
      }
      chartData = _;
      return row;
    };

    row.font = function(_) {
      if (!arguments.length){
        return font;
      }
      font = _;
      return row;
    };

    row.layout = function() {
      _layout();
      return row;
    };

    var _layout = function() {
      var tagArr = chartData;
      var d, textSize, i, len;
      for (i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        textSize = TextRuler.fastMeasure(tagArr[i].word.val+'i', tagArr[i].fontSize+'px', 'normal', font);
        d.width = textSize.width;
        d.height = textSize.height;
      }

      var startX = 0;
      var maxRowHeight = 0, startY = 0, newLineIndex = 0;
      for (i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        
        if((d.width > width) || (d.height > height) || (NumberUtils.isNoValue(tagArr[i].fontSize))){
          continue;
        }
        
        if (startX + d.width > width) {
          // New Row
          startX = 0;
          _adjustLastLineTagPosition(newLineIndex, i, startY + maxRowHeight);
          
          newLineIndex = i;
          startY = startY + maxRowHeight;
          maxRowHeight = tagArr[i].height;
        }
        if(d.height > maxRowHeight){
          maxRowHeight = d.height;
        }
        d.x = startX;
        d.y = startY;
        startX = startX + d.width;
        d.rotate = undefined;
      }
      _adjustLastLineTagPosition(newLineIndex, i, startY + maxRowHeight);
    };
    
    /*
     * Set last line tag position.
     */
    var _adjustLastLineTagPosition = function(startIndex, endIndex, newYPosition){
      var dArr;
      for(var j = startIndex; j < endIndex; j++){
        dArr = chartData[j];
        if(dArr.y !== undefined){
          dArr.y = newYPosition;
        }
      }
    };
    return row;
  };
  return rowLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.tagcloud.rowLayout',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.tagcloud.columnLayout',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.tagcloud.wordleLayout',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.BoundUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.util.defaultSelectionUtil',
  version : '4.0.2'
}
],
function Setup(TypeUtils, dispatch, ColorSeries, langManager, RowLayout, ColumnLayout, WordleLayout, MeasureBasedColoring, NumberUtils, ObjectUtils, tooltipDataHandler, Objects, boundUtil, defaultSelUtil) {
  var tagCloud = function(manifest, ctx) {
    var CSSCLASS_HOVERLINE = 'v-hovershadow';
    var width = 400, height = 200, wrap = null, chartData = {}, tagArr = [], maxfont = 48, minfont = 12, fontColorScale, selectionList = [], effectManager = ctx.effectManager;
    var randomSuffix = ObjectUtils.guid();
    var minFontFamily = Number.MAX_VALUE, maxFontFamily = Number.MIN_VALUE, hasNullValue = false, tooltipVisible = true;
    var tagStyle = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'color' : '#555555'
    };
    var style = {};
    var opacity = 1, defaultString = langManager.get('IDS_ISNOVALUE');
    var options, layoutMode, textDirection;

    options = manifest.props(null);
    textDirection = options.layout.textDirection;
    layoutMode = options.layout.mode;

    var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'); //, 'showTooltip', 'hideTooltip'
      
    var decorativeShape = null;
    var isDataSchemaChanged = false, isDataLoading = true, isSizeChanged = false, isDatasetChanged = false, hasDefaultSelection = false;
    //@Alex Su, judge whether we should enable animation
    
    function enableAnimation(){
      var hasAnmation = false;
      if(isDataLoading){
        hasAnmation = options.animation.dataLoading;
      }else if(isDatasetChanged){
        hasAnmation = options.animation.dataUpdating;
      }else if(isSizeChanged){
        hasAnmation = options.animation.resizing;
      }
      return hasAnmation;
    }

    var chart = function(selection) {
      selection.each(function() {
        boundUtil.drawBound(selection, width, height);

        _calculateTagPosition();
        
        if(decorativeShape === null){
          decorativeShape = selection.append('rect').attr('fill', style.hoverline.fill).attr('class', CSSCLASS_HOVERLINE).style('visibility', 'hidden');
        }else{
          decorativeShape.attr('width', 0).attr('height', 0).attr('x', 0).attr('y', 0).style('visibility', 'hidden');
        }
        
        //filter hidden data
        var labelsData = _filterData();
        
        wrap = d3.select(this);

        //remove old data item while updateing dataset
        if(isDatasetChanged && !wrap.selectAll('g.v-word').empty()){
          wrap.selectAll('g.v-word').remove();
        }
        
        wrap.attr('style', 'cursor:default');//.on('click', clickHandler).on('mouseover', mouseOverHandler).on('mouseout', mouseOutHandler);
        var wordsWrap = wrap.selectAll('g.v-word').data(labelsData, function(d, i){
          return (d.word ? d.word.val : "") + " " + (d.wordFontFamily ? d.wordFontFamily.val : "") + " " + (d.wordSize ? d.wordSize.val : "");
        });
        
        wordsWrap.selectAll('text').data(function(d, i){
          return d;
        }).text(function(d, i){ 
          return d.word.val;
        });
        
        var wordsWrapEnter = wordsWrap.enter().append('g').attr('class', 'v-word').append('text').text(function(d, i){ 
            return d.word.val;
          })
          .attr('id', function(d, i){
            return 'TAG_ID_' + i + randomSuffix;
          })
          .attr('class', 'v-datapoint')
          .attr('visibility', function(d, i){
            var isVisible = 'visible';
            if(NumberUtils.isNoValue(d.fontSize) || d.x === undefined || d.y === undefined){
              isVisible = 'hidden';
            }
            return isVisible;
          })  
          .attr('font-size', function(d, i){
            return d.fontSize;
          }).attr('font-family', tagStyle.fontfamily);
//        wordsWrap.exit().remove();
        
//        wordsWrap.transition().attr('dx', function(d, i){
//            return d.x;
//          }).attr('dy', function(d, i){
//            return d.y;
//          }).duration(800).delay(100);
        
//        wordsWrap.append('line').attr('stroke', 'red').attr('x1', function(d, i){
//              return d.x + d.x0;
//            }).attr('y1', function(d, i){
//              return d.y;
//            }).attr('x2', function(d, i){
//              return d.x + d.x1;
//            }).attr('y2', function(d, i){
//              return d.y;
//            }).attr('fill', 'none');
        wordsWrap.exit().attr('transform', 'translate(-1000, -1000)');
        wordsWrap.selectAll('.v-datapoint').attr("fill",function(d, i){
          var color;
          if(fontColorScale && d.wordFontFamily !== null && d.wordFontFamily.val !== null){
            var j, len, domain = fontColorScale.domain();
            for(j = 0, len = domain.length - 1; j < len; j++){
              if(d.wordFontFamily.val!==null && (domain[j][1] > d.wordFontFamily.val)){
                break;
              }
            }
            color = fontColorScale(domain[j]);
          }else{
            color = tagStyle.color;
          }  
          var parameter = {
            fillColor:color,
            drawingEffect:"normal"
          };
          return effectManager.register(parameter);
        }).attr('text-anchor', function(){
          if(layoutMode === 'Wordle'){
            return 'middle';
          }else{
            return 'start';
          }
        });
        wordsWrap.selectAll('text').attr('fill-opacity', opacity);
        
        if(enableAnimation()){
          wordsWrap.transition().attr('transform', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined && d.y < height && d.x < width){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            return translate;
          }).duration(800).delay(100).each('end', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined && d.y < height && d.x < width){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            this.setAttribute('transform', translate);
            
            if(i === labelsData.length-1){
              eDispatch.initialized();
            }
          });
        }else{
          wordsWrap.attr('transform', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            return translate;
          });
          //When the endAnimation is called, animation may not be end. 
          //(it looks like a bug of d3 or browsers) 
          setTimeout(eDispatch.initialized, 0);
        }
        isDataSchemaChanged = false, isDataLoading = false, isSizeChanged = false, isDatasetChanged = false;        
      });
    };
      
      /**
      * set/get width
      */
      chart.width = function(_){
          if (!arguments.length){
            return width;
          }
          isSizeChanged = (!isSizeChanged && (_ === width)) ? false : true;
          width = _;
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(_){
        if (!arguments.length){
          return height;
         }
        isSizeChanged = (!isSizeChanged && (_ === height)) ? false : true;
        height = _;
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
      chart.data = function(_){
        if (!arguments.length){
          return chartData;
         }
        var data = {};
        data.words = _.getAnalysisAxisDataByIdx(0).values[0];

        var wordsData = _.getMeasureValuesGroupDataByIdx(0);
        if(wordsData && _.getMeasureValuesGroupDataByIdx(0).values.length > 0){
          data.wordsSize = _.getMeasureValuesGroupDataByIdx(0).values[0];
        }else{
          data.wordsSize = undefined;
        }
        
        if ( wordsData.values[0] &&  wordsData.values[0].rows[0][0].info && wordsData.values[0].rows[0][0].info.defaultSelection ) {
          hasDefaultSelection = true;
        }else{
          hasDefaultSelection = false;
        }
        
        var wordsFontFamilySata = _.getMeasureValuesGroupDataByIdx(1);
        if(wordsFontFamilySata && wordsFontFamilySata.values.length > 0){
          data.wordsFontFamily = _.getMeasureValuesGroupDataByIdx(1).values[0];
        }else{
          data.wordsFontFamily = undefined;
          fontColorScale = undefined;
        }
        _parseData(data);
        
        //Check dataset is changed.
        isDatasetChanged = true;
        isDataSchemaChanged = _isDatasetChanged(data);
        chartData = data;
         return chart;        
      };

      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return options;
         }
         Objects.extend(true, options, props);
         parseOption();
         return chart;
      };
      
      /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return chart;
      };
      
      
      /*
       * Font color scale.
       */
      chart.mbcLegendInfo = function(){
        var title = chartData.wordsFontFamily ? chartData.wordsFontFamily.col : '';
        return {
          'colorScale' : fontColorScale,
          'title' : title
        };
      };
      
      /*
       * Add mouse interaction functions.
       */
      chart.parent = function(){
        return wrap;
      };
      

          chart.highlight = function(elems) {
      if (elems instanceof Array) {
        for ( var i = 0, len = elems.length; i < len; i++) {
          elems[i].setAttribute('fill-opacity', 1);
          // opacity = 0.2;
        }
      } else {
        elems.setAttribute('fill-opacity', 1);
        // opacity = 0.2;
      }

      if (hasDefaultSelection) {
        defaultSelUtil.clearSelectionInfo(wrap, true, elems);
      }

    };

    chart.unhighlight = function(elems) {
      if (elems instanceof Array) {
        for ( var i = 0, len = elems.length; i < len; i++) {
          elems[i].setAttribute('fill-opacity', 0.4);
        }
      } else {
        elems.setAttribute('fill-opacity', 0.4);
      }
      if (hasDefaultSelection) {
        defaultSelUtil.clearSelectionInfo(wrap, false, elems);
      }
    };

    chart.clear = function(gray) {
      if (gray === null || gray === false || gray === undefined) {
        var words = wrap.selectAll('.v-datapoint');
        words.attr('fill-opacity', 1);
        opacity = 1;
        if (hasDefaultSelection) {
          defaultSelUtil.clearSelectionInfo(wrap, false, words);
        }
      } else {
        wrap.selectAll('.v-datapoint').attr('fill-opacity', 0.4);
      }
    };
      
      chart.mouseover = function(elem){
        var item = d3.select(elem);
        var clickedItemID = item.attr('id');
        if(clickedItemID && tooltipVisible){
          var tooltipData = generateTooltipData(item.datum());
          var transform = wrap.node().getTransformToElement(wrap.node().ownerSVGElement);
          var svgRect = wrap.node().ownerSVGElement.getBoundingClientRect();
          var itemRect = item.node().getBoundingClientRect(), wrapRect = wrap.node().getBoundingClientRect();
          
          decorativeShape.attr('width', itemRect.width).attr('height', itemRect.height).attr('x', itemRect.left - wrapRect.left).attr('y', itemRect.top - wrapRect.top).style('visibility', 'visible');
          tooltipData.point = {
            x: itemRect.left - svgRect.left + itemRect.width/2,
            y: itemRect.top - svgRect.top
          };
          
          tooltipData.plotArea = {
            x : transform.e,
          y : transform.f,
          width : width,
          height : height
          };
          
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      };
      
      chart.mouseout = function(){
        decorativeShape.attr('width', 0).attr('height', 0).attr('x', 0).attr('y', 0).style('visibility', 'hidden');
        if(tooltipVisible){
          eDispatch.hideTooltip();
        }
      };
      
      /**
       * interfaces for MBC legend selection
       * @param {Object} selectedData 
       * <pre>
       * {
       * ctx: {
       *   ranges: {
       *    endValue:100
       *    isLeftOpen:false
       *    isRightOpen:true
       *    startValue:84
       *   }
       * },
       * val: 84   
       * }
       * @returns {Array} d3 selections in the given range  
       */
      chart.getDatapointsByRange = function(selectedData){
        var datapoints = d3.selectAll('.v-datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
        for(var i = 0, len = datapoints.length; i < len; i++){
          data = datapoints[i].__data__.wordFontFamily.val;
          if (NumberUtils.isNoValue(selectedData.val)) {
          if (NumberUtils.isNoValue(data)) {
            ctxDatapoints.push(datapoints[i]);
          }
        } else {
          if (data < ranges.endValue && data > ranges.startValue) {
            ctxDatapoints.push(datapoints[i]);
          } else {
            if (!ranges.isLeftOpen && data === ranges.startValue) {
              ctxDatapoints.push(datapoints[i]);
            } else if (!ranges.isRightOpen && data === ranges.endValue) {
              ctxDatapoints.push(datapoints[i]);
            }
          }
        }
        }
        return ctxDatapoints;
      };
    
    var _isDatasetChanged = function(newData){
      var oldData = chartData, isDatasetChanged = false;
      if(oldData.words && newData.words){
        if(oldData.words.rows.length !== newData.words.rows.length){
          isDatasetChanged = true;
        }else if((oldData.wordsFontFamily && !newData.wordsFontFamily) || (!oldData.wordsFontFamily && newData.wordsFontFamily)){
          isDatasetChanged = true;
        }else{
          var oldWords = oldData.words.rows, newWords = newData.words.rows;
          for(var i = 0, iLen = oldWords.length; i < iLen; i++){
            if(oldWords[i].val !== newWords[i].val){
              isDatasetChanged = true;
              break;
            }
          }
        }
      }
      return isDatasetChanged;
    };
      
    var parseOption = function() {
      if (options.layout instanceof Object){
        layoutMode = options.layout.mode;
      } else {
        layoutMode = options.layout;
      }
      if (layoutMode !== 'Row' && layoutMode !== 'Column' && layoutMode !== 'Wordle'){
        layoutMode =  'Wordle';          
      }
      textDirection = options.layout.textDirection;
      if (textDirection !== 'Mixed' && textDirection !== 'Vertical' && textDirection !== 'Horizontal'){
        textDirection = 'Mixed';
      }
      tooltipVisible = options.tooltip.enabled;
      if (fontColorScale) {
        _calculateFontFamily(minFontFamily, maxFontFamily, hasNullValue);
      }
    };
    
    var _filterData = function(){
      var labelsData = [], item;
      for(var i = 0, len = tagArr.length; i < len; i++){
        item = tagArr[i];
        if(!(NumberUtils.isNoValue(item.fontSize) || item.x === undefined || item.y === undefined || item.y > height || item.x > width)){
          //Hide this tag, remove it.
          labelsData.push(item);
        }
      }
      return labelsData;
    };
    
      var generateTooltipData = function(data){
        var tooltipData = {
            body: [],
            footer: []
        };
        
        if(chartData.wordsSize){
          tooltipData.body.push({
            name: chartData.wordsSize.col,
            val:[{
              value: _handleNullValue(data.wordSize.val)
            }]
          });
        }
        
        if(chartData.wordsFontFamily){
          tooltipData.body.push({
            name:chartData.wordsFontFamily.col,
            val:[{
              value: _handleNullValue(data.wordFontFamily.val)
            }]
          });
        }
        
        if(chartData.words){
          tooltipData.footer.push({
            label: chartData.words.col,
            value: data.word.val
          });
        }
        
        return tooltipData;
      };
        
      var _parseData = function(data){
      tagArr = [];
      var minFontSize, maxFontSize, fontfamilyValue, tagItem;
      minFontFamily = undefined, maxFontFamily = undefined, hasNullValue = false;
      
      for(var i=0, len = data.words.rows.length; i < len; i++){
        if(data.words && data.words.rows[i].val && data.wordsSize && data.wordsSize.rows[0][i] && !NumberUtils.isNoValue(data.wordsSize.rows[0][i].val)){
          tagItem = {};
          tagItem.word = data.words.rows[i];
          tagItem.wordSize = (data.wordsSize ? data.wordsSize.rows[0][i] : undefined);
          tagItem.wordFontFamily = (data.wordsFontFamily ? data.wordsFontFamily.rows[0][i] : undefined);
          
          //For selection event data.
          tagItem.val = [data.words.rows[i].val];
          tagItem.ctx = [data.words.rows[i].ctx];
          tagItem.info = [data.words.rows[i].info];
        
          if(tagItem.wordSize){
            tagItem.val.push(data.wordsSize.rows[0][i].val);
            tagItem.ctx.push(data.wordsSize.rows[0][i].ctx);
            tagItem.info.push(data.wordsSize.rows[0][i].info);
            
            if(tagItem.wordSize.val !== null){
              if(minFontSize === undefined || tagItem.wordSize.val < minFontSize){
                minFontSize = tagItem.wordSize.val; 
              }
              if(maxFontSize === undefined || tagItem.wordSize.val > maxFontSize){
                maxFontSize = tagItem.wordSize.val; 
              }
            }
          }
          
          if(tagItem.wordFontFamily){
            tagItem.val.push(tagItem.wordFontFamily.val);
            tagItem.ctx.push(tagItem.wordFontFamily.ctx);
            tagItem.info.push(tagItem.wordFontFamily.info);
            
            fontfamilyValue = tagItem.wordFontFamily.val;
            
            if(fontfamilyValue === null){
              hasNullValue = true;
            }else{
              if(minFontFamily === undefined || fontfamilyValue < minFontFamily){
                minFontFamily = tagItem.wordFontFamily.val; 
              }
              if(maxFontFamily === undefined || fontfamilyValue > maxFontFamily){
                maxFontFamily = tagItem.wordFontFamily.val; 
              }
            }
          }
          tagArr.push(tagItem);
        }
      }
      
      //Linear font weight scale. Add more scale type here.
      _calculateFontSize(minFontSize, maxFontSize);
      if(data.wordsFontFamily){
        _calculateFontFamily(minFontFamily, maxFontFamily, hasNullValue);
      }else{
        fontColorScale = undefined;
      }
    };
    
    /*
     * Calculate font size by font-weight
     */
    var _calculateFontSize = function(min, max){
      //Generate font size arguments
      var count = tagArr.length;
      var a, b, fsize;
      
      if (min === 0){
              min = 1;
              max += 1;
          }
      
      if (count > 1) {
        b = (maxfont - (minfont * (max / min))) / (1 - (max / min));
        a = (minfont - b) / min;
      } else {
        b = 0;
        a = maxfont / (min < 0 ? -min : min);
      }
      
      for(var i=0, len = tagArr.length; i < len; i++){
        //Set Font Size
        if(tagArr[i].wordSize && min !== max){
          fsize = Math.round(a * tagArr[i].wordSize.val + b);
        }else{
          fsize = minfont;
        }
        tagArr[i].fontSize = (tagArr[i].wordSize.val === null) ? null : fsize;
      }
    };
    
    /*
     * Calculate font color family.
     */
    var _calculateFontFamily = function(minVal, maxVal, hasNullValue){
      if(minVal === undefined && maxVal === undefined){
        fontColorScale = d3.scale.ordinal().domain([[]]).range([tagStyle.color]);
      }else{
        fontColorScale = MeasureBasedColoring.getScale(minVal, maxVal, 5, options.startColor, options.endColor);
        
        if(hasNullValue){
          var domains = fontColorScale.domain();
          var ranges = fontColorScale.range();
          domains.push([]);
          ranges.push(tagStyle.color);
        }
      }
    };
    
    var _calculateTagPosition = function(){
      var layout;
      if(layoutMode === 'Column'){
        layout = ColumnLayout();
      } else if(layoutMode === 'Row'){
        layout = RowLayout();
      } else if(layoutMode === 'Wordle'){
        layout = WordleLayout();
      }
      
      if(layout !== undefined){
        //TODO remove me
        var start = (new Date()).valueOf();
        layout.width(width).height(height).data(tagArr).font(tagStyle.fontfamily).textDirection(textDirection).layout();
        var end = (new Date()).valueOf();
        //console.log(options.layout, start, end, end-start);
      }
    };
    
    var _handleNullValue = function(value){
      return (value === null || value === undefined) ? defaultString : value;
    };

    function getCSSStyle() {
      style.hoverline = ctx.styleManager.queryDefault(CSSCLASS_HOVERLINE);
    }

    getCSSStyle();
    return chart;
  };
  return tagCloud;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.TagCloud',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.tagcloud',
  version : '4.0.2'
},
{  qname : 'sap.viz.feeds.TagCloud',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.tagcloud',
    'type' : Constants.Module.Type.Chart,
    'name' : 'tagcloud',
    'properties' : {
      'layout':{
        'name' : 'layout',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'mode' : {
            'name' : 'mode',
            'supportedValueType' : 'List',
            'supportedValues' : [ 'Row', 'Column', 'Wordle' ],
            'defaultValue' : 'Wordle',
            'description' : 'Set layout mode of tag cloud.'
          },
          'textDirection':{
            'name' : 'textDirection',
            'supportedValueType' : 'List',
            'supportedValues' : [ 'Mixed', 'Vertical', 'Horizontal' ],
            'defaultValue' : 'Mixed',
            'description' : 'Set text direction of tagcloud. Only taking effect when layout mode is set to \'Wordle\'.'        
          }
        },
        'description' : 'Settings for layout options of tagcloud.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data updating animation of plot area.'
            },
            'resizing' : {
              'name' : 'resizing',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable resizing animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
        },
      'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set tagCloud start color.'
        },
        
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set tagCloud endcolor.'
        },
        'tooltip' : {
          'name' : 'tooltip',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'enabled' : {
              'name' : 'enabled',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled tooltip.'
            }
          },
          'isExported' : false,
          'description' : 'Settings for tooltip related properties.'
        }
    },
    'events' : {
      'initialized': Constants.Module.Event.Initialized.desc,
        'selectData' : Constants.Module.Event.SelectData.desc,
        'deselectData' : Constants.Module.Event.DeSelectData.desc,
        'showTooltip' : Constants.Module.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Module.Event.TooltipHide.desc

    },
    'feeds' : {
      id : "tagCloud"
    },
    'css' : {
        '.v-hovershadow' : {
            'description' : 'Define style for hover shadow color.',
            'value' : {
                'fill' : '#cccccc',
            }
        }
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.TagCloudChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.TagCloud',
  version : '4.0.2'
}
],
function Setup(Manifest, Constants) {
  var chart = {
    id : 'viz/tagcloud',
    name : 'IDS_TAGCLOUDCHART',
    base : 'riv/base/single',
    modules : {
      root : {
        configure : {
          properties : {
            layout : { adjustPolicy : Constants.LAYOUT_ADJUST_POLICY.RELAYOUT }
          }
        },
        modules : {
          legends : {
            modules : {
            layout : {
              id : 'sap.viz.modules.layout.stack'
            },
              legend : {
                feeds : [],
                configure : {
                  'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
                  properties : {
                    type : 'MeasureBasedColoringLegend',
					layout:{
						position: 'right',
						priotity: 1
					}
                  },
                  propertiesOverride : {
                    isHierarchical : {
                      isExported : false
                    },
                    formatString: {
                      isExported: true
                    }
                  }
                }
              }
            }
          },
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'tagcloud',
                  orientation : 'bottom'
                }
              }
            },
        
          interaction : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              clientID : "main",
              propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
                }
             }
           },
        
          main : {
            modules : {
              dataLabel:null,
              plot : {
                id : 'sap.viz.modules.tagcloud',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'root.legends.legend',
        target : 'mbcLegendInfo',
        sourceModule : 'root.main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'root.legends.legend',
          target : 'setSelectionMode',
          sourceModule : 'root.interaction',
          source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'root.interaction',
        listener : 'registerEvent',
        sourceModule : 'root.main.plot',
        type : 'initialized.interaction'
      },  {
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'root.legends.legend',
            listener : 'deselectLegend',
            sourceModule : 'root.interaction',
            type : 'deselectLegend'
      }, {
        targetModule : 'root.tooltip',
        listener : 'showTooltip',
        sourceModule : 'root.main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'root.tooltip',
        listener : 'hideTooltip',
        sourceModule : 'root.main.plot',
        type : 'hideTooltip'
      }, {
        targetModule : 'root.interaction',
        listener : 'defaultSelection',
        sourceModule : 'root.main.plot',
        type : 'initialized.defaultSelection'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.RadarChart',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.RootContainer',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.2'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/radar',
    name : 'IDS_RADARCHART',
    base : "riv/base/single",
    modules : {
      root : {
        modules : {
          legends : {
            modules : {
              legend : {
                id : "sap.viz.modules.legend.common",
                data : { aa : [ 2, 3 ] }
              }
            }
          },
          tooltip : {
            id : "sap.viz.modules.tooltip",
            configure : {
            propertyCategory : 'tooltip',
              properties : {
                chartType : "radar",
                orientation : "left"
              }
            }
          },
          
          interaction : {
            id : "sap.viz.modules.controller.interaction",
            configure : {
              clientID : "main",
              propertyCategory : "interaction",
              properties : {
                supportedEventNames : [ "mousemove", "mouseup", "touchstart" ]
              }
            }
          },
          
          main : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot: {
                id : 'sap.viz.modules.radar',
                configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }    
              },
              dataLabel : {
                id : 'sap.viz.modules.datalabel',
                configure : {
                  propertyCategory : 'dataLabel',
                  properties : {
                    paintingMode : 'rectCoordinate',
                    visible : false,
                    orientation : 'vertical',
                    position : 'outside',
                    automaticInOutside : false,
                    showZero : true,
                    isStackMode : false,
                    isPercentMode : false,
                    outsideVisible : true,
                    outsidePosition : 'up',
                    positionPreference : true
                  }
                }
              }
            }
          }
        }
      }
    },
    dependencies : {
      attributes : 
      [
        {
          targetModule : "root.legends.legend",
          target : "colorPalette",
          sourceModule : "root.main.plot",
          source : "colorPalette"
        },  {
          targetModule : 'root.legends.legend',
          target : 'shapes',
          sourceModule : 'root.main.plot',
          source : 'shapes'
        }, {
            targetModule : 'root.legends.legend',
            target : 'setSelectionMode',
            sourceModule : 'root.interaction',
            source : 'getSelectionMode'
        } 
      ],
      events : 
      [
        {
          targetModule : "root.interaction",
          listener : "registerEvent",
          sourceModule : "root.main.plot",
          type : "initialized.interaction"
        },{
          targetModule : 'root.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'root.legends.legend',
          type : 'highlightedByLegend'
        }, {
          targetModule : 'root.legends.legend',
          listener : 'deselectLegend',
          sourceModule : 'root.interaction',
          type : 'deselectLegend'
        }, {
          targetModule : "root.tooltip",
          listener : "showTooltip",
          sourceModule : "root.main.plot",
          type : "showTooltip"
        }, {
          targetModule : "root.tooltip",
          listener : "hideTooltip",
          sourceModule : "root.main.plot",
          type : "hideTooltip"
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'showLabel',
          sourceModule : 'root.main.plot',
          type : 'initialized.datalabel'
        }, {
          targetModule : 'root.main.dataLabel',
          listener : 'removeLabel',
          sourceModule : 'root.main.plot',
          type : 'startToInit.datalabel'
        }, {
          targetModule : 'root.interaction',
          listener : 'defaultSelection',
          sourceModule : 'root.main.plot',
          type : 'initialized.defaultSelection'
        }
      ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.load',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.manifests.RadarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.TagCloudChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.HeatMapChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.TreeMapChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.scatter.BubbleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.scatter.ScatterChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiBubbleChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.ScatterMatrixChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualLineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualHorizontalLineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.pie.DonutChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.pie.DonutWithDepthChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.pie.PieWithDepthChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiPieWithDepthChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDonutChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDonutWithDepthChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.PercentageStackedVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.PercentageStackedBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualPercentageStackedBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualPercentageStackedVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.ImageBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalWaterfallChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.WaterfallChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.StackedWaterfallChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalStackedWaterfallChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualHorizontalLineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualLineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualCombinationChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.DualHorizontalCombinationChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.VerticalBoxplotChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalBoxplotChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.MekkoChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.PercentageMekkoChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalMekkoChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.PercentageHorizontalMekkoChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.AreaChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.PercentageAreaChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.HorizontalAreaChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xy.PercentageHorizontalAreaChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xyz.Column3DChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.xyz.Bar3DChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiRadarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiPercentageStackedBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiPercentageStackedVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualPercentageStackedBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiDualPercentageStackedVerticalBarChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiAreaChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiPercentageAreaChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiHorizontalAreaChart',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifests.MultiPercentageHorizontalAreaChart',
  version : '4.0.2'
}
],
function Setup() {return;});sap.riv.module(
{
  qname : 'sap.viz.base.utils.SVGTransformParser',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.Logger',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
function Setup(LOG, FuncUtils) {

	var transformMatrixMultiply = function(m1, m2) {
		var result = [];
		for ( var i = 0; i < 3; i++) {
			result[i] = [];
			for ( var j = 0; j < 3; j++) {
				var sum = 0;
				for ( var k = 0; k < 3; k++) {
					sum += m1[i][k] * m2[k][j];
				}
				result[i][j] = sum;
			}
		}
		return result;
	};

	var buildRotateMatrix = function(args) {
		var cosA = Math.cos(args.rad);
		var sinA = Math.sin(args.rad);
		return [ [ cosA, -sinA, -args.cx * cosA + args.cy * sinA + args.cx ],
				[ sinA, cosA, -args.cx * sinA - args.cy * cosA + args.cy ], [ 0, 0, 1 ] ];
	};

	var _dbg_withtrace = false;
	var _dbg_string = '';

	function __dbg_print(text) {
		_dbg_string += text + '\n';
	}

	function __lex(info) {
		var state = 0;
		var match = -1;
		var match_pos = 0;
		var start = 0;
		var pos = info.offset + 1;

		do {
			pos--;
			state = 0;
			match = -2;
			start = pos;

			if (info.src.length <= start)
				return 33;

			do {

				switch (state) {
				case 0:
					if ((info.src.charCodeAt(pos) >= 9 && info.src.charCodeAt(pos) <= 10)
							|| info.src.charCodeAt(pos) == 13 || info.src.charCodeAt(pos) == 32)
						state = 1;
					else if (info.src.charCodeAt(pos) == 40)
						state = 2;
					else if (info.src.charCodeAt(pos) == 41)
						state = 3;
					else if (info.src.charCodeAt(pos) == 43 || info.src.charCodeAt(pos) == 45)
						state = 4;
					else if (info.src.charCodeAt(pos) == 44)
						state = 5;
					else if (info.src.charCodeAt(pos) == 46)
						state = 6;
					else if ((info.src.charCodeAt(pos) >= 48 && info.src.charCodeAt(pos) <= 57))
						state = 7;
					else if (info.src.charCodeAt(pos) == 69 || info.src.charCodeAt(pos) == 101)
						state = 8;
					else if (info.src.charCodeAt(pos) == 109)
						state = 15;
					else if (info.src.charCodeAt(pos) == 114)
						state = 16;
					else if (info.src.charCodeAt(pos) == 115)
						state = 17;
					else if (info.src.charCodeAt(pos) == 116)
						state = 18;
					else
						state = -1;
					break;

				case 1:
					state = -1;
					match = 1;
					match_pos = pos;
					break;

				case 2:
					state = -1;
					match = 7;
					match_pos = pos;
					break;

				case 3:
					state = -1;
					match = 8;
					match_pos = pos;
					break;

				case 4:
					state = -1;
					match = 3;
					match_pos = pos;
					break;

				case 5:
					state = -1;
					match = 6;
					match_pos = pos;
					break;

				case 6:
					state = -1;
					match = 5;
					match_pos = pos;
					break;

				case 7:
					if ((info.src.charCodeAt(pos) >= 48 && info.src.charCodeAt(pos) <= 57))
						state = 7;
					else
						state = -1;
					match = 2;
					match_pos = pos;
					break;

				case 8:
					state = -1;
					match = 4;
					match_pos = pos;
					break;

				case 9:
					state = -1;
					match = 12;
					match_pos = pos;
					break;

				case 10:
					state = -1;
					match = 9;
					match_pos = pos;
					break;

				case 11:
					state = -1;
					match = 10;
					match_pos = pos;
					break;

				case 12:
					state = -1;
					match = 14;
					match_pos = pos;
					break;

				case 13:
					state = -1;
					match = 11;
					match_pos = pos;
					break;

				case 14:
					state = -1;
					match = 13;
					match_pos = pos;
					break;

				case 15:
					if (info.src.charCodeAt(pos) == 97)
						state = 19;
					else
						state = -1;
					break;

				case 16:
					if (info.src.charCodeAt(pos) == 111)
						state = 37;
					else
						state = -1;
					break;

				case 17:
					if (info.src.charCodeAt(pos) == 99)
						state = 20;
					else if (info.src.charCodeAt(pos) == 107)
						state = 21;
					else
						state = -1;
					break;

				case 18:
					if (info.src.charCodeAt(pos) == 114)
						state = 38;
					else
						state = -1;
					break;

				case 19:
					if (info.src.charCodeAt(pos) == 116)
						state = 22;
					else
						state = -1;
					break;

				case 20:
					if (info.src.charCodeAt(pos) == 97)
						state = 23;
					else
						state = -1;
					break;

				case 21:
					if (info.src.charCodeAt(pos) == 101)
						state = 24;
					else
						state = -1;
					break;

				case 22:
					if (info.src.charCodeAt(pos) == 114)
						state = 26;
					else
						state = -1;
					break;

				case 23:
					if (info.src.charCodeAt(pos) == 108)
						state = 28;
					else
						state = -1;
					break;

				case 24:
					if (info.src.charCodeAt(pos) == 119)
						state = 29;
					else
						state = -1;
					break;

				case 25:
					if (info.src.charCodeAt(pos) == 110)
						state = 30;
					else
						state = -1;
					break;

				case 26:
					if (info.src.charCodeAt(pos) == 105)
						state = 31;
					else
						state = -1;
					break;

				case 27:
					if (info.src.charCodeAt(pos) == 116)
						state = 32;
					else
						state = -1;
					break;

				case 28:
					if (info.src.charCodeAt(pos) == 101)
						state = 9;
					else
						state = -1;
					break;

				case 29:
					if (info.src.charCodeAt(pos) == 88)
						state = 10;
					else if (info.src.charCodeAt(pos) == 89)
						state = 11;
					else
						state = -1;
					break;

				case 30:
					if (info.src.charCodeAt(pos) == 115)
						state = 33;
					else
						state = -1;
					break;

				case 31:
					if (info.src.charCodeAt(pos) == 120)
						state = 12;
					else
						state = -1;
					break;

				case 32:
					if (info.src.charCodeAt(pos) == 101)
						state = 13;
					else
						state = -1;
					break;

				case 33:
					if (info.src.charCodeAt(pos) == 108)
						state = 34;
					else
						state = -1;
					break;

				case 34:
					if (info.src.charCodeAt(pos) == 97)
						state = 35;
					else
						state = -1;
					break;

				case 35:
					if (info.src.charCodeAt(pos) == 116)
						state = 36;
					else
						state = -1;
					break;

				case 36:
					if (info.src.charCodeAt(pos) == 101)
						state = 14;
					else
						state = -1;
					break;

				case 37:
					if (info.src.charCodeAt(pos) == 116)
						state = 39;
					else
						state = -1;
					break;

				case 38:
					if (info.src.charCodeAt(pos) == 97)
						state = 25;
					else
						state = -1;
					break;

				case 39:
					if (info.src.charCodeAt(pos) == 97)
						state = 27;
					else
						state = -1;
					break;

				}

				pos++;

			} while (state > -1);

		} while (1 > -1 && match == 1);

		if (match > -1) {
			info.att = info.src.substr(start, match_pos - start);
			info.offset = match_pos;

		} else {
			info.att = new String();
			match = -1;
		}

		return match;
	}

	/* Pop-Table */
	var pop_tab = new Array(new Array(0/* transform_list' */, 1), new Array(16/* transform_list */, 1), new Array(
			16/* transform_list */, 0), new Array(15/* transforms */, 1), new Array(15/* transforms */, 3),
			new Array(17/* transform */, 1), new Array(17/* transform */, 1), new Array(17/* transform */, 1),
			new Array(17/* transform */, 1), new Array(17/* transform */, 1), new Array(17/* transform */, 1),
			new Array(19/* matrix */, 14), new Array(26/* translate_sequence */, 1), new Array(
					26/* translate_sequence */, 3), new Array(20/* translate */, 4), new Array(
					27/* scale_sequence */, 1), new Array(27/* scale_sequence */, 3), new Array(21/* scale */, 4),
			new Array(28/* rotate_sequence */, 1), new Array(28/* rotate_sequence */, 5), new Array(22/* rotate */,
					4), new Array(23/* skewX */, 4), new Array(24/* skewY */, 4), new Array(25/* number */, 1),
			new Array(25/* number */, 1), new Array(25/* number */, 2), new Array(25/* number */, 2), new Array(
					18/* opt-comma-wsp */, 1), new Array(18/* opt-comma-wsp */, 0), new Array(
					29/* integer-constant */, 1), new Array(30/* floating-point-constant */, 1), new Array(
					30/* floating-point-constant */, 2), new Array(30/* floating-point-constant */, 2), new Array(
					31/* fractional-constant */, 2), new Array(31/* fractional-constant */, 2), new Array(
					31/* fractional-constant */, 3), new Array(32/* exponent */, 2), new Array(32/* exponent */, 3));

	/* Action-Table */
	var act_tab = new Array(
	/* State 0 */new Array(14/* "MATRIX_INDICATOR" */, 10, 13/* "TRANSLATE_INDICATOR" */, 11,
			12/* "SCALE_INDICATOR" */, 12, 11/* "ROTATE_INDICATOR" */, 13, 9/* "SKEW_X_INDICATOR" */, 14,
			10/* "SKEW_Y_INDICATOR" */, 15, 33/* "$" */, -2),
	/* State 1 */new Array(33/* "$" */, 0),
	/* State 2 */new Array(33/* "$" */, -1),
	/* State 3 */new Array(6/* "COMMA" */, 17, 33/* "$" */, -3, 14/* "MATRIX_INDICATOR" */, -28,
			13/* "TRANSLATE_INDICATOR" */, -28, 12/* "SCALE_INDICATOR" */, -28, 11/* "ROTATE_INDICATOR" */, -28,
			9/* "SKEW_X_INDICATOR" */, -28, 10/* "SKEW_Y_INDICATOR" */, -28),
	/* State 4 */new Array(33/* "$" */, -5, 6/* "COMMA" */, -5, 14/* "MATRIX_INDICATOR" */, -5,
			13/* "TRANSLATE_INDICATOR" */, -5, 12/* "SCALE_INDICATOR" */, -5, 11/* "ROTATE_INDICATOR" */, -5,
			9/* "SKEW_X_INDICATOR" */, -5, 10/* "SKEW_Y_INDICATOR" */, -5),
	/* State 5 */new Array(33/* "$" */, -6, 6/* "COMMA" */, -6, 14/* "MATRIX_INDICATOR" */, -6,
			13/* "TRANSLATE_INDICATOR" */, -6, 12/* "SCALE_INDICATOR" */, -6, 11/* "ROTATE_INDICATOR" */, -6,
			9/* "SKEW_X_INDICATOR" */, -6, 10/* "SKEW_Y_INDICATOR" */, -6),
	/* State 6 */new Array(33/* "$" */, -7, 6/* "COMMA" */, -7, 14/* "MATRIX_INDICATOR" */, -7,
			13/* "TRANSLATE_INDICATOR" */, -7, 12/* "SCALE_INDICATOR" */, -7, 11/* "ROTATE_INDICATOR" */, -7,
			9/* "SKEW_X_INDICATOR" */, -7, 10/* "SKEW_Y_INDICATOR" */, -7),
	/* State 7 */new Array(33/* "$" */, -8, 6/* "COMMA" */, -8, 14/* "MATRIX_INDICATOR" */, -8,
			13/* "TRANSLATE_INDICATOR" */, -8, 12/* "SCALE_INDICATOR" */, -8, 11/* "ROTATE_INDICATOR" */, -8,
			9/* "SKEW_X_INDICATOR" */, -8, 10/* "SKEW_Y_INDICATOR" */, -8),
	/* State 8 */new Array(33/* "$" */, -9, 6/* "COMMA" */, -9, 14/* "MATRIX_INDICATOR" */, -9,
			13/* "TRANSLATE_INDICATOR" */, -9, 12/* "SCALE_INDICATOR" */, -9, 11/* "ROTATE_INDICATOR" */, -9,
			9/* "SKEW_X_INDICATOR" */, -9, 10/* "SKEW_Y_INDICATOR" */, -9),
	/* State 9 */new Array(33/* "$" */, -10, 6/* "COMMA" */, -10, 14/* "MATRIX_INDICATOR" */, -10,
			13/* "TRANSLATE_INDICATOR" */, -10, 12/* "SCALE_INDICATOR" */, -10, 11/* "ROTATE_INDICATOR" */, -10,
			9/* "SKEW_X_INDICATOR" */, -10, 10/* "SKEW_Y_INDICATOR" */, -10),
	/* State 10 */new Array(7/* "LEFT_P" */, 18),
	/* State 11 */new Array(7/* "LEFT_P" */, 19),
	/* State 12 */new Array(7/* "LEFT_P" */, 20),
	/* State 13 */new Array(7/* "LEFT_P" */, 21),
	/* State 14 */new Array(7/* "LEFT_P" */, 22),
	/* State 15 */new Array(7/* "LEFT_P" */, 23),
	/* State 16 */new Array(14/* "MATRIX_INDICATOR" */, 10, 13/* "TRANSLATE_INDICATOR" */, 11,
			12/* "SCALE_INDICATOR" */, 12, 11/* "ROTATE_INDICATOR" */, 13, 9/* "SKEW_X_INDICATOR" */, 14,
			10/* "SKEW_Y_INDICATOR" */, 15),
	/* State 17 */new Array(14/* "MATRIX_INDICATOR" */, -27, 13/* "TRANSLATE_INDICATOR" */, -27,
			12/* "SCALE_INDICATOR" */, -27, 11/* "ROTATE_INDICATOR" */, -27, 9/* "SKEW_X_INDICATOR" */, -27,
			10/* "SKEW_Y_INDICATOR" */, -27, 3/* "SIGN" */, -27, 2/* "DIGIT-SEQUENCE" */, -27,
			5/* "DECIMAL_DOT" */, -27),
	/* State 18 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 19 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 20 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 21 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 22 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 23 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 24 */new Array(33/* "$" */, -4),
	/* State 25 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 26 */new Array(6/* "COMMA" */, -23, 3/* "SIGN" */, -23, 2/* "DIGIT-SEQUENCE" */, -23,
			5/* "DECIMAL_DOT" */, -23, 8/* "RIGHT_P" */, -23),
	/* State 27 */new Array(6/* "COMMA" */, -24, 3/* "SIGN" */, -24, 2/* "DIGIT-SEQUENCE" */, -24,
			5/* "DECIMAL_DOT" */, -24, 8/* "RIGHT_P" */, -24),
	/* State 28 */new Array(2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 29 */new Array(5/* "DECIMAL_DOT" */, 43, 4/* "EXPONENT_INDICATOR" */, 45, 6/* "COMMA" */, -29,
			3/* "SIGN" */, -29, 2/* "DIGIT-SEQUENCE" */, -29, 8/* "RIGHT_P" */, -29),
	/* State 30 */new Array(4/* "EXPONENT_INDICATOR" */, 45, 6/* "COMMA" */, -30, 3/* "SIGN" */, -30,
			2/* "DIGIT-SEQUENCE" */, -30, 5/* "DECIMAL_DOT" */, -30, 8/* "RIGHT_P" */, -30),
	/* State 31 */new Array(2/* "DIGIT-SEQUENCE" */, 47),
	/* State 32 */new Array(8/* "RIGHT_P" */, 48),
	/* State 33 */new Array(6/* "COMMA" */, 17, 8/* "RIGHT_P" */, -12, 3/* "SIGN" */, -28,
			2/* "DIGIT-SEQUENCE" */, -28, 5/* "DECIMAL_DOT" */, -28),
	/* State 34 */new Array(8/* "RIGHT_P" */, 50),
	/* State 35 */new Array(6/* "COMMA" */, 17, 8/* "RIGHT_P" */, -15, 3/* "SIGN" */, -28,
			2/* "DIGIT-SEQUENCE" */, -28, 5/* "DECIMAL_DOT" */, -28),
	/* State 36 */new Array(8/* "RIGHT_P" */, 52),
	/* State 37 */new Array(6/* "COMMA" */, 17, 8/* "RIGHT_P" */, -18, 3/* "SIGN" */, -28,
			2/* "DIGIT-SEQUENCE" */, -28, 5/* "DECIMAL_DOT" */, -28),
	/* State 38 */new Array(8/* "RIGHT_P" */, 54),
	/* State 39 */new Array(8/* "RIGHT_P" */, 55),
	/* State 40 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 41 */new Array(6/* "COMMA" */, -26, 3/* "SIGN" */, -26, 2/* "DIGIT-SEQUENCE" */, -26,
			5/* "DECIMAL_DOT" */, -26, 8/* "RIGHT_P" */, -26),
	/* State 42 */new Array(6/* "COMMA" */, -25, 3/* "SIGN" */, -25, 2/* "DIGIT-SEQUENCE" */, -25,
			5/* "DECIMAL_DOT" */, -25, 8/* "RIGHT_P" */, -25),
	/* State 43 */new Array(2/* "DIGIT-SEQUENCE" */, 57, 6/* "COMMA" */, -34, 3/* "SIGN" */, -34,
			5/* "DECIMAL_DOT" */, -34, 4/* "EXPONENT_INDICATOR" */, -34, 8/* "RIGHT_P" */, -34),
	/* State 44 */new Array(6/* "COMMA" */, -32, 3/* "SIGN" */, -32, 2/* "DIGIT-SEQUENCE" */, -32,
			5/* "DECIMAL_DOT" */, -32, 8/* "RIGHT_P" */, -32),
	/* State 45 */new Array(3/* "SIGN" */, 58, 2/* "DIGIT-SEQUENCE" */, 59),
	/* State 46 */new Array(6/* "COMMA" */, -31, 3/* "SIGN" */, -31, 2/* "DIGIT-SEQUENCE" */, -31,
			5/* "DECIMAL_DOT" */, -31, 8/* "RIGHT_P" */, -31),
	/* State 47 */new Array(6/* "COMMA" */, -33, 3/* "SIGN" */, -33, 2/* "DIGIT-SEQUENCE" */, -33,
			5/* "DECIMAL_DOT" */, -33, 4/* "EXPONENT_INDICATOR" */, -33, 8/* "RIGHT_P" */, -33),
	/* State 48 */new Array(33/* "$" */, -14, 6/* "COMMA" */, -14, 14/* "MATRIX_INDICATOR" */, -14,
			13/* "TRANSLATE_INDICATOR" */, -14, 12/* "SCALE_INDICATOR" */, -14, 11/* "ROTATE_INDICATOR" */, -14,
			9/* "SKEW_X_INDICATOR" */, -14, 10/* "SKEW_Y_INDICATOR" */, -14),
	/* State 49 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 50 */new Array(33/* "$" */, -17, 6/* "COMMA" */, -17, 14/* "MATRIX_INDICATOR" */, -17,
			13/* "TRANSLATE_INDICATOR" */, -17, 12/* "SCALE_INDICATOR" */, -17, 11/* "ROTATE_INDICATOR" */, -17,
			9/* "SKEW_X_INDICATOR" */, -17, 10/* "SKEW_Y_INDICATOR" */, -17),
	/* State 51 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 52 */new Array(33/* "$" */, -20, 6/* "COMMA" */, -20, 14/* "MATRIX_INDICATOR" */, -20,
			13/* "TRANSLATE_INDICATOR" */, -20, 12/* "SCALE_INDICATOR" */, -20, 11/* "ROTATE_INDICATOR" */, -20,
			9/* "SKEW_X_INDICATOR" */, -20, 10/* "SKEW_Y_INDICATOR" */, -20),
	/* State 53 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 54 */new Array(33/* "$" */, -21, 6/* "COMMA" */, -21, 14/* "MATRIX_INDICATOR" */, -21,
			13/* "TRANSLATE_INDICATOR" */, -21, 12/* "SCALE_INDICATOR" */, -21, 11/* "ROTATE_INDICATOR" */, -21,
			9/* "SKEW_X_INDICATOR" */, -21, 10/* "SKEW_Y_INDICATOR" */, -21),
	/* State 55 */new Array(33/* "$" */, -22, 6/* "COMMA" */, -22, 14/* "MATRIX_INDICATOR" */, -22,
			13/* "TRANSLATE_INDICATOR" */, -22, 12/* "SCALE_INDICATOR" */, -22, 11/* "ROTATE_INDICATOR" */, -22,
			9/* "SKEW_X_INDICATOR" */, -22, 10/* "SKEW_Y_INDICATOR" */, -22),
	/* State 56 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 57 */new Array(6/* "COMMA" */, -35, 3/* "SIGN" */, -35, 2/* "DIGIT-SEQUENCE" */, -35,
			5/* "DECIMAL_DOT" */, -35, 4/* "EXPONENT_INDICATOR" */, -35, 8/* "RIGHT_P" */, -35),
	/* State 58 */new Array(2/* "DIGIT-SEQUENCE" */, 64),
	/* State 59 */new Array(6/* "COMMA" */, -36, 3/* "SIGN" */, -36, 2/* "DIGIT-SEQUENCE" */, -36,
			5/* "DECIMAL_DOT" */, -36, 8/* "RIGHT_P" */, -36),
	/* State 60 */new Array(8/* "RIGHT_P" */, -13),
	/* State 61 */new Array(8/* "RIGHT_P" */, -16),
	/* State 62 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 63 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 64 */new Array(6/* "COMMA" */, -37, 3/* "SIGN" */, -37, 2/* "DIGIT-SEQUENCE" */, -37,
			5/* "DECIMAL_DOT" */, -37, 8/* "RIGHT_P" */, -37),
	/* State 65 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 66 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 67 */new Array(8/* "RIGHT_P" */, -19),
	/* State 68 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 69 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 70 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 71 */new Array(6/* "COMMA" */, 17, 3/* "SIGN" */, -28, 2/* "DIGIT-SEQUENCE" */, -28,
			5/* "DECIMAL_DOT" */, -28),
	/* State 72 */new Array(3/* "SIGN" */, 28, 2/* "DIGIT-SEQUENCE" */, 29, 5/* "DECIMAL_DOT" */, 31),
	/* State 73 */new Array(8/* "RIGHT_P" */, 74),
	/* State 74 */new Array(33/* "$" */, -11, 6/* "COMMA" */, -11, 14/* "MATRIX_INDICATOR" */, -11,
			13/* "TRANSLATE_INDICATOR" */, -11, 12/* "SCALE_INDICATOR" */, -11, 11/* "ROTATE_INDICATOR" */, -11,
			9/* "SKEW_X_INDICATOR" */, -11, 10/* "SKEW_Y_INDICATOR" */, -11));

	/* Goto-Table */
	var goto_tab = new Array(
	/* State 0 */new Array(16/* transform_list */, 1, 15/* transforms */, 2, 17/* transform */, 3, 19/* matrix */,
			4, 20/* translate */, 5, 21/* scale */, 6, 22/* rotate */, 7, 23/* skewX */, 8, 24/* skewY */, 9),
	/* State 1 */new Array(),
	/* State 2 */new Array(),
	/* State 3 */new Array(18/* opt-comma-wsp */, 16),
	/* State 4 */new Array(),
	/* State 5 */new Array(),
	/* State 6 */new Array(),
	/* State 7 */new Array(),
	/* State 8 */new Array(),
	/* State 9 */new Array(),
	/* State 10 */new Array(),
	/* State 11 */new Array(),
	/* State 12 */new Array(),
	/* State 13 */new Array(),
	/* State 14 */new Array(),
	/* State 15 */new Array(),
	/* State 16 */new Array(15/* transforms */, 24, 17/* transform */, 3, 19/* matrix */, 4, 20/* translate */, 5,
			21/* scale */, 6, 22/* rotate */, 7, 23/* skewX */, 8, 24/* skewY */, 9),
	/* State 17 */new Array(),
	/* State 18 */new Array(25/* number */, 25, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 19 */new Array(26/* translate_sequence */, 32, 25/* number */, 33, 29/* integer-constant */, 26,
			30/* floating-point-constant */, 27, 31/* fractional-constant */, 30),
	/* State 20 */new Array(27/* scale_sequence */, 34, 25/* number */, 35, 29/* integer-constant */, 26,
			30/* floating-point-constant */, 27, 31/* fractional-constant */, 30),
	/* State 21 */new Array(28/* rotate_sequence */, 36, 25/* number */, 37, 29/* integer-constant */, 26,
			30/* floating-point-constant */, 27, 31/* fractional-constant */, 30),
	/* State 22 */new Array(25/* number */, 38, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 23 */new Array(25/* number */, 39, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 24 */new Array(),
	/* State 25 */new Array(18/* opt-comma-wsp */, 40),
	/* State 26 */new Array(),
	/* State 27 */new Array(),
	/* State 28 */new Array(30/* floating-point-constant */, 41, 29/* integer-constant */, 42,
			31/* fractional-constant */, 30),
	/* State 29 */new Array(32/* exponent */, 44),
	/* State 30 */new Array(32/* exponent */, 46),
	/* State 31 */new Array(),
	/* State 32 */new Array(),
	/* State 33 */new Array(18/* opt-comma-wsp */, 49),
	/* State 34 */new Array(),
	/* State 35 */new Array(18/* opt-comma-wsp */, 51),
	/* State 36 */new Array(),
	/* State 37 */new Array(18/* opt-comma-wsp */, 53),
	/* State 38 */new Array(),
	/* State 39 */new Array(),
	/* State 40 */new Array(25/* number */, 56, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 41 */new Array(),
	/* State 42 */new Array(),
	/* State 43 */new Array(),
	/* State 44 */new Array(),
	/* State 45 */new Array(),
	/* State 46 */new Array(),
	/* State 47 */new Array(),
	/* State 48 */new Array(),
	/* State 49 */new Array(25/* number */, 60, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 50 */new Array(),
	/* State 51 */new Array(25/* number */, 61, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 52 */new Array(),
	/* State 53 */new Array(25/* number */, 62, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 54 */new Array(),
	/* State 55 */new Array(),
	/* State 56 */new Array(18/* opt-comma-wsp */, 63),
	/* State 57 */new Array(),
	/* State 58 */new Array(),
	/* State 59 */new Array(),
	/* State 60 */new Array(),
	/* State 61 */new Array(),
	/* State 62 */new Array(18/* opt-comma-wsp */, 65),
	/* State 63 */new Array(25/* number */, 66, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 64 */new Array(),
	/* State 65 */new Array(25/* number */, 67, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 66 */new Array(18/* opt-comma-wsp */, 68),
	/* State 67 */new Array(),
	/* State 68 */new Array(25/* number */, 69, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 69 */new Array(18/* opt-comma-wsp */, 70),
	/* State 70 */new Array(25/* number */, 71, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 71 */new Array(18/* opt-comma-wsp */, 72),
	/* State 72 */new Array(25/* number */, 73, 29/* integer-constant */, 26, 30/* floating-point-constant */, 27,
			31/* fractional-constant */, 30),
	/* State 73 */new Array(),
	/* State 74 */new Array());

	/* Symbol labels */
	var labels = new Array("transform_list'" /* Non-terminal symbol */, "WHITESPACE" /*
																						 * Terminal
																						 * symbol
																						 */, "DIGIT-SEQUENCE" /* Terminal symbol */, "SIGN" /* Terminal symbol */,
			"EXPONENT_INDICATOR" /* Terminal symbol */, "DECIMAL_DOT" /*
																		 * Terminal
																		 * symbol
																		 */, "COMMA" /* Terminal symbol */, "LEFT_P" /* Terminal symbol */, "RIGHT_P" /*
																							 * Terminal
																							 * symbol
																							 */, "SKEW_X_INDICATOR" /* Terminal symbol */, "SKEW_Y_INDICATOR" /*
																				 * Terminal
																				 * symbol
																				 */, "ROTATE_INDICATOR" /* Terminal symbol */, "SCALE_INDICATOR" /*
																				 * Terminal
																				 * symbol
																				 */, "TRANSLATE_INDICATOR" /* Terminal symbol */, "MATRIX_INDICATOR" /*
																					 * Terminal
																					 * symbol
																					 */, "transforms" /* Non-terminal symbol */, "transform_list" /*
																			 * Non-terminal
																			 * symbol
																			 */, "transform" /* Non-terminal symbol */, "opt-comma-wsp" /*
																		 * Non-terminal
																		 * symbol
																		 */, "matrix" /* Non-terminal symbol */, "translate" /*
																	 * Non-terminal
																	 * symbol
																	 */, "scale" /* Non-terminal symbol */, "rotate" /*
																 * Non-terminal
																 * symbol
																 */, "skewX" /* Non-terminal symbol */, "skewY" /*
															 * Non-terminal
															 * symbol
															 */,
			"number" /* Non-terminal symbol */, "translate_sequence" /*
																		 * Non-terminal
																		 * symbol
																		 */, "scale_sequence" /* Non-terminal symbol */, "rotate_sequence" /*
																				 * Non-terminal
																				 * symbol
																				 */, "integer-constant" /* Non-terminal symbol */, "floating-point-constant" /*
																							 * Non-terminal
																							 * symbol
																							 */, "fractional-constant" /* Non-terminal symbol */, "exponent" /*
																				 * Non-terminal
																				 * symbol
																				 */, "$" /*
						 * Terminal symbol
						 */
	);

	function __parse(src) {
		var err_cnt = 0, err_off = [], err_la = [];
		var act, go, la;
		var rval = undefined;
		var info = {
			offset : 0,
			src : src,
			att : ''
		};
		var sstack = [ 0 ], vstack = [ 0 ];

		la = __lex(info);

		while (true) {
			act = 76;
			for ( var i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2) {
				if (act_tab[sstack[sstack.length - 1]][i] == la) {
					act = act_tab[sstack[sstack.length - 1]][i + 1];
					break;
				}
			}

			if (_dbg_withtrace && sstack.length > 0) {
				__dbg_print('\\nState ' + sstack[sstack.length - 1] + '\\n' + '\\tLookahead: ' + labels[la] + ' (\\\"'
						+ info.att + '\\\")\\n' + '\\tAction: ' + act + '\\n' + '\\tSource: \\\"'
						+ info.src.substr(info.offset, 30) + ((info.offset + 30 < info.src.length) ? '...' : '')
						+ '\\\"\\n' + '\\tStack: ' + sstack.join() + '\\n' + '\\tValue stack: ' + vstack.join() + '\\n');
			}

			// Panic-mode: Try recovery when parse-error occurs!
			if (act == 76) {
				if (_dbg_withtrace)
					__dbg_print('Error detected: There is no reduce or shift on the symbol ' + labels[la]);

				err_cnt++;
				err_off.push(info.offset - info.att.length);
				err_la.push(new Array());
				for ( var i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2)
					err_la[err_la.length - 1].push(labels[act_tab[sstack[sstack.length - 1]][i]]);

				// Remember the original stack!
				var rsstack = new Array();
				var rvstack = new Array();
				for ( var i = 0; i < sstack.length; i++) {
					rsstack[i] = sstack[i];
					rvstack[i] = vstack[i];
				}

				while (act == 76 && la != 33) {
					if (_dbg_withtrace)
						__dbg_print('\\tError recovery\\n' + 'Current lookahead: ' + labels[la] + ' (' + info.att
								+ ')\\n' + 'Action: ' + act + '\\n\\n');
					if (la == -1)
						info.offset++;

					while (act == 76 && sstack.length > 0) {
						sstack.pop();
						vstack.pop();

						if (sstack.length == 0)
							break;

						act = 76;
						for ( var i = 0; i < act_tab[sstack[sstack.length - 1]].length; i += 2) {
							if (act_tab[sstack[sstack.length - 1]][i] == la) {
								act = act_tab[sstack[sstack.length - 1]][i + 1];
								break;
							}
						}
					}

					if (act != 76)
						break;

					for ( var i = 0; i < rsstack.length; i++) {
						sstack.push(rsstack[i]);
						vstack.push(rvstack[i]);
					}

					la = __lex(info);
				}

				if (act == 76) {
					if (_dbg_withtrace)
						__dbg_print('\\tError recovery failed, terminating parse process...');
					break;
				}

				if (_dbg_withtrace)
					__dbg_print('\\tError recovery succeeded, continuing');
			}

			/*
			 * if( act == 76 ) break;
			 */

			// Shift
			if (act > 0) {
				if (_dbg_withtrace)
					__dbg_print('Shifting symbol: ' + labels[la] + ' (' + info.att + ')');

				sstack.push(act);
				vstack.push(info.att);

				la = __lex(info);

				if (_dbg_withtrace)
					__dbg_print('\\tNew lookahead symbol: ' + labels[la] + ' (' + info.att + ')');
			}
			// Reduce
			else {
				act *= -1;

				if (_dbg_withtrace)
					__dbg_print('Reducing by producution: ' + act);

				rval = void (0);

				if (_dbg_withtrace)
					__dbg_print('\\tPerforming semantic action...');

				switch (act) {
				case 0: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 1: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 2: {
					rval = [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
				}
					break;
				case 3: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 4: {
					rval = transformMatrixMultiply(vstack[vstack.length - 3], vstack[vstack.length - 1]);
				}
					break;
				case 5: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 6: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 7: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 8: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 9: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 10: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 11: {
					rval = [ [ vstack[vstack.length - 12], vstack[vstack.length - 8], vstack[vstack.length - 4] ],
							[ vstack[vstack.length - 10], vstack[vstack.length - 6], vstack[vstack.length - 2] ],
							[ 0, 0, 1 ] ];
				}
					break;
				case 12: {
					rval = {
						tx : vstack[vstack.length - 1],
						ty : 0
					};
				}
					break;
				case 13: {
					rval = {
						tx : vstack[vstack.length - 3],
						ty : vstack[vstack.length - 1]
					};
				}
					break;
				case 14: {
					rval = [ [ 1, 0, vstack[vstack.length - 2].tx ], [ 0, 1, vstack[vstack.length - 2].ty ],
							[ 0, 0, 1 ] ];
				}
					break;
				case 15: {
					rval = {
						sx : vstack[vstack.length - 1],
						sy : vstack[vstack.length - 1]
					};
				}
					break;
				case 16: {
					rval = {
						sx : vstack[vstack.length - 3],
						sy : vstack[vstack.length - 1]
					};
				}
					break;
				case 17: {
					rval = [ [ vstack[vstack.length - 2].sx, 0, 0 ], [ 0, vstack[vstack.length - 2].sy, 0 ],
							[ 0, 0, 1 ] ];
				}
					break;
				case 18: {
					rval = {
						rad : vstack[vstack.length - 1] * Math.PI / 180,
						cx : 0,
						cy : 0
					};
				}
					break;
				case 19: {
					rval = {
						rad : vstack[vstack.length - 5] * Math.PI / 180,
						cx : vstack[vstack.length - 3],
						cy : vstack[vstack.length - 1]
					};
				}
					break;
				case 20: {
					rval = buildRotateMatrix(vstack[vstack.length - 2]);
				}
					break;
				case 21: {
					rval = [ [ 1, Math.tan(vstack[vstack.length - 2] * Math.PI / 180), 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
				}
					break;
				case 22: {
					rval = [ [ 1, 0, 0 ], [ Math.tan(vstack[vstack.length - 2] * Math.PI / 180), 1, 0 ], [ 0, 0, 1 ] ];
				}
					break;
				case 23: {
					rval = parseInt(vstack[vstack.length - 1]);
				}
					break;
				case 24: {
					rval = parseFloat(vstack[vstack.length - 1]);
				}
					break;
				case 25: {
					rval = parseInt(vstack[vstack.length - 2] + vstack[vstack.length - 1]);
				}
					break;
				case 26: {
					rval = parseFloat(vstack[vstack.length - 2] + vstack[vstack.length - 1]);
				}
					break;
				case 27: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 28: {
					rval = vstack[vstack.length - 0];
				}
					break;
				case 29: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 30: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 31: {
					rval = vstack[vstack.length - 2] + 'e' + vstack[vstack.length - 1];
				}
					break;
				case 32: {
					rval = vstack[vstack.length - 2] + 'e' + vstack[vstack.length - 1];
				}
					break;
				case 33: {
					rval = '0.' + vstack[vstack.length - 1];
				}
					break;
				case 34: {
					rval = vstack[vstack.length - 2] + '.0';
				}
					break;
				case 35: {
					rval = vstack[vstack.length - 3] + '.' + vstack[vstack.length - 1];
				}
					break;
				case 36: {
					rval = vstack[vstack.length - 1];
				}
					break;
				case 37: {
					rval = vstack[vstack.length - 2] + vstack[vstack.length - 1];
				}
					break;
				}

				if (_dbg_withtrace)
					__dbg_print('\\tPopping ' + pop_tab[act][1] + ' off the stack...');

				for ( var i = 0; i < pop_tab[act][1]; i++) {
					sstack.pop();
					vstack.pop();
				}

				go = -1;
				for ( var i = 0; i < goto_tab[sstack[sstack.length - 1]].length; i += 2) {
					if (goto_tab[sstack[sstack.length - 1]][i] == pop_tab[act][0]) {
						go = goto_tab[sstack[sstack.length - 1]][i + 1];
						break;
					}
				}

				if (act == 0)
					break;

				if (_dbg_withtrace)
					__dbg_print('\\tPushing non-terminal ' + labels[pop_tab[act][0]]);

				sstack.push(go);
				vstack.push(rval);
			}

			if (_dbg_withtrace) {
				_dbg_string = new String();
				LOG.trace(_dbg_string, 'SVGTranformParser');
			}
		}

		if (_dbg_withtrace) {
			LOG.debug('\\nParse complete.', 'SVGTranformParser');
		}

		if (err_cnt) {
			var errMsg = '';
			for ( var i = 0; i < err_cnt; i++) {
				errMsg += 'Parse error near >' + src.substr(err_off[i], 30) + '<, expecting \\\"' + err_la[i].join()
						+ '\\\"\\n';
			}
			LOG.error(errMsg);
			return false;
		}
		return rval;
	}

	var TransformParser = {
		parse : __parse
	};

	return TransformParser;

});sap.riv.module(
{
  qname : 'sap.viz.base.utils.TransformHelper',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.Math',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.SVGTransformParser',
  version : '4.0.2'
}
],

function Setup(TypeUtils, Math, TransformParser) {
	var isString = TypeUtils.isString, isArray = TypeUtils.isArray;
	var matrixMultiply = function(left, right) {
		if (left[0].length !== right.length)
			return false;
		var row = left.length, col = right[0].length, d = right.length;
		var i = -1, j, k, rowVec, e;
		var result = [];
		while (++i < row) {
			rowVec = [];
			j = -1;
			while (++j < col) {
				k = -1;
				e = 0;
				while (++k < d) {
					e += left[i][k] * right[k][j];
				}
				rowVec.push(e);
			}
			result.push(rowVec);
		}
		return result;
	};
	/**
	 * Static Transform Utility
	 * 
	 * @name sap.viz.base.utils.TransformHelper
	 * @class
	 */
	var TransformHelper = {

		/**
		 * Multiply two matrixes, the two matrixes should be multiply
		 * compatible, otherwise false will be returned.
		 * 
		 * @param {Array}
		 *            left left matrix of the multiplication
		 * @param {Array}
		 *            right right matrix of the multiplication
		 * @returns {Array|false}
		 */
		multiply : matrixMultiply,

		/**
		 * Get the transform matrix by parsing svg transform string, if the
		 * string is not a valid, false will be returned.
		 * 
		 * @param SvgTransform
		 * @returns {Array|false}
		 */
		parse : function(svgTransform) {
			return TransformParser.parse('' + svgTransform);
		},

		/**
		 * Calculate the inversion of a transform. If the transform is not
		 * valid, false will be returned.
		 * 
		 * @param {Array|SvgTransform}
		 *            m the transform to be inverted, either in matrix array
		 *            form or SvgTransform string form.
		 * @returns {Array|false}
		 */
		invert : function(m) {
			if (isString(m)) {
				m = TransformParser.parse(m);
			}
			var a = m[0][0], b = m[0][1], c = m[0][2], d = m[1][0], e = m[1][1], f = m[1][2];
			var det = a * e - b * d;
			if (det != 0) {
				return [ [ e / det, -b / det, (b * f - c * e) / det ], [ -d / det, a / det, (c * d - a * f) / det ],
						[ 0, 0, 1 ] ];
			} else {
				return false;
			}
		},

		/**
		 * Get an identity transform matrix.
		 * 
		 * @return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]
		 */
		identityTransform : function() {
			return [ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
		},

		/**
		 * Make a rotation transform
		 * 
		 * @param {Number}
		 *            angle Rotation angel in radian
		 * @returns {Array}
		 */
		rotate : function(angle) {
			angle = +angle;
			var cosA = Math.cos(angle), sinA = Math.sin(angle);
			return [ [ cosA, -sinA, 0 ], [ sinA, cosA, 0 ], [ 0, 0, 1 ] ];
		},
		/**
		 * Make a translate transform
		 * 
		 * @param {Number}
		 *            tx translate distance in x direction
		 * @param {Number}
		 *            (ty) translate distance in y direction, if omitted, it
		 *            equals 0.
		 * @returns {Array}
		 */
		translate : function(tx, ty) {
			if (arguments.length < 2) {
				ty = 0;
			}
			return [ [ 1, 0, +tx ], [ 0, 1, +ty ], [ 0, 0, 1 ] ];
		},
		/**
		 * Make a scale transform
		 * 
		 * @param {Number}
		 *            sx scale factor in x direction
		 * @param {Number}
		 *            (sy) scale factor in y direction, if omitted, it equals to
		 *            sx.
		 * @returns {Array}
		 */
		scale : function(sx, sy) {
			if (arguments.length < 2) {
				sy = sx;
			}
			return [ [ +sx, 0, 0 ], [ 0, +sy, 0 ], [ 0, 0, 1 ] ];
		},
		/**
		 * Make a transform skew the coordinate system in x direction
		 * 
		 * @param {Number}
		 *            a skewing X coordinates by angle a
		 * @returns {Array}
		 */
		skewX : function(a) {
			return [ [ 1, Math.tan(+a), 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ];
		},

		/**
		 * Make a transform skew the coordinate system in y direction
		 * 
		 * @param {Number}
		 *            a skewing Y coordinates by angle a
		 * @returns {Array}
		 */
		skewY : function(a) {
			return [ [ 1, 0, 0 ], [ Math.tan(+a), 1, 0 ], [ 0, 0, 1 ] ];
		},
		/**
		 * Whether the two transforms are identical
		 * 
		 * @param {transform}
		 *            atm one transform
		 * @param {transform}
		 *            btm another transform
		 * @return {Boolean}
		 */
		isEqualTransform : function(atm, btm) {
			if (isString(atm))
				atm = TransformParser.parse(atm);
			if (isString(btm))
				btm = TransformParser.parse(btm);
			return atm
					&& btm
					&& (atm[0][0] == btm[0][0] && atm[0][1] == btm[0][1] && atm[0][2] == btm[0][2]
							&& atm[1][0] == btm[1][0] && atm[1][1] == btm[1][1] && atm[1][2] == btm[1][2]
							&& atm[2][0] == btm[2][0] && atm[2][1] == btm[2][1] && atm[2][2] == btm[2][2]);
		},
		/**
		 * Whether the matrix is identity matrix, empty string will be treated
		 * as Identity Transform
		 * 
		 * @param {transform|SvgTransform}
		 *            tm the transform matrix or SVG transform string.
		 * @return {Boolean}
		 */
		isIdentityTransform : function(atm) {
			if (isString(atm)) {
				atm = TransformParser.parse(atm);
			}
			return atm
					&& (atm[0][0] == 1 && atm[0][1] == 0 && atm[0][2] == 0 && atm[1][0] == 0 && atm[1][1] == 1
							&& atm[1][2] == 0 && atm[2][0] == 0 && atm[2][1] == 0 && atm[2][2] == 1);
		},
		/**
		 * Whether the matrix is a valid affine transform matrix
		 * 
		 * @param {transform}
		 *            tm the transform to check
		 * @return {Boolean}
		 */
		isValidTransform : function(tm) {
			if (isString(tm)) {
				tm = TransformParser.parse(tm);
			}
			if (!isArray(tm) || tm.length < 3 || tm[0].length < 3) {
				return false;
			}
			return tm && (tm[0][0] * tm[1][1] != tm[1][0] * tm[0][1]);
		},
		/**
		 * Transform a point in current coordinate system into another
		 * coordinate system by given transform.
		 * 
		 * @param {Number|Point}
		 *            x could be the x coordinate of the point or <b>Point</b>
		 *            object.
		 * 
		 * @param {Number|Transform}
		 *            (y) could be the y coordinate of the point or transform.
		 * 
		 * @param {Transform}
		 *            (t) the transform matrix or string in SVG transform format
		 * 
		 * @return {Point}
		 * 
		 * <b>Point</b> object is defined as:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##
		 * }
		 * </pre>
		 */
		transformPoint : function(x, y, t) {
			if (arguments.length === 2) {
				t = y;
				y = +x.y;
				x = +x.x;
			}
			if (isString(t)) {
				t = TransformParser.parse(t);
			}
			return {
				x : t[0][0] * x + t[0][1] * y + t[0][2],
				y : t[1][0] * x + t[1][1] * y + t[1][2]
			};
		},
		/**
		 * Transform a rectangle discribed in current coordinate system into
		 * another coordinate system by given transform.
		 * 
		 * @param {Number|Rect}
		 *            x the x coordinate of the top-left corner of the rectangle
		 *            or <b>Rect</b> object
		 * @param {Number|Transform}
		 *            (y) the y coordinate of the top-left corner of the
		 *            rectangle if the first argument x is designated as the x
		 *            coordinate, otherwise transform matrix or Svg Transform
		 *            string should be specified.
		 * @param {Number}
		 *            (width) the width of the rectangle, should be omitted when
		 *            x is <b>Rect</b> object
		 * 
		 * @param {Number}
		 *            (height) the height of the rectangle, should be omitted
		 *            when x is <b>Rect</b> object
		 * 
		 * @param {Transform}
		 *            (t) the transform applied, could be transform matrix or
		 *            Svg Transform string. Should be used when previous 4
		 *            arguments are used
		 * 
		 * <b>Rect</b> object is defined as:
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @return {Object} transformed rectangle
		 * 
		 */
		transformRect : function(x, y, width, height, t) {
			if (arguments.length === 2) {
				t = y;
				height = +x.height;
				width = +x.width;
				y = +x.y;
				x = +x.x;
			}
			if (isString(t)) {
				t = TransformParser.parse(t);
			}

			var xy = {
				minx : Number.POSITIVE_INFINITY,
				maxx : Number.NEGATIVE_INFINITY,
				miny : Number.POSITIVE_INFINITY,
				maxy : Number.NEGATIVE_INFINITY
			};
			var corners = [
					[ t[0][0] * x + t[0][1] * y + t[0][2], t[1][0] * x + t[1][1] * y + t[1][2] ],
					[ t[0][0] * (x + width) + t[0][1] * y + t[0][2], t[1][0] * (x + width) + t[1][1] * y + t[1][2] ],
					[ t[0][0] * (x + width) + t[0][1] * (y + height) + t[0][2],
							t[1][0] * (x + width) + t[1][1] * (y + height) + t[1][2] ],
					[ t[0][0] * x + t[0][1] * (y + height) + t[0][2], t[1][0] * x + t[1][1] * (y + height) + t[1][2] ] ];
			for ( var i = 0, corner; i < 4; i++) {
				corner = corners[i];
				if (xy.minx > corner[0]) {
					xy.minx = corner[0];
				}
				if (xy.miny > corner[1]) {
					xy.miny = corner[1];
				}
				if (xy.maxx < corner[0]) {
					xy.maxx = corner[0];
				}
				if (xy.maxy < corner[1]) {
					xy.maxy = corner[1];
				}
			}
			return {
				x : xy.minx,
				y : xy.miny,
				width : xy.maxx - xy.minx,
				height : xy.maxy - xy.miny
			};
		},
		/**
		 * Decomposite a 2d transform matrix by translate, scale, skew, rotate
		 * primitive transform, if the transform is not valid, false will be
		 * returned.
		 * 
		 * @param {transform}
		 *            transform the transform to decomposite
		 * @returns {Object} decomposed transform components
		 * 
		 * <pre>
		 * {
		 * 	tx : tx, //translate in x
		 * 	ty : ty, //translate in y
		 * 	sx : sx, //scale in x
		 * 	sy : sy, //scale in y
		 * 	skew : skew, //skew in xy
		 * 	rotate : rotate
		 * //rotation in radians
		 * }
		 * </pre>
		 */
		unmatrix : function(transform) {
			if (isString(transform)) {
				transform = TransformParser.parse(transform);
			}
			if (!transform) {
				return false;
			}
			var a = transform[0][0], b = transform[1][0], c = transform[0][1], d = transform[1][1], tx = transform[0][2], ty = transform[1][2];

			var rot0 = [ a, b ], rot1 = [ c, d ];
			var scaleX = Math.sqrt(a * a + b * b);
			if (scaleX) {
				rot0[0] /= scaleX;
				rot0[1] /= scaleX;
			}

			var scaleZ = rot0[0] * rot1[0] + rot0[1] * rot1[1];
			rot1[0] += -scaleZ * rot0[0];
			rot1[1] += -scaleZ * rot0[1];

			var scaleY = Math.sqrt(rot1[0] * rot1[0] + rot1[1] * rot1[1]) || 0;
			if (scaleY) {
				rot1[0] /= scaleY;
				rot1[1] /= scaleY;
			}

			if (rot0[0] * rot1[1] < rot1[0] * rot0[1]) {
				rot0[0] *= -1;
				rot0[1] *= -1;
				kx *= -1;
				kz *= -1;
			}

			return {
				tx : tx,
				ty : ty,
				sx : scaleX,
				sy : scaleY,
				skew : scaleY ? Math.atan2(scaleZ, scaleY) : 0,
				rotate : scaleX ? Math.atan2(rot0[1], rot0[0]) : Math.atan2(-rot1[0], rot1[1])
			};
		}
	};
	return TransformHelper;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.DomUtils',
  version : '4.0.2'},
[

],
function Setup() {
//	"use strict";
	var expando = ( '' + Math.random() ).replace( /\D/g, "" ), cache = {/*listener, data*/}, guid = 1;
	var DomWrapper = function(elem) {
		if (arguments.length !==1) {
			throw new Error('One and only one argument is expected.');
		}
		if (typeof elem === 'string') {
			if (elem.length < 2 || elem.charAt(0) !== '#') {
				throw new Error('Only support id selector, please start with #');
			}
			var id = elem.substring(1);
			elem = document.getElementById(id);
//			if (!elem) throw new Error("Can't get an element with id = " + id);
		} else if (typeof elem.jquery === 'string') {
			elem = elem[0];
		}
		if (elem && !elem.nodeType) {
			throw new Error("The argument passed in must be an HTML node.");
		}
		this.elem = elem;
	};
	var utils = {
		css: function(elem, name, value) {
			if (typeof name === 'object') {
				for (var key in name) {
					this.css(elem, key, name[key]);
				}
				return;
			}
			//convert name to camelname
			name = name.replace(/^-ms-/, "ms-").replace(/-([\da-z])/gi, function(all, letter) {
				return ( letter + "" ).toUpperCase();
			});
			if (value === undefined) { //get css value
				var ret, 
					style = elem.style;
				if (window.getComputedStyle) {
					var computed = window.getComputedStyle(elem, null);
					// getPropertyValue is only needed for .css('filter') in IE9, see #12537
					ret = computed.getPropertyValue( name ) || computed[ name ];	
					if (ret === '') {
						if ( !utils.contains(elem.ownerDocument, elem) ){ //a doesn't contain b
							ret = style[name];
						}
					}
				} else if (document.documentElement.currentStyle) {
					ret = elem.currentStyle && elem.currentStyle[name];
					if (ret === null && style && style[name])
						ret = style[name];
				}
				return ret;
			}
			//set css value
			if (typeof name === 'object') {
				for (var key in name) {
					this.css(elem, key, name[key]);
				}
			} else {
				if (!isNaN(value))
					value += 'px';
				elem.style[name] = value;
			}
		},		
		getWindow: function( elem ) {
			return elem !== null && elem == elem.window ?
				elem :
				elem.nodeType === 9 ?
					elem.defaultView || elem.parentWindow :
					false;
		},
		contains: function ( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && adown.contains && adown.contains(bup) );
		},
		bodyOffset: function( body ) {
			var top = body.offsetTop,
				left = body.offsetLeft;
	
			if ( body.offsetTop !== 1 ) { //jQuery.support.doesNotIncludeMarginInBodyOffset
				top  += parseFloat( utils.css(body, "marginTop") ) || 0;
				left += parseFloat( utils.css(body, "marginLeft") ) || 0;
			}
	
			return { top: top, left: left };
		}	
	};
	DomWrapper.prototype = {
		constructor: DomWrapper, 
		get: function(idx) {
			if (idx !== 0) throw new Error("Only get(0) is supported");
			return this.elem;
		},
		css: function(name, value) {
			var ret = utils.css(this.elem, name, value);
			if (value === undefined && typeof name !== 'object') return ret;
			return this;
		},
		/*
		 * Note: the logic of computing width & height in jQuery is very complicated, mainly deal with window and document,
		 * here we call css only to get its value because in most cases we don't query width & height of window or document
		 * 
		 */
		width: function(value) { 
			if (this.elem == this.elem.window || this.elem.nodeType === 9) {
				throw new Error("this method does not support window or document");
			}
			if (arguments.length === 0) {
				var val = this.css('width'),
					num = parseFloat(val);
				return isNaN(num) ? 0 : num;
			}
			return this.css('width', value);
		},
		height: function(value) {
			if (this.elem == this.elem.window || this.elem.nodeType === 9) {
				throw new Error("this method does not support window or document");
			}
			if (arguments.length === 0) {
				var val = this.css('height'),
					num = parseFloat(val);
				return isNaN(num) ? 0 : num;
			}
			return this.css('height', value);
		},
		offset: function() {
			if (arguments.length) throw new Error("Don't support set offset.");
			var docElem, body, win, clientTop, clientLeft, scrollTop, scrollLeft,
				box = { top: 0, left: 0 },
				elem = this.elem,
				doc = elem && elem.ownerDocument;
		
			if ( !doc ) {
				return;
			}
		
			if ( (body = doc.body) === elem ) {
				return utils.bodyOffset( elem );
			}
		
			docElem = doc.documentElement;
		
			// Make sure it's not a disconnected DOM node
			if ( !utils.contains( docElem, elem ) ) {
				return box;
			}
		
			// If we don't have gBCR, just use 0,0 rather than error
			// BlackBerry 5, iOS 3 (original iPhone)
			if ( typeof elem.getBoundingClientRect !== "undefined" ) {
				box = elem.getBoundingClientRect();
			}
			win = utils.getWindow( doc );
			clientTop  = docElem.clientTop  || body.clientTop  || 0;
			clientLeft = docElem.clientLeft || body.clientLeft || 0;
			scrollTop  = win.pageYOffset || docElem.scrollTop;
			scrollLeft = win.pageXOffset || docElem.scrollLeft;
			return {
				top: box.top  + scrollTop  - clientTop,
				left: box.left + scrollLeft - clientLeft
			};			
		},
		attr: function(name, value) {
			if (arguments.length === 1) {
				return this.elem.getAttribute(name);
			} else if (arguments.length === 2){
				this.elem.setAttribute(name, value);
				return this;
			} else {
				throw new Error('Illegal argument number = ' + arguments.length);
			}
		},
//		append: function(child) {
//			if (child instanceof this.constructor) child = child.elem;
//			this.elem.appendChild(child);
//		},
//		prepend: function(newElem) {
//			if (newElem instanceof this.constructor) newElem = newElem.elem;
//			this.elem.insertBefore(newElem, this.elem.firstChild);
//		},
//		insertBefore: function(newElem) {
//			if (newElem instanceof this.constructor) newElem = newElem.elem;
//			if (this.elem.parentNode) {
//				this.elem.parentNode.insertBefore(newElem, this.elem);
//			}
//		},
//		insertAfter: function(newElem) {
//			if (newElem instanceof this.constructor) newElem = newElem.elem;
//			if (this.elem.parentNode) {
//				this.elem.parentNode.insertAfter(newElem, this.elem);
//			}
//		},
		detach: function() {
			if (this.elem && this.elem.parentNode) 
				this.elem.parentNode.removeChild(this.elem);
			this.elem = undefined;
		},
		parent: function() {
			var cur = this.elem;
			while (cur && cur.nodeType !== 9) {
				cur = cur.parentNode;
				if (cur.nodeType === 1) {
					break;
				}
			}
			return DomUtils(cur);
		},
		offsetParent: function () {
		    function nodeName( elem, name ) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
            }
            return (function() {
                var offsetParent = this.offsetParent || document.documentElement;
                while ( offsetParent && ( !nodeName( offsetParent, "html" ) && (new DomWrapper(offsetParent)).css("position") === "static" ) ) {
                    offsetParent = offsetParent.offsetParent;
                }
                return offsetParent || document.documentElement;
            }).call(this.elem);
        },
		length: function() {
			return this.elem ? 1 : 0;
		},
		prev: function() {
			do {
				this.elem = this.elem.previousSibling;
			} while (this.elem && this.elem.nodeType !== 1);
			return this;
		},
		next: function() {
			do {
				this.elem = this.elem.nextSibling;
			} while (this.elem && this.elem.nodeType !== 1);
			return this;
		},
		bind: function(type, fn) {
			if (typeof type !== 'string' || typeof fn !== 'function' || arguments.length !== 2) {
				throw new Error('Invalid arguments, you must pass in two arguments, ' +
						'the first one is event type in string, ' +
						'and the second one is a function.');
			}
			// Don't attach events to text/comment nodes 
			if ( this.elem.nodeType === 3 || this.elem.nodeType === 8 ) {
				return;
			}			
			var elem = this.elem,
				id = elem[expando] || (elem[expando] = guid++),
				listener = (cache[id] || (cache[id] = {})).listener;
			if (!listener) {
				listener = cache[id].listener = (function() {
					var handlers = {};
					var listener = function(event) {
						var fns = handlers[event.type];
						if (!fns) {
							return;
						}
						for (var i = 0; i < fns.length; i++) {
							var ret = fns[i].apply(elem, arguments);
							if (ret === false) {
								event.preventDefault();
								event.stopPropagation();
							}
						}
					};
					listener.addHandler = function(type, fn) {
						var fns = handlers[type] || (handlers[type] = []);
						fns.push(fn);
					};
					listener.removeHandler = function(type, fn) {
						if (fn === undefined) {
							delete handlers[type];
						} else {
							var fns = handlers[type],
								idx = fns ? fns.indexOf(fn) : -1;
							if (fns && idx >= 0) {
								fns.splice(idx, 1);
								if (fns.length === 0) delete handlers[type];
							}
						}
					};
					listener.clean = function() {
						for (var type in handlers) {
							delete handlers[type];
						}
					};
					listener.listeningType = function(type) {
						return handlers[type] !== undefined;
					};
					listener.isEmpty = function() {
						for (var type in handlers) {
							return false;
						}
						return true;
					};
					
					return listener;
				})();
			}
			if (!listener.listeningType(type)) {
				if (elem.addEventListener) {
					elem.addEventListener(type, listener, false);
				} else if (elem.attachEvent) {
					elem.attachEvent("on" + type, listener);
				}
			}
			listener.addHandler(type, fn);
		},
		unbind: function(type, fn) {
			if ((arguments.length > 0 && typeof type !== 'string') || arguments.length > 2 || (arguments.length ===2 && typeof fn !== 'function')) {
				throw new Error('Invalid arguments, you must pass in one or two arguments, ' +
						'the first one (mandatory) is event type in string, ' +
						'and the second one (optional) is a function.');
			}
			var elem = this.elem,
				id = elem[expando],
				listener = id ? (cache[id] && cache[id].listener) : undefined;
			if (!listener) return;
			if (arguments.length === 0) {//remove all events;
				listener.clean();
			} else {
				listener.removeHandler(type, fn);
			}
			if (listener.isEmpty()) {
				if (elem.removeEventListener) {
					elem.removeEventListener(type, listener, false);
				} else if (elem.detachEvent) {
					elem.detachEvent("on" + type, listener);
				}
				delete cache[id].listener;
			}
		},
		data: function(name, value) {
			var elem = this.elem,
				id = elem[expando] || (elem[expando] = guid++),
				data = (cache[id] || (cache[id] = {})).data;
			if (value === undefined && !data) return;
			if (typeof data !== 'object') {
				data = cache[id].data = {};
			}
			if (typeof name === 'object') {
				for (var key in name) {
					this.data(key, name[key]);
				}
				return this;
			}
			if (value === undefined) { //get
				return data[name];
			}
			data[name] = value;
			return this;
		},
		removeData: function(name) {
			var elem = this.elem,
				id = elem[expando];
			if (!id || !cache[id]) return;
			var data = cache[id].data;
			if (!data || !data[name]) return;
			delete data[name];
			//delete data if it's empty
			var empty = true;
			for (var i in data) {
				empty = false;
				break;
			}
			if (empty) {
				delete cache[id].data;
			}
			//delete cache if it's empty
			empty = true;
			for (var i in cache[id]) {
				empty = false;
				break;
			}
			if (empty) {
				delete cache[id];
			}
		}
	};
	var DomUtils = function(elem) {
//		if (elem instanceof DomWrapper) return elem;
		var wrapper = new DomWrapper(elem);
		return wrapper;
	};
	return (DomUtils);
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.LinkedHashSet',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
}
],
function Setup(FuncUtils, TypeUtils) {

	function hasNextInOrder() {
		this._cursor = this._cursor.next;
		return this._cursor !== this._sentinel;
	}

	function hasNextInReverse() {
		this._cursor = this._cursor.prev;
		return this._cursor !== this._sentinel;
	}
	/**
	 * Iterator for LinkedHashSet, to get an iterator for a linked hash Set
	 * instance, use {@link sap.viz.base.utils.LinkedHashSet#iterator}
	 * 
	 * @name sap.viz.base.utils.LinkedHashSet.Iterator
	 * @constructor
	 */
	function Iterator(lhs, reverseOrder) {
		this._lhs = lhs;
		this._sentinel = this._lhs._head;
		this._cursor = this._sentinel;
		if (reverseOrder) {
			this.hasNext = hasNextInReverse;
		} else {
			this.hasNext = hasNextInOrder;
		}
	}

	var proto = Iterator.prototype;

	/**
	 * Check and move to the next item
	 * 
	 * @name sap.viz.base.utils.LinkedHashSet.Iterator#hasNext
	 * @function
	 * @returns {Boolean}
	 */
	proto.hasNext = FuncUtils.noop;

	/**
	 * Get the next item, should be used in cooperated with
	 * {@link sap.viz.base.utils.LinkedHashSet#hasNext}
	 * 
	 * @name sap.viz.base.utils.LinkedHashSet.Iterator#next
	 * @function
	 * @returns {undefined|Object}
	 */
	proto.next = function() {
		return this._cursor.value;
	};

	/**
	 * Remove the current item from LinkedHashSet, this method is supposed to be
	 * called only once during each iteration, otherwise the internal state will
	 * get broken.
	 * 
	 * @name sap.viz.base.utils.LinkedHashSet.Iterator#remove
	 * @function
	 */
	proto.remove = function() {
		// move the cursor back one step
		if (this._cursor !== this._sentinel) {
			var item = this._cursor.value;
			this._cursor = this._cursor.prev;
			return this._lhs.remove(item);
		}
	};

	/**
	 * Create an empty LinedHashSet, most of the time you have to specify a
	 * hasher function used to calculate the hash value of each added item. The
	 * default implementation just uses the string representation of the item.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet
	 * @constructor
	 * @param {Function}
	 *            (hasher) function used to calculate the hash value of each
	 *            added item, default is String.
	 */
	var LinedHashSet = function(hasher) {
		this._hash = hasher || String;
		this._head = {
			value : undefined,
			next : undefined,
			prev : undefined
		};
		this._map = {};
		this._length = 0;
		this._head.next = this._head.prev = this._head;
	};
	proto = LinedHashSet.prototype;

	/**
	 * Add one item to the set. Old item with same hash will be replaced and
	 * returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#add
	 * @function
	 * @param {Object}
	 *            item the item to be added
	 * @returns {null|Object} old item if exists.
	 */
	proto.add = function(item) {
		var m = this._map;
		var ret = null;
		var key = this._hash(item);
		if (!m.hasOwnProperty(key)) {
			var node = {
				prev : null,
				value : item,
				next : null
			}, head = this._head, last = head.prev;
			m[key] = head.prev = node;
			node.prev = last;
			node.next = head;
			last.next = node;
			this._length++;
		} else {
			ret = m[key].value;
			m[key].value = item;
		}
		return ret;
	};
	/**
	 * Add items from another LinkedHashSet, the two hash set must share same
	 * hash function.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#addAll
	 * @function
	 * @param {sap.viz.base.utils.LinedHashSet}
	 *            other another LinedHashSet
	 * @returns {[]} array of replaced items
	 */
	proto.addAll = function(other) {
		var itr = LinedHashSet.iterator();
		var ret = [], added;
		while (itr.hasNext()) {
			if (added = this.add(itr.next()))
				ret.push(added);
		}
		return ret;
	};

	/**
	 * Insert item before other existing one, if the item exists, it will be
	 * removed first and insert then.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#insertBefore
	 * @function
	 * @param {Object}
	 *            item the item to be inserted
	 * @param {Object}
	 *            before target item
	 * @returns {Object} the value just inserted
	 */
	proto.insertBefore = function(item, before) {
		var m = this._map, hash = this._hash;
		var key = hash(item), beforeKey = hash(before);
		if (m.hasOwnProperty(beforeKey) && beforeKey !== key) {
			if (m.hasOwnProperty(key)) {
				this.remove(item);
			}
			var nnode = {
				prev : null,
				value : item,
				next : null
			};
			var bnode = m[beforeKey];
			nnode.prev = bnode.prev;
			bnode.prev.next = nnode;
			nnode.next = bnode;
			bnode.prev = nnode;
			m[key] = nnode;
			this._length++;
			return item;
		}
	};

	/**
	 * Insert item after other existing one, if the item exists, it will be
	 * removed first and insert then.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#insertAfter
	 * @function
	 * @param {Object}
	 *            item the item to be inserted
	 * @param {Object}
	 *            after target item
	 * @returns {Object} the value just inserted
	 */
	proto.insertAfter = function(item, after) {
		var m = this._map, hash = this._hash;
		var key = hash(item), afterKey = hash(after);
		if (m.hasOwnProperty(afterKey) && afterKey !== key) {
			if (m.hasOwnProperty(key)) {
				this.remove(item);
			}
			var nnode = {
				prev : null,
				value : item,
				next : null
			};
			var anode = m[afterKey];
			nnode.prev = anode;
			nnode.next = anode.next;
			anode.next.prev = nnode;
			anode.next = nnode;
			m[key] = nnode;
			this._length++;
			return item;
		}
	};

	/**
	 * Replace the existing item with given item, if the given item exists, it
	 * will be removed first.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#replace
	 * @function
	 * @param {Object}
	 *            item the given item
	 * @param {Object}
	 *            target target item to be replaced
	 * @returns {Object} the item replaced
	 */
	proto.replace = function(item, target) {
		var m = this._map, hash = this._hash;
		var key = hash(item), targetKey = hash(target);
		if (m.hasOwnProperty(targetKey) && targetKey !== key) {
			if (m.hasOwnProperty(key)) {
				this.remove(item);
			}
			var nnode = {
				prev : null,
				value : item,
				next : null
			};
			var rnode = m[targetKey];
			nnode.prev = rnode.prev;
			nnode.next = rnode.next;
			rnode.prev.next = nnode;
			rnode.next.prev = nnode;
			m[key] = nnode;
			delete m[targetKey];
			return rnode.value;
		}
	};
	/**
	 * Get first added item. If set is empty, undefined will be returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#first
	 * @function
	 * 
	 * @returns {undefined|Object}
	 */
	proto.first = function() {
		return this._head.next.value;
	};
	/**
	 * Get last added item. If set is empty, undefined will be returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#last
	 * @function
	 * 
	 * @returns {undefined|Object}
	 */
	proto.last = function() {
		return this._head.prev.value;
	};

	/**
	 * Get item next to the item specified, If the specified item doesn't exist
	 * or is the last one or the set is empty, undefined will be returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#next
	 * @function
	 * @param {Object}
	 *            item
	 * @returns {undefined|Object}
	 */
	proto.next = function(item) {
		var ret;
		if (ret = this._map[this._hash(item)]) {
			return ret.next.value;
		}
		return ret;
	};
	/**
	 * Get item previous to the item specified, If the specified item doesn't
	 * exist or is the first one or the set is empty, undefined will be
	 * returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#prev
	 * @function
	 * @param {Object}
	 *            item
	 * @returns {undefined|Object}
	 */
	proto.prev = function(item) {
		var ret;
		if (ret = this._map[this._hash(item)]) {
			return ret.prev.value;
		}
		return ret;
	};

	/**
	 * Move the specified item to the first of the linked list.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#moveToFirst
	 * @function
	 * @param {Object}
	 *            item
	 */
	proto.moveToFirst = function(item) {
		var node;
		if (node = this._map[this._hash(item)]) {
			var first = this._head.next;
			if (first !== node) {
				node.prev.next = node.next;
				node.next.prev = node.prev;

				node.next = first;
				node.prev = first.prev;
				first.prev.next = node;
				first.prev = node;
			}
		}
	};

	/**
	 * Move the specified item to the last of the linked list.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#moveToLast
	 * @function
	 * @param {Object}
	 *            item
	 */
	proto.moveToLast = function(item) {
		var node;
		if (node = this._map[this._hash(item)]) {
			var last = this._head.prev;
			if (last !== node) {
				node.prev.next = node.next;
				node.next.prev = node.prev;

				node.prev = last;
				node.next = last.next;
				last.next.prev = node;
				last.next = node;
			}
		}
	};

	/**
	 * A convenient method to get the item for given hash
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#has
	 * @function
	 * @param {String}
	 *            hash
	 * @returns {Boolean}
	 */
	proto.getByHash = function(hash) {
		var ret = this._map[hash];
		return ret ? ret.value : undefined;
	};

	/**
	 * Check the containment of the specified item
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#has
	 * @function
	 * @param {Object}
	 *            item
	 * @returns {Boolean}
	 */
	proto.has = function(item) {
		return this._map.hasOwnProperty(this._hash(item));
	};
	/**
	 * Remove the item from the set, if the item is not in the set, Null will be
	 * returned.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#remove
	 * @function
	 * @param {Object}
	 *            item
	 * @returns {Null|Object} the removed item
	 */
	proto.remove = function(item) {
		var m = this._map, key = this._hash(item);
		var ret = null;
		if (m.hasOwnProperty(key)) {
			var node = m[key];
			ret = node.value;

			node.prev.next = node.next;
			node.next.prev = node.prev;

			delete m[key];
			this._length--;
		}
		return ret;
	};
	/**
	 * Remove all items from the set
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#purgeAll
	 * @function
	 */
	proto.purgeAll = function() {
		this._map = {};
		// reset the sentinel
		this._head.next = this._head.prev = this._head;
		this._length = 0;
	};
	/**
	 * Whether the set is empty
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#isEmpty
	 * @function
	 * 
	 * @returns {Boolean}
	 */
	proto.isEmpty = function() {
		return this._length === 0;
	};
	/**
	 * Length of the set
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#length
	 * @function
	 * @returns {Integer}
	 */
	proto.length = function() {
		return this._length;
	};
	/**
	 * Get the iterator of the set
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#iterator
	 * @function
	 * @param {Boolean}
	 *            reverseOrder whether iterate in reverse order
	 * @returns {sap.viz.base.utils.LinedHashSet.Iterator}
	 */
	proto.iterator = function(reverseOrder) {
		return new Iterator(this, reverseOrder || false);
	};

	/**
	 * Return the contents of the set as an array, the order conforms to the
	 * traversal order.
	 * 
	 * @name sap.viz.base.utils.LinedHashSet#items
	 * @function
	 * 
	 * @returns {Array}
	 */
	proto.items = function() {
		var ret = [], c = head = this._head;
		while ((c = c.next) !== head) {
			ret.push(c.value);
		}
		return ret;
	};
	return LinedHashSet;
});sap.riv.module(
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.Class',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
}
],
function Setup(Class, TypeUtils) {
	var ArraySlice = Array.prototype.slice, ObjectGetPrototypeOf = Object.getPrototypeOf;
	function addEvents(/* event1, event2,...,eventn */) {
		var es = this._events, en, len = arguments.length;
		while (--len >= 0) {
			if (!es.hasOwnProperty(en = arguments[len])) {
				es[en] = [];
			}
		}
	}

	var Observable = Class.define({
		/**
		 * To utilize observable object, You have to extend your object from it,
		 * and set the 'events' property as Array of event name to the
		 * constructor
		 * 
		 * @name sap.viz.base.utils.Observable
		 * @constructor
		 */
		constructor : function(option) {
			this._events = {};
			var c = this, t;
			while ((c = ObjectGetPrototypeOf(c)).constructor !== Object) {
				if ((t = c.events) && t.length) {
					addEvents.apply(this, t);
				}
			}
			if (option) {
				if (t = option.listeners) {
					this.on(t);
					delete option.listeners;
				}
			}
		},

		/**
		 * Add events that could be monitored
		 * 
		 * @name sap.viz.base.utils.Observable#addEvents
		 * @function
		 * @parameter {String|String|...} event1,event2,event3... variable
		 *            length arguments of String
		 */
		addEvents : addEvents,
		/**
		 * Get the supported events
		 * 
		 * @name sap.viz.base.utils.Observable#getSupportedEvents
		 * @function
		 * @return {Array} an array of event names
		 */
		getSupportedEvents : function() {
			return this._events.key();
		},

		/**
		 * Add event listeners
		 * 
		 * @name sap.viz.base.utils.Observable#on
		 * @function
		 * @param {String|Object}
		 *            eventName the event to be monitored, or a object which key
		 *            is eventName and value is corresponding listener
		 * @param {Function}
		 *            [listener] the function to be triggered when event is
		 *            fired
		 * @param {String}
		 *            [category] optional string to give the listener a
		 *            category, could be used in removing listener
		 */
		on : function(event, listener, category) {
			if (arguments.length >= 1) {
				if (arguments.length > 1) {
					var t = {};
					t[event] = listener;
					event = t;
				}
				for ( var en in event) {
					if (listener = this._events[en]) {
						event[en]['category'] = category;
						listener.push(event[en]);
					}
				}
			}
			return this;
		},

		/**
		 * Check whether the listener is listening on the event
		 * 
		 * @name sap.viz.base.utils.Observable#isListening
		 * @function
		 * @param {String}
		 *            eventName the eventName to which the listener is
		 *            monitoring
		 * @param {Function}
		 *            listener the listener to find
		 * 
		 * @returns {Boolean}
		 */
		isListening : function(eventName, listener) {
			if (eventName = this._events[eventName]) {
				return eventName.indexOf(listener) > -1;
			}
			return false;
		},

		/**
		 * Remove the registered listener for given event, if no listener
		 * function specified, all listeners registered will be removed, instead
		 * to specify listener function, it can also accept a string to indicate
		 * category of listener, in this case only listeners in the given
		 * category will be removed
		 * 
		 * @name sap.viz.base.utils.Observable#un
		 * @function
		 * @param {String}
		 *            eventName the eventName to which the listener is
		 *            monitoring
		 * @param {Function|String}
		 *            (listener) the listener to find or a string to indicate
		 *            the category of listener
		 */
		un : function(eventName, fn) {
			if (arguments.length === 1) {
				var es = this._events;
				if (es.hasOwnProperty(eventName)) {
					es[eventName] = [];
				}
			} else if (arguments.length === 2) {
				var event = this._events[eventName];
				if (event) {
					if (typeof fn === 'function') {
						var idx;
						while ((idx = event.indexOf(fn)) > -1) {
							event.splice(idx, 1);
						}
					} else {
						var len = event.length;
						while (len--) {
							if (event[len].category === fn) {
								event.splice(len, 1);
							}
						}
					}
				}
			}
		},

		/**
		 * Purge all listeners registered on the observable object
		 * 
		 * @name sap.viz.base.utils.Observable#purgeListeners
		 * @function
		 * @param {String}
		 *            eventName the eventName to which the listener is
		 *            monitoring
		 * @returns {Boolean}
		 */
		purgeListeners : function() {
			var es = this._events;
			for ( var e in es) {
				es[e] = [];
			}
		},

		/**
		 * Fire an event
		 * 
		 * @name sap.viz.base.utils.Observable#fireEvent
		 * @function
		 * @param {String}
		 *            eventName name of the event to be fired
		 * @param {Object}
		 *            args additional arguments passed to listener
		 */
		fireEvent : function(eventName) {
			var args = ArraySlice.call(arguments, 1);
			if (eventName = this._events[eventName]) {
				for ( var i = 0, len = eventName.length; i < len; i++) {
					eventName[i].apply(this, args);
				}
			}
		}
	});

	return Observable;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.LinkedHashSet',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.DomUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.TransformHelper',
  version : '4.0.2'
}
],
function Setup(Observable, LinkedHashSet, D, FuncUtils, GestureDetector,
		TmHelper) {
	// var $ = jQuery;
	var noop = FuncUtils.noop;
	// if (!$) {
	// FuncUtils.error('Cannot find jQuery');
	// }

	/**
	 * Mark width & height is not flexible when its parent component's size
	 * changed
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#None
	 * @field
	 * 
	 */
	var None = 0;
	/**
	 * Mark the left margin is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleLeftMargin
	 * @field
	 */
	var FlexibleLeftMargin = 1 << 0;
	/**
	 * Mark the width is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleWidth
	 * @field
	 */
	var FlexibleWidth = 1 << 1;
	/**
	 * Mark the right margin is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleRightMargin
	 * @field
	 */
	var FlexibleRightMargin = 1 << 2;
	/**
	 * Mark the top margin is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleTopMargin
	 * @field
	 */
	var FlexibleTopMargin = 1 << 3;
	/**
	 * Mark the height is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleHeight
	 * @field
	 */
	var FlexibleHeight = 1 << 4;
	/**
	 * Mark the bottom margin is flexible
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing#FlexibleBottomMargin
	 * @field
	 */
	var FlexibleBottomMargin = 1 << 5;

	var id = 0;
	var nextId = function() {
		return id++;
	};

	function walk(node, fn) {
		var pStack = [{
					node : node,
					childrenItr : node.children.iterator()
				}];
		var current, node, childrenItr;
		while (pStack.length) {
			current = pStack[pStack.length - 1];
			node = current.node;
			fn(node);
			childrenItr = current.childrenItr;
			if (childrenItr.hasNext()) {
				var child = childrenItr.next();
				pStack.push({
							node : child,
							childrenItr : child.children.iterator()
						});
			} else {
				pStack.pop();
			}
		}
	}

	function layout(oldsize, newsize) {
		if (this._autoresizable) {
			var subCompItr = this.children.iterator();
			var subComp, newFrame;
			while (subCompItr.hasNext()) {
				subComp = subCompItr.next();
				newFrame = resizeSubComp.call(this, subComp, oldsize, newsize);
				subComp.frame(newFrame);
			}
		} else {
			this.doLayout();
		}
	}

	function resizeSubComp(subComp, oldsize, newsize) {
		var origFrame = subComp.frame();
		var x = origFrame.x, y = origFrame.y, width = origFrame.width, height = origFrame.height;
		var ml = x, mr = oldsize.width - x - width, mt = y, mb = oldsize.height
				- y - height;
		var wdiff = newsize.width - oldsize.width, hdiff = newsize.height
				- oldsize.height;
		var arMask = subComp._autoresizingMask;
		var horizontalMask = FlexibleLeftMargin | FlexibleWidth
				| FlexibleRightMargin;
		var verticalMask = FlexibleTopMargin | FlexibleHeight
				| FlexibleBottomMargin;
		switch (arMask & horizontalMask) {
			case None :
				if (ml !== 0) {
					x += wdiff * ml / (ml + mr);
				}
				break;
			case FlexibleLeftMargin :
				x += wdiff;
				break;
			case FlexibleLeftMargin | FlexibleRightMargin :
			case FlexibleRightMargin :
				break;
			case FlexibleWidth :
				width += wdiff;
				break;
			case FlexibleLeftMargin | FlexibleWidth :
				if (width !== 0) {
					x += wdiff * ml / (ml + width);
					width += wdiff * width / (ml + width);
				}
				break;
			case FlexibleRightMargin | FlexibleWidth :
				if (width !== 0) {
					width += wdiff * width / (mr + width);
				}
				break;
			case FlexibleLeftMargin | FlexibleWidth | FlexibleRightMargin :
				if (oldsize.width !== 0) {
					var r = wdiff / oldsize.width;
					x += x * r;
					width += width * r;
				}
				break;
		}
		switch (arMask & verticalMask) {
			case None :
				if (mt !== 0) {
					y += hdiff * mt / (mt + mb);
				}
				break;
			case FlexibleTopMargin :
				y += hdiff;
				break;
			case FlexibleTopMargin | FlexibleBottomMargin :
			case FlexibleBottomMargin :
				break;
			case FlexibleHeight :
				height += hdiff;
				break;
			case FlexibleTopMargin | FlexibleHeight :
				if (height !== 0) {
					y += hdiff * mt / (mt + height);
					height += hdiff * height / (mt + height);
				}
				break;
			case FlexibleBottomMargin | FlexibleHeight :
				if (height != 0) {
					height += hdiff * height / (mb + height);
				}
				break;
			case FlexibleTopMargin | FlexibleHeight | FlexibleBottomMargin :
				if (oldsize.height) {
					var r = hdiff / oldsize.height;
					y += y * r;
					height += height * r;
				}
				break;
		}
		return {
			x : x,
			y : y,
			height : height,
			width : width
		};
	}

	function init(options) {
		var opt, dc = D(this.container);
		if (options.clipToBound === false) {
			dc.css('overflow', 'visible');
		}
		if (options.hidden === true) {
			dc.css('display', 'none');
			this._hidden = true;
		}
		if (options.autoResizingMask < 32) {
			this._autoresizingMask = +options.autoSizingMask;
		}
		if (opt = options.pin) {
			this._pinX = opt.x;
			this._pinY = opt.y;
		}
		if (opt = options.position) {
			this._x = opt.x;
			this._y = opt.y;
			dc.css('left', this._x - this._pinX * this._width);
			dc.css('top', this._y - this._pinY * this._height);
		}

		if (opt = options.size) {
			this._width = opt.w || opt.width;
			this._height = opt.h || opt.height;
			dc.width(this._width);
			dc.height(this._height);
		}
		registerMandatoryHandler.call(this);
	}

	function registerMandatoryHandler() {
		this.on({
					'sizeChanged' : updateContainerSize.bind(this),
					'heightChanged' : updateContainerHeight.bind(this),
					'widthChanged' : updateContainerWidth.bind(this),
					'positionChanged' : updateContainerPos.bind(this),
					'pinChanged' : updateContainerPin.bind(this)
				});
	}

	function updateContainerSize(os, ns) {
		var dc = D(this.container);
		dc.width(ns.width);
		dc.height(ns.height);
		if (this._pinX || this._pinY) {
			dc.css('left', this._x - this._pinX * ns.width);
			dc.css('top', this._y - this._pinY * ns.height);
		}
		this.doContentResize(os, ns);
		layout.call(this, os, ns);
	}
	function updateContainerWidth(ow, nw) {
		var dc = D(this.container);
		dc.width(nw);
		if (this._pinX) {
			dc.css('left', this._x - this._pinX * nw);
		}
		var os = {
			height : this._height,
			width : ow
		}, ns = {
			height : this._height,
			width : nw
		};
		this.doContentResize(os, ns);
		layout.call(this, os, ns);
	}

	function updateContainerHeight(oh, nh) {
		var dc = D(this.container);
		dc.height(nh);
		if (this._pinY) {
			dc.css('top', this._y - this._pinY * nh);
		}
		var os = {
			height : oh,
			width : this._width
		}, ns = {
			height : nh,
			width : this._width
		};
		this.doContentResize(os, ns);
		layout.call(this, os, ns);
	}

	function updateContainerPos(op, np) {
		var dc = D(this.container);
		dc.css('left', np.x - this._pinX * this._width);
		dc.css('top', np.y - this._pinY * this._height);
	}

	function updateContainerPin(oap, nap) {
		var dc = D(this.container);
		dc.css('left', this._x - nap.x * this._width);
		dc.css('top', this._y - nap.y * this._height);
	}

	function handleSubCompHide(comp) {
		var pv = comp.visibility();
		if (pv) {
			comp.doBeforeHide();
			comp.fireEvent('beforeHide');
		}
		comp._parentVisible = false;
		var subCompItr = comp.children.iterator();
		while (subCompItr.hasNext()) {
			handleSubCompHide.call(comp, subCompItr.next());
		}
		if (pv) {
			comp.doAfterHide();
			comp.fireEvent('afterHide');
		}
	}

	function handleSubCompShow(comp) {
		var pv = comp.visibility();
		comp._parentVisible = comp.parent.visibility();// true;
		if (!pv && comp.visibility()) {
			comp.doBeforeShow();
			comp.fireEvent('beforeShow');
		}
		var subCompItr = comp.children.iterator();
		while (subCompItr.hasNext()) {
			handleSubCompShow.call(comp, subCompItr.next());
		}

		if (!pv && comp.visibility()) {
			comp.doAfterShow();
			comp.fireEvent('afterShow');
		}
	}

	/**
	 * This class defines UI component which serves as the super class of every
	 * controls
	 * 
	 * @name sap.viz.mvc.UIComponent
	 * @class
	 * @augments sap.viz.base.utils.Observable
	 */
	var UIComponent = Observable.extend(
			/**
			 * @lends sap.viz.mvc.UIComponent
			 * 
			 */
			{
		events : ['widthChanged', 'heightChanged', 'sizeChanged',
				'positionChanged', 'pinChanged', 'attached', 'detached',
				'beforeShow', 'afterShow', 'beforeHide', 'afterHide',
				'focusin', 'focusout', 'focus', 'blur', 'mousedown', 'mouseup',
				'mouseenter', 'mouseleave', 'mousemove', 'click', 'dblclick',
				'touchstart', 'touchmove', 'touchend', 'touchcancel'],
		/**
		 * @constructor
		 * @param {Object}
		 *            options the options to initialize the UI component
		 * @param {Boolean}
		 *            [options.hidden] whether the UI component is hidden
		 * @param {Integer}
		 *            [options.autoresizingMask] the bitwise combination of the
		 *            autoresizing mask, default is
		 *            {@link  sap.viz.mvc.UIComponent.Autosizing#None}
		 * @param {Object}
		 *            [options.anchor] the anchor point of the UI component,
		 *            default is
		 * 
		 * <pre>
		 * {
		 * 	x : 0.5,
		 * 	y : 0.5
		 * }
		 * </pre>
		 * 
		 * @param {Object}
		 *            [options.position] the position of the UI component,
		 *            default is
		 * 
		 * <pre>
		 * {
		 * 	x : 0,
		 * 	y : 0
		 * }
		 * </pre>
		 * 
		 * @param {Object}
		 *            [options.size] the size of the UI component, default is
		 * 
		 * <pre>
		 * {
		 * 	width : 0,
		 * 	height : 0
		 * }
		 * </pre>
		 */
		constructor : function(options) {
			options = options || {};
			var id = options.id ? options.id + '_' + nextId() : 'UIComp_'
					+ nextId();
			Object.defineProperties(this, {
						'id' : {
							value : id,
							enumerable : true
						},
						'container' : {
							// DOM div container for this ui component
							value : D(document.createElement('div'))
									.attr('id', id).css('position', 'relative')
									.css({
												'overflow' : 'hidden',
												'font-size' : '10px',
												'box-sizing' : 'border-box',
												'-moz-box-sizing' : 'border-box',
												'-ms-box-sizing' : 'border-box',
												'-webkit-box-sizing' : 'border-box'
											}).data('selfComp', this).get(0),
							enumerable : true
						},

						'root' : {
							value : undefined,
							writable : true,
							enumerable : true
						},
						'parent' : {
							value : undefined,
							writable : true,
							enumerable : true
						},
						'children' : {
							value : new LinkedHashSet(function(item) {
										return item.id;
									}),
							enumerable : true
						},
						'gestureDetectors' : {
							value : [],
							enumerable : true
						}
					});
			// Flag indicates if the underlying div is attached to DOM
			this._attached = false;

			this._hidden = false;

			this._parentVisible = false;

			this._autoresizable = true;

			this._autoresizingMask = None;

			this._x = 0;

			this._y = 0;

			this._width = 1;

			this._height = 1;

			this._pinX = 0.5;

			this._pinY = 0.5;

			init.call(this, options);
		},

		markAttached : function() {
			this._attached = true;
			if (this.parent)
				this._parentVisible = this.parent.visibility();
			if (this.visibility()) {
				this.doBeforeShow();
				this.fireEvent('beforeShow');
			}
			var subCompItr = this.children.iterator();
			while (subCompItr.hasNext()) {
				subCompItr.next().markAttached();
			}
			if (this.visibility()) {
				this.doAfterShow();
				this.fireEvent('afterShow');
			}
		},

		markDetached : function() {
			var pv = this.visibility();
			this._attached = false;
			if (pv) {
				this.doBeforeHide();
				this.fireEvent('beforeHide');
			}
			var subCompItr = this.children.iterator();
			while (subCompItr.hasNext()) {
				subCompItr.next().markDetached();
			}
			if (pv) {
				this.doAfterHide();
				this.fireEvent('afterHide');
			}
		},

		/**
		 * Mark the component as hidden, if the component is already marked as
		 * hidden, nothing will happen; Whether the component will be hidden and
		 * whether the events <b>beforeHide</b>, <b>afterHide</b> will get
		 * fired and the call-back methods <b>doBeforeHide</b>, <b>doAfterHide</b>
		 * will get triggered depend on two conditions: 1, whether its parent is
		 * current shown. 2, whether the component is attached to DOM currently.
		 * 
		 * @name sap.viz.mvc.UIComponent#markHide
		 * @function
		 * @returns {this}
		 */
		markHide : function() {
			if (this._hidden === false) {
				var pv = this.visibility();
				if (pv) {
					this.doBeforeHide();
					this.fireEvent('beforeHide');
				}
				this._hidden = true;
				D(this.container).css('display', 'none');
				var subCompItr = this.children.iterator();
				while (subCompItr.hasNext()) {
					handleSubCompHide.call(this, subCompItr.next());
				}
				if (pv) {
					this.doAfterHide();
					this.fireEvent('afterHide');
				}
			}
			return this;
		},

		/**
		 * Mark the component as shown, if the component is already marked as
		 * shown, nothing will happen; Whether the component will be shown and
		 * whether the events <b>beforeShow</b>, <b>afterShow</b> and the
		 * call-back methods <b>doBeforeShow</b>, <b>doAfterShow</b> will get
		 * triggered depend on two conditions: 1, all of its ancestors are
		 * marked as shown. 2, the component is currently attached to DOM.
		 * 
		 * @name sap.viz.mvc.UIComponent#markShow
		 * @function
		 * @returns {this}
		 */
		markShow : function() {
			if (this._hidden === true) {
				this._hidden = false;
				if (this.visibility()) {
					this.doBeforeShow();
					this.fireEvent('beforeShow');
				}
				D(this.container).css('display', 'block');
				var subCompItr = this.children.iterator();
				while (subCompItr.hasNext()) {
					handleSubCompShow.call(subCompItr.next());
				}
				if (this.visibility()) {
					this.doAfterShow();
					this.fireEvent('afterShow');
				}
			}
			return this;
		},

		clipToBound : function(clipToBound) {
			var dc = D(this.container);
			if (arguments.length) {
				dc.css('overflow', clipToBound ? 'hidden' : 'visible');
				return this;
			} else {
				return dc.css('overflow') === 'hidden';
			}
		},

		/**
		 * Get the current visibility of the component, the visibility is
		 * affected by the component's hidden/shown status, whether it's
		 * attached to DOM, whether it's ancestor components are shown.
		 * 
		 * 
		 * @name sap.viz.mvc.UIComponent#visibility
		 * @function
		 * @returns {Boolean}
		 */
		visibility : function() {
			return !this._hidden && this._attached && this._parentVisible;
		},

		/**
		 * Get and set whether the component should resize automatically when
		 * its parent's size changed
		 * 
		 * @name sap.viz.mvc.UIComponent#autoResizable
		 * @function
		 * @param {undefined|Boolean}
		 *            autoresize
		 * @returns {this|Boolean}
		 */
		autoResizable : function(autoResize) {
			if (arguments.length) {
				this._autoresizable = autoResize && true;
				return this;
			} else {
				return this._autoresizable && true;
			}
		},

		/**
		 * Get and set the autoresizing mask of the component
		 * 
		 * @name sap.viz.mvc.UIComponent#autoResizingMask
		 * @function
		 * @param {undefined|Integer}
		 *            mask
		 * @returns {this|Integer}
		 */
		autoResizingMask : function(mask) {
			if (arguments.length) {
				if (mask < 32) {
					this._autoresizingMask = +mask;
				}
				return this;
			} else {
				return this._autoresizingMask;
			}
		},

		/**
		 * Get the position of the component, the position is in Page coordinate
		 * system
		 * 
		 * @name sap.viz.mvc.UIComponent#pagePosition
		 * @function
		 * 
		 * <pre>
		 * {
		 *      x : ##,
		 *      y : ##,
		 * }
		 * </pre>
		 * 
		 * @returns {Object}
		 */
		pagePosition : function() {
			var offset = D(this.container).offset();
			return {
				x : offset.left,
				y : offset.top
			};
		},
		/**
		 * Get and set the position of the component, the position is in it's
		 * direct super component's coordinate system
		 * 
		 * @name sap.viz.mvc.UIComponent#position
		 * @function
		 * @param {Point|Number}
		 *            x x coordinate or <b>Point</b> object.
		 * @param {Number}
		 *            [y] y coordinate
		 * 
		 * 
		 * @returns {this|Point }
		 */
		position : function(x, y) {
			if (arguments.length === 0)
				return {
					x : this._x,
					y : this._y
				};

			if (arguments.length === 1) {
				y = x.y;
				x = x.x;
			}
			x = +x;
			y = +y;
			if (this._x !== x || this._y !== y)
				this.fireEvent('positionChanged', {
							x : this._x,
							y : this._y
						}, {
							x : this._x = x,
							y : this._y = y
						});
			return this;
		},
		/**
		 * Get and set the size of the component
		 * 
		 * @name sap.viz.mvc.UIComponent#size
		 * @function
		 * @param {Number|Size}
		 *            width the width of the layer or <b>Size</b> object
		 * @param {Number}
		 *            (height) the height of the layer, omitted when receiving a
		 *            <b>Size</b> object
		 * 
		 * Size Object is defined as:
		 * 
		 * <pre>
		 * {
		 *      width : ##,
		 *      height : ##
		 * }
		 * </pre>
		 * 
		 * @returns {this|Size}
		 */
		size : function(width, height) {
			if (!arguments.length)
				return {
					width : this._width,
					height : this._height
				};

			if (arguments.length === 1) {
				height = width.height;
				width = width.width;
			}
			height = +height;
			width = +width;
			if (width !== this._width || height !== this._height)
				this.fireEvent('sizeChanged', {
							width : this._width,
							height : this._height
						}, {
							width : this._width = width,
							height : this._height = height
						});

			return this;
		},
		/**
		 * Get and set the width of the component
		 * 
		 * @name sap.viz.mvc.UIComponent#width
		 * @function
		 * @param {Number}
		 *            width the new width of the layer
		 * 
		 * 
		 * @returns {this|Number}
		 */
		width : function(width) {
			if (!arguments.length)
				return this._width;

			width = +width;
			if (this._width !== width && width > 0)
				this.fireEvent('sizeChanged', {
							width : this._width,
							height : this._height
						}, {
							width : this._width = width,
							height : this._height
						});

			return this;
		},
		/**
		 * Get and set the height of the component
		 * 
		 * @name sap.viz.mvc.UIComponent#height
		 * @function
		 * @param {Number|Function}
		 *            (height) the new height of the layer or function returns
		 *            height value.
		 * 
		 * 
		 * @returns {this|Number}
		 * 
		 * 
		 * @returns {this|Number}
		 */
		height : function(height) {
			if (!arguments.length)
				return this._height;

			height = +height;
			if (this._height !== height && height > 0)
				this.fireEvent('sizeChanged', {
							width : this._width,
							height : this._height
						}, {
							width : this._width,
							height : this._height = height
						});

			return this;
		},
		/**
		 * Pin is used to specify which point the component's geometric boundary
		 * is used to locate the layer. If no argument specified, current Pin is
		 * returned, the default Pin is (0.5,0.5). If single argument specified,
		 * it must be either <b>Point</b> object or a function returns <b>Point</b>.
		 * If two arguments specified, they must be two numbers corresponding to
		 * x, y of Pin.
		 * 
		 * @name sap.viz.mvc.UIComponent#pin
		 * @function
		 * @param {Number|Point}
		 *            (x)
		 * @param {Number}
		 *            (y)
		 * 
		 * 
		 * @returns {this|Point }
		 */
		pin : function(x, y) {
			if (!arguments.length)
				return {
					x : this._pinX,
					y : this._pinY
				};

			if (arguments.length === 1) {
				y = x.y;
				x = x.x;
			}
			x = +x;
			y = +y;

			if (x !== this._pinX || y !== this._pinY)
				this.fireEvent('pinChanged', {
							x : this._pinX,
							y : this._pinY
						}, {
							x : this._pinX = x,
							y : this._pinY = y
						});

			return this;
		},
		/**
		 * Frame is a convenient way to update position and size of the
		 * component at once, frame defines the component's rectangular boundary
		 * using a rectangle in parent's layer's coordinate system. If no
		 * argument specified, the current frame is returned. If single argument
		 * specified, it must be either <b>Rect</b> object or a function
		 * returns <b>Rect</b> object, otherwise 4 arguments must be supplied.
		 * 
		 * @name sap.viz.mvc.UIComponent#frame
		 * @function
		 * @function
		 * @param {Rect|Number}
		 *            x could be Number, <b>Rect</b> object
		 * @param {Number)
		 *            (y)
		 * @param {Number)
		 *            (width)
		 * @param {Number)
		 *            (height)
		 * 
		 * 
		 * @returns {this|Rect }
		 */
		frame : function(x, y, width, height) {
			if (!arguments.length)
				return {
					x : this._x - this._pinX * this._width,
					y : this._y - this._pinY * this._height,
					width : this._width,
					height : this._height
				};

			if (arguments.length === 1) {
				y = x.y;
				width = x.width;
				height = x.height;
				x = x.x;
			}
			var newPosX = x + width * this._pinX, newPosY = y + height
					* this._pinY;
			if (width !== this._width || height !== this._height) {
				this.fireEvent('sizeChanged', {
							width : this._width,
							height : this._height
						}, {
							width : this._width = width,
							height : this._height = height
						});
			}
			if (newPosX !== this._x || newPosY !== this._y) {
				this.fireEvent('positionChanged', {
							x : this._x,
							y : this._y
						}, {
							x : this._x = newPosX,
							y : this._y = newPosY
						});
			}
			return this;
		},

		/**
		 * Append a component as its last child component, the visibility
		 * related events and call-back methods will get triggered on the
		 * component tree based on the appended component's visibility.
		 * 
		 * @name sap.viz.mvc.UIComponent#append
		 * @function
		 * @param {sap.viz.mvc.UIComponent}
		 *            subComp component to append
		 * @return {this}
		 */
		append : function(subComp) {
			if (subComp) {
				if (subComp.parent !== undefined)
					subComp.detach();
				subComp.parent = this;
				if (this.root) {
					walk(subComp, function(node) {
								node.root = this;
							}.bind(this.root));
				}
				this.children.add(subComp);
				this.container.appendChild(subComp.container);
				if (this._attached) {
					subComp.markAttached();
				}
				return this;
			}
		},

		/**
		 * Append this component to other component as a child
		 * 
		 * @param {sap.viz.mvc.UIComponent}
		 *            superComp component to be appended
		 * @return {this}
		 */
		appendTo : function(superComp) {
			superComp.append(this);
			return this;
		},
		/**
		 * Detach this component from its parent, the detached component is not
		 * destroyed and could be reattached later. the visibility related
		 * events and call-back methods will get triggered based on the detached
		 * component's previous visibility.
		 * 
		 * @name sap.viz.mvc.UIComponent#detach
		 * @function
		 */
		detach : function() {
			if (this.parent) {
				this.parent.children.remove(this);
				D(this.container).detach();
				this.parent = undefined;
				walk(this, function(node) {
							node.root = undefined;
						});
				this.markDetached();
			}
			return this;
		},

		before : function(target) {
			target.insertBefore(this);
			return this;
		},
		/**
		 * Insert this component as a child before the specified component, if
		 * this component has been attached to other component, it will be
		 * detached firstly.
		 * 
		 * @name sap.viz.mvc.UIComponent#insertBefore
		 * @function
		 * @param {sap.viz.mvc.UIComponent}
		 *            target the component to be inserted before
		 */
		insertBefore : function(target) {
			if (target && target.parent && target !== this) {
				if (this.parent) {
					this.detach();
				}
				var superComp = target.parent;
				this.parent = superComp;
				if (superComp.root) {
					walk(this, function(node) {
								node.root = this;
							}.bind(superComp.root));
				}
				superComp.children.insertBefore(this, target);
				this.container.parentNode.insertBefore(target.container,
						this.container);
				if (this._attached) {
					this.markAttached();
				}
			}
			return this;
		},

		after : function(target) {
			target.insertAfter(this);
			return this;
		},

		/**
		 * Insert this component as a child after the specified component, if
		 * this component has been attached to other component, it will be
		 * detached firstly.
		 * 
		 * @name sap.viz.mvc.UIComponent#insertAfterSubComponent
		 * @function
		 * 
		 * @param {sap.viz.mvc.UIComponent}
		 *            target the component to be inserted before
		 */
		insertAfter : function(target) {
			if (target && target.parent && target !== this) {
				if (this.parent) {
					this.detach();
				}
				var superComp = target.parent;
				this.parent = superComp;
				if (superComp.root) {
					walk(this, function(node) {
								node.root = this;
							}.bind(superComp.root));
				}
				superComp.children.insertAfter(this, target);
				this.container.parentNode.insertAfter(target.container,
						this.container);
				if (this._attached) {
					this.markAttached();
				}
			}
			return this;
		},
		/**
		 * Bring this component as the last component of its super component
		 * 
		 * @name sap.viz.mvc.UIComponent#bringToFront
		 * @function
		 * 
		 */
		bringToFront : function() {
			var superComp = this.parent;
			if (superComp) {
				if (superComp.children.last() !== this) {
					superComp.children.moveToLast(this);
					D(this.container).detach();
					// this.container.appendTo(subComp.container);
					subComp.container.appendChild(this.container);
				}
			}
			return this;
		},
		/**
		 * Send this component as the first component of its super component
		 * 
		 * @name sap.viz.mvc.UIComponent#bringToFront
		 * 
		 * @name sap.viz.mvc.UIComponent#sendToBack
		 * @function
		 */
		sendToBack : function() {
			var superComp = this.parent;
			if (superComp) {
				if (superComp.children.first() !== this) {
					superComp.children.moveToFirst(this);
					D(this.container).detach();
					// this.container.prependTo(subComp.container);
					subComp.container.insertBefore(this.container,
							subComp.container.firstChild);
				}
			}
			return this;
		},

		/**
		 * Convert the point from other component's coordinate system to this
		 * component's coordinate system. If the <b>this<b> component is
		 * detached from root, no convertion happens; if the <b>from</b>
		 * component is not specified or is detached, the specified x,y will be
		 * treated as a point in global coordinate system.
		 * 
		 * @name sap.viz.mvc.UIComponent#pointFrom
		 * @function
		 * @param {Number|Point}
		 *            x the x coordinate of the point or Point object
		 * @param {Number|sap.viz.mvc.UIComponent}
		 *            (y) the y coordinate of the point or other UIComponent
		 * @param {sap.viz.mvc.UIComponent}
		 *            (from)
		 * @returns {Point}
		 */
		pointFrom : function(x, y, from) {
			if (arguments.length === 1) {
				y = x.y;
				x = x.x;
				from = false;
			}
			if (arguments.length === 2) {
				if (isNaN(x)) {
					from = y;
					y = x.y;
					x = x.x;
				} else {
					from = false;
				}
			}
			x = +x;
			y = +y;
			from.root || (from = false);
			var root = this.root;
			if (root) {
				from || (from = root);

				// this -> from conversion
				var dx = 0, dy = 0, current = this, frame;
				while (current !== root && current !== from) {
					frame = current.frame();
					dx += frame.x;
					dy += frame.y;
					current = current.parent;
				}
				if (current !== from) {
					// "this" is not a child of "from"
					current = from;
					// from -> this conversion
					while (current !== root && current !== this) {
						frame = current.frame();
						x += frame.x;
						y += frame.y;
						current = current.parent;
					}
					if (current === this) {
						// "this" is an ancestor of "from"
						return {
							x : x,
							y : y
						};
					}
				}
				return {
					x : x - dx,
					y : y - dy
				};
			}
			return {
				x : x,
				y : y
			};
		},
		/**
		 * Convert local point to a point in the coordinate system of the
		 * specified component. If the <b>this<b> component is detached from
		 * root, no convertion happens; if the <b>to</b> component is not
		 * specified or is detached, the specified x,y will be converted to
		 * global coordinate system.
		 * 
		 * @name sap.viz.mvc.UIComponent#pointFrom
		 * @function
		 * @param {Number|Point}
		 *            x the x coordinate of the point or Point object
		 * @param {Number|sap.viz.mvc.UIComponent}
		 *            (y) the y coordinate of the point or other UIComponent
		 * @param {sap.viz.mvc.UIComponent}
		 *            (from)
		 * @returns {Point}
		 */
		pointTo : function(x, y, to) {
			if (arguments.length === 1) {
				y = x.y;
				x = x.x;
				from = false;
			}
			if (arguments.length === 2) {
				if (isNaN(x)) {
					from = y;
					y = x.y;
					x = x.x;
				} else {
					from = false;
				}
			}
			x = +x;
			y = +y;
			var root = this.root;
			if (root) {
				to || (to = root);
				return to.pointFrom(x, y, this);
			}
			return {
				x : x,
				y : y
			};
		},

		fireFocusEvent : function(event) {
			this.fireEvent(event.type, event);
			if (this.parent && event.shouldBubble()) {
				event.currentTarget = this.parent;
				this.parent.fireEvent(event);
			}
		},

		fireMouseEvent : function(event) {
			this.fireEvent(event.type, event);
			if (this.parent && event.shouldBubble()) {
				event.currentTarget = this.parent;
				event.currentLocalXY = {
					x : event.currentLocalXY.x + this._x - this._pinX
							* this._width,
					y : event.currentLocalXY.y + this._y - this._pinY
							* this._height
				};
				this.parent.fireMouseEvent(event);
			}
		},

		fireTouchEvent : function(event) {
			this.fireEvent(event.type, event);
			if (this.parent && event.shouldBubble()) {
				event.currentTarget = this.parent;
				this.parent.fireTouchEvent(event);
			}
		},

		/**
		 * Remove all listeners currently attached to the component
		 * 
		 * @name sap.viz.mvc.UIComponent#purgeListeners
		 * @function
		 */
		purgeListeners : function() {
			this._super();
			registerMandatoryHandler.call(this);
		},
		/**
		 * Remove all listeners currently listening on the given event
		 * 
		 * @name sap.viz.mvc.UIComponent#un
		 * @function
		 * @param {String}
		 *            eventName
		 */
		un : function(eventName) {
			this._super.apply(this, arguments);
			if (arguments.length === 1) {
				switch (eventName) {
					case 'sizeChanged' :
						this.on('sizeChanged', updateContainerSize.bind(this));
						break;
					case 'heightChanged' :
						this.on('heightChanged', updateContainerHeight
										.bind(this));
						break;
					case 'widthChanged' :
						this
								.on('widthChanged', updateContainerWidth
												.bind(this));
						break;
					case 'positionChanged' :
						this.on('positionChanged', updateContainerPos
										.bind(this));
						break;
					case 'pinChanged' :
						this.on('pinChanged', updateContainerPin.bind(this));
						break;
				}
			}
		},
		/**
		 * Add a gesture detector to this component
		 * 
		 * @name sap.viz.mvc.UIComponent#addGestureDetector
		 * @function
		 * @param {sap.viz.mvc.GestureDetector}
		 *            detector
		 */
		addGestureDetector : function(detector) {
			if (detector instanceof GestureDetector) {
				detector.watchedComponent = this;
				this.gestureDetectors.push(detector);
			}
		},
		/**
		 * remove a previously added gesture detector to this component
		 * 
		 * @name sap.viz.mvc.UIComponent#addGestureDetector
		 * @function
		 * @param {sap.viz.mvc.GestureDetector}
		 *            detector
		 */
		removeGestureDetector : function(detector) {
			for (var i = 0, len = this.gestureDetectors.length; i < len; i++) {
				if (this.gestureDetectors[i] === detector) {
					this.gestureDetectors.splice(i, 1);
					detector.watchedComponent = undefined;
					len--;
				}
			}
		},

		/**
		 * Returns the farthest descendant uicomponent that can respond to the
		 * hit point.
		 * 
		 * @name sap.viz.mvc.UIComponent#hitTest
		 * @param {Number|Point}
		 *            x the x coordinate of the point or the point object
		 * @param {Number}
		 *            (y) the y coordinate of the point
		 * @returns {sap.viz.mvc.UIComponent}
		 */
		hitTest : function(x, y) {
			if (arguments.length = 1) {
				y = x.y;
				x = x.x;
			}
			var pStack = [{
						comp : this,
						subCompsItr : this.children.iterator(true)
					}];
			var comp, subCompsItr;
			while (pStack.length) {
				comp = pStack[pStack.length - 1];
				subCompsItr = comp.subCompsItr;
				comp = comp.comp;
				if (comp.visibility()) {
					if (subCompsItr.hasNext()) {
						var subComp = subCompsItr.next();
						pStack.push({
									comp : subComp,
									subCompsItr : subComp.children
											.iterator(true)
								});
						continue;
					} else {
						var point = comp.pointFrom(x, y, this);
						if (point.x >= 0 && point.y >= 0
								&& point.x < comp.width()
								&& point.y < comp.height()
								&& comp.pointContent(x, y))
							return comp;
					}
					pStack.pop();
				} else {
					pStack.pop();
				}
			}
		},

		/**
		 * Test whether the given local point is currently pointing the visual
		 * content of the UIComponent. Hitting test will furthur use this method
		 * to determine if a point is hitting the component after checking the
		 * boundary enclosing. Default implementation always returns true.
		 * 
		 * @name sap.viz.mvc.UIComponent#pointContent
		 * @function
		 * @param {Number|Point}
		 *            x the x coordinate of the point or Point object
		 * @param {Number}
		 *            (y) the y coordinate of the point
		 * @returns {Boolean}
		 */
		pointContent : function(x, y) {
			return true;
		},

		/**
		 * Implement this method to do adhoc sub-components layout, this method
		 * will be called on super component when its size changed.
		 * 
		 * @name sap.viz.mvc.UIComponent#doLayout
		 * @function
		 */
		doLayout : noop,

		/**
		 * Resize component's visual content, when the component's size changed,
		 * this method will be invoked before layout sub components
		 * 
		 * @name sap.viz.mvc.UIComponent#doContentResize
		 * @function
		 * @param {Object}
		 *            os the old size of the component
		 * @param {Object}
		 *            ns the new size of the component
		 */
		doContentResize : noop,

		/**
		 * This method will get called before the component becoming hidden
		 * 
		 * @name sap.viz.mvc.UIComponent#doBeforeHide
		 * @function
		 */
		doBeforeHide : noop,
		/**
		 * This method will get called after the component is hided
		 * 
		 * @name sap.viz.mvc.UIComponent#doAfterHide
		 * @function
		 */
		doAfterHide : noop,
		/**
		 * This method will get called before the component becoming visible
		 * 
		 * @name sap.viz.mvc.UIComponent#doBeforeShow
		 * @function
		 */
		doBeforeShow : noop,
		/**
		 * This method will get called after the component is visible
		 * 
		 * @name sap.viz.mvc.UIComponent#doAfterShow
		 * @function
		 */
		doAfterShow : noop,

		doDestroy : noop,

		destroy : function() {
			this.doDestroy();
			walk(this, function(node) {
						node.detach();
						node.purgeListeners();
					});
			D(this.container).removeData('selfComp');
		}
	});
	UIComponent.Autosizing = {
		None : None,
		FlexibleLeftMargin : FlexibleLeftMargin,
		FlexibleWidth : FlexibleWidth,
		FlexibleRightMargin : FlexibleRightMargin,
		FlexibleTopMargin : FlexibleTopMargin,
		FlexibleHeight : FlexibleHeight,
		FlexibleBottomMargin : FlexibleBottomMargin
	};
	return UIComponent;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.UIController',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.Class',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.2'
}
],
function Setup(Class, FuncUtils, UIComponent) {
	var noop = FuncUtils.noop;
	var defaultWidth = 300, defaultHeight = 150;
	var UIController = Class
			.define({
				/**
				 * The base class of Controller in VizKit MVC framework
				 * 
				 * @name sap.viz.mvc.UIController
				 * @constructor
				 */
				constructor : function(vizApp) {
					Object
							.defineProperties(
									this,
									{
										'application' : {
											value : vizApp,
											writable : false,
											enumerable : true,
											configurable : false
										},
										'rootUIComponent' : {
											value : new (this.constructor.prototype.RootComponentClass || UIComponent)(
													{
														size : {
															width : defaultWidth,
															height : defaultHeight
														},
														listeners : {
															'beforeShow' : this.beforeUIComponentAppear
																	.bind(this),
															'beforeHide' : this.beforeUIComponentDisappear
																	.bind(this),
															'afterShow' : this.afterUIComponentAppear
																	.bind(this),
															'afterHide' : this.afterUIComponentDisappear
																	.bind(this)
														}
													}),
											writable : true,
											enumerable : true
										}
									});
				},

				/**
				 * This method will be called automatically when app finishes
				 * launching.
				 * 
				 * @name sap.viz.mvc.UIController#initialize
				 * @param {Object}
				 *            the option passed in app's constructor
				 * @function
				 */
				initialize : noop,
				/**
				 * Fire the event supported by application which is declared in
				 * {@link sap.viz.mvc.VizApplication#getSupportedEvents}
				 * 
				 * @name sap.viz.mvc.UIController#fireAppEvent
				 * @function
				 */
				fireAppEvent : function(event, arguments) {
					this.application.fireEvent(event, arguments);
				},

				/**
				 * This method will be called when the managed UIComponent will
				 * become visible via set the hidden property
				 * 
				 * @name sap.viz.mvc.UIController#beforeUIComponentAppear
				 * @function
				 */
				beforeUIComponentAppear : noop,

				/**
				 * This method will be called after the managed UIComponent
				 * became visible via set the hidden property
				 * 
				 * @name sap.viz.mvc.UIController#afterUIComponentAppear
				 * @function
				 */
				afterUIComponentAppear : noop,
				/**
				 * This method will be called when the managed UIComponent will
				 * become visible via set the hidden property
				 * 
				 * @name sap.viz.mvc.UIController#beforeUIComponentDisappear
				 * @function
				 */
				beforeUIComponentDisappear : noop,
				/**
				 * This method will be called after the managed UIComponent
				 * became visible via set the hidden property
				 * 
				 * @name sap.viz.mvc.UIController#afterUIComponentDisappear
				 * @function
				 */
				afterUIComponentDisappear : noop,

				/**
				 * This method will be called when user apply a new theme, and
				 * if and only if the controller is the root controller.
				 * 
				 * @name sap.viz.mvc.UIController#doThemeApplied
				 * @function
				 * @param {String}
				 *            old the name of the old theme
				 * @param {String}
				 *            new the name of the new theme
				 */
				doThemeApplied : noop,

				/**
				 * This method will be called when user update the theme setting
				 * and if and only if the controller is the root controller.
				 * 
				 * @name sap.viz.mvc.UIController#doThemeUpdated
				 * @function
				 * @param {String}
				 *            key the key of the updated property
				 * @param {Object}
				 *            oldValue the old value
				 * @param {Object}
				 *            newValue the new value
				 */
				doThemeUpdated : noop,

				/**
				 * Default implementation is to destroy the component hierarchy
				 * it managed from the root. Subclass is encouraged to override
				 * this method to provide it's own implementation.
				 * 
				 * @name sap.viz.mvc.UIController#destroy
				 */
				destroy : function() {
					this.rootUIComponent.destroy();
				}
			});

	return UIController;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.Event',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.Class',
  version : '4.0.2'
}
],
function Setup(Class) {
	var Event = Class.define({
		/**
		 * Event class
		 * 
		 * @name sap.viz.mvc.Event
		 * @constructor
		 */
		constructor : function(type, target, canBubbling) {
			this.type = type;
			this.target = target;
			this.currentTarget = target;
			this.timestamp = Date.now();
			this.load = undefined;
			this._canBubbling = canBubbling !== undefined ? canBubbling : true;
		},

		/**
		 * Whether the event is in the bubbling phase
		 * 
		 * @name sap.viz.mvc.Event#isInBubbling
		 * @function
		 * @returns {Boolean}
		 * 
		 */
		isInBubbling : function() {
			return this.target.id !== this.currentTarget.id;
		},
		/**
		 * Whether the event should be bubbled
		 * 
		 * @name sap.viz.mvc.Event#shouldBubble
		 * @function
		 * @returns {Boolean}
		 * 
		 */
		shouldBubble : function() {
			return this._canBubbling;
		},
		/**
		 * Stop the event propagation in the bubbling phase
		 * 
		 * @name sap.viz.mvc.Event#stopPropagation
		 * @function
		 * 
		 */
		stopPropagation : function() {
			this._canBubbling = false;
		}
	});

	return Event;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.TouchEvent',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.Event',
  version : '4.0.2'
}
],
function Setup(FuncUtils, Event) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * Touch class
	 * 
	 * @name sap.viz.mvc.Touch
	 * @constructor
	 */
	var Touch = function(identifier, target, localXY, pageXY) {
		this.identifier = identifier;
		this.target = target;
		this.localXY = localXY;
		this.pageXY = pageXY;
	};
	/**
	 * Touch List class
	 * 
	 * @name sap.viz.mvc.TouchList
	 * @constructor
	 */
	var TouchList = function(tArray, tMap) {
		this.tA = tArray, this.tM = tMap;
	};

	var tlp = TouchList.prototype;
	/**
	 * Return the length of the list
	 * 
	 * @name sap.viz.mvc.TouchList#length
	 * @function
	 * @returns {Number}
	 * 
	 */
	tlp.length = function() {
		return this.tA.length;
	};
	/**
	 * Get the touch at specified index
	 * 
	 * @name sap.viz.mvc.TouchList#item
	 * @function
	 * @param {Number}
	 *            index
	 * @returns {sap.viz.mvc.Touch}
	 */
	tlp.item = function(index) {
		if (index >= 0 && (index < this.tA.length)) {
			return this.tA[index];
		}
	};
	/**
	 * Get the touch with specified identifier
	 * 
	 * @name sap.viz.mvc.TouchList#identifiedTouch
	 * @function
	 * @param {Number}
	 *            identifier
	 * @returns {sap.viz.mvc.Touch}
	 */
	tlp.identifiedTouch = function(identifier) {
		if (identifier) {
			return this.tM[identifier];
		}
	};
	/**
	 * This class defines Touch Event
	 * 
	 * @name sap.viz.mvc.TouchEvent
	 * @class
	 * @augments sap.viz.mvc.Event
	 */
	var TouchEvent = Event.extend(
	/**
	 * @lends sap.viz.mvc.TouchEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, touches, targetTouches, changedTouches) {
			this.touches = touches;
			this.targetTouches = targetTouches;
			this.changedTouches = changedTouches;
		}
	});
	var _buildTouchListFromTouchList = function(touchlist) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchlist.length; i < len; i++) {
			targetComp = _findTargetComp(touchlist.item(i));
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchlist.item(i), targetComp);
				tArray.push(touch);
				tMap[touch.identifier] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _buildTouchListFromTouchArray = function(touchArray) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchArray.length; i < len; i++) {
			targetComp = _findTargetComp(touchArray[i]);
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchArray[i], targetComp);
				tArray.push(touch);
				tMap[touch.identifier] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _findTargetComp = function(touch) {
		var cnode = $(touch.target);
		while (cnode.length && !cnode.data('selfComp')) {
			cnode = cnode.parent();
		}
		return cnode.data('selfComp');
	};

	var _buildTouch = function(touch, targetComp) {
		var targetCompPagePosition = targetComp.pagePosition();
		var localXY = {
			x : touch.pageX - targetCompPagePosition.x,
			y : touch.pageY - targetCompPagePosition.y
		};
		// binding to UIComponent instead of Element
		return new Touch(touch.identifier, targetComp, localXY, {
			x : touch.pageX,
			y : touch.pageY
		});
	};
	TouchEvent.buildFrom3TouchArray = function(type, target, touches, changedTouches, targetTouches, canBubbling) {
		var _touches = _buildTouchListFromTouchArray(touches);
		var _targetTouches = _buildTouchListFromTouchArray(targetTouches);
		var _changedTouches = _buildTouchListFromTouchArray(changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	TouchEvent.buildFromDomTouchEvent = function(type, target, domTouchEvent, canBubbling) {
		var _touches = _buildTouchListFromTouchList(domTouchEvent.touches);
		var _targetTouches = _buildTouchListFromTouchList(domTouchEvent.targetTouches);
		var _changedTouches = _buildTouchListFromTouchList(domTouchEvent.changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	return TouchEvent;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.MouseEvent',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.mvc.Event',
  version : '4.0.2'
}
],
function Setup(Event) {
	/**
	 * This class defines Mouse Event
	 * 
	 * @name sap.viz.mvc.MouseEvent
	 * @class
	 * @augments sap.viz.mvc.Event
	 */
	var MouseEvent = Event.extend(
	/**
	 * @lends sap.viz.mvc.MouseEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, localXY, pageXY) {
			this.relatedTarget = undefined;
			this.targetLocalXY = localXY;
			this.currentLocalXY = localXY;
			this.pageXY = pageXY;
		}
	});
	return MouseEvent;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
function Setup(FuncUtils) {
	function hasMoreInOrder() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._head;
			} else {
				this._cursor = this._cursor.next;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	}

	function hasMoreInReverse() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._last;
			} else {
				this._cursor = this._cursor.prev;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	}
	/**
	 * Iterator for LinkedHashMap, to get an iterator for a linkedHashMap
	 * instance, use {@link sap.viz.base.utils.LinkedHashMap#getIterator}
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator
	 * @constructor
	 */
	var lhmItr = function(lhm, reverseOrder) {
		this._lhm = lhm;
		this._reverse = reverseOrder || false;
		this._count = lhm._length;
		this._cursor = this._reverse ? this._lhm._last : this._lhm._head;
		if (this._reverse) {
			this.hasMore = hasMoreInReverse;
		} else {
			this.hasMore = hasMoreInOrder;
		}
	};

	var lhmItrP = lhmItr.prototype;

	/**
	 * Find if there is more item to iterate, calling this method will move the
	 * cursor forward to next item
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#hasMore
	 * @function
	 * @returns {Boolean}
	 */
	lhmItrP.hasMore = FuncUtils.noop;

	/**
	 * Get the entry at the current cursor, calling this method without calling
	 * hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#next
	 * @function
	 * @returns {Object} with key & value property indicating the entry's key
	 *          and value object
	 */
	lhmItrP.next = function() {
		var ret = {
			key : this._cursor.key,
			value : this._cursor.value
		};
		return ret;
	};
	/**
	 * Get the value of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#nextValue
	 * @function
	 * @returns {Object}
	 */
	lhmItrP.nextValue = function() {
		return this._cursor.value;
	};
	/**
	 * Get the key of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#nextKey
	 * @function
	 * @returns {String}
	 */
	lhmItrP.nextKey = function() {
		return this._cursor.key;
	};
	/**
	 * Reset the iterator to initial state
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#reset
	 * @function
	 */
	lhmItrP.reset = function() {
		this._count = this._lhm._length;
	};

	/**
	 * Remove the current entry from LinkedHashMap
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#remove
	 * @function
	 */
	lhmItrP.remove = function() {
		return this._lhm.remove(this._cursor.key);
	};

	/**
	 * Create an empty LinkedHashMap
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap
	 * @constructor
	 */
	var LinkedHashMap = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	var lhmp = LinkedHashMap.prototype;

	/**
	 * Add one entry, if the key for the entry is already existing, then the old
	 * value will be replaced.
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#add
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @returns {undefined|Object} undefined if key is new, otherwise will be
	 *          the replaced value
	 */
	lhmp.add = function(key, value) {
		var m = this._map;
		var ret = null;
		var node = {
			prev : null,
			key : key,
			value : value,
			next : null
		};
		if (!this._length) {
			this._head = this._last = node;
		}
		if (!m.hasOwnProperty(key)) {
			m[key] = node;
			this._length++;
			node.prev = this._last;
			this._last.next = node;
			this._last = node;
			this._last.next = this._head;
			this._head.prev = this._last;
		} else {
			ret = m[key].value;
			m[key].value = value;
		}
		return ret;
	};
	/**
	 * Add entries from an existing linked hash map, the duplicated entry will
	 * be replaced silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#addAll
	 * @function
	 * @param {sap.viz.base.utils.LinkedHashMap}
	 *            linkedHashMap another linkedHashMap to added
	 */
	lhmp.addAll = function(linkedHashMap) {
		var itr = linkedHashMap.getIterator();
		var entry;
		while (itr.hasMore()) {
			entry = itr.next();
			this.add(entry.key, entry.value);
		}
	};
	/**
	 * Insert the entry before one entry, if the inserted entry exists or the
	 * entry to be inserted before doesn't exist, insertion will fail silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#insertBefore
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            beforeKey the key of the entry to be inserted before
	 * @returns {Object} the value inserted
	 */
	lhmp.insertBefore = function(key, value, beforeKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(beforeKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[beforeKey];
			if (anode !== this._head) {
				nnode.prev = anode.prev;
				anode.prev.next = nnode;
			} else {
				this._head = nnode;
				nnode.prev = this._last;
			}
			nnode.next = anode;
			anode.prev = nnode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Insert the entry after one entry, if the inserted entry exists or the
	 * entry to be inserted after doesn't exist, insertion will fail silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#insertAfter
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            afterKey the key of the entry to be inserted after
	 * @returns {Object} the value inserted
	 */
	lhmp.insertAfter = function(key, value, afterKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(afterKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[afterKey];
			if (anode !== this._last) {
				nnode.next = anode.next;
				anode.next.prev = nnode;
			} else {
				this._last = nnode;
				this._last.next = this._head;
			}
			anode.next = nnode;
			nnode.prev = anode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Replace the existing entry with new entry, including key in place
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#replace
	 * @function
	 * @param {String}
	 *            key the key for the entry to be replaced
	 * @param {withKey}
	 *            withKey the key for the entry to be added
	 * @param {Object}
	 *            andValue the value of the entry to be added
	 * @returns {Object} the value to be replaced
	 */
	lhmp.replace = function(key, withKey, andValue) {
		var m = this._map;
		if (!m.hasOwnProperty(withKey) && m.hasOwnProperty(key)) {
			var nnode = {
				prev : null,
				key : withKey,
				value : andValue,
				next : null
			};
			var rnode = m[key];
			nnode.prev = rnode.prev;
			nnode.next = rnode.next;
			rnode.prev.next = nnode;
			rnode.next.prev = nnode;
			if (this._head === rnode)
				this._head = nnode;
			if (this._last === rnode)
				this._last = nnode;
			m[withKey] = nnode;
			delete m[key];
			return rnode.value;
		}
	};
	/**
	 * Get the value for the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#get
	 * @function
	 * @param {String}
	 *            key the key for the entry to get
	 * 
	 * @returns {Null|Object} the value for the key or Null if key is
	 *          non-existing
	 */
	lhmp.get = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].value;
		}
		return null;
	};
	/**
	 * Get the value of entry next to the entry associated with the given key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#next
	 * @function
	 * @param {String}
	 *            key the key of the entry
	 * 
	 * @returns {Null|Object} the value for the key or Null if key is
	 *          non-existing
	 */
	lhmp.next = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].next;
		}
		return null;
	};
	/**
	 * Get the value of entry previous to the entry associated with the given
	 * key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#prev
	 * @function
	 * @param {String}
	 *            key the key of the entry
	 * 
	 * @returns {Null|Object} the value for the key or Null if key is
	 *          non-existing
	 */
	lhmp.prev = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].prev;
		}
		return null;
	};
	/**
	 * Get the first inserted entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getFirstInsert
	 * @function
	 * 
	 * @returns {Object} the value first inserted
	 */
	lhmp.getFirstInsert = function() {
		return this._head ? this._head.value : null;
	};
	/**
	 * Get the last inserted entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getLastInsert
	 * @function
	 * 
	 * @returns {Object} the value last inserted
	 */
	lhmp.getLastInsert = function() {
		return this._last ? this._last.value : null;
	};
	/**
	 * Move entry associated with key to the last of the link
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#moveToLast
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 */
	lhmp.moveToLast = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._last.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.prev = this._last;
			node.next = this._last.next;
			this._last.next = node;
			this._last = node;
			this._head = node.next;
			this._head.prev = node;

		}
	};
	/**
	 * Move entry associated with key to the first of the link
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#moveToFirst
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 */
	lhmp.moveToFirst = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._head.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = this._head;
			node.prev = this._head.prev;
			this._head.prev = node;
			this._head = node;
			this._last = node.prev;
			this._last.next = node;
		}
	};
	/**
	 * Check whether having the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#has
	 * @function
	 * @param {String}
	 *            key the key of the entry to check
	 * @returns {Boolean}
	 */
	lhmp.has = function(key) {
		var m = this._map;
		return m.hasOwnProperty(key);
	};
	/**
	 * Remove the entry associated with the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#remove
	 * @function
	 * @param {String}
	 *            key the key of the entry to remove
	 * @returns {undefined|Object} the removed item or undefined if key is
	 *          non-existing
	 */
	lhmp.remove = function(key) {
		var m = this._map;
		var ret;
		if (m.hasOwnProperty(key)) {
			var node = m[key];
			ret = node.value;
			if (node === this._head) {
				this._head = node.next;
			}
			if (node === this._last) {
				this._last = node.prev;
			}
			node.prev.next = node.next;
			node.next.prev = node.prev;

			delete m[key];
			this._length--;
			if (this._length === 0) {
				this._head = this._last = undefined;
			}
			return ret;
		}
	};
	/**
	 * Remove all entries added before
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#purgeAll
	 * @function
	 */
	lhmp.purgeAll = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	/**
	 * Whether the map is empty
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#isEmpty
	 * @function
	 * 
	 * @returns {Boolean}
	 */
	lhmp.isEmpty = function() {
		return this._length == 0;
	};
	/**
	 * Length of the map
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#length
	 * @function
	 * @returns {Integer}
	 */
	lhmp.length = function() {
		return this._length;
	};
	/**
	 * Get the iterator of the map
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getIterator
	 * @function
	 * @param {Boolean}
	 *            reverseOrder whether iterate in reverse order
	 * @returns {sap.viz.base.utils.LinkedHashMap.Iterator}
	 */
	lhmp.getIterator = function(reverseOrder) {
		return new lhmItr(this, reverseOrder);
	};

	lhmp.keys = function() {
		var itr = this.getIterator(), keys = [];
		while (itr.hasMore())
			keys.push(itr.nextKey());
		return keys;
	};

	lhmp.values = function() {
		var itr = this.getIterator(), values = [];
		while (itr.hasMore())
			values.push(itr.nextValue());
		return values;
	};
	return LinkedHashMap;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.DomWatcher',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.2'
}
],
function Setup(UADetector, LinkedHashMap) {
	var watcherId = 0, domNo = 1, observer;
	
	function nextWatcherId() {
		return watcherId++;
	}
	function nextDomNo() {
		return domNo++;
	}
                
	function isEmpty(obj) {
		for ( var prop in obj) {
			if (obj.hasOwnProperty(prop))
				return false;
		}
		return true;
	}
	function css(dom, prop) {
		var val = null;
		if (window.getComputedStyle) {
			val = window.getComputedStyle(dom, null)[prop];
		} else if (dom.currentStyle) {
			val = dom.currentStyle[prop];
		}
		return val;
	}
	function domDataAccessor(key, value) {
		if (!this._data)
			this._data = {};
		if (arguments.length === 2) {
			this._data[key] = value;
		} else
			return this._data[key];
	}
	var domTasks = new LinkedHashMap();
	//var observers = new LinkedHashMap();
	function eventHandler(mutations) {
		var task, dom, domNo, domTaskIt;
		mutations.forEach(
    		function(mutation){
        		dom = mutation.target;
        		domNo = domDataAccessor.call(dom, 'domNo');
        		if (!domNo)
        			return;
        		domTaskIt = domTasks.get(domNo).getIterator();
        		while (domTaskIt.hasMore()) {
        			task = domTaskIt.nextValue();
        			task.checkChange();
    		  }
    		}
		);
	}
	
    var Observer = window.MutationObserver || window.WebKitMutationObserver;

	function addEventHandler(id) {
		var task = taskQueue.get(id);
		var dom = task.domElem;
		var domNo = domDataAccessor.call(dom, 'domNo');
		var observer;
		if (!domNo) {
			domNo = nextDomNo();
			domDataAccessor.call(dom, 'domNo', domNo);
			domTasks.add(domNo, new LinkedHashMap());
		}
		domTasks.get(domNo).add(task.id, task);
		if (!domDataAccessor.call(dom, 'observer')){
		    
		    if(!Observer)
		        return;
		    
		    observer = new Observer(eventHandler);
		    domDataAccessor.call(dom, 'observer', observer);
		    observer.observe(dom, { attributes: true });
		}
		/*if (!domDataAccessor.call(dom, 'eventHandler')) {
			if (typeof (dom.onpropertychange) == "object") {
				dom.attachEvent("onpropertychange", eventHandler);
			} else if (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
				dom.addEventListener("DOMAttrModified", eventHandler);
			}
			domDataAccessor.call(dom, 'eventHandler', eventHandler);
		}*/
	}
	function removeFromEventHandler(task) {
		var dom = task.domElem;
		var domNo = domDataAccessor.call(dom, 'domNo');
		if (!domNo)
			return;

		if (domTasks.get(domNo).has(task.id))
			domTasks.get(domNo).remove(task.id);

		if (domTasks.get(domNo).isEmpty()) {
			//var eventHandler = domDataAccessor.call(dom, 'eventHandler');
			/*if (typeof (dom.onpropertychange) == "object") {
				dom.detachEvent("onpropertychange", eventHandler);
			} else if (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
				dom.removeEventListener("DOMAttrModified", eventHandler);
			}
			domDataAccessor.call(dom, 'eventHandler', null);*/
			domDataAccessor.call(dom, 'observer').disconnect();
		}
	}
	var scannerInstance = undefined;
	var taskQueue = new LinkedHashMap();
	function scanner() {
		var taskItr = taskQueue.getIterator();
		var task;
		while (taskItr.hasMore()) {
			task = taskItr.nextValue();
			task.checkChange();
		}
	}
	function addIntervalTask(task) {
		if (!scannerInstance)
			scannerInstance = setInterval(scanner, 100);
		if (!taskQueue.has(task.id))
			taskQueue.add(task.id, task);
	}
	function removeIntervalTask(id) {
		if (taskQueue.has(id)) {
			taskQueue.remove(id);
		}
		if (taskQueue.isEmpty()) {
			clearInterval(scannerInstance);
			scannerInstance = undefined;
		}
	}
	function hookChange(task) {
		var dom = task.domElem;
		if (typeof (MutationObserver) == "function" 
				|| UADetector.isFirefox && parseInt(UADetector.version())>=14 
                || UADetector.isChrome && parseInt(UADetector.version())>=18) {
			addEventHandler(task.id);
		} else {
			// for browsers not support dom attributes change event, add a
			// iterval task to check properties changes.
			addIntervalTask(task);
		}
	}
	function __watcher(id) {
		var task = taskQueue.get(id);
		if (!task)
			return;
		var dom = task.domElem;
		if (!task.callback)
			return;

		var changed = false;
		var i = 0;
		var changedProps = [];
		for ( var l = task.cssProps.length; i < l; i++) {
			var newVal = css(dom, task.cssProps[i]);
			if (task.lastestVals[i] != newVal) {
				task.lastestVals[i] = newVal;
				changed = true;
				changedProps.push(task.cssProps[i]);
			}
		}
		if (changed)
			// task.callback.call(caller, changedProps);
			task.callback(changedProps);
	}
	// var caller;
	var DomWatcher = {
		/**
		 * watch a dom element on specific css properties, if change, excute
		 * callback func, callback parameter is an array of changed properties
		 * 
		 * @param dom
		 *            element to watch
		 * @param props
		 *            properties on element to watch, input as a string,
		 *            properties should be seperated by comma ','
		 *            valid properties are {position|size|show}
		 * @param func
		 *            function to execute on properties change, when calling
		 *            DomWatcher.watch
		 * @return generated watcher id
		 */
		watch : function(dom, props, func) {
			// caller = this.watch.caller;
			var id = nextWatcherId();
			var task = {
				id : id,
				domElem : dom,
				cssProps : props.split(","),
				lastestVals : [ props.split(",").length ],
				callback : func,
				checkChange : function() {
                    __watcher(id);
                }
			};

			for ( var i = 0, len = task.cssProps.length; i < len; i++) {
				task.lastestVals[i] = css(dom, task.cssProps[i]);
			}
			if (!taskQueue.has(task.id))
				taskQueue.add(task.id, task);
			hookChange(task);
			return id;
		},
		unwatch : function(id) {
			var task = taskQueue.get(id);
			if (task){
				var dom = task.domElem;
				try {
					if (typeof (dom.onpropertychange) == "object"
							|| (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
						removeFromEventHandler(task);
					} else
						removeIntervalTask(task.id);
				}
				// ignore if element was already unbound
				catch (e) {
				}
			}
		}
	};
	return DomWatcher;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.VizFrame',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.DomUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.DomWatcher',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.Event',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.MouseEvent',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.TouchEvent',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.Math',
  version : '4.0.2'
}
],
function Setup(FuncUtils, D, UIComponent, GestureDetector, DomWatcher, Event,
        MouseEvent, TouchEvent, Math) {
    var ArrayPush = Array.prototype.push;
    // var $ = jQuery;
    var error = FuncUtils.error;
    // if (!$) {
    // error('Cannot find jQuery');
    // }
    function isInDOM(el) {
        while (el = el.parentNode)
            if (el === document)
                return true;
        return false;
    }

    function getHittedComponent(event) {
        var domEntity = D(event.target);
        while (!domEntity.data('selfComp')) {
            domEntity = domEntity.parent();
        }
        return domEntity.data('selfComp');
    }

    var ts = GestureDetector.TransitionState;

    function regDOMEventHandlers() {
        var handler = handleDomEvent.bind(this);
        D(this.container).bind('click', handler);
        D(this.container).bind('dblclick', handler);
        D(this.container).bind('focusin', handler);
        D(this.container).bind('focusout', handler);
        D(this.container).bind('focus', handler);
        D(this.container).bind('blur', handler);
        D(this.container).bind('mousedown', handler);
        D(this.container).bind('mouseup', handler);
        D(this.container).bind('mouseenter', handler);
        D(this.container).bind('mouseleave', handler);
        D(this.container).bind('mousemove', handler);
        // Below events are supposed to be fired when the
        // element is attached/detached to/from document,
        // it's used to register touch listener correctly in
        // iOS Mobile Safari.
        D(this.container).bind('DOMNodeInsertedIntoDocument',
                registerDOMTouchHandler.bind(this));
        D(this.container).bind('DOMNodeRemovedFromDocument',
                unregisterDOMTouchHandler.bind(this));
    }

    function registerDOMTouchHandler() {
        var handler = handleDomEvent.bind(this);
        D(this.container).bind('touchstart', handler);
        D(this.container).bind('touchmove', handler);
        D(this.container).bind('touchend', handler);
        D(this.container).bind('touchcancel', handler);
    }

    function unregisterDOMTouchHandler() {
        D(this.container).unbind('touchstart');
        D(this.container).unbind('touchmove');
        D(this.container).unbind('touchend');
        D(this.container).unbind('touchcancel');
    }

    function handleDomEvent(event) {
        event.preventDefault();
        var hittedComp = getHittedComponent(event), e;
        switch (event.type) {
        case 'mousemove':
            if (hittedComp) {
                var hittedCompPageXY = hittedComp.pagePosition();
                var localPoint = {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                };
                if (this._msTracking.length) {
                    if (this._msTracking[this._msTracking.length - 1] !== hittedComp) {
                        var enteredComps = [];
                        var entered = hittedComp;
                        while (entered) {
                            enteredComps.push(entered);
                            entered = entered.parent;
                        }
                        var inCompCount = 0, checkFinished = false, minLen = Math
                                .min(this._msTracking.length,
                                        enteredComps.length);
                        while (true) {
                            var left = undefined;
                            if (!checkFinished
                                    && this._msTracking[inCompCount] === enteredComps[enteredComps.length
                                            - 1 - inCompCount]) {
                                inCompCount++;
                                checkFinished = inCompCount === minLen;
                            } else {
                                while (this._msTracking.length > inCompCount) {
                                    left = this._msTracking.pop();
                                    e = new MouseEvent('mouseleave', left,
                                            false, left.pointFrom(localPoint,
                                                    hittedComp), {
                                                x : event.pageX,
                                                y : event.pageY
                                            });
                                    e.relatedTarget = hittedComp;
                                    // load property of the dom event is used as
                                    // the vehicle to transfer information to
                                    // component event
                                    e.load = event.load;
                                    left.fireMouseEvent(e);
                                }
                                while (inCompCount < enteredComps.length) {
                                    var entered = enteredComps.shift();
                                    left = this._msTracking[enteredComps.length - 1];
                                    this._msTracking[enteredComps.length] = entered;
                                    e = new MouseEvent('mouseenter', entered,
                                            false, entered.pointFrom(
                                                    localPoint, hittedComp), {
                                                x : event.pageX,
                                                y : event.pageY
                                            });
                                    e.relatedTarget = left;
                                    e.load = event.load;
                                    entered.fireMouseEvent(e);
                                }
                                break;
                            }
                        }
                    }
                } else {
                    var entered = hittedComp, e;
                    do {
                        this._msTracking.push(entered);
                        e = new MouseEvent('mouseenter', entered, false,
                                localPoint, {
                                    x : event.pageX,
                                    y : event.pageY
                                });
                        e.load = event.load;
                        entered.fireMouseEvent(e);
                        entered = entered.parent;
                    } while (entered)
                    this._msTracking.reverse();
                }
                e = new MouseEvent('mousemove', hittedComp, true, localPoint, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                hittedComp.fireMouseEvent(e);
            } else {
                while (this._msTracking.length) {
                    var left = this._msTracking.pop();
                    var framePagePosition = this.pagePosition();
                    e = new MouseEvent('mouseleave', left, false, {
                        x : event.pageX - framePagePosition.x,
                        y : event.pageY - framePagePosition.y
                    }, {
                        x : event.pageX,
                        y : event.pageY
                    });
                    e.load = event.load;
                    left.fireMouseEvent(e);
                }
            }
            break;
        case 'mouseleave':
            while (this._msTracking.length) {
                var left = this._msTracking.pop();
                var leftCompPageXY = left.pagePosition();
                e = new MouseEvent('mouseleave', left, false, {
                    x : event.pageX - leftCompPageXY.x,
                    y : event.pageY - leftCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                left.fireMouseEvent(e);
            }
            break;
        case 'mouseup':
            if (hittedComp) {
                var hittedCompPageXY = hittedComp.pagePosition();
                e = new MouseEvent('mouseup', hittedComp, true, {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                hittedComp.fireMouseEvent(e);
            }
            break;
        case 'mousedown':
            if (hittedComp) {
                var hittedCompPageXY = hittedComp.pagePosition();
                e = new MouseEvent('mousedown', hittedComp, true, {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                hittedComp.fireMouseEvent(e);
            }
            break;
        case 'dblclick':
            if (hittedComp) {
                if (this._focusedComp) {
                    if (this._focusedComp.id !== hittedComp.id) {
                        e = new Event('blur', this._focusedComp, false);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        e = new Event('focusout', this._focusedLayer, true);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        this._focusedComp = hittedComp;
                        e = new Event('focus', this._focusedComp, false);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        e = new Event('focusin', this._focusedComp, true);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                    }
                } else {
                    this._focusedComp = hittedComp;
                    e = new Event('focus', this._focusedComp, false);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    e = new Event('focusin', this._focusedComp, true);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                }
                var hittedCompPageXY = hittedComp.pagePosition();
                e = new MouseEvent('dblclick', this._focusedComp, true, {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                this._focusedComp.fireMouseEvent(e);
            } else {
                if (this._focusedComp) {
                    e = new Event('blur', this._focusedLayer, false);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    e = new Event('focusout', this._focusedLayer, true);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    this._focusedComp = undefined;
                }
            }
            break;
        case 'click':
            if (hittedComp) {
                if (this._focusedComp) {
                    if (this._focusedComp.id !== hittedComp.id) {
                        e = new Event('blur', this._focusedComp, false);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        e = new Event('focusout', this._focusedComp, true);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        this._focusedComp = hittedComp;
                        e = new Event('focus', this._focusedComp, false);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                        e = new Event('focusin', this._focusedComp, true);
                        e.load = event.load;
                        this._focusedComp.fireFocusEvent(e);
                    }
                } else {
                    this._focusedComp = hittedComp;
                    e = new Event('focus', this._focusedComp, false);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    e = new Event('focusin', this._focusedComp, true);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                }
                var hittedCompPageXY = hittedComp.pagePosition();
                e = new MouseEvent('click', this._focusedComp, true, {
                    x : event.pageX - hittedCompPageXY.x,
                    y : event.pageY - hittedCompPageXY.y
                }, {
                    x : event.pageX,
                    y : event.pageY
                });
                e.load = event.load;
                this._focusedComp.fireMouseEvent(e);
            } else {
                if (this._focusedComp) {
                    e = new Event('blur', this._focusedComp, false);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    e = new Event('focusout', this._focusedComp, true);
                    e.load = event.load;
                    this._focusedComp.fireFocusEvent(e);
                    this._focusedComp = undefined;
                }
            }
            break;
        case 'touchstart':
            for ( var i = 0, touch, changedTouches = event.changedTouches, len = changedTouches.length; i < len; i++) {
                touch = changedTouches.item(i);
                // 'false' means the touch hasn't been
                // marked
                // cancelled
                this._touchSeqTracking[touch.identifier] = false;
            }

            // Handle gesture Detection
            handleGestureDetect.call(this, hittedComp, event);
            e = TouchEvent.buildFromDomTouchEvent('touchstart', hittedComp,
                    event);
            e.load = event.load;
            hittedComp.fireTouchEvent(e);
            break;
        case 'touchmove':
            // Handle gesture Detection and fire touchmove
            // event when no gesture currently detected
            if (!handleGestureDetect.call(this, hittedComp, event)) {
                e = TouchEvent.buildFromDomTouchEvent('touchmove', hittedComp,
                        event);
                e.load = event.load;
                hittedComp.fireTouchEvent(e);
            }
            break;
        case 'touchend':
            // Handle gesture Detection
            handleGestureDetect.call(this, hittedComp, event);
            var uncancelledTouchesArray = [], cancelledTouchesArray = [], touchesArray = [], targetTouchesArray = [];
            for ( var i = 0, touch, changedTouches = event.changedTouches, len = changedTouches.length; i < len; i++) {
                touch = changedTouches.item(i);
                this._touchSeqTracking[touch.identifier] === true ? cancelledTouchesArray
                        .push(touch)
                        : uncancelledTouchesArray.push(touch);
                delete this._touchSeqTracking[touch.identifier];
            }

            if (uncancelledTouchesArray.length) {
                // Some touches are not cancelled, so we
                // have to split the event into two events,
                // one for cancelled touches, one for
                // uncancelled touches
                for ( var i = 0, touch, targetTouches = event.targetTouches, len = targetTouches.length; i < len; i++) {
                    touch = targetTouches.item(i);
                    targetTouchesArray.push(touch);
                }
                for ( var i = 0, touch, touches = event.touches, len = touches.length; i < len; i++) {
                    touch = touches.item(i);
                    touchesArray.push(touch);
                }
                e = TouchEvent
                        .buildFrom3TouchArray('touchcancel', hittedComp,
                                touchesArray, cancelledTouchesArray,
                                targetTouchesArray);
                e.load = event.load;
                hittedComp.fireTouchEvent(e);
                e = TouchEvent.buildFrom3TouchArray('touchend', hittedComp,
                        touchesArray, uncancelledTouchesArray,
                        targetTouchesArray);
                e.load = event.load;
                hittedComp.fireTouchEvent(e);
            } else {
                // All ended touches are marked as cancelled
                e = TouchEvent.buildFromDomTouchEvent('touchcancel',
                        hittedComp, event);
                e.load = event.load;
                hittedComp.fireTouchEvent(e);
            }
            // Fire touch event
            break;

        case 'touchcancel':
            // Handle gesture Detection
            handleGestureDetect.call(this, hittedComp, event);
            for ( var i = 0, touch, changedTouches = event.changedTouches, len = changedTouches.length; i < len; i++) {
                touch = changedTouches.item(i);
                delete this._touchSeqTracking[touch.identifier];
            }
            e = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
                    event);
            e.load = event.load;
            hittedComp.fireTouchEvent(e);
            break;
        }
    }

    function handleGestureDetect(hittedComponent, origTouchEvent) {
        var grs = [];
        var thisLevel = hittedComponent;
        // find the gesture recognizers responsible for the
        // gesture detection of the component hierarchy
        do {
            ArrayPush.apply(grs, thisLevel.gestureDetectors);
        } while (thisLevel = thisLevel.parent)

        var someGestureDetected = false, gestureDetected, needToCancelTouches = false;
        for ( var i = 0, state, gd, len = grs.length; i < len; i++) {
            gd = grs[i];
            switch (origTouchEvent.type) {
            case 'touchstart':
                gd.touchBegin(origTouchEvent);
                break;
            case 'touchmove':
                gd.touchMove(origTouchEvent);
                break;
            case 'touchend':
                gd.touchEnd(origTouchEvent);
                break;
            case 'touchcancel':
                gd.touchCancel(origTouchEvent);
                break;
            }
            state = gd.state;
            gestureDetected = (state === ts.Began) || (state === ts.Changed)
                    || (state === ts.Recognized);
            someGestureDetected = someGestureDetected || gestureDetected;
            needToCancelTouches = needToCancelTouches
                    || (gestureDetected && gd.cancelTouches());
        }
        if (needToCancelTouches) {
            for ( var i = 0, touch, changedTouches = origTouchEvent.changedTouches, len = changedTouches.length; i < len; i++) {
                touch = changedTouches.item(i);
                // Mark all changed touch as cancelled
                this._touchSeqTracking[touch.identifier] = true;
            }
        }
        return someGestureDetected;
    }
    

    var VizFrame = UIComponent
            .extend({
                constructor : function(options) {
                    options = options || {};
                    if (options.holder) {
                        /*this._watcherIds = [];
                        var onResize = function(dom, callback) {
                            var percentSizeReg = /.*%/, dDom = D(dom);
                            this._watcherIds.push(DomWatcher.watch(dom, "width,height", callback));
                            if (percentSizeReg.test(dom.style.width)
                                    || percentSizeReg.test(dom.style.height)) {
                                if (dDom.css("position") !== "absolute"){
                                    this._watcherIds.push(DomWatcher.watch(D(dom).parent().get(0), "width,height",
                                            callback));
                                }
                                else{
                                    this._watcherIds.push(DomWatcher.watch(D(dom).offsetParent(), "width,height",
                                            callback));
                                }
                            }
                        }.bind(this);*/
                        this._holder = D(options.holder).get(0);

                        D(this._holder).bind('DOMNodeInsertedIntoDocument',
                                function() {
                                    this.markAttached();
                                }.bind(this));
                        D(this._holder).bind('DOMNodeRemovedFromDocument',
                                function() {
                                    this.markDetached();
                                }.bind(this));

                        this.pin({
                            x : 0,
                            y : 0
                        });
                        // structure for event dispatching
                        this._msTracking = [];
                        this._touchSeqTracking = {};

                        this.frame({
                            x : 0,
                            y : 0,
                            width : D(this._holder).width(),
                            height : D(this._holder).height()
                        });
                        /*var resizeDelay;
                        onResize(this._holder,function(){
                            clearTimeout(resizeDelay);
                            resizeDelay = setTimeout(function(){
                                this.size(D(this._holder).width(), D(this._holder).height());
                            }.bind(this),100);
                        }.bind(this));*/
                        this.clipToBound(false);
                        regDOMEventHandlers.call(this);
                        // this.container.appendTo(this._holder);
                        this._holder.appendChild(this.container);
                        this.markDetached();
                        this.markHide();

                        if (isInDOM(this._holder)) {
                            this.markAttached();
                        }
                        if (D(this._holder).css('display') === 'none'
                                || D(this._holder).css('visibility') === 'hidden') {
                            this._parentVisible = false;
                            this.markHide();
                        } else {
                            this._parentVisible = true;
                            this.markShow();
                        }
                        this.root = this;
                    } else {
                        error('you have to provide a container for viz frame');
                    }
                },
                doDestroy : function() {
                    //this._watcherIds.forEach(DomWatcher.unwatch);
                    D(this._holder).unbind('DOMNodeInsertedIntoDocument');
                    D(this._holder).unbind('DOMNodeRemovedFromDocument');
                    D(this.container).unbind();
                },
                destroy : function() {
                    this._super();
                    D(this.container).detach();
                }
            });
    return VizFrame;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.ImageManager',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
}
],
function Setup(FuncUtils) {
	/**
	 * The image object
	 * 
	 * @name sap.viz.mvc.Image
	 * @constructor
	 */
	var img = function(htmlImageElement) {
		this._imgEl = htmlImageElement;
	};

	/**
	 * Return the underlying htmlImageElement
	 * 
	 * @name sap.viz.mvc.Image#getBitmap
	 * @function
	 * @returns {HtmlImageElement}
	 */
	img.prototype.getBitmap = function() {
		return this._imgEl;
	};

	/**
	 * Get or set the visual width of the image
	 * 
	 * @name sap.viz.mvc.Image#width
	 * @param {undefined|Number}
	 *            width the new width of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the width
	 */
	img.prototype.width = function(width) {
		if (width !== undefined) {
			this._imgEl.width = width;
			return this;
		}
		return this._imgEl.width;
	};

	/**
	 * Get or set the visual height of the image
	 * 
	 * @name sap.viz.mvc.Image#height
	 * @param {undefined|Number}
	 *            height the new height of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the height
	 */
	img.prototype.height = function(height) {
		if (height !== undefined) {
			this._imgEl.height = height;
			return this;
		}
		return this._imgEl.height;
	};

	/**
	 * Get the intrinsic height of the image
	 * 
	 * @name sap.viz.mvc.Image#intrinsicHeight
	 * @returns {Number}
	 */
	img.prototype.intrinsicHeight = function() {
		return this._imgEl.naturalHeight;
	};

	/**
	 * Get the intrinsic width of the image
	 * 
	 * @name sap.viz.mvc.Image#intrinsicWidth
	 * @returns {Number}
	 */
	img.prototype.intrinsicWidth = function() {
		return this._imgEl.naturalWidth;
	};

	/**
	 * Get the url of the image
	 * 
	 * @name sap.viz.mvc.Image#url
	 * @returns {String} the url of the image
	 */
	img.prototype.url = function() {
		return this._imgEl.src;
	};

	var _imageCache = {};
	var _id2src = {};
	var _src2ids = {};

	/**
	 * This class defines global shared image manager used for loading external
	 * image. The loading process is asynchronously. The loaded images are
	 * indentified by src urls internally, and can shared within the all viz
	 * application. You must assign an id when loading an image. You can
	 * retrieve the loaded image by id only. the same image can be assigned
	 * multiple ids.
	 * 
	 * @name sap.viz.mvc.ImageManager
	 * @class
	 */
	var ImageManager = {
		/**
		 * Load an image designated by URL. The loading is asynchronized, the
		 * image will be available when the onComplete is called
		 * 
		 * @param {String}
		 *            id the caller-provided Id of the image to be loaded and
		 *            retrieved later.
		 * @param {String}
		 *            url the url of the image to be loaded
		 * @param {Function}
		 *            [onComplete], the on complete callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImage : function(id, url, onComplete) {
			if (id && url) {
				onComplete = onComplete || FuncUtils.noop;
				if (_id2src.hasOwnProperty(id)) {
					if (_imageCache[_id2src[id]]) {
						onComplete(true);
						return;
					}
				}
				var imgEl = new Image();
				imgEl.onabort = imgEl.onerror = function() {
					onComplete(false, {
						id : id,
						url : url
					});
				};
				imgEl.onload = function() {
					var src = imgEl.src;
					if (!_imageCache.hasOwnProperty(src)) {
						var imgObj = new img(imgEl);
						_id2src[id] = src;
						_src2ids[src] = {
							ids : {
								id : id
							},
							length : 1
						};
						_imageCache[src] = imgObj;
					} else {
						_id2src[id] = imgEl.src;
						_src2ids[src].ids[id] = id;
						_src2ids[src].length++;
					}
					onComplete(true, {
						id : id,
						url : url
					});
				}.bind(this);
				imgEl.src = url;
			}
		},
		/**
		 * Load an array of images concurrently. The loading is asynchronized,
		 * the images will be available when the onComplete is called
		 * 
		 * @param {Object[]}
		 *            urls the array of the image url to be loaded. The urls
		 *            should follow the format:
		 * 
		 * <pre>
		 * [ {
		 * 	id : 'IMAGE_ID',
		 * 	url : 'IMAGE_URL'
		 * } ]
		 * </pre>
		 * 
		 * @param {Function}
		 *            [onComplete] the on-complete function callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImages : function(urls, onProgress, onComplete) {
			onProgress = onProgress || FuncUtils.noop;
			onComplete = onComplete || FuncUtils.noop;
			var total = urls.length;
			if (total == 0) {
				onComplete(true);
			} else {
				var count = 0;
				var _stepFunction = function(isSuccessful, imgInfo) {
					count++;
					if (count < total) {
						onProgress(count / total, isSuccessful, imgInfo);
					} else {
						onComplete(true, imgInfo);
					}
				};
				for ( var i = 0, len = urls.length; i < len; i++) {
					ImageManager.loadImage(urls[i].id, urls[i].url, _stepFunction);
				}
			}
		},

		/**
		 * Check if the image has been loaded
		 * 
		 * @param {String}
		 *            id the id of the image to be checked
		 * @returns {Boolean}
		 */
		hasImage : function(id) {
			return _id2src.hasOwnProperty(id);
		},

		/**
		 * Get the loaded image by its id, the caller has to ensure the image is
		 * loaded
		 * 
		 * @param {String}
		 *            id the id of the image to get
		 * @returns {sap.viz.mvc.Image}
		 */
		getImage : function(id) {
			if (_id2src.hasOwnProperty(id)) {
				return _imageCache[_id2src[id]];
			}
		},

		/**
		 * Remove the loaded image from internal cache
		 * 
		 * @param {String}
		 *            id the id of the image
		 */
		disposeImage : function(id) {
			if (_id2src.hasOwnProperty(id)) {
				var src = _id2src[id];
				delete _id2src[id];
				delete _src2ids[src].ids[id];
				_src2ids[src].length--;
				if (!_src2ids[src].length) {
					delete _src2ids[src];
					delete _imageCache[src];
				}
			}
		}
	};
	return ImageManager;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.Observable',
  version : '4.0.2'
}
],
function Setup(ObjUtils, Observable) {
	/**
	 * A global theme manager
	 * 
	 * @class sap.viz.mvc.ThemeManager
	 */
	var ThemeManager = new (Observable.extend(
	{
		events : [ 'defaultThemeChanged', 'themeSettingChanged' ],
		constructor : function(options) {
			this._themeReg = {};
		},
		/**
		 * Get or set the global default theme
		 * 
		 * @name sap.viz.mvc.ThemeManager#defaultTheme
		 * @function
		 * @param {String}
		 *            [theme] the name of the default theme.
		 * @return {String} the name of the current default theme
		 */
		defaultTheme : function(theme) {
			if (theme !== undefined) {
				if (this._defaultTheme !== theme && this.hasThemeInstalled(theme)) {
					var old = this._defaultTheme;
					this._defaultTheme = theme;
					this.fireEvent('defaultThemeChanged', old, theme);
				}
				return this;
			}
			return this._defaultTheme;
		},
		/**
		 * Check whether the theme has already been installed.
		 * 
		 * @name sap.viz.mvc.ThemeManager#hasThemeInstalled
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @return {Boolean}
		 */
		hasThemeInstalled : function(theme) {
			return this._themeReg.hasOwnProperty(theme);
		},
		/**
		 * Install a new theme, if it's been already installed, nothing happens.
		 * 
		 * @name sap.viz.mvc.ThemeManager#installTheme
		 * @function
		 * @param {String}
		 *            name the name of the new theme
		 * @param {Object}
		 *            settings the settings of the theme
		 */
		installTheme : function(name, settings) {
			if (!this._themeReg.hasOwnProperty(name)) {
				this._themeReg[name] = ObjUtils.extend({}, settings);
			}
		},
		/**
		 * Get the settings of given theme.
		 * 
		 * @name sap.viz.mvc.ThemeManager#getThemeSettings
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @return {Object} the settings of the theme
		 */
		getThemeSettings : function(theme) {
			if (this._themeReg.hasOwnProperty(theme)) {
				return ObjUtils.extend({}, this._themeReg[theme]);
			}
		},
		/**
		 * Update a value of a given theme's property, will fire
		 * <b>themeSettingChanged</b> event if succeed.
		 * 
		 * @name sap.viz.mvc.ThemeManager#updateThemeSetting
		 * @function
		 * @param {String}
		 *            theme the name of the theme.
		 * @param {String}
		 *            key the key whose value to be updated.
		 * @param {String}
		 *            value the new value of the key
		 */
		updateThemeSetting : function(theme, key, value) {
			if (this._themeReg.hasOwnProperty(theme)) {
				var old = this._themeReg[theme][key];
				this._themeReg[theme][key] = value;
				this.fireEvent('themeSettingChanged', theme, key, old, value);
			}
		}
	}))();
	return ThemeManager;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.VizApplication',
  version : '4.0.2'},
[
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.ImageManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.VizFrame',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.UIController',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.Logger',
  version : '4.0.2'
}
],
function Setup(Observable, FuncUtils, ThemeManager, ImageManager, VizFrame,
		UIComponent, UIController, LOG) {
	var noop = FuncUtils.noop, error = FuncUtils.error, unimplemented = FuncUtils.unimplemented, arrayPush = Array.prototype.push;
	var id = 0;
	function nextId() {
		return id++;
	}
	var Autosizing = UIComponent.Autosizing;
	/**
	 * The constructor of visualization.
	 * 
	 * @name sap.viz.mvc.VizApplication
	 * @constructor
	 * @param {Object}
	 *            options The possible options could be:
	 * 
	 * <pre>
	 * {
	 * 		id : 'ID_PREFIX',
	 * 		holder : 'Element', // The holder element
	 * 		launchOptions : 'Other Options', //the additional option that will pass to the
	 *            {@link sap.viz.mvc.VizApplication#appDidFinishLaunching}
	 * }
	 * </pre>
	 * 
	 */
	var VizApplication = Observable.extend({
		/**
		 * If there are images will be used in app, declares them here, app
		 * launching process will make sure them loaded before finishing
		 * launching.
		 * 
		 * @name sap.viz.mvc.VizApplication#images
		 * @property todo
		 */
		images : [],

		/**
		 * Place holder for UIController subclass.
		 * 
		 * @name sap.viz.mvc.VizApplication#RootControllerClass
		 * @property todo
		 */
		RootControllerClass : UIController,

		constructor : function(options) {
			if (!arguments.length) {
				error('You have to specify the options to initialize');
			}
			var holder = options.holder, id = options.id;
			if (!holder) {
				error('You have to specify the holder for the visualization');
			}
			delete options.holder;
			delete options.id;
			var prototype = this.constructor.prototype;

			if (!(prototype.RootControllerClass)) {
				error('Cannot initialize without a root UIController');
			}

			this.appWillLaunch.apply(this, [ options ]);

			var theme = ThemeManager.defaultTheme();
			Object.defineProperties(this, {
				'id' : {
					value : id ? id + '_' + nextId() : 'VizApp_' + nextId(),
					writable : false
				},
				'vizFrame' : {
					value : new VizFrame({
						holder : holder
					}),
					writable : false
				},
				'theme' : {
					get : function() {
						return theme;
					},
					set : function(value) {
						theme = value;
						if (ThemeManager.hasThemeInstalled(value)) {
							theme !== value;
							this.controller.doThemeApplied(theme);
						}
						return this;
					}
				}
			});

			ThemeManager.on('defaultThemeChanged', function(oldDefault,
					newDefault) {
				if (this._theme === oldDefault) {
					this._theme = newDefault;
					this.controller.doThemeApplied(newDefault);
				}
			}.bind(this), this.id);
			ThemeManager.on('themeSettingChanged', function(theme, key,
					oldValue, newValue) {
				if (this._theme === theme) {
					this.controller.doThemeUpdated(key, oldValue, newValue);
				}
			}.bind(this), this.id);

			var imagesToLoad = [];
			if (this.hasOwnProperty("images") && this.images) {
				arrayPush.apply(imagesToLoad, this.images);
			}
			arrayPush.apply(imagesToLoad, prototype.images);

			ImageManager.loadImages(imagesToLoad, undefined, function() {
				var rc = new prototype.RootControllerClass(this);
				Object.defineProperty(this, 'controller', {
					value : rc,
					writable : false,
					enumerable : true,
					configurable : false
				});
				this.vizFrame.append(rc.rootUIComponent);
				this.controller.initialize(options);
				this.appDidFinishLaunching.apply(this, [ options ]);

				rc.rootUIComponent.autoResizingMask(Autosizing.FlexibleWidth
						| Autosizing.FlexibleHeight);
				rc.rootUIComponent.frame(0, 0, this.vizFrame.width(),
						this.vizFrame.height());
			}.bind(this));
		},

		/**
		 * This method will be called before the application starting to
		 * launched. launchOptions(if any) will be passed as argument. Normally
		 * you can declare any images that will be used.
		 * 
		 * @name sap.viz.mvc.VizApplication#appWillLaunch
		 * @function
		 * @param {Object}
		 *            launchOption the launchOption which is passed in
		 *            VizApplication constructor
		 */
		appWillLaunch : noop,

		/**
		 * This method will be called after the application fully launched. Any
		 * visualization application specific initialization should be put here,
		 * e.g. initialize necessary data structure.
		 * 
		 * @name sap.viz.mvc.VizApplication#appDidFinishLaunching
		 * @function
		 * @param {Object}
		 *            launchOption the launchOption which is passed in
		 *            VizApplication constructor
		 */
		appDidFinishLaunching : noop,

		/**
		 * Returns metadata about the current app instance. The metadata
		 * contains 3 kinds of specification:SupportedEvent,
		 * SupportedProperties, SupportedMethods
		 * 
		 * @name sap.viz.mvc.VizApplication#getMetadata
		 * @function
		 */
		getMetadata : unimplemented,

		/**
		 * Subclass should implement this method to return plain object contains
		 * the values of requested properties or all properties if no properties
		 * 
		 * 
		 * @name sap.viz.mvc.VizApplication#getPropertyValues
		 * @param {String}
		 *            prop1
		 * @param {String}
		 *            prop2
		 * @returns {Object} property bag
		 * 
		 */
		getPropertyValues : unimplemented,

		/**
		 * Subclass should implement this method to accept a property bag.
		 * 
		 * 
		 * 
		 * @name sap.viz.mvc.VizApplication#setPropertyValues
		 * @param {Object}
		 *            property bag
		 * 
		 */
		setPropertyValues : unimplemented,

		/**
		 * Destroy the viz application instance, after being destroyed calls to
		 * this instance will not be gauranteed to return correctly
		 * 
		 * @name sap.viz.mvc.VizApplication#destroy
		 */
		destroy : function() {
			ThemeManager.un('defaultThemeChanged', this.id);
			ThemeManager.un('themeSettingChanged', this.id);
			this.controller.destroy();
			this.vizFrame.destroy();
		}
	});

	return VizApplication;
});sap.riv.module(
{
  qname : 'sap.viz.core',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.UIController',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.2'
},
{  qname : 'sap.viz.mvc.VizApplication',
  version : '4.0.2'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.2'
},
{  qname : 'sap.viz.load',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.append',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.ignite',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.handler.BaseDataHandler',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.2'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.config',
  version : '4.0.2'
},
{  qname : 'sap.viz.style.Manager',
  version : '4.0.2'
},
{  qname : 'sap.viz.TemplateManager',
  version : '4.0.2'
},
{  qname : 'sap.viz.style.Sheet',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.fn.dombuilder',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.fn.domposition',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.log.LogUtil',
  version : '4.0.2'
},
{  qname : 'sap.viz.modules.event.Manager',
  version : '4.0.2'
}
],
function Setup ( 
  TypeUtils, ObjectUtils, Objects, Functions,  // core collection
  UIController, UIComponent, VizApplication,   // foundation classes
  manifest, Modules, registry, load, append, ignite,
  Feeder, BaseDataHandler, MultiAxesDataAdapter, 
  langManager, canvgConf, StyleManager, TemplateManager, StyleSheet, 
  dombuilder, domposition, LOG , EventManager ) {
  
  function buildPropertiesTree ( obj ) {
    var returnObj = {};
    for ( var i in obj ) {
      if ( obj.hasOwnProperty(i) ) {
        if ( obj[i].supportedValueType === "Object" ) {
          returnObj[i] = buildPropertiesTree(obj[i].supportedValues);
        } else {
          returnObj[i] = obj[i].defaultValue;
        }
      }
    }
    return returnObj;
  }
  
  function mergeProperties ( defaultVal, all ) {
    var defaults = defaultVal, ret = {};    
    
    // FIXME This function is inadequate for handling container
    // property merge. This code snippet is just as a rescue to
    // pass the unit testing and should not be treated as correct.
    // Please correct it later.
    if ( all.general && defaults.layout ) {
      defaults.general = {};
      defaults.general.layout = Objects.extend(true, {}, defaults.layout);
      delete defaults.layout;
    }
    
    ret = Objects.extend(true, {}, defaults);
    
    for ( var key in defaults ) {
      if ( defaults.hasOwnProperty(key) ) {
        if ( typeof all === 'object' && all.hasOwnProperty(key) ) {
          if ( defaults[key] !== null &&
               typeof defaults[key] === 'object' && 
               !( defaults[key] instanceof Array ) ) {
            ret[key] = mergeProperties(defaults[key], all[key]);
          } else {
            if ( (typeof all[key] !== 'undefined' && all[key] instanceof Array && 
                  defaults[key] instanceof Array) || 
                 (typeof all[key] !== 'undefined' && typeof all[key] !== 'object') ) {
              ret[key] = all[key];
            }
          }
        }
      }
    }
    
    // FIXME hard-coding
    if ( ret.general ) {
      ret.layout = $.extend(true, {}, ret.general.layout);
      delete ret.general;
    }
    return ret;
  }

  function extractProperties ( modules, chartId ) {
    var defaultProperties = manifest.viz.get(chartId).allProperties();
    var mergedProperties = {};
    var tempKey;
    var tempProp = {};
    var i, j;
    for ( i in modules ) {
      if ( modules.hasOwnProperty(i) ) {
        if ( modules[i].properties && !TypeUtils.isEmptyObject(modules[i].properties()) ) {
          if ( i.indexOf('[') > -1 ) {
            if ( parseInt(i[i.indexOf('[') + 1],10) > 0 ) {
              continue;
            } else {
              tempKey = i.substring(0,i.indexOf('[')) + i.substring(i.indexOf(']') + 1);
            }
          } else {
            tempKey = i;
          }
          for ( j in defaultProperties ) {
            if ( defaultProperties.hasOwnProperty(j) ) {
              if ( defaultProperties[j].moduleRefPath === tempKey ) {
                tempProp = buildPropertiesTree(defaultProperties[j]);
                mergedProperties[j] = mergeProperties(tempProp, modules[i].properties());
              }
            }
          }
        }
      }
    }
    return mergedProperties;
  }
  
  /* Represents the root component. */
  var ChartComponent = UIComponent.extend({

    initialize : function ( options ) {
      this._config = options.config;
      this._data = options.data;
      this._modules = {};
      this._selections = {};
      this._properties = options.options;
      this._dispatch = d3.dispatch('dataTruncation', 'initialized');
      this._attachedByFramework = false;
      this._initializedEventDispatched = false;
      
      this._i18nListener = {
        fn : this._localeChanged,
        scope : this
      };

      langManager.addListener(this._i18nListener);
      
      if ( this._data.emptyDataset() ) { return; } //TODO support empty data set in module level 
      
      this._canvas = d3.select(document.createElement('canvas'))
        .style('width', 0).style('height', 0);
      
      $(this.container).prepend(this._canvas.node());
      
      var m_canvg_config = canvgConf.get(this._config.id) || {} ;
      this._max_svg =  canvgConf.enableCanvg() && m_canvg_config.max_svg ? 
        m_canvg_config.max_svg : Number.POSITIVE_INFINITY ;
      this._max_canvas = canvgConf.enableCanvg() && m_canvg_config.max_canvas ?
        m_canvg_config.max_canvas : Number.POSITIVE_INFINITY ;
      
      this._root = d3.select(this.container);      // D3 selection
      this._component_status = 'svg';
      
      var id = ObjectUtils.guid("sap-viz");
      var chartClass = id;
      
      var chartId = options.config.id.split('/');
      for ( var i = 0; i < chartId.length; i++ ) {chartClass= chartClass + ' v-'+chartId[i];}
      this._root.attr("class", chartClass);      
      this._id = id;
      
      
      this._properties = this._mergeProperties({}, this._properties);
      
      this._styleSheets = [];
      this._styleManager = new StyleManager(this._styleSheets);
      this._eventManager = EventManager().UIComponent(this);

      var helpers = {
        styleManager : this._styleManager.child(undefined, undefined, "div"),
        eventManager : this._eventManager
      };
      
      var that = this;
      
      LOG.profiling("Engine: dom builder for root level!");
      // start the initialization process, currently there is only root in _selections.
      this._selections = dombuilder(this._root, this._config.modules);
      LOG.profiling("Engine: dom builder for root level!");
      
      //fix the bug: BITVIZ-1111 [reg][PI][all chart][JavaFx] when resize chart to small, chart is cut 
      this._selections.root.style('position', 'absolute');

      if ( this._data.dataPointCount() > this._max_svg ) {
          this._component_status = 'canvg';
          this._selections.root.attr('visibility', 'hidden').style('left', 0).style('top', 0);
       }
      
      
      this._modules = (function () {
        var modules = {};
        
        //FIXME remove hard code here. and the performance is OK for now as for most of the chart we only have one module in root level
        // initialize top level modules
        var modulesArray = [];
        for (var i in that._config.modules) {
          if (that._config.modules.hasOwnProperty(i)) {
            //The following is hard code, it is just for letting data transform module be the first in initialized chain of modules.
            if(i === 'datatransform'){
              modulesArray.splice(0, 0, {'key' : i, 'module' : that._config.modules[i] });
            }else{
              modulesArray.push({'key' : i, 'module' : that._config.modules[i] });  
            }
          }
        }
        
        //root component wants to listen on 'initialized' event for each module (if they have) in root level
        that._toBeInitializedModulesCount = 0;
        
        function internalListener(){
          that._intializedListener.apply(that);
        }
        
        $.each(modulesArray, function ( index, itr ) {
          var key = itr.key;
          var value = itr.module;
          LOG.profiling("Engine: create module");
          var target = ignite(value.id, helpers, "v-m-"+key, that._selections[key] ? that._selections[key].node().nodeName : undefined);
          LOG.profiling("Engine: create module");
          
          LOG.profiling("Engine: prepare data");
          var data = value.data ? that._data.createDataAdapterForModule(value.data) : that._data;
          LOG.profiling("Engine: prepare data");
          
          var props = {};
          
          LOG.profiling("Engine: set data");
          modules[key] = target.data ? target.data(data) : target;
          LOG.profiling("Engine: set data");
          
          //root component wants to listen on 'initialized' event for each module (if they have) in root level
          if(target.dispatch && target.dispatch()['initialized']){
            that._toBeInitializedModulesCount++;
            target.dispatch().on('initialized.rootComponent', internalListener);
          }
          
          modules[key].alias = key;
          
          // TODO add support for non-containers
          
          if ( value.modules ) { // container indicator
            
            LOG.profiling("Engine: initialize children, set properties");
            if ( value.configure ) {
              props[value.configure.propertyCategory] = value.properties;
            }
            
            if ( modules[key].container ) {
              modules[key].container(that._root.node()); 
            }
            
            if ( modules[key].parent ) {
              modules[key].parent(that._selections[key]);
            }
            
            modules[key].config(value)
              .properties(Objects.extend( true, {}, props, that._properties ))
              .recharge({ func : that._wire, scope : that });
            LOG.profiling("Engine: initialize children, set properties");
            
          } else {
            LOG.profiling("Engine: set properties");
            modules[key].properties(Objects.extend( 
              true, 
              {}, 
              value.configure.properties, 
              that._properties[value.configure.propertyCategory] ));
            LOG.profiling("Engine: set properties");
          }
        });

        return modules;
      })();
      
      LOG.profiling("Engine: flattern modules");
      // flatten and extract sub module names
      var allModules = {};
      for ( var key in this._modules ) {
        if ( this._modules.hasOwnProperty(key)) {
          allModules = Objects.extend(true, {}, allModules, this._flatten(key, this._modules[key]));
        }
      }
      this._modules = allModules;
      LOG.profiling("Engine: flattern modules");
      
      this._domposition(this.size());
      
      LOG.profiling("CSS: parse css");
      this.css(options.css);
      LOG.profiling("CSS: parse css");
      
      this._dispatch.on('initialized.exportToCanvas', function () {
        that._exportToCanvas.apply(that);
      });
      
      this._attachEvents(options);
    },
    
    /* Jimmy/3/25/2013 comment out as currently it's strange that framework will invoke
     * doAfterShow first and then initialize (controller's initUIComponent) 
     *
    doAfterShow : function(){
      //Jimmy, 3/25/2013, framework doesn't support callback for attach event only
      //it will call doaftershow for attach and show/hide, we have to distinguish them
      this._attachedByFramework = true;
      if(!this._initializedEventDispatched && this._toBeInitializedModulesCount === 0){
        this._dispatch.initialized();
        this._initializedEventDispatched = true;
      }
    },
    */
    _intializedListener : function(){
      var targetCount = this._toBeInitializedModulesCount;
      targetCount--;
      if(targetCount === 0 /*&& this._attachedByFramework && !this._initializedEventDispatched*/){
        //Jimmy,3/25/2013, JS will run initialized callback immediately, however, we haven't
        //finished all work when code executing here. we will redispatch initialized event only
        //when framework is ready
        
        //Jimmy, see comments above, currently it's a workaround to use setTimeout
        var that = this;
        setTimeout(function(){
          that._dispatch.initialized();
        }, 0);        
        //this._initializedEventDispatched = true;
      }
    },
    
    _getRootLevelModules : function ( keys, modules ) {
      var allModules = {};
      for (var i = 0; i < keys.length; i++) {
        if (this._modules.hasOwnProperty(keys[i])) {
          allModules = Objects.extend(true, {}, allModules, this._flatten(keys[i], this._modules[keys[i]]));
        }
      }
      return allModules;
    },
    
    // flatten keys of the modules tree
    _flatten : function ( rootKey, rootNode, joiner ) {
      var token = joiner || '.', 
          ret = {},
          hierarchy = [ { key : rootKey, value : rootNode } ];
      
      // depth-first and exhaustively walk the tree
      (function walk ( parentKey, node ) {
        if (node.hasOwnProperty('modules')) {
          var children = node.modules(), 
              layer, 
              currentKey = parentKey;
          
          for ( var k in children ) {
            if ( children.hasOwnProperty(k) ) {
              layer = {
                key : parentKey + token + k,
                value : children[k]
              }; 
              hierarchy.push(layer);
              
              if ( children[k].modules ) {
                walk(currentKey + token + k, children[k]);
              }
            }
          }
        }
      })(rootKey, rootNode);
      
      for ( var i = 0; i < hierarchy.length; i++ ) {
        ret[hierarchy[i].key] = hierarchy[i].value;
      }
      
      return ret;
    },
    
    _attachEvents : function ( options ) {
      var events = options.events;
      
      for ( var obj in events ) {
        if ( events.hasOwnProperty(obj) ) {
          this.attachEvent(obj, events[obj].fn, events[obj].scope);
        }
      }
    },
    
    //event register strategy
    //0. first check the event on chart component,if find, only listen on controller
    //1. when modules A, B, C in the same level has this event type dispatch, register this event type on all modules.
    //2. If the module A contain other modules B, C and A, B, C all has this event type dispatch, only register event on this module.
    //3. Also there are event on chart controller, and the event name in chart controller should be unique.
    attachEvent : function ( evtType, callback, scope ) {
      var modules = this.modules(), hittedModules = {};
      var dispatch = this._dispatch;
      
      //we support optional namespace in evtType
      var i = evtType.indexOf(".");
      var typeToCheck = i > 0 ? evtType.substring(0, i) : evtType;
      
      //first check the event on chart controller
      //if find, only listen on component
      if ( dispatch[typeToCheck] ) {
        dispatch.on(typeToCheck, function () {
          callback.apply(scope, arguments);
        });
        return;
      }
      
      for ( var m in modules ) {
        if ( modules.hasOwnProperty(m) ) {
          var slist = m.split('.'),  index = slist.length - 1;
          if ( modules[m].dispatch && modules[m].dispatch()[typeToCheck] ) {
            
            for ( var t = 0; t <= index; t++ ) {
              if ( hittedModules[t] && hittedModules[t][slist.slice(0, t).toString()] ) {
                break;
              }
            }
            //if t is larger than index, it means do not exist the parent modules has this event type dispatch.
            if ( t > index ) {
              if ( !hittedModules[slist.length] ) {
                hittedModules[slist.length] = {};
              }
              hittedModules[slist.length][slist.toString()] = modules[m];
              modules[m].dispatch().on(evtType, function(){
                callback.apply(scope, arguments);
              });
            }
          }
        }
      }
    },
    
    _getRootLevelKeys : function () {
      if ( this._rootKeys ) { return this._rootKeys; }
      this._rootKeys = [];
      for ( var key in this._modules ) {
        if ( this._modules.hasOwnProperty(key) && key.indexOf('.') < 0 ) {
          this._rootKeys.push(key);
        }
      }
      return this._rootKeys;
    },
    
    _getRootKey : function () {
      if ( this._rootKey ) { return this._rootKey; }
      var type;
      for ( var key in this._modules ) {
        if ( this._modules.hasOwnProperty(key)){
          type = Modules.get(this._config.modules[key].id).type;
          if(type !== registry.Type.Controller && type !== registry.Type.Behavior && key.indexOf('.') < 0) {
            return ( this._rootKey = key );
          }
        }  
      }
    },
    
    _getRootContainer : function () {
      if ( this._rootContainer ) { return this._rootContainer; } 
      for ( var key in this._config.modules ) {
        if ( this._config.modules.hasOwnProperty(key) && 
             Modules.get(this._config.modules[key].id).type === registry.Type.Container ) {
          return ( this._rootContainer = this._modules[key] );
        }
      }
    },
    
    _domposition : function (newSize) {
      //Jimmy/1/28/2013 layout root container, in the core level, we only allow one drawing element (does it have to be a container?)
      //so we give all size to it, we will resize when the actual size being changed from framework
      var rootKey = this._getRootKey();
      var allSizeLayout = {};
      //do we need an extra layout module for this to accept padding/margin properties?
      allSizeLayout[rootKey] = {
        'bounds': {
          'x' : 0,
          'y' : 0,
          'width' : newSize.width,
          'height' : newSize.height
        }
      };
      domposition(allSizeLayout, this._selections);
    },

    _doLayout : function ( newSize ) {
      this._domposition(newSize);
      this._getRootContainer().size(newSize);
    },
    
    _updateProperties : function () {
      this._properties = this._mergeProperties(this._properties);
      
      var conf = this._config.modules;
      for ( var key in conf ) {
        if ( conf.hasOwnProperty(key) ) {
          if ( Modules.get(conf[key].id).type === registry.Type.Container ) {
            this._modules[key].properties(this._properties);
            continue;
          }
          if ( conf[key].configure && conf[key].configure.propertyCategory ) {
            this._modules[key].properties(
              this._properties[conf[key].configure.propertyCategory]);
          }
        }
      }
    },
    
    _mergeProperties : function ( xs, xs1 ) {
      var ret = {};
      ret = Objects.extend(true, {}, xs, xs1);
      return this._mergeCanvgProperties(ret) || ret;
    },
    
    _mergeCanvgProperties : function (xs) {
      if ( canvgConf.enableCanvg() && this._data.dataPointCount() >= this._max_svg ) {
        var ret = {};
        // FIXME 
        // Currently, property category is missing from GEO charts 
        // by invoking this._config.getChartPropCate(). So plotArea is used to
        // mark CanVG properties instead. 
        ret['plotArea'] = {
          animation: { dataLoading: false, dataUpdating: false }
        };
        return Objects.extend( true, {}, xs, ret );
      }
    },
    
    render : function () {
      if ( this._data.emptyDataset() ) { return; } // TODO support empty data set in module level
      
      LOG.profiling("Render: layout");
      this._doLayout(this.size());
      LOG.profiling("Render: layout");
      
      LOG.profiling("Render: drawing");
      this._paint();
      LOG.profiling("Render: drawing");
    },
    
    _localeChanged : function () {
      // update the data of modules to let the module have change to make up locale string again.
      this._getRootContainer().data(this._data);
      this._updateProperties();
      this.render();
    },

    properties : function (xs) {
      if ( !arguments.length ) { 
        return extractProperties(this._modules, this._config.id);
      }
      this._properties = this._mergeProperties(this._properties, xs);

      var conf = this._config.modules;
      for ( var key in conf ) {
        if ( conf.hasOwnProperty(key) ) {
          if ( Modules.get(conf[key].id).type === registry.Type.Container ) {
            this._modules[key].properties(this._properties);
          } else {
            if ( !conf[key].configure ) { continue; }
            this._modules[key].properties(
              this._properties[conf[key].configure.propertyCategory]);
          }
        }
      }
      //Alex Su: we may also need to update sub module path when numberOfDimsInColumn is changed
//      this._modules = this._flatten(this._getRootKey(), this._getRootContainer());
      this._modules = this._getRootLevelModules(this._getRootLevelKeys(), this._modules);
    },
       
    css : function( cssText ) {
      if ( cssText === undefined ) {
        var str = "";
        this._styleSheets.forEach(function( sheet ) {
          str += sheet.source;
        });

        return str;
      }

      if ( cssText ) {
        var sheet = new StyleSheet(cssText, this._id);
        this._styleManager.applyCSS(sheet);
        this._styleSheets.push(sheet);
      }
    },
    
    data : function (_) {
      if ( !arguments.length ) { return this._data; }
      
      this._data = _;
     
      // Hard cord: data transform module needs to refresh data
      if (this._modules.hasOwnProperty('datatransform')) {
        this._modules['datatransform'].data(this._data);
      }
      
      //currenty, we should update properties when reset dataset. As when change the component mode from svg to canvg, we should disable all animation
      this._updateProperties();
      
     
    //switch canvg mode to svg mode when change the size of dataset
      var isCanvgMode = (this._data.dataPointCount() >= this._max_svg ) && canvgConf.enableCanvg();

      if( ! ( this._component_status === 'svg' && !isCanvgMode ) ){
        this._canvas.node().getContext('2d').clearRect(0, 0, this._canvas.node().width, this._canvas.node().height);
        this._canvas.style('width', 0), this._canvas.style('height', 0);
        this._canvas.attr('width', 0), this._canvas.attr('height', 0);

        if ( isCanvgMode ) {
          this._component_status = 'canvg';
          this._selections[this._getRootKey()].attr('visibility', 'hidden').style('left', 0).style('top', 0);
        } else {
          this._component_status = 'svg';
          this._selections[this._getRootKey()].attr('visibility', 'visible');
        }
      }
      
      // refresh data
      this._getRootContainer().data(this._data);
      this._getRootContainer().refresh();
      
      // after we reset data, we need update submodules as they may
      // have changed during data update
      // TODO a potential optimization here: if we split data update and schema data updata
      // we can skip module update when only data has been updated
      //this._modules = this._flatten(this._getRootKey(), this._getRootContainer());
      this._modules = this._getRootLevelModules(this._getRootLevelKeys(), this._modules);
    },
    
    modules : function () { return this._modules; },
    
    // Callback invoked by platform upon the occurrence of a resizing event.
    doContentResize : function ( oldSize, newSize ) {
      this._super('doContentResize', oldSize, newSize);
      this.render();
    },
    
    _expandDependencyDefs : function ( item ) {
      var defs = [];
      var sourceModule = item['sourceModule'];
      var targetModule = item['targetModule'];
      var expandedSourceModules = this._expandModulePath(sourceModule);
      var expandedTargetModules = this._expandModulePath(targetModule);
      if ( expandedSourceModules.length > 1 && expandedTargetModules.length > 1 ) {
        if ( expandedSourceModules.length !== expandedTargetModules.length ) {
          Functions.error('Error on resolving dependency:' + sourceModule + ',' + targetModule);
        } else {
          for ( var i = 0, len = expandedSourceModules.length; i < len; i++ ) {
            defs.push({
              'sourceModule' : expandedSourceModules[i],
              'targetModule' : expandedTargetModules[i],
              'source' : item['source'],
              'target' : item['target'],
              'type' : item['type'],
              'listener' : item['listener']
            });
          }
        }
      } else {
        //we are sure that one of the loop will execute only once, and we don't care which one
        for ( var n = 0, nlen = expandedSourceModules.length; n < nlen; n++ ) {
          for ( var j = 0, jlen = expandedTargetModules.length; j < jlen; j++ ) {
            defs.push({
              'sourceModule' : expandedSourceModules[n],
              'targetModule' : expandedTargetModules[j],
              'source' : item['source'],
              'target' : item['target'],
              'type' : item['type'],
              'listener' : item['listener']
            });
          }
        }
      }
      
      //FIXME jimmy/8/8/2012 if both sourceModule and targetModule have
      //been expanded, and they have different number of items, what should
      //we do? do cartesian product? currently we simply throw exception
      return defs;
    },
    
    //nodeN.nodeN-1.nodeN-2...node1, for each nodeN,
    //if we have several entities for it, we should expand it
    _expandModulePath : function ( path ) {
      var pathArray = path.split('.');
      var currentPrefix = [];
      var currentExpand = [];
      for ( var i = 0, len = pathArray.length; i < len; i++ ) {
        var j = 0, jlen = currentPrefix.length;
        do {
          var pathI = jlen > 0 ? [currentPrefix[j], pathArray[i]].join('.') : pathArray[i];
          if ( TypeUtils.isArray(this._modules[pathI]) ) {
            //we have to expand this, and we may have undefined items in the array
            for ( var k = 0, klen = this._modules[pathI].length; k < klen; k++ ) {
              if ( this._modules[pathI][k] ) {
                var newPrefix = jlen > 0 ? [currentPrefix[j], pathArray[i] + '[' + k + ']'].join('.') : pathArray[i] + '[' + k + ']';
                currentExpand.push(newPrefix);
              }
            }
          } else {
            // put it in directly
            currentExpand.push(pathI);
          }
          j++;
        } while ( j < jlen );
        
        var refTemp = currentPrefix;
        currentPrefix = [].concat(currentExpand);
        currentExpand.length = 0;
        refTemp.length = 0;
      }
      return currentPrefix;  
    },

    _expandModules : function () {
      var modules = this._modules;
      var result = [];
      for ( var p in modules ) {
        if ( modules.hasOwnProperty(p) ) { 
          var m = modules[p];
          if ( TypeUtils.isArray(m) ) {
            for ( var i = 0; i < m.length; i++ ) {
              result[p + '[' + i + ']'] = m[i];
            }
          } else {
            result[p] = m; 
          }
        }
      }
        
      return result;
    },
    
    // Configures various kinds of module dependencies.
    _wire : function () {
      var dependencies = this._config.dependencies, item, i;
      var attrs = dependencies.attributes || [],
          events = dependencies.events || [];
      
      var expandedDefs, expandedDef;
      
      // Resolve attributes.
      /*
     * [jimmy/8/8/2012]each node in the path may have several entities
     * like main.plot, we may create several main.plots
     * (here the xycontainer), by using 'main.plot.xAxis'
     * here we actually means for xAxis in each main.plot
     * 
     * in the future, we may need support more complicated dependency resolving
     * like 'the 3rd xycontainer's xAxis', can be described
     * as main.plot[2].xAxis
     */
      var modules = this._expandModules();
      
      for ( i = 0; i < attrs.length; i++ ) {
        item = attrs[i];
        if( item === null ){
          continue;
        }
        expandedDefs = this._expandDependencyDefs(item);
        for(var j = 0, jlen = expandedDefs.length; j < jlen; j++) {
          expandedDef = expandedDefs[j];
          if ( modules[ expandedDef['sourceModule'] ] && modules[ expandedDef['targetModule'] ] ) {
            if ( typeof modules[ expandedDef['sourceModule'] ][ expandedDef['source'] ] === 'function' &&
                 typeof modules[ expandedDef['targetModule'] ][ expandedDef['target'] ] === 'function' ) {
              modules[ expandedDef['targetModule'] ][ expandedDef['target'] ]( 
                modules[ expandedDef['sourceModule']][ expandedDef['source']]() );
            } else {
              Functions.error('dependency configuration error');
            }
          } else {
            Functions.error('dependency configuration error');
          }
        }
      }
      
      // Resolve events.
      for ( i = 0; i < events.length; i++ ) {
        item = events[i];
        expandedDefs = this._expandDependencyDefs(item);
        for(var n = 0, nlen = expandedDefs.length; n < nlen; n++) {
          expandedDef = expandedDefs[n];
          if ( modules[ expandedDef['targetModule'] ] && modules[ expandedDef['sourceModule'] ] ) {
            if ( typeof modules[ expandedDef['targetModule'] ][ expandedDef['listener'] ] === 'function' &&
                 typeof modules[ expandedDef['sourceModule'] ] === 'function' ) {
                   if(typeof modules[ expandedDef['sourceModule'] ].dispatch === 'function'){
                      modules[ expandedDef['sourceModule'] ].dispatch().on(expandedDef['type'] + '.' + expandedDef['targetModule'] + '.' + n, 
                        modules[ expandedDef['targetModule'] ][ expandedDef['listener'] ]);
                   } else {
                     Functions.error('dependency configuration error:' + expandedDef['sourceModule'] + ' does not support event!');
                   }
            } else {
              Functions.error('dependency configuration error');
            }
          } else {
            Functions.error('dependency configuration error: source or target does not exist!');
          }
        }
      }
    },
    
    // starting point of invoking the chain of painting logic
    _paint : function () {
      this._selections[this._getRootKey()].call(this._getRootContainer());
      //FIXME Jimmy, 3/25/2013 currently we don't call modules in the root level, such as datatransform
      //we may need do it in the future.
    },
    
    // Merge Ian Li's fix to make canvg waiting for chart modules' initialized event
    _exportToCanvas: function(){
      if ( canvgConf.enableCanvg() && this._component_status === 'canvg' ) {
          d3.select(this.container).selectAll('title').remove();
          if ( canvg ) {
              var node = this._selections[this._getRootKey()].node().cloneNode(true);
              node.setAttribute('visibility', 'visible');
              
              canvg(this._canvas.node(), $('<div></div>').append(node).html(), { ignoreMouse: true, ignoreAnimation: true });
              
              if ( this._data.dataPointCount() > this._max_canvas ) {
                this._dispatch.dataTruncation();
              }
          }
        }
    },
    
    /**
     * Loops over events configuration of each module
     * and return the events TypeUtils.
     * 
     * @function
     * @returns {Array} Array of supported event TypeUtils
     */
    getSupportedEvents : function () {
      var events = [];
      var modules = this._config.modules;
      
      function getEventDefs( modules ) {
        for ( var m in modules ) {
          if ( modules.hasOwnProperty(m) ) {
            if(!modules[m]) {
                continue;
            }
              
            var module = manifest.module.get(modules[m].id);
            if ( module && module.events ) {
              events.push({
                sourceId : modules[m].id,
                source : {},
                evtTypes : module.events
              });
            }
            // Continue searching for composite module like a container
            if ( modules[m].modules ) {
                getEventDefs(modules[m].modules);
            } 
          }
        }
      }
      getEventDefs(modules);
      return events;
    },
    
    doDestroy : function(){
      var modules = this._modules;
      for(var key in modules){
        if(modules.hasOwnProperty(key)){
          var destroyFn = modules[key].destroy;
          if(destroyFn){
            destroyFn();
          }          
        }
      }
      
        langManager.removeListener(this._i18nListener);
          this.detach();
          this._styleSheets.forEach(function(sheet){
        sheet.destroy();
      });
    }
  });
  
  /* Represents the chart controller. */
  var ChartController = UIController.extend({
    RootComponentClass : ChartComponent,
    
    _parseOptions : function ( options ) {
      if ( !manifest.viz.get(options.vizType) ) {
        Functions.error('Invalid vizType');  
      } 
      this._dataset = options.dataset ? options.dataset : {};
      this._options = options.option;
      this._vizType = options.vizType;
      this._dataFeeding = options.feeding;
      this._css = options.css;
      this._events = options.events;
    },
    
    initUIComponent : function ( options ) {
        this._parseOptions(options);
        var config = manifest.viz.get(this._vizType);
        this.rootUIComponent.initialize({
          data : this._dataset,
          dataFeeding : this._dataFeeding,
          config : config,
          options : this._options,
          clipToBound : true,
          css : this._css,
          events : this._events
        });
      },
      
    
    getSupportedEvents : function () {
        return this.rootUIComponent.getSupportedEvents();
    },
    
    setDataset : function ( dataset ) {
        this.rootUIComponent.data(dataset);
    },
    
    doThemeChanged : function(){
        this.rootUIComponent.themeChanged();
    },
    
    updateProperties : function (props) {
        this.rootUIComponent.properties(props);
    },
    
    getProperties : function() {
        return this.rootUIComponent.properties();
    },
    
    css : function () {
        return this.rootUIComponent.css.apply(this.rootUIComponent, arguments);
    },
    
    render : function(){
        this.rootUIComponent.render();
    }
    
  });
  
  /* Represents the application class. */
  var ChartApplication = VizApplication.extend({
    RootControllerClass : ChartController,
    appDidFinishLaunching : function ( options ) {
      // Format data set from data feeds.
        var launchOptions = options.launchOptions;
      this._vc_vizType = launchOptions.vizType;
      this._vc_dataset = launchOptions.data.rawData;
      this._vc_feeding = launchOptions.feeding;
      this._vc_properties = launchOptions.options;

      var vc_config = canvgConf.get(this._vc_vizType) ?canvgConf.get(this._vc_vizType) : {} ;
      this.max_canvas = canvgConf.enableCanvg() && vc_config.max_canvas ? vc_config.max_canvas : Number.POSITIVE_INFINITY;
      LOG.profiling("Data: turn to adapter!");
      var dataAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding, this.max_canvas);
      LOG.profiling("Data: turn to adapter!");
      this.controller.initUIComponent({
         vizType : this._vc_vizType,
         dataset : dataAdapter,
         option : launchOptions.options,// Chart properties,
         css : launchOptions.css,
         events : launchOptions.events
      });
    },
    
    _vc_createAdapter : function(vizType, rawData, feeding, upperLimit) {
      var feeder = Feeder(manifest.viz.get(vizType).allFeeds(true), rawData, feeding);
      var dataHandler = new BaseDataHandler(feeder, rawData, upperLimit);
      var feeds = feeder.getFeeds();
      var dataAdapter = new MultiAxesDataAdapter(feeder.getBindingInfo());
      dataAdapter.fakeData(rawData.hasFakeData());
      dataAdapter.emptyDataset(rawData.isEmptyDataset());
      dataAdapter.dataPointCount(rawData.getDataPointCount());
      var id, dataItems;
      for ( var i = 0, len = feeds.length; i < len; i++ ) {
      id = feeds[i].feedId();
        dataItems = dataHandler.getFeedValues(id);
        if(dataItems !== null){
          if(feeds[i].type() === "Dimension"){
            dataAdapter.addAnalysisAxis({values:dataItems, index: feeds[i].getIndex() - 1});
          }else{
            dataAdapter.addMeasureValuesGroup({values:dataItems, index: feeds[i].getIndex() - 1});
          }
        }     
      }
      return dataAdapter;
    },
    
    css : function() {
        return this.controller.css.apply(this.controller, arguments);
    },
    
    size : function(size) {
        if (size !== undefined) {
            this.vizFrame.size(size);
            return this;
        } else {
            return this.vizFrame.size();
        }
    },
    
    update : function(updates) {
      if(updates){
        var needRender = false;
        //TODO Jimmy/9/19/2012 finish update property workflow
        //especially properties like 'numberOfDimensionsInColumn' which will
        //affect the structure, and ideally, we need merge all updates into one
        //function in each module, currently we still call them separately  
        if(updates.properties) {
          if(this.controller){
            this._vc_properties = updates.properties;
            this.controller.updateProperties(this._vc_properties);
            needRender = true;
          }
        }
        
        if(updates.css) {
            this.controller.css(updates.css);
            needRender = true;
        }
        
        if(updates.data || updates.feeding) {
          if(updates.data) {
              this._vc_dataset = updates.data;
          }
          if(updates.feeding) {
              this._vc_feeding = updates.feeding;
          }
          var newAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding, this.max_canvas);
          this.controller.setDataset(newAdapter);
          needRender = true;
        }
        if(needRender)
        {
       this.controller.render();
        }
      }
    },  
    getSupportedEvents : function () {
        return this.controller.getSupportedEvents();
    },
    
    setDataset : function ( dataset ) {
      this._vc_dataset = dataset;
      var newAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding);
      this.controller.setDataset(newAdapter);
    },
    
    getDataset : function (){
      return this._vc_dataset;
    },
    
    updateProperties : function (props) {
      if(this._controller){
        this._vc_properties = props;
        this.controller.updateProperties(this._vc_properties);
      }
    },
    
    getProperties : function() {
        return this.controller.getProperties();
    }
  });
  
  var riv = 
  /**
   * @lends sap.viz.core
   */
  {
        /**
         * @constructs
         */
        constructor : function() {

        },
        
        /**
         * @ignore 
         */
        instances : [], // Stores references to chart applications for easy processing of global events.
        
        /**
         * The main entry point of creating a chart.
         * @param {Object} usrOptions
         * <pre>
         * {
         *   type: 'viz/bar', //see propDoc.html for all supported viz chart TypeUtils
         *   options: {}, //see propDoc.html for all supported options for each viz type
         *   css: String, //see propDoc.html for all supported css items for each viz type
         *   container: HTMLDivElement, // HTMLDivElement is the container of viz chart in html
         *   data: {@link sap.viz.data.CrosstableDataset},
         *   feeding: {@link sap.viz.VizInstance#feeding},
         *   events: {}, //Events is an object with key and value pair. Key is the event name, and the value is an object containing function and scope. For example, {'initialized':{ fn: function(){return;}, scope: this}}.
         * }
         * </pre>
         * @returns {Object} vizApplication instance {@link sap.viz.VizInstance}
         */
        createViz : function ( usrOptions ) {
          var _eventsListeners = {}, 
              _feeding = usrOptions.feeding,
              _riv = this;
          
          LOG.context(':creation:' + Objects.size(usrOptions.options) + ':' + usrOptions.data.getDataPointCount() + ':' + Objects.size(usrOptions.css));
          
          var viz = 
          /**
           * @lends sap.viz.VizInstance.prototype
           */
          {
            /**
             * it can only be created by {@link sap.viz.core}
             * @constructs
             */
            constructor : function() {},
            
            /**
             * add event listener. one eventType can only have one listener, to register multiple listeners to a certain eventType you
             * have to add additional namespace after the eventType, such as 'selectData.foo' or 'selectData.bar'
             * @param {String} evtType see propDoc.html for supported events for each kind of chart
             * @param {Function} callback listener function
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            on : function ( evtType, callback, scope ) {
              _eventsListeners[evtType] = {
                callback : callback,
                scope: scope
              };
              this.app.controller.rootUIComponent.attachEvent(evtType, callback, scope);
              
              return this;
            },
            /**
             * Get/set chart size.
             * @param {Object} size {width:xx, height:xx}
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            size : function (size) {
              if ( !arguments.length ) {
                  return this.app.size();  
              }
              this.app.size(size);
              
              return this;
            },
            
            /**
             * Get/set chart data.
             * @param {Object} data {@link sap.viz.data.CrosstableDataset} 
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            data : function (data) {
              if ( !arguments.length ) {
                return this.app.getDataset();  
              }
              this.update({ 'data' : data });
              
              // re-bind event listener as upon data update, sub plots may be recreated
              for ( var evt in _eventsListeners ) {
                if ( _eventsListeners.hasOwnProperty(evt) ) {
                  this.on(evt, _eventsListeners[evt].callback, _eventsListeners[evt].scope);
                }
              }
              
              return this;
            },
            
            /**
             * Get/set chart properties.
             * @ignore
             * @param {Object} props see propDoc.html
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            properties : function (props) {
              if ( !arguments.length ){
                return this.app.getProperties();  
              } 
              
              LOG.context(':updateProperty:' + Objects.size(props));
              
              this.update({ properties : props });
              return this;
            },
            
            /**
             * Append a new internal css.
             * @param {Object} cssText the css text
             * @returns {Object} {@link sap.viz.VizInstance}
             * @example
             * chartInstance.css('.v-m-title .v-title:{fill:#333333}');
             */
            css : function (css) {
              if ( !arguments.length ){
                return this.app.css();  
              } 
              this.update({ css : css });
              return this;
            },
            
            /**
             * Get/set data feeding info
             * @param {Array} feedingObj every element in the array is in the following structure: 
             * <pre>
             * {
             *   'feedId':feedId  // feed id for example 'regionColor', see propDoc.html
             *   'binding': [{
             *     'type' : 'analysisAxis' | 'measureValuesGroup' | 'measureNamesDimension',
             *     'index':  Number
             *   }]             
             * }
             * </pre>
             *@returns {Object} {@link sap.viz.VizInstance} 
             */
            feeding : function(feedingObj) {
              if ( !arguments.length ) {
                return _feeding;
              } 
              
              _feeding = feedingObj;
              this.update({ feeding : feedingObj });
              return this;
            },
            
            /**
             * Update various items in one go.
             * @param {Object} updates {data: {@link sap.viz.data.CrosstableDataset}, feeding: feedingObj, css: cssString}
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            update : function ( updates ) {
              if(updates){
                //we actually support use a null value to clear current feeding and switch to use
                //auto feed
                if(TypeUtils.isDefined(updates.feeding)) {
                  _feeding = updates.feeding;
                }
                this.app.update(updates);
              }
              return this;
            },
            

            /**
             * Destroy this chart instance. This will remove all dom
             * nodes of chart and its listeners.
             */
            destroy : function() {
              _riv.instances.splice(_riv.instances.indexOf(this), 1);
              this.app.destroy();
            },
        
        /**
             * export chart instance into a JSON object which contains
             * all information of the chart including type, data, properties
             * style, feeding and size
             */
            toJSON : function() {
              var doc = {};
              doc.type = usrOptions.type;
              doc.data = { type : "crosstable", val : this.app.getDataset().data() };
              doc.properties = this.properties(); 
              doc.css = this.css();
              doc.feeding = _feeding;
              doc.size = this.app.size();
              return doc;    
            }
          };
          
          LOG.profiling("Property: merge with template!");
          var template = TemplateManager.current();
          var type = usrOptions.type;
          var mergeWithTemplate = Objects.extend(true, null, template.props(type), usrOptions.options);
          LOG.profiling("Property: merge with template!"); 
          
          viz.app = new ChartApplication({
            holder : usrOptions.container,
            launchOptions : {
                vizType : type,
                options : mergeWithTemplate,
                css : (template.css || "") + (usrOptions.css || ""),
              data : { rawData : usrOptions.data },
              feeding : usrOptions.feeding || usrOptions.dataFeeding, /* dataFeeding for backward compatibility*/ 
              events : usrOptions.events
            }
          });        

          Object.defineProperty(viz, "type", {
            value : type,
            enumerable : true
          });
          
          _riv.instances.push(viz);
          return viz;
        },
        
        /**
         * Destroy chart.
         * @param {Object...} viz instances to be destroyed
         */
        destroyViz : function () {
          for ( var i = -1, j = arguments.length; ++i < j; ) {
            arguments[i].destroy(); 
          }
        },
        
        /**
         * export chart instance into a JSON object which contains
         * all information of the chart including type, data, properties
         * style, feeding and size
         * @param {Object} chartInstance {@link sap.viz.VizInstance}
         */
        exportViz : function(chart){
          return chart.toJSON();           
        }
  }; 
  
  return riv;
});sap.riv.module(
{
  qname : 'sap.viz.ccl',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.core',
  version : '4.0.2'
},
{  qname : 'sap.viz.data.CrosstableDataset',
  version : '4.0.2'
}
],
function Setup(Core, CrosstableDataset) {

	var ccl =
	/** @lends sap.viz.ccl */
	{
		/**
		 * @constructs
		 */
		constructor : function() {
			return;
		},

		/**
		 * load chart from JSON into a div
		 * @param {Object...} viz json document
		 * @param {Object...} div object to contain the visualization
		 */
		loadViz : function(doc, container) {
			var option = {};
			option.container = container;
			option.type = doc.type;
			option.options = doc.properties;
			option.data = new CrosstableDataset();
			option.data.setData(doc.data.val);
			option.css = doc.css;
			option.feeding = doc.feeding;

			return Core.createViz(option);
		}
	};

	return ccl;

});sap.riv.module(
{
  qname : 'sap.viz.util.log.Analyzer',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.Logger',
  version : '4.0.2'
}
],
function Setup(LOG) {
  function Stack() {
    this.stac = [];

    this.pop = function() {
      return this.stac.pop();
    };

    this.push = function(item) {
      this.stac.push(item);
    };

    this.peek = function() {
      return this.stac[this.stac.length - 1];
    };
  }

  /*
   * return {
   *   'usedJSHeapSize' : [OPTIONAL] int
   *   'totalJSHeapSize' : [OPTIONAL] int
   *   'flag' : string
   * }
   */
  function parseProfilingMsg(msg) {
    //[18403120][24402304][767557632]Render: layout
    var ret = {};
    var exp = /\[\d+\]/g;
    var exp2 = /\d+/;
    var exp3 = /[^\d\[\]]+/;
    var heapsize = msg.match(exp);
    if(heapsize) {
      ret.usedJSHeapSize = heapsize[0].match(exp2)[0];
      ret.totalJSHeapSize = heapsize[1].match(exp2)[0];
    }
    ret.flag = msg.match(exp3)[0];
    return ret;
  }
  
  /*
   * return {
   *   'name': string,
   *   'client': string,
   *   'info' : Array
   * }
   */
  function parseContextMsg(msg) {
    //"[Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.22 (KHTML, like Gecko) Chrome/25.0.1364.152 Safari/537.22]creation:3:16:0"
    //[useragent]contextname:[:additional values]
    var ret = {};
    var exp = /\[.+\]/;
    var exp2 = /\]:.+$/;
    ret.client = msg.match(exp)[0];
    var ctxMatch = msg.match(exp2);
    if(ctxMatch){
      var ctxa = ctxMatch[0].split(':');
      ret.name = ctxa[1];
      ctxa.shift();
      ctxa.shift();
      ret.info = ctxa;
    }
    return ret;
  }
  
  //TODO FIXME @Eddy CHANGE TO STRING
    var threshold = LOG.LEVEL.DEBUG;
    var msgs = [];
    var layout = null;

  var Analyzer = {
    
    doAppend : function(logTime, logLevel, logCate, logMsg) {
      msgs.push([logTime, logLevel, logCate, logMsg]);
    },
    setLayout : function(layout) {
      return layout.format && (this.layout = layout);
    },
    getLevel : function() {
      return threshold;
    },
    setLevel : function(level) {
      threshold = level;
    },
    
    reset : function(){
      msgs = [];
    },
    
    profiling : function() {
      //TODO FIXME @Eddy flush support
      LOG.disable();//disable to flush
      
      var pfs = new Stack();
      var pfa = [];
      var msg, pmsg, ctxmsg, peek, pop, currentPF;
      
      for(var i = 0, len = msgs.length; i < len; i++) {
        //typical msg:
        //[1362633819088][DEBUG][PROFILING]-[18403120][24402304][767557632]Render: layout
        //[1362633819099][DEBUG][PROFILING]-[18786948][24402304][767557632]Render: layout
        msg = msgs[i];
        //check context
        if(msg[2] === 'CONTEXT'){
          ctxmsg = parseContextMsg(msg[3]);
          currentPF = {
            ctx: {
              name: ctxmsg.name,
              client: ctxmsg.client,
              info: ctxmsg.info
            },
            data : []
          };
          pfa.push(currentPF);
        }else if(msg[2] === 'PROFILING') {
          pmsg = parseProfilingMsg(msg[3]);
          peek = pfs.peek();
          if(peek && peek.flag === pmsg.flag) {
            pop = pfs.pop();
            currentPF.data.push([pop.flag, msg[0] - pop.time, pmsg.usedJSHeapSize - pop.heapSizeUsed, pmsg.totalJSHeapSize - pop.heapSizeTotal, pmsg.usedJSHeapSize, pmsg.totalJSHeapSize]);
          } else {
            pfs.push({
              'flag' : pmsg.flag,
              'time' : msg[0],
              'heapSizeUsed' : pmsg.usedJSHeapSize,
              'heapSizeTotal' : pmsg.totalJSHeapSize
            });
          }
        }
      }
      
      LOG.enable();
      
      return pfa;
    }
  };

  return Analyzer;
});sap.riv.module(
{
  qname : 'sap.viz.env',
  version : '4.0.2',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.2'
},
{  qname : 'sap.viz.base.Logger',
  version : '4.0.2'
},
{  qname : 'sap.viz.config',
  version : '4.0.2'
},
{  qname : 'sap.viz.Locale',
  version : '4.0.2'
},
{  qname : 'sap.viz.util.log.Analyzer',
  version : '4.0.2'
}
],
function Setup(TypeUtils, LOG,  config, Locale, analyzer) {
    var _setLogLevel = function(_level) {
        if(TypeUtils.isExist(_level)) {
            LOG.setLevel(_level);
        }
    };
    var _initLogger = function(options) {
        if(!options) {
            return;
        }
            
        if(options.enable) {
            LOG.enable();
        }
           
        if(!options.appenders){
            //no customize appenders, we'll use default appender
            if(options.level){
              //FIXME @Eddy, allow set level with string
              //FIXME and only for debug, trace we will use analyzer as appender
              //otherwise we set this level to default appender
              LOG.setAppenders([{appenderKey: 'sap.viz.util.analyzer', appender: analyzer}]);
            }
            return;
        }
        //if user set appenders, we remove default appender
        LOG.setAppenders([]);   
        for(var i = 0, l = options.appenders.length; i < l; i++) {
            var appender = options.appenders[i];
            if(appender.appenderKey) {
                 LOG.addAppender(appender.appenderKey, appender.appender);    
            }
               
            else {
                 LOG.addAppender(appender.appender);
            }
               
        }
        // LOG.addAppender('analyzerAppender', new AnalyzerAppender());
        // LOG.addAppender("ajaxApp", new LOG.AjaxAppender("http://localhost:8800"));
        // LOG.getAppender("ajaxApp").setLevel(LOG.LEVEL.DEBUG);
        //LOG.getAppender("[default]").setLevel(_level);
    };
    
    var _initLocal = function(options, callback){
      Locale.locale(options.locale, callback);
    };
    
    var env =
    /**
     * @lends sap.viz.Environment
     */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
        /**
         * initialize visualization environment
         * @param {Object}
         *            option {locale:'en_US'}
         *
         */
        initialize : function(option, callback) {
          if (!option) {
              return;  
          }
            _initLogger(option.log);
            if (option.locale){
              _initLocal(option, callback);
            } else {
                   if(callback) {
                       callback.call();
                   }
            }
            config.enableCanvg(option.enableCanvg);
            // _setLogLevel(option.log);
        },
        
        /**
         * @ignore
         * @param enable
         */
        setLoggerEnable : function(enable) {
            if(enable === true) {
                 LOG.enable();
            }
               
            else if(enable === false) {
                 LOG.disable();    
            }
               
        },
        
        /**
         * @ignore
         * @returns TODO: add desc
         */
        addLogAppender : function() {
            if(arguments.length === 1) {
                return LOG.addAppender(arguments[0]);
            }
                
            else if(arguments.length === 2) {
                return LOG.addAppender(arguments[0], arguments[1]);
            }
               
        },
        
        /**
         * @ignore
         * @param key
         * @returns TODO: add desc
         */
        removeLogAppender : function(key) {
            return LOG.removeAppender(key);
        }
    };

    return env;
});sap.viz.lang.langManager.register({id:'dev',value: {IDS_DEFAULTMND:"All Measures",IDS_DEFAULTCHARTTITLE:"Title of Chart",IDS_ISNOVALUE:"No value",IDS_BARCHART:"Bar Chart",IDS_COMBINATIONCHART:"Combined Column Line Chart",IDS_DUALBARCHART:"Bar Chart with 2 X-Axes",IDS_DUALCOMBINATIONCHART:"Combined Column Line Chart with 2 Y-Axes",IDS_DUALHORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart with 2 X-Axes",IDS_DUALHORIZONTALLINECHART:"Horizontal Line Chart with 2 X-Axes",IDS_DIUALLINECHART:"Line Chart with 2 Y-Axes",IDS_DUALPERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart with 2 X-Axes",IDS_DUALSTACKEDVERTICALBARCHART:"Stacked Column Chart with 2 Y-Axes",IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart with 2 Y-Axes",IDS_DUALSTACKEDBARCHART:"Stacked Bar Chart with 2 X-Axes",IDS_DUALVERTICALBARCHART:"Column Chart with 2 Y-Axes",IDS_HORIZONTALBOXPLOTCHART:"Horizontal Box Plot",IDS_HORIZONTALCOMBINATIONCHART:"Combined Bar Line Chart",IDS_HORIZONTALLINECHART:"Horizontal Line Chart",IDS_HORIZONTALWATERFALLCHART:"Horizontal Waterfall Chart",IDS_HORIZONTALSTACKEDWATERFALL:"Horizontal Stacked Waterfall Chart",IDS_LINECHART:"Line Chart",IDS_PERCENTAGESTACKEDBARCHART:"100% Stacked Bar Chart",IDS_PERCENTAGESTACKEDVERTICALBARCHART:"100% Stacked Column Chart",IDS_SPARKLINECHART:"Spark Line Chart (POC)",IDS_STACKEDBARCHART:"Stacked Bar Chart",IDS_STACKEDVERTICALBARCHART:"Stacked Column Chart",IDS_STACKEDWATERFALLCHART:"Stacked Waterfall Chart",IDS_VARIANTBARCHART:"Variant Bar Chart (POC)",IDS_VERTICALBARCHART:"Column Chart",IDS_VERTICALBOXPLOTCHART:"Box Plot",IDS_WATERFALLCHART:"Waterfall Chart",IDS_DONUTCHART:"Donut Chart",IDS_PIECHART:"Pie Chart",IDS_BASEBUBBLECHART:"Base Scatter Chart",IDS_BUBBLECHART:"Bubble Chart",IDS_SCATTERCHART:"Scatter Plot",IDS_BASECHART:"Base Chart",IDS_BASEHORIZONTALCHART:"Base horizontal XY Chart",IDS_BASEVERTICALCHART:"Base Vertical XY Chart",IDS_BASEMULTIPLECHART:"Base Multiple Chart",IDS_BASEMULTIPLEXYCHART:"Base Multiple XY Chart",IDS_BASESINGLECHART:"Base Single Chart",IDS_HEATMAPCHART:"Heat Map",IDS_TREEMAPCHART:"Tree Map",IDS_MULTIBARCHART:"Multiple Bar Chart",IDS_MULTIBUBBLECHART:"Multiple Bubble Chart",IDS_MULTIDONUTCHART:"Multiple Donut Chart",IDS_MULTIDUALBARCHART:"Multiple Bar Chart with 2 X-Axes",IDS_MULTIDUALHORIZONTALLINECHART:"Multiple Horizontal Line Chart with 2 X-Axes",IDS_MULTIDUALLINECHART:"Multiple Line Chart with 2 Y-Axes",IDS_MULTIDUALPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart with 2 X-Axes",IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart with 2 Y-Axes",IDS_MULTIDUALSTACKEDBARCHART:"Multiple Stacked Bar Chart with 2 X-Axes",IDS_MULTIDUALSTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart with 2 Y-Axes",IDS_MULTIDUALVERTICALBARCHART:"Multiple Column Chart with 2 Y-Axes",IDS_MULTIHORIZONTALLINECHART:"Multiple Horizontal Line Chart",IDS_MULTILINECHART:"Multiple Line Chart",IDS_MULTIPERCENTAGESTACKEDBARCHART:"Multiple 100% Stacked Bar Chart",IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART:"Multiple 100% Stacked Column Chart",IDS_MULTIPIECHART:"Multiple Pie Chart",IDS_MULTISCATTERCHART:"Multiple Scatter Plot",IDS_MULTISTACKEDBARCHART:"Multiple Stacked Bar Chart",IDS_MULTISTACKEDVERTICALBARCHART:"Multiple Stacked Column Chart",IDS_MULTIVERTICALBARCHART:"Multiple Column Chart",IDS_MULTIRADARCHART:"Multiple Radar Chart",IDS_RADARCHART:"Radar Chart",IDS_SCATTERMATRIXCHART:"Scatter Matrix Chart",IDS_TAGCLOUDCHART:"Tag Cloud",IDS_MEKKOCHART:"Mekko chart",IDS_HORIZONTALMEKKOCHART:"Horizontal Mekko Chart",IDS_PERCENTAGEMEKKOCHART:"100% Mekko Chart",IDS_PERCENTAGEHORIZONTALMEKKOCHART:"100% Horizontal Mekko Chart",IDS_AREACHART:"Area Chart",IDS_PERCENTAGEAREACHART:"100% Area Chart",IDS_HORIZONTALAREACHART:"Horizontal Area Chart",IDS_PERCENTAGEHORIZONTALAREACHART:"100% Horizontal Area Chart",IDS_MULTIAREACHART:"Multiple Area Chart",IDS_MULTIHORIZONTALAREACHART:"Multiple Horizontal Area Chart",IDS_MULTIPERCENTAGEAREACHART:"Multiple 100% Area Chart",IDS_MULTIPERCENTAGEHORIZONTALAREACHART:"Multiple 100% Horizontal Area Chart",IDS_3D_BAR:"3D Bar Chart",IDS_3D_COLUMN:"3D Column Chart",IDS_PIEWITHDEPTHCHART:"Pie With Depth Chart",IDS_DONUTWITHDEPTHCHART:"Donut With Depth Chart",IDS_REGIONCOLOR:"Region Color",IDS_PRIMARYVALUES:"Primary Values",IDS_SECONDARYVALUES:"Secondary Values",IDS_AXISLABELS:"Axis Labels",IDS_RECTANGLETITLE:"Rectangle Title",IDS_RECTANGLEWEIGHT:"Rectangle Weight",IDS_RECTANGLECOLOR:"Rectangle Color",IDS_TAGNAME:"Tags Name",IDS_TAGWEIGHT:"Tags Weight",IDS_TAGFAMILY:"Tags Family",IDS_CATEGORYAXIS:"Axis Labels Category",IDS_REGIONSHAPE:"Region Shape",IDS_BUBBLEWIDTH:"Bubble Width",IDS_BUBBLEHEIGHT:"Bubble Height",IDS_RADARAXES:"Radar Axes",IDS_RADARAXESVALUE:"Radar Axes Values",IDS_PIESECTORCOLORNAME:"Sector Color",IDS_PIESECTORSIZE:"Sector Size",IDS_PIEDEPTHSIZE:"Depth Size",IDS_MAINLABELAXISNAME:"Main Category Axis",IDS_SECONDARYAXISLABELNAME:"Secondary Category Axis",IDS_SELECTABILITY:"selectability",IDS_PRIMARYVALUECOLORPALETTE:"primaryValuesColorPalette",IDS_SECONDARYVALUESCOLORPALETTE:"secondaryValuesColorPalette",IDS_DRAWINGEFFECT:"drawingEffect",IDS_TOOLTIPVISIBLE:"tooltipVisible",IDS_ENABLEROUNDCORNER:"enableRoundCorner",IDS_ANIMATION:"animation",IDS_DATALOADING:"dataLoading",IDS_DATAUPDATING:"dataUpdating",IDS_BAR:"bar",IDS_LINE:"line",IDS_WIDTH:"width",IDS_HOVERLINEVISIBLE:"hoverlineVisible",IDS_MARKER:"marker",IDS_VISIBLE:"visible",IDS_SHAPE:"shape",IDS_SIZE:"size",IDS_HEADERVISIBLE:"headerVisible",IDS_AXISVISIBLE:"axisVisible",IDS_GRIDVISIBLE:"gridVisible",IDS_COLUMNSEQUENCE:"columnSequence",IDS_COLUMNCONFIG:"columnConfig",IDS_STARTCOLUMN:"startColumn",IDS_LABEL:"label",IDS_VALUEFORMAT:"valueFormat",IDS_ENDCOLUMN:"endColumn",IDS_HIGHCOLUMN:"highColumn",IDS_LOWCOLUMN:"lowColumn",IDS_LINECONFIG:"lineConfig",IDS_MARKERS:"markers",IDS_FILLVISIBLE:"fillVisible",IDS_REFINEVISIBLE:"reflineVisible",IDS_MODE:"mode",IDS_TITLE:"title",IDS_TEXT:"text",IDS_GRIDLINE:"gridline",IDS_SHOWFIRSTLINE:"showFirstLine",IDS_TYPE:"type",IDS_FORMAT:"format",IDS_POSITION:"position",IDS_BORDER:"border",IDS_STARTCOLOR:"startcolor",IDS_ENDCOLOR:"endcolor",}});