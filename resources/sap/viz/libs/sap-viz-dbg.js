/* BuildVersion: 3.2.0.78 */(function() {
	if (!Array.prototype.indexOf) {
		Array.prototype.indexOf = function(searchElement /* , fromIndex */) {
			"use strict";
			if (this == null) {
				throw new TypeError();
			}
			var t = Object(this);
			var len = t.length >>> 0;
			if (len === 0) {
				return -1;
			}
			var n = 0;
			if (arguments.length > 0) {
				n = Number(arguments[1]);
				if (n != n) { // shortcut for verifying if it's NaN
					n = 0;
				} else if (n != 0 && n != Infinity && n != -Infinity) {
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
				}
			}
			if (n >= len) {
				return -1;
			}
			var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
			for (; k < len; k++) {
				if (k in t && t[k] === searchElement) {
					return k;
				}
			}
			return -1;
		}
	}

	if (!Array.prototype.lastIndexOf) {
		Array.prototype.lastIndexOf = function(searchElement /* , fromIndex */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (len === 0)
				return -1;

			var n = len;
			if (arguments.length > 1) {
				n = Number(arguments[1]);
				if (n != n)
					n = 0;
				else if (n != 0 && n != (1 / 0) && n != -(1 / 0))
					n = (n > 0 || -1) * Math.floor(Math.abs(n));
			}

			var k = n >= 0 ? Math.min(n, len - 1) : len - Math.abs(n);

			for (; k >= 0; k--) {
				if (k in t && t[k] === searchElement)
					return k;
			}
			return -1;
		};
	}

	if (!Array.prototype.filter) {
		Array.prototype.filter = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var res = [];
			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t) {
					var val = t[i]; // in case fun mutates this
					if (fun.call(thisp, val, i, t))
						res.push(val);
				}
			}

			return res;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.18
	// Reference: http://es5.github.com/#x15.4.4.18
	if (!Array.prototype.forEach) {

		Array.prototype.forEach = function(callback, thisArg) {

			var T, k;

			if (this == null) {
				throw new TypeError("this is null or not defined");
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			// value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal method
			// of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0; // Hack to convert O.length to a UInt32

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be
			// undefined.
			if (thisArg) {
				T = thisArg;
			}

			// 6. Let k be 0
			k = 0;

			// 7. Repeat, while k < len
			while (k < len) {

				var kValue;

				// a. Let Pk be ToString(k).
				// This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty
				// internal method of O with argument Pk.
				// This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					// method of O with argument Pk.
					kValue = O[k];

					// ii. Call the Call internal method of callback with T as
					// the this value and
					// argument list containing kValue, k, and O.
					callback.call(T, kValue, k, O);
				}
				// d. Increase k by 1.
				k++;
			}
			// 8. return undefined
		};
	}

	if (!Array.prototype.every) {
		Array.prototype.every = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t && !fun.call(thisp, t[i], i, t))
					return false;
			}

			return true;
		};
	}

	// Production steps of ECMA-262, Edition 5, 15.4.4.19
	// Reference: http://es5.github.com/#x15.4.4.19
	if (!Array.prototype.map) {
		Array.prototype.map = function(callback, thisArg) {

			var T, A, k;

			if (this == null) {
				throw new TypeError(" this is null or not defined");
			}

			// 1. Let O be the result of calling ToObject passing the |this|
			// value as the argument.
			var O = Object(this);

			// 2. Let lenValue be the result of calling the Get internal method
			// of O with the argument "length".
			// 3. Let len be ToUint32(lenValue).
			var len = O.length >>> 0;

			// 4. If IsCallable(callback) is false, throw a TypeError exception.
			// See: http://es5.github.com/#x9.11
			if ({}.toString.call(callback) != "[object Function]") {
				throw new TypeError(callback + " is not a function");
			}

			// 5. If thisArg was supplied, let T be thisArg; else let T be
			// undefined.
			if (thisArg) {
				T = thisArg;
			}

			// 6. Let A be a new array created as if by the expression new
			// Array(len) where Array is
			// the standard built-in constructor with that name and len is the
			// value of len.
			A = new Array(len);

			// 7. Let k be 0
			k = 0;

			// 8. Repeat, while k < len
			while (k < len) {

				var kValue, mappedValue;

				// a. Let Pk be ToString(k).
				// This is implicit for LHS operands of the in operator
				// b. Let kPresent be the result of calling the HasProperty
				// internal method of O with argument Pk.
				// This step can be combined with c
				// c. If kPresent is true, then
				if (k in O) {

					// i. Let kValue be the result of calling the Get internal
					// method of O with argument Pk.
					kValue = O[k];

					// ii. Let mappedValue be the result of calling the Call
					// internal method of callback
					// with T as the this value and argument list containing
					// kValue, k, and O.
					mappedValue = callback.call(T, kValue, k, O);

					// iii. Call the DefineOwnProperty internal method of A with
					// arguments
					// Pk, Property Descriptor {Value: mappedValue, Writable:
					// true, Enumerable: true, Configurable: true},
					// and false.

					// In browsers that support Object.defineProperty, use the
					// following:
					// Object.defineProperty(A, Pk, { value: mappedValue,
					// writable: true, enumerable: true, configurable: true });

					// For best browser support, use the following:
					A[k] = mappedValue;
				}
				// d. Increase k by 1.
				k++;
			}

			// 9. return A
			return A;
		};
	}

	if (!Array.prototype.some) {
		Array.prototype.some = function(fun /* , thisp */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof fun != "function")
				throw new TypeError();

			var thisp = arguments[1];
			for ( var i = 0; i < len; i++) {
				if (i in t && fun.call(thisp, t[i], i, t))
					return true;
			}

			return false;
		};
	}

	if (!Array.prototype.reduce) {
		Array.prototype.reduce = function reduce(accumulator) {
			if (this === null || this === undefined)
				throw new TypeError("Object is null or undefined");
			var i = 0, l = this.length >> 0, curr;

			if (typeof accumulator !== "function") // ES5 : "If
				// IsCallable(callbackfn) is
				// false, throw a TypeError
				// exception."
				throw new TypeError("First argument is not callable");

			if (arguments.length < 2) {
				if (l === 0)
					throw new TypeError("Array length is 0 and no second argument");
				curr = this[0];
				i = 1; // start accumulating at the second element
			} else
				curr = arguments[1];

			while (i < l) {
				if (i in this)
					curr = accumulator.call(undefined, curr, this[i], i, this);
				++i;
			}

			return curr;
		};
	}

	if (!Array.prototype.reduceRight) {
		Array.prototype.reduceRight = function(callbackfn /* , initialValue */) {
			"use strict";

			if (this == null)
				throw new TypeError();

			var t = Object(this);
			var len = t.length >>> 0;
			if (typeof callbackfn != "function")
				throw new TypeError();

			// no value to return if no initial value, empty array
			if (len === 0 && arguments.length === 1)
				throw new TypeError();

			var k = len - 1;
			var accumulator;
			if (arguments.length >= 2) {
				accumulator = arguments[1];
			} else {
				do {
					if (k in this) {
						accumulator = this[k--];
						break;
					}

					// if array contains no values, no initial value to return
					if (--k < 0)
						throw new TypeError();
				} while (true);
			}

			while (k >= 0) {
				if (k in t)
					accumulator = callbackfn.call(undefined, accumulator, t[k], k, t);
				k--;
			}

			return accumulator;
		};
	}

	if (!Function.prototype.bind) {
		Function.prototype.bind = function(oThis) {
			if (typeof this !== "function") {
				// closest thing possible to the ECMAScript 5 internal
				// IsCallable function
				throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
			}

			var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function() {
			}, fBound = function() {
				return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice
						.call(arguments)));
			};

			fNOP.prototype = this.prototype;
			fBound.prototype = new fNOP();

			return fBound;
		};
	}

	if (!Object.create) {
		// this is the polyfill implementation covers the main use case
		Object.create = function(o) {
			if (arguments.length > 1) {
				throw new Error('Object.create implementation only accepts the first parameter.');
			}
			function F() {
			}
			F.prototype = o;
			return new F();
		};
	}

	function defineProperties(obj, properties) {
		// this is the polyfill implementation covers the main use case
		function convertToDescriptor(desc) {
			function hasProperty(obj, prop) {
				return Object.prototype.hasOwnProperty.call(obj, prop);
			}

			function isCallable(v) {
				// NB: modify as necessary if other values than functions are
				// callable.
				return typeof v === "function";
			}

			if (typeof desc !== "object" || desc === null)
				throw new TypeError("bad desc");

			var d = {};
			if (hasProperty(desc, "enumerable"))
				d.enumerable = !!obj.enumerable;
			if (hasProperty(desc, "configurable"))
				d.configurable = !!obj.configurable;
			if (hasProperty(desc, "value"))
				d.value = obj.value;
			if (hasProperty(desc, "writable"))
				d.writable = !!desc.writable;
			if (hasProperty(desc, "get")) {
				var g = desc.get;
				if (!isCallable(g) && g !== "undefined")
					throw new TypeError("bad get");
				d.get = g;
			}
			if (hasProperty(desc, "set")) {
				var s = desc.set;
				if (!isCallable(s) && s !== "undefined")
					throw new TypeError("bad set");
				d.set = s;
			}

			if (("get" in d || "set" in d) && ("value" in d || "writable" in d))
				throw new TypeError("identity-confused descriptor");

			return d;
		}

		if (typeof obj !== "object" || obj === null)
			throw new TypeError("bad obj");

		properties = Object(properties);
		var keys = Object.keys(properties);
		var descs = [];
		for ( var i = 0; i < keys.length; i++)
			descs.push([ keys[i], convertToDescriptor(properties[keys[i]]) ]);
		for ( var i = 0; i < descs.length; i++)
			Object.defineProperty(obj, descs[i][0], descs[i][1]);

		return obj;
	}

	if (!Object.keys) {
		Object.keys = (function() {
			var hasOwnProperty = Object.prototype.hasOwnProperty, hasDontEnumBug = !({
				toString : null
			}).propertyIsEnumerable('toString'), dontEnums = [ 'toString', 'toLocaleString', 'valueOf',
					'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor' ], dontEnumsLength = dontEnums.length

			return function(obj) {
				if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null)
					throw new TypeError('Object.keys called on non-object')

				var result = []

				for ( var prop in obj) {
					if (hasOwnProperty.call(obj, prop))
						result.push(prop)
				}

				if (hasDontEnumBug) {
					for ( var i = 0; i < dontEnumsLength; i++) {
						if (hasOwnProperty.call(obj, dontEnums[i]))
							result.push(dontEnums[i])
					}
				}
				return result
			}
		})()
	}

	if (typeof Object.getPrototypeOf !== "function") {
		if (typeof "test".__proto__ === "object") {
			Object.getPrototypeOf = function(object) {
				return object.__proto__;
			};
		} else {
			Object.getPrototypeOf = function(object) {
				// May break if the constructor has been tampered with
				return object.constructor.prototype;
			};
		}
	}

	if (!String.prototype.trim) {
		String.prototype.trim = function() {
			return this.replace(/^\s+|\s+$/g, '');
		};
	}

	var undefined = void (0);
	if (window.sap !== undefined && window.sap.riv !== undefined && window.sap.riv.module !== undefined) {
		// In case of already defined
		return;
	}

	var isJQueryUsed = jQuery !== undefined ? true : false

	var jQueryHoldReady = function(shouldHold) {
		if (isJQueryUsed) {
			if (jQuery.holdReady) {
				jQuery.holdReady(shouldHold);
			} else if (shouldHold) {
				jQuery.readyWait += 1;
			} else {
				jQuery.ready(true);
			}
		}
	}
	var curScript = undefined;
	var context_path = '/';
	var scripts = document.getElementsByTagName("script");
	var trace = function() {
	};
	// A ugly way to determine whether the script tag is used for
	// loading sap.viz.base.js
	// Sometimes the base js is not loaded via script tag
	if (scripts.length && scripts[scripts.length - 1].getAttribute('src')
			&& scripts[scripts.length - 1].getAttribute('src').lastIndexOf('sap.viz.base.js')) {
		curScript = scripts[scripts.length - 1];
		if (((curScript.getAttribute('trace') || '').toLowerCase() === 'true') && (typeof console !== undefined)) {
			trace = function(traceLog) {
				console.log(traceLog);
			};
		}

		var context_path = curScript.getAttribute('base-url');

		if (!context_path) {
			var src = curScript.getAttribute('src');
			context_path = src.substring(0, src.lastIndexOf('/'));
		}
		if (context_path.charAt(context_path.length - 1) !== '/')
			context_path = context_path + '/';
	}

	window.sap = window.sap || {};
	window.sap.riv = window.sap.riv || {};

	var ENTRY_CREATED = 0, IN_LOADING = 1, DEFINED = 2, ERROR = 3;

	var hasOwn = Object.prototype.hasOwnProperty;

	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	var isFunction = function(obj) {
		return type(obj) === "function";
	};

	var isArray = Array.isArray || function(obj) {
		return type(obj) === "array";
	};

	var isString = function(obj) {
		return type(obj) === "string";
	};

	// A crude way of determining if an object is a window
	var isWindow = function(obj) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	};

	var isNaN = function(obj) {
		return obj == null || !/\d/.test(obj) || isNaN(obj);
	};

	var isNumber = function(n) {
		return !isNaN(parseFloat(n)) && isFinite(n);
	};

	var isDefined = function(v) {
		return typeof (v) !== 'undefined';
	};

	var isUndefined = function(v) {
		return typeof (v) === 'undefined';
	};

	var isPlainObject = function(obj) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the
		// constructor property.
		// Make sure that DOM nodes and window objects don't pass through,
		// as well
		if (!obj || type(obj) !== "object" || obj.nodeType || isWindow(obj)) {
			return false;
		}

		// Not own constructor property must be Object
		if (obj.constructor && !hasOwn.call(obj, "constructor")
				&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for (key in obj) {
		}

		return key === undefined || hasOwn.call(obj, key);
	};

	var isEmptyObject = function(obj) {
		for ( var name in obj) {
			return false;
		}
		return true;
	};

	var ModuleEntry = function(qname, version) {
		this._qname = qname;
		this._version = version;
		this._moduleSetupFunc = undefined;
		this._status = ENTRY_CREATED;
		this._moduleObject = undefined;
		this._exportToGlobal = false;
		this._depList = [];
		this._pendingDefTaskList = [];
		jQueryHoldReady(true);
	};
	ModuleEntry.prototype.moduleObject = function(moduleObj) {
		return this._moduleObject;
	};
	ModuleEntry.prototype.setupFunction = function(setupFunction) {
		if (isDefined(setupFunction)) {
			this._moduleSetupFunc = setupFunction;
			return this;
		} else {
			return this._moduleSetupFunc;
		}
	};
	ModuleEntry.prototype.setModuleObject = function(moduleObj) {
		this._moduleObject = moduleObj;
	};
	ModuleEntry.prototype.qname = function() {
		return this._qname;
	};
	ModuleEntry.prototype.version = function() {
		return this._version;
	};
	ModuleEntry.prototype.status = function(status) {
		if (status !== undefined) {
			this._status = status;
			return this;
		} else {
			return this._status;
		}
	};
	ModuleEntry.prototype.dependentModules = function(depList) {
		if (isDefined(depList)) {
			this._depList = depList;
			return this;
		} else {
			return this._depList;
		}
	};
	ModuleEntry.prototype.exportToGlobal = function(exportToGlobal) {
		if (isDefined(exportToGlobal)) {
			this._exportToGlobal = exportToGlobal;
			return this;
		} else {
			return this._exportToGlobal;
		}

	};

	ModuleEntry.prototype.waitUntilDefined = function(pendingDefTask) {
		this._pendingDefTaskList.push(pendingDefTask);
	};
	ModuleEntry.prototype.getPendingDefTasks = function() {
		return this._pendingDefTaskList;
	};

	// A global pool for containing all of the managed modules
	var modulesPool = {};
	// Register loaded url
	var loadedURLs = {};

	var loader = function(url) {
		if (!loadedURLs.hasOwnProperty(url)) {
			loadedURLs[url] = false;
			var head = document.getElementsByTagName("head")[0] || document.documentElement;
			var script = document.createElement("script");
			script.type = 'text/javascript';
			script.src = url;
			// Handle Script loading
			var done = false;
			// Attach handlers for all browsers
			script.onload = script.onreadystatechange = function() {
				if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
					done = true;
					// Handle memory leak in IE
					script.onload = script.onreadystatechange = null;
					if (head && script.parentNode) {
						head.removeChild(script);
					}
					loadedURLs[url] = true;
				}
			};
			if (script.addEventListener) {
				script.addEventListener('error', function() {
					throw new Error('Loading ' + url + ' failed.')
				}, true);
			}
			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709 and #4378).
			head.insertBefore(script, head.firstChild);
			// We handle everything using the script element injection
		}

		return undefined;
	};

	var isValidSemanticVersion = function(semver) {
		if (semver === undefined || typeof semver !== 'string') {
			return false;
		}
		var components = semver.split('.');
		if (components.length > 3) {
			return false;
		}
		for ( var i = 0, len = components.length; i < len; i++) {
			if (parseInt(components[i]) === NaN) {
				return false;
			}
		}
		return true;
	};

	var buildModuleURL = function(qname, version) {
		var paths = qname.split('.');
		var fileName = paths.splice(paths.length - 1, 1);
		return context_path + paths.join('/') + '/' + fileName + '.' + version + '.js';
	};

	var setupModule = function(moduleEntry) {
		var moduleObject;
		if (isFunction(moduleEntry.setupFunction())) {
			var args = [];
			for ( var i = 0, depModule, depModuleList = moduleEntry.dependentModules(), len = depModuleList.length; i < len; i++) {
				depModule = depModuleList[i];
				args.push(modulesPool[depModule.qname][depModule.version].moduleObject());
			}
			moduleObject = moduleEntry.setupFunction().apply(window, args);
		} else {
			moduleObject = moduleEntry.moduleObject();
		}
		if (moduleEntry.exportToGlobal()) {
			var qnameComps = moduleEntry.qname().split('.');
			var attachTo = window;
			for ( var i = 0, part, len = qnameComps.length; i < len; i++) {
				part = qnameComps[i];
				if (i === len - 1) {
					attachTo[part] = moduleObject;
				} else {
					attachTo[part] = attachTo[part] || {};
					attachTo = attachTo[part];
				}
			}
		}
		moduleEntry.setModuleObject(moduleObject);
		moduleEntry.status(DEFINED);
		trace(moduleEntry.qname() + ' ' + moduleEntry.version() + ' loaded')
		// Resume the definition tasks that are blocked on this module
		var pendingTasks = moduleEntry.getPendingDefTasks();
		while (pendingTasks.length) {
			var pendingTask = pendingTasks.pop();
			pendingTask(moduleEntry);
		}
		jQueryHoldReady(false)
	};

	var createPendingDefTask = function(waitedModules, moduleEntry) {
		return (function(availableModuleEntry) {
			// remove the available module from the waited modules
			delete waitedModules[availableModuleEntry.qname()][availableModuleEntry.version()];
			if (isEmptyObject(waitedModules[availableModuleEntry.qname()])) {
				delete waitedModules[availableModuleEntry.qname()];
			}
			if (isEmptyObject(waitedModules)) {
				setupModule(moduleEntry);
			}
		});
	};

	sap.riv.module = function(moduleCfg, dependencies, moduleSetupFunc) {
		if (isUndefined(moduleCfg) || isUndefined(moduleCfg.qname) || isUndefined(moduleCfg.version)) {
			throw new Error('Bad Arguments: you have to specify the qname and version for the module.');
		}
		if (!isString(moduleCfg.qname) || !isValidSemanticVersion(moduleCfg.version)) {
			throw new Error('Invalid qname or version string');
		}
		if (arguments.length === 2) {
			if (!isPlainObject(dependencies) && !isFunction(dependencies)) {
				throw new Error('You must specify a plain object or a module setup function');
			}
			moduleSetupFunc = dependencies;
			dependencies = [];
		}
		if (arguments.length === 3) {
			if (!isArray(dependencies) || (!isPlainObject(moduleSetupFunc) && !isFunction(moduleSetupFunc))) {
				throw new Error(
						'Dependencies must be array, and you must specify an plain object or a module setup function');
			}
		}
		var qname = moduleCfg.qname, version = moduleCfg.version, exportToGlobal = isUndefined(moduleCfg.exported) ? false
				: moduleCfg.exported, moduleEntry;

		if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool, version)) {
			modulesPool[qname] = modulesPool[qname] || {};
			modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
		}
		moduleEntry = modulesPool[qname][version];

		if (moduleEntry.status() === ENTRY_CREATED) {
			// The depending module is just created for the loading
			if (typeof moduleSetupFunc === 'object') {
				// Module is just a plain object
				moduleEntry.exportToGlobal(exportToGlobal).setModuleObject(moduleSetupFunc);
			} else {
				var depList = [];
				for ( var i = 0, depModule, len = dependencies.length; i < len; i++) {
					depModule = dependencies[i];
					if (!isString(depModule.qname) || !isValidSemanticVersion(depModule.version)) {
						throw new Error('You must specify qname and version for the depending module');
					}
					depList.push({
						qname : depModule.qname,
						version : depModule.version
					});
				}
				moduleEntry.exportToGlobal(exportToGlobal).dependentModules(depList).setupFunction(moduleSetupFunc);
			}
		}

		if (moduleEntry.status() === DEFINED || moduleEntry.status() === IN_LOADING) {
			return;
		}
		moduleEntry.status(IN_LOADING);

		if (moduleEntry.dependentModules().length === 0) {
			setupModule(moduleEntry);
			return;
		} else {
			var waitedModules = {};
			for ( var i = 0, dep, depList = moduleEntry.dependentModules(), len = depList.length; i < len; i++) {
				dep = depList[i];
				if (!(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))
						|| (modulesPool[dep.qname][dep.version].status() !== DEFINED)) {
					// The depending module is not ready, either because of not
					// loaded yet or because of pending on defining
					waitedModules[dep.qname] = waitedModules[dep.qname] || {};
					waitedModules[dep.qname][dep.version] = waitedModules[dep.qname][dep.version] || {
						qname : dep.qname,
						version : dep.version,
						url : dep.url || buildModuleURL(dep.qname, dep.version)
					};
				}
			}
			if (isEmptyObject(waitedModules)) {
				// All the depending modules are ready
				setupModule(moduleEntry);
				return;
			} else {
				// Some of the depending modules are not ready, either because
				// of not loaded yet or because of pending on defining
				for ( var qname in waitedModules) {
					for ( var version in waitedModules[qname]) {
						if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool[qname], version)) {
							// if it's a brand new module, then create a entry
							// for it
							modulesPool[qname] = modulesPool[qname] || {};
							modulesPool[qname][version] = modulesPool[qname][version]
									|| new ModuleEntry(qname, version);
							// TODO check circular dependencies
							modulesPool[qname][version].waitUntilDefined(createPendingDefTask(waitedModules,
									moduleEntry));
							// TODO handle loading error
							loader(waitedModules[qname][version].url);
						} else {
							// if it's not ready(either is loading or not), wait
							// until it's done
							modulesPool[qname][version].waitUntilDefined(createPendingDefTask(waitedModules,
									moduleEntry));
						}
					}
				}
			}
		}
	};

	var executeRequiredFunction = function(requiredFunction, requiredModules) {
		var args = [];
		for ( var i = 0, requiredModule, len = requiredModules.length; i < len; i++) {
			requiredModule = requiredModules[i];
			args.push(modulesPool[requiredModule.qname][requiredModule.version].moduleObject());
		}
		requiredFunction.apply(window, args);
	};

	var createPendingRequireTask = function(waitedModules, requiredFunc, requiredModules) {
		return (function(availableModuleEntry) {
			// remove the available module from the waited modules
			delete waitedModules[availableModuleEntry.qname()][availableModuleEntry.version()];
			if (isEmptyObject(waitedModules[availableModuleEntry.qname()])) {
				delete waitedModules[availableModuleEntry.qname()];
			}
			if (isEmptyObject(waitedModules)) {
				executeRequiredFunction(requiredFunc, requiredModules);
			}
		});
	};

	sap.riv.require = function(dependencies, requireFunc) {
		if (arguments.length === 1) {
			if (!isFunction(dependencies)) {
				throw new Error('You have to specify a function to run');
			}
			requireFunc = dependencies;
			dependencies = [];
		}
		if (arguments.length === 2) {
			if (!isArray(dependencies) || !isFunction(requireFunc)) {
				throw new Error(
						'the first argument has to be array of depending modules, the second argument should be function type');
			}
		}

		if (!dependencies.length) {
			// No dependencies specified, execute it right away.
			executeRequiredFunction(requireFunc, dependencies);
			return;
		}

		var waitedModules = {};
		for ( var i = 0, dep, len = dependencies.length; i < len; i++) {
			dep = dependencies[i];
			if (!(hasOwn.call(modulesPool, dep.qname) && hasOwn.call(modulesPool[dep.qname], dep.version))
					|| (modulesPool[dep.qname][dep.version].status() !== DEFINED)) {
				// The depending module is not ready, either because of not
				// loaded yet or because of pending on defining
				waitedModules[dep.qname] = waitedModules[dep.qname] || {};
				waitedModules[dep.qname][dep.version] = waitedModules[dep.qname][dep.version] || {
					qname : dep.qname,
					version : dep.version,
					url : dep.url || buildModuleURL(dep.qname, dep.version)
				};
			}
		}
		if (isEmptyObject(waitedModules)) {
			// All the depending modules are ready
			executeRequiredFunction(requireFunc, dependencies);
			return;
		} else {
			// Some of the depending modules are not ready, either because
			// of not loaded yet or because of pending on defining
			for ( var qname in waitedModules) {
				for ( var version in waitedModules[qname]) {
					if (!hasOwn.call(modulesPool, qname) || !hasOwn.call(modulesPool[qname], version)) {
						// if it's a brand new module, then create a entry
						// for it
						modulesPool[qname] = modulesPool[qname] || {};
						modulesPool[qname][version] = modulesPool[qname][version] || new ModuleEntry(qname, version);
						// TODO check circular dependencies
						modulesPool[qname][version].waitUntilDefined(createPendingRequireTask(waitedModules,
								requireFunc, dependencies));
						// TODO handle loading error
						loader(waitedModules[qname][version].url);
					} else {
						// if it's not ready(either is loading or not), wait
						// until it's done
						modulesPool[qname][version].waitUntilDefined(createPendingRequireTask(waitedModules,
								requireFunc, dependencies));
					}
				}
			}
		}
	};

	// Evalulates a script in a global context
	var globalEval = function(data) {
		if (data && /\S/.test(data)) {
			// Inspired by code by Andrea Giammarchi
			// http://webreflection.blogspot.com/2007/08/global-scope-evaluation-and-dom.html
			var head = document.getElementsByTagName("head")[0] || document.documentElement, script = document
					.createElement("script");

			script.type = "text/javascript";

			try {
				script.appendChild(document.createTextNode(data));
			} catch (e) {
				script.text = data;
			}

			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709).
			head.insertBefore(script, head.firstChild);
			head.removeChild(script);
		}
	};

	sap.riv.setBaseUrl = function(url) {
		context_path = url;
	};
	// if the base js is not loaded via script tag, skip the evaluating of
	// embeded script.
	if (curScript) {
		var script = curScript.innerHTML;
		if (script) {
			globalEval(script);
		}
	}
})();sap.riv.module(
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'},
[

],
function Setup() {
	var class2type = {
		'[object Boolean]' : 'boolean',
		'[object Number]' : 'number',
		'[object String]' : 'string',
		'[object Function]' : 'function',
		'[object Array]' : 'array',
		'[object Date]' : 'date',
		'[object RegExp]' : 'regexp',
		'[object Object]' : 'object'
	};

	var hasOwn = Object.prototype.hasOwnProperty;
	// Used for trimming whitespace
	var rdigit = /\d/;

	var type = function(obj) {
		return obj == null ? String(obj) : class2type[Object.prototype.toString.call(obj)] || "object";
	};

	/**
	 * Type Utilities for common variable type related tasks
	 * 
	 * @name sap.viz.base.utils.TypeUtils
	 * @class
	 */
	var typeUtils = {

		/**
	     * Returns a boolean value indicating whether the parameter is of type function
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		// See test/unit/core.js for details concerning isFunction.
		// Since version 1.3, DOM methods and functions like alert
		// aren't supported. They return false on IE (#2968).
		isFunction : function(obj) {
			return type(obj) === "function";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is of type array
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isArray : Array.isArray || function(obj) {
			return type(obj) === "array";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is of type string
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isString : function(obj) {
			return type(obj) === "string";
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a non-empty string
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isNonEmptyString : function(obj) {
			return this.isString(obj) && obj.length !== 0;
		},

		/**
	     * Returns a boolean value indicating whether the parameter is an empty string
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isEmptyString : function(obj) {
			return this.isString(obj) && obj.length === 0;
		},

		/**
	     * Returns a boolean value indicating whether the parameter is NaN
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isNaN : function(obj) {
			return obj === null || obj === undefined || !rdigit.test(obj) || isNaN(obj);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a number
	     *
	     * @param {object}
	     * @returns {boolean} Caution: isNumber(Infinity) returns false.
	     */
		isNumber : function(n) {
			return !this.isNaN(parseFloat(n)) && isFinite(n);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is defined
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isDefined : function(v) {
			return typeof (v) !== 'undefined';
		},

		/**
	     * Returns a boolean value indicating whether the parameter is undefined
	     *
	     * @param {object}
	     * @returns {boolean} 
	     */
		isUndefined : function(v) {
			return typeof (v) === 'undefined';
		},

		/**
	     * Returns a boolean value indicating whether the parameter is a plain object
	     *
	     * @param {object}
	     * @returns {boolean}
	     * Caution: A plain object is an object that has no prototype method and
	     *  no parent class. Null, undefined, DOM nodes and window object are not considered as plain object.
	     */
		isPlainObject : function(obj) {
			// Must be an Object.
			// Because of IE, we also have to check the presence of the
			// constructor property.
			// Make sure that DOM nodes and window objects don't pass through,
			// as well
			if (!obj || type(obj) !== "object" || obj.nodeType
					|| (obj && typeof obj === "object" && "setInterval" in obj)) {
				return false;
			}

			// Not own constructor property must be Object
			if (obj.constructor && !hasOwn.call(obj, "constructor")
					&& !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
				return false;
			}

			// Own properties are enumerated firstly, so to speed up,
			// if last one is own, then all properties are own.

			var key;
			for (key in obj) {
			}

			return key === undefined || hasOwn.call(obj, key);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is an empty object
	     *
	     * @param {object}
	     * @returns {boolean}
	     * Caution: An empty is a plain object without any properties.
	     */
		isEmptyObject : function(obj) {
			for ( var name in obj) {
				return false;
			}
			return this.isPlainObject(obj);
		},

		/**
	     * Returns a boolean value indicating whether the parameter is undefined or null
	     *
	     * @param {object}
	     * @returns {boolean}
	     */
		isExist : function(o) {
			if ((typeof (o) === 'undefined') || (o === null)) {
				return false;
			}
			return true;
		}
	};

	return typeUtils;
});sap.riv.module(
{
  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils) {
  var NumberUtils = {
    isNoValue: function(n) {
      return TypeUtils.isNaN(n);
    }
  };
  return NumberUtils;
});sap.riv.module(
{
  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'},
[

],

function Setup() {
    
    var Scaler = {
        /**
         * @param _scale
         *        d3 quantitative scale
         *                
         * @param _roughTickNum
         *        rough tick number
         *                
         * @param _accurateTickNum
         *        accurate tick number
         *
         * @returns d3 quantitative scale which can be divided by ticks perfectly
         */
        perfect : function(_scale, _roughTickNum, _accurateTickNum)
        {
            //the function may change the domain, but never change the range.
            var const_minTickNum = 2;
            var const_extendNum = 100;

            var domainArray = _scale.domain();

            var originalDomainBegin = domainArray[0];
            var originalDomainEnd = domainArray[domainArray.length-1];

            //if the domain is [0,0], we change it to [0,100]
            //if the domain is [-x,-x], we change it to [-x,0]
            //if the domain is [x,x], we change it to [x,0]
            //we do this in modules
            
            var roughTickNum = -1;
            var accurateTickNum = -1;

            if(!_accurateTickNum || _accurateTickNum < const_minTickNum)
            {
                if(!_roughTickNum || _roughTickNum < const_minTickNum)
                {
                    var rangeArray = _scale.range();
                    var rangeLen = Math.abs(rangeArray[0] - rangeArray[rangeArray.length-1]);
                    if(rangeLen > 10)
                    {
                        roughTickNum = const_minTickNum + Math.round(rangeLen/100);
                    }
                    else
                    {
                        roughTickNum = const_minTickNum;
                    }
                }
                else
                {
                    roughTickNum = _roughTickNum;
                }
            }
            else
            {
                accurateTickNum = _accurateTickNum;
            }

            var qScale = _scale.nice();
            if(accurateTickNum < 0)
            {
                var ticks = qScale.ticks(roughTickNum);
                
                var adjustDomain = true;
                var distance;
                if(ticks.length == 0)
                {
                    adjustDomain = false;
                }
                else if(ticks.length > 1)
                {
                    distance = ticks[1] - ticks[0];//>0
                }
                else//ticks.length==1
                {
                    var beginDis = Math.abs(domainArray[0] - ticks[0]);//>0
                    var endDis = Math.abs(domainArray[domainArray.length - 1] - ticks[0]);//>0
                    if(beginDis > endDis)
                    {
                        distance = beginDis;
                    }
                    else
                    {
                        distance = endDis;
                    }
                }
                
                var realTickNum = const_minTickNum;
                if(adjustDomain)
                {
                    realTickNum = ticks.length;
                    if(domainArray[0] < domainArray[1])
                    {
                        if(ticks[0] != domainArray[0])
                        {
                            domainArray[0] = ticks[0] - distance;
                            realTickNum++;
                        }

                        if(ticks[ticks.length -1] != domainArray[domainArray.length - 1])
                        {
                            domainArray[domainArray.length - 1] = ticks[ticks.length - 1] + distance;
                            realTickNum++;
                        }
                    }
                    else
                    {
                        if(ticks[0] != domainArray[domainArray.length - 1])
                        {
                            domainArray[domainArray.length - 1] = ticks[0] - distance;
                            realTickNum++;
                        }

                        if(ticks[ticks.length -1] != domainArray[0])
                        {
                            domainArray[0] = ticks[ticks.length - 1] + distance;
                            realTickNum++;
                        }
                    }
                }

                qScale.tickNum = realTickNum;
                qScale.distance = distance;
                qScale.tickHint = realTickNum - 1;

                //to nice the domainArray, avoid the domain contains 0.00060000001
                domainArray[0] = parseFloat(domainArray[0].toFixed(8));
                domainArray[domainArray.length - 1] = parseFloat(domainArray[domainArray.length - 1].toFixed(8));
                qScale.domain(domainArray);
                
            }
            else
            {
                //accurateTickNum:
                //1. use it as roughTickNum. 
                //2. adjust the ticNum or not
                this.perfect(qScale, accurateTickNum);
                if(qScale.tickNum > accurateTickNum)
                {
                    //try to make sure qScale.tickNum < accurateTickNum
                    var tempNum = accurateTickNum;
                    for(;tempNum >= const_minTickNum;)
                    {
                        tempNum--;
                        this.perfect(qScale, tempNum);
                        if(qScale.tickNum <= accurateTickNum)
                        {
                            break;
                        }
                    }
                }
                
                //adjust the domain
                if(qScale.tickNum < accurateTickNum)
                {
                    var tickNumToAdd = (accurateTickNum - qScale.tickNum);
                    var domainArray = qScale.domain();
                    //var originalDomainBegin 
                    //var originalDomainEnd

                    for(;tickNumToAdd > 0;)
                    {
                        if(domainArray[0] < domainArray[1])
                        {
                            if(Math.abs(domainArray[1] - originalDomainEnd) > Math.abs(originalDomainBegin - domainArray[0]))
                            {
                                domainArray[0] -= qScale.distance;
                            }
                            else
                            {
                                domainArray[1] += qScale.distance;
                            }
                            tickNumToAdd--;
                            qScale.tickNum++;
                        }
                        else
                        {
                            if(Math.abs(domainArray[1] - originalDomainEnd) > Math.abs(originalDomainBegin - domainArray[0]))
                            {
                                domainArray[0] += qScale.distance;
                            }
                            else
                            {
                                domainArray[1] -= qScale.distance;
                            }
                            tickNumToAdd--;
                            qScale.tickNum++;
                        }
                    }
                    
                    qScale.tickHint = qScale.tickNum - 1;
                    //to nice the domainArray, avoid the domain contains 0.00060000001
                    domainArray[0] = parseFloat(domainArray[0].toFixed(8));
                    domainArray[domainArray.length - 1] = parseFloat(domainArray[domainArray.length - 1].toFixed(8));
                    qScale.domain(domainArray);
                    
                }
            }

            return qScale;
        },
        
        /**
         * @param _scaleA
         *        d3 linear scale
         *                
         * @param _scaleB
         *        d3 linear scale
         */
        perfectDual : function(_scaleA, _scaleB) {

            this.perfect(_scaleA);
            this.perfect(_scaleB);
            
            var domainArrayA = _scaleA.domain();
            var domainArrayB = _scaleB.domain();

            var rangeArrayA = _scaleA.range();
            var rangeArrayB = _scaleB.range();

            if( (domainArrayA[0] > domainArrayA[domainArrayA.length-1]
                && domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                ||
                (domainArrayA[0] < domainArrayA[domainArrayA.length-1]
                && domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                ||
                (domainArrayA[0] < 0
                && domainArrayA[domainArrayA.length-1] < 0)
                ||
                (domainArrayB[0] < 0
                && domainArrayB[domainArrayB.length-1] < 0)
                ||
                (domainArrayA[0] > 0
                && domainArrayA[domainArrayA.length-1] > 0)
                ||
                (domainArrayB[0] > 0
                && domainArrayB[domainArrayB.length-1] > 0)
                || 
                ( Math.abs(rangeArrayA[0] - rangeArrayA[rangeArrayA.length-1])
                != Math.abs(rangeArrayB[0] - rangeArrayB[rangeArrayB.length-1]) )
              )
            {
                //we do not need to do anythings to support this "dual"
                return;
            }

            //now make sure 
            //1. same tickNum before 0
            //2. same tickNum after 0
            var positiveTickNumA = 0;
            var negativeTickNumA = 0;

            var positiveTickNumB = 0;
            var negativeTickNumB = 0;

            var tickNumA = _scaleA.tickNum; //tickNumA >= const_minTickNum
            var tickNumB = _scaleB.tickNum; //tickNumB >= const_minTickNum

            var intervalA = (domainArrayA[domainArrayA.length-1] - domainArrayA[0])/(tickNumA-1);
            for(var i = 0; i < tickNumA; i++)
            {
                var tickValue = domainArrayA[0] + i * intervalA;
                if(tickValue > 0)
                {
                    positiveTickNumA++;
                }
                else if(tickValue < 0)
                {
                    negativeTickNumA++;
                }
            }

            var intervalB = (domainArrayB[domainArrayB.length-1] - domainArrayB[0])/(tickNumB-1);
            for(var i = 0; i < tickNumB; i++)
            {
                var tickValue = domainArrayB[0] + i * intervalB;
                if(tickValue > 0)
                {
                    positiveTickNumB++;
                }
                else if(tickValue < 0)
                {
                    negativeTickNumB++;
                }
            }

            if(positiveTickNumA > positiveTickNumB)
            {
                var moreInterNum = positiveTickNumA - positiveTickNumB;
                if(domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[domainArrayB.length-1] += (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
                else if(domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[0] += (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
            }
            else if(positiveTickNumA < positiveTickNumB)
            {
                var moreInterNum = positiveTickNumB - positiveTickNumA;
                if(domainArrayA[0] < domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[domainArrayA.length-1] += (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
                else if(domainArrayA[0] > domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[0] += (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
            }

            //negative values
            if(negativeTickNumA > negativeTickNumB)
            {
                var moreInterNum = negativeTickNumA - negativeTickNumB;
                if(domainArrayB[0] < domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[0] -= (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
                else if(domainArrayB[0] > domainArrayB[domainArrayB.length-1])
                {
                    domainArrayB[domainArrayB.length-1] -= (moreInterNum * Math.abs(intervalB));
                    _scaleB.tickNum += moreInterNum;
                }
            }
            else if(negativeTickNumA < negativeTickNumB)
            {
                var moreInterNum = negativeTickNumB - negativeTickNumA;
                if(domainArrayA[0] < domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[0] -= (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
                else if(domainArrayA[0] > domainArrayA[domainArrayA.length-1])
                {
                    domainArrayA[domainArrayA.length-1] -= (moreInterNum * Math.abs(intervalA));
                    _scaleA.tickNum += moreInterNum;
                }
            }

            //to nice the domainArray, avoid the domain contains 0.00060000001
            domainArrayA[0] = parseFloat(domainArrayA[0].toFixed(8));
            domainArrayA[1] = parseFloat(domainArrayA[1].toFixed(8));
            domainArrayB[0] = parseFloat(domainArrayB[0].toFixed(8));
            domainArrayB[1] = parseFloat(domainArrayB[1].toFixed(8));
            
            _scaleA.domain(domainArrayA);
            _scaleB.domain(domainArrayB);

            _scaleA.tickHint = _scaleA.tickNum -1;
            _scaleB.tickHint = _scaleB.tickNum -1;
        }
    };
    
    return Scaler;
});sap.riv.module(
{
  qname : 'sap.viz.Constants',
  version : '4.0.0'},
[

],
function Setup() {
  var constants = {
    SAPColorSingleAxis : [ "#748CB2", "#9CC677", "#EACF5E", "#F9AD79",
        "#D16A7C", "#8873A2", "#3A95B3", "#B6D949", "#FDD36C", "#F47958",
        "#A65084", "#0063B1", "#0DA841", "#FCB71D", "#F05620", "#B22D6E",
        "#3C368E", "#8FB2CF", "#95D4AB", "#EAE98F", "#F9BE92", "#EC9A99",
        "#BC98BD", "#1EB7B2", "#73C03C", "#F48323", "#EB271B", "#D9B5CA",
        "#AED1DA", "#DFECB2", "#FCDAB0", "#F5BCB4" ],

    SAPColorDualAxis1 : [ "#8FBADD", "#B8D4E9", "#7AAED6", '#A3C7E3',
        '#3D88C4', '#66A1D0', '#297CBE', '#5295CA', '#005BA3', '#146FB7',
        '#005395', '#0063B1' ],

    SAPColorDualAxis2 : [ "#F6A09B", "#F9C3C0", "#F58E88", '#F8B1AD',
        '#F05B52', '#F37D76', '#EE4A40', '#F16C64', '#D92419', '#ED382D',
        '#C52117', '#EB271B' ]
  };

  constants.SAPColor = constants.SAPColorSingleAxis;

  return constants;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils) {
	var msgparas = /\{(\d+)\}/g;

	var emptyFn = function() {
	};

	var funcUtils = {
		/**
		 * empty function
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#noop
		 * @function
		 */
		noop : emptyFn,

		/**
		 * function throwing unsupported exception
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#unsupported
		 * @function
		 */
		unsupported : function() {
			throw new Error('Unsupported function!');
		},

		/**
		 * function throwing unimplemented exception
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#unimplemented
		 * @function
		 */
		unimplemented : function() {
			throw new Error('Unimplemented function!');
		},

		/**
		 * function throwing error
		 * 
		 * @name sap.viz.base.utils.FunctionUtils#error
		 * @param {String}
		 *            msg the error message
		 * @function
		 */
		error : function(msg) {
			var args = arguments;
			if (args[0]) {
				var msg = args[0].replace(msgparas, function(m, n) {
					return args[parseInt(n) + 1];
				});
				throw msg;
			} else {
				throw 'unknown error!';
			}
		},

		createCallChain : function() {
			var len = arguments.length;
			if (len > 1) {
				var callChain = [];
				for ( var i = 0; i < len; i++) {
					if (TypeUtils.isFunction(arguments[i])) {
						callChain.push(arguments[i]);
					} else {
						funcUtils.error('Could not create call chain for non-function object');
					}
				}
				return (function() {
					for ( var i = 0; i < len; i++) {
						callChain[i].apply(this, arguments);
					}
				});
			} else {
				return TypeUtils.isFunction(arguments[0]) ? arguments[0] : emptyFn;
			}
		}
	};

	return funcUtils;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, FuncUtils) {
	var emptyFn = function(){};
	var trimLeft = /^\s+/, trimRight = /\s+$/,
	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/, rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g;

	var trim = trim ? function(text) {
		return text == null ? "" : trim.call(text);
	} :
	// Otherwise use our own trimming functionality
	function(text) {
		return text == null ? "" : text.toString().replace(trimLeft, "").replace(trimRight, "");
	};

	/**
	 * OO static utilities
	 * 
	 * @name sap.viz.base.utils.ObjectUtils
	 * @class
	 */
	var objUtils = {
		uuid : function() {
			return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {var r = Math.random()*16|0,v=c=='x'?r:r&0x3|0x8;return v.toString(16);});
		},
		
		proxy : function(fn, proxy, thisObject) {
			if (arguments.length === 2) {
				if (typeof proxy === "string") {
					thisObject = fn;
					fn = thisObject[proxy];
					proxy = undefined;

				} else if (proxy && !TypeUtils.isFunction(proxy)) {
					thisObject = proxy;
					proxy = undefined;
				}
			}

			if (!proxy && fn) {
				proxy = function() {
					return fn.apply(thisObject || this, arguments);
				};
			}
			// So proxy can be declared as an argument
			return proxy;
		},

		// Copy from jQuery
		extend : function() {
			var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

			// Handle a deep copy situation
			if (typeof target === "boolean") {
				deep = target;
				target = arguments[1] || {};
				// skip the boolean and the target
				i = 2;
			}

			// Handle case when target is a string or something (possible in
			// deep
			// copy)
			if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
				target = {};
			}

			// extend jQuery itself if only one argument is passed
			if (length === i) {
				target = this;
				--i;
			}

			for (; i < length; i++) {
				// Only deal with non-null/undefined values
				if ((options = arguments[i]) != null) {
					// Extend the base object
					for (name in options) {
						src = target[name];
						copy = options[name];

						// Prevent never-ending loop
						if (target === copy) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if (deep && copy && (TypeUtils.isPlainObject(copy) || (copyIsArray = TypeUtils.isArray(copy)))) {
							if (copyIsArray) {
								copyIsArray = false;
								clone = src && TypeUtils.isArray(src) ? src : [];

							} else {
								clone = src && TypeUtils.isPlainObject(src) ? src : {};
							}
							// Never move original objects, clone them
							target[name] = objUtils.extend(deep, clone, copy);
							// Don't bring in undefined values
						} else if (copy !== undefined) {
							target[name] = copy;
						}
					}
				}
			}
			// Return the modified object
			return target;
		},

		// args is for internal usage only
		each : function(object, callback, args) {
			var name, i = 0, length = object.length, isObj = length === undefined || TypeUtils.isFunction(object);

			if (args) {
				if (isObj) {
					for (name in object) {
						if (callback.apply(object[name], args) === false) {
							break;
						}
					}
				} else {
					for (; i < length;) {
						if (callback.apply(object[i++], args) === false) {
							break;
						}
					}
				}

				// A special, fast, case for the most common use of each
			} else {
				if (isObj) {
					for (name in object) {
						if (callback.call(object[name], name, object[name]) === false) {
							break;
						}
					}
				} else {
					for ( var value = object[0]; i < length && callback.call(value, i, value) !== false; value = object[++i]) {
					}
				}
			}
			return object;
		},

		parseJSON : function(data) {
			if (typeof data !== "string" || !data) {
				return null;
			}

			// Make sure leading/trailing whitespace is removed (IE can't handle
			// it)
			data = trim(data);

			// Make sure the incoming data is actual JSON
			// Logic borrowed from http://json.org/json2.js
			if (rvalidchars.test(data.replace(rvalidescape, "@").replace(rvalidtokens, "]").replace(rvalidbraces, ""))) {

				// Try to use the native JSON parser first
				return window && window.JSON && window.JSON.parse ? window.JSON.parse(data) : (new Function("return "
						+ data))();

			} else {
				TypeUtils.error("Invalid JSON: " + data);
			}
		},

		/**
		 * make the subclass derived from passed-in superclass, the superclass's
		 * constructor will be automatically called.
		 * 
		 * @name sap.viz.base.utils.ObjectUtils.derive
		 * @function
		 * @param {Function}
		 *            subcls constructor of subclass or baseclass to extend
		 * @param {Function}
		 *            supercls or overide constructor of superclass, or object
		 *            literals to overide
		 * @return {Function} the constructor of the derived class with some
		 *         additional field: 'clazz' points to current constructor,
		 *         superclazz points to superclass' constructor. superclass in
		 *         prototype points to superclass's prototype
		 */
		derive : function(subcls, supercls) {
			var ret;
			var retp;
			if (typeof subcls === 'function') {
				if (typeof supercls === 'function') {
					if (supercls.prototype.constructor == Object.prototype.constructor) {
						supercls.prototype.constructor = supercls;
					}
					emptyFn.prototype = supercls.prototype;
					var h = new emptyFn();
					var sbp = subcls.prototype;
					for (var p in sbp) {
						if (sbp.hasOwnProperty(p)) {
							h[p] = sbp[p];
						}
					}
					ret = FuncUtils.createCallChain(supercls, subcls);
					retp = ret.prototype = h;
					retp.constructor = ret;
					retp.superclass = supercls.prototype;
					retp.callParent = (function() {
						var stack = [];
						return function() {
							var funcName = arguments[0];
							if (!stack.length) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							} else if (stack[stack.length - 1].funcName !== funcName
									|| stack[stack.length - 1].thisObj !== this) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							}

							var skip = stack[stack.length - 1].level;
							var currentProto = this.superclass;
							while (skip--) {
								currentProto = currentProto.superclass;
							}
							stack[stack.length - 1].level++;
							var args = [];
							for ( var i = 1; i < arguments.length; i++) {
								args.push(arguments[i]);
							}
							currentProto[funcName].apply(stack[stack.length - 1].thisObj, args);
							stack[stack.length - 1].level--;
							if (!stack[stack.length - 1].level) {
								stack.pop();
							}
						};
					})();
					ret.superclazz = supercls;
					return ret;
				} else if (typeof supercls === 'object') {
					var basecls = subcls;
					var mixin = supercls;
					var bcp = basecls.prototype;

					emptyFn.prototype = bcp;
					var h = new emptyFn();
					ret = FuncUtils.createCallChain(basecls, mixin.constructor);
					retp = ret.prototype = h;
					for (p in mixin) {
						if (mixin.hasOwnProperty(p)) {
							retp[p] = mixin[p];
						}
					}
					retp.constructor = ret;
					retp.superclass = basecls.prototype;
					retp.callParent = (function() {
						var stack = [];
						return function() {
							var funcName = arguments[0];
							if (!stack.length) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							} else if (stack[stack.length - 1].funcName !== funcName
									|| stack[stack.length - 1].thisObj !== this) {
								stack.push({
									funcName : funcName,
									thisObj : this,
									level : 0
								});
							}

							var skip = stack[stack.length - 1].level;
							var currentProto = this.superclass;
							while (skip--) {
								currentProto = currentProto.superclass;
							}
							stack[stack.length - 1].level++;
							var args = [];
							for ( var i = 1; i < arguments.length; i++) {
								args.push(arguments[i]);
							}
							currentProto[funcName].apply(stack[stack.length - 1].thisObj, args);
							stack[stack.length - 1].level--;
							if (!stack[stack.length - 1].level) {
								stack.pop();
							}
						};
					})();
					ret.superclazz = basecls;
				}
			}
			return ret;
		}
	};
	return objUtils;
});sap.riv.module(
{
  qname : 'sap.viz.lang.langManager',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(FunctionUtils, ObjectUtils, TypeUtils) {

  function loadResource(url,  cb, onError) {
    var head = document.getElementsByTagName("head")[0]
        || document.documentElement;
    var script = document.createElement("script");
    script.type = 'text/javascript';
    script.src = url;

    var done = false;
    script.onload = script.onreadystatechange = function() {
      if (!done
          && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
        done = true;
        script.onload = script.onreadystatechange = null;
        if (head && script.parentNode) {
          head.removeChild(script);
        }
        cb();
      }
    };
    if (script.addEventListener) {
      script.addEventListener('error', function() {
        //clear script
        script.onload = script.onreadystatechange = null;
        script.parentNode.removeChild(script);
        //call error callback
        onError();
      }, true);
    }

    head.insertBefore(script, head.firstChild);
  }
  
  function loadResources(loadPath, index, id, cb, onError ){
    if(index < loadPath.length){
      var url = loadPath[index] + 'language_' + id + '.js';
      var done = function(){
        loadResources(loadPath, index+1, id, cb, onError);
      };
      loadResource(url, done, done);
    }else{
      var c_language = get(id);
      if(c_language){ cb(c_language);}
      else onError();
    }
  }
  
  var listeners = [];
  
  function onLocaleChanged(cb) {
    listeners.forEach(function(listener) {
      listener.fn.apply(listener.scope, [ currentLanguage ]);
    });
    
    if(cb) cb();
  }
  
  function get(id){
    return languageSetting[id];
  }
  
  var languageSetting = {};
  

    var currentLanguage = languageSetting['dev'] = {IDS_DEFAULTMND:'All Measures',IDS_DEFAULTCHARTTITLE:'Title of Chart',IDS_ISNOVALUE:'No value',IDS_BARCHART:'Bar Chart',IDS_COMBINATIONCHART:'Combined Column Line Chart',IDS_DUALBARCHART:'Bar Chart with 2 X-Axes',IDS_DUALCOMBINATIONCHART:'Combined Column Line Chart with 2 Y-Axes',IDS_DUALHORIZONTALCOMBINATIONCHART:'Combined Bar Line Chart with 2 X-Axes',IDS_DUALHORIZONTALLINECHART:'Horizontal Line Chart with 2 X-Axes',IDS_DIUALLINECHART:'Line Chart with 2 Y-Axes',IDS_DUALPERCENTAGESTACKEDBARCHART:'100% Stacked Bar Chart with 2 X-Axes',IDS_DUALSTACKEDVERTICALBARCHART:'Stacked Column Chart with 2 Y-Axes',IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART:'100% Stacked Column Chart with 2 Y-Axes',IDS_DUALSTACKEDBARCHART:'Stacked Bar Chart with 2 X-Axes',IDS_DUALVERTICALBARCHART:'Column Chart with 2 Y-Axes',IDS_HORIZONTALBOXPLOTCHART:'Horizontal Box Plot',IDS_HORIZONTALCOMBINATIONCHART:'Combined Bar Line Chart',IDS_HORIZONTALLINECHART:'Horizontal Line Chart',IDS_HORIZONTALWATERFALLCHART:'Horizontal Waterfall Chart',IDS_LINECHART:'Line Chart',IDS_PERCENTAGESTACKEDBARCHART:'100% Stacked Bar Chart',IDS_PERCENTAGESTACKEDVERTICALBARCHART:'100% Stacked Column Chart',IDS_SPARKLINECHART:'Spark Line Chart (POC)',IDS_STACKEDBARCHART:'Stacked Bar Chart',IDS_STACKEDVERTICALBARCHART:'Stacked Column Chart',IDS_VARIANTBARCHART:'Variant Bar Chart (POC)',IDS_VERTICALBARCHART:'Column Chart',IDS_VERTICALBOXPLOTCHART:'Box Plot',IDS_WATERFALLCHART:'Waterfall Chart',IDS_DONUTCHART:'Donut Chart',IDS_PIECHART:'Pie Chart',IDS_BASEBUBBLECHART:'Base Scatter Chart',IDS_BUBBLECHART:'Bubble Chart',IDS_SCATTERCHART:'Scatter Plot',IDS_BASECHART:'Base Chart',IDS_BASEHORIZONTALCHART:'Base horizontal XY Chart',IDS_BASEVERTICALCHART:'Base Vertical XY Chart',IDS_BASEMULTIPLECHART:'Base Multiple Chart',IDS_BASEMULTIPLEXYCHART:'Base Multiple XY Chart',IDS_BASESINGLECHART:'Base Single Chart',IDS_HEATMAPCHART:'Heat Map',IDS_MULTIBARCHART:'Multiple Bar Chart',IDS_MULTIBUBBLECHART:'Multiple Bubble Chart',IDS_MULTIDONUTCHART:'Multiple Donut Chart',IDS_MULTIDUALBARCHART:'Multiple Bar Chart with 2 X-Axes',IDS_MULTIDUALHORIZONTALLINECHART:'Multiple Horizontal Line Chart with 2 X-Axes',IDS_MULTIDUALLINECHART:'Multiple Line Chart with 2 Y-Axes',IDS_MULTIDUALPERCENTAGESTACKEDBARCHART:'Multiple 100% Stacked Bar Chart with 2 X-Axes',IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART:'Multiple 100% Stacked Column Chart with 2 Y-Axes',IDS_MULTIDUALSTACKEDBARCHART:'Multiple Stacked Bar Chart with 2 X-Axes',IDS_MULTIDUALSTACKEDVERTICALBARCHART:'Multiple Stacked Column Chart with 2 Y-Axes',IDS_MULTIDUALVERTICALBARCHART:'Multiple Column Chart with 2 Y-Axes',IDS_MULTIHORIZONTALLINECHART:'Multiple Horizontal Line Chart',IDS_MULTILINECHART:'Multiple Line Chart',IDS_MULTIPERCENTAGESTACKEDBARCHART:'Multiple 100% Stacked Bar Chart',IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART:'Multiple 100% Stacked Column Chart',IDS_MULTIPIECHART:'Multiple Pie Chart',IDS_MULTISCATTERCHART:'Multiple Scatter Plot',IDS_MULTISTACKEDBARCHART:'Multiple Stacked Bar Chart',IDS_MULTISTACKEDVERTICALBARCHART:'Multiple Stacked Column Chart',IDS_MULTIVERTICALBARCHART:'Multiple Column Chart',IDS_MULTIRADARCHART:'Multiple Radar Chart',IDS_RADARCHART:'Radar Chart',IDS_SCATTERMATRIXCHART:'Scatter Matrix Chart',IDS_TAGCLOUDCHART:'Tag Cloud',IDS_TREEMAPCHART:'Tree Map (POC)',IDS_GEOBUBBLE:'Geo Bubble Chart',IDS_GEOPIE:'Geo Pie Chart',IDS_CHOROPLETH:'Geo Choropleth Chart',IDS_MULTIGEOBUBBLE:'Multiple Geo Bubble Chart',IDS_MULTICHOROPLETH:'Multiple Geo Choropleth Chart',IDS_REGIONCOLOR:'Region Color',IDS_PRIMARYVALUES:'Primary Values',IDS_SECONDARYVALUES:'Secondary Values',IDS_AXISLABELS:'Axis Labels',IDS_RECTANGLETITLE:'Rectangle Title',IDS_RECTANGLEWEIGHT:'Rectangle Weight',IDS_RECTANGLECOLOR:'Rectangle Color',IDS_TAGNAME:'Tag Name',IDS_TAGWEIGHT:'Tags Weight',IDS_TAGFAMILY:'Tags Family',IDS_CATEGORYAXIS:'Axis Labels Category',IDS_REGIONSHAPE:'Region Shape',IDS_BUBBLEWIDTH:'Bubble Width',IDS_BUBBLEHEIGHT:'Bubble Height',IDS_RADARAXES:'Radar Axes',IDS_RADARAXESVALUE:'Radar Axes Values',IDS_PIESECTORCOLORNAME:'Sector Color',IDS_PIESECTORSIZE:'Sector Size',IDS_MAINLABELAXISNAME:'Main Category Axis',IDS_SECONDARYAXISLABELNAME:'Secondary Category Axis',IDS_SELECTABILITY:'selectability',IDS_PRIMARYVALUECOLORPALETTE:'primaryValuesColorPalette',IDS_SECONDARYVALUESCOLORPALETTE:'secondaryValuesColorPalette',IDS_DRAWINGEFFECT:'drawingEffect',IDS_TOOLTIPVISIBLE:'tooltipVisible',IDS_ENABLEROUNDCORNER:'enableRoundCorner',IDS_ANIMATION:'animation',IDS_DATALOADING:'dataLoading',IDS_DATAUPDATING:'dataUpdating',IDS_BAR:'bar',IDS_LINE:'line',IDS_WIDTH:'width',IDS_HOVERLINEVISIBLE:'hoverlineVisible',IDS_MARKER:'marker',IDS_VISIBLE:'visible',IDS_SHAPE:'shape',IDS_SIZE:'size',IDS_HEADERVISIBLE:'headerVisible',IDS_AXISVISIBLE:'axisVisible',IDS_GRIDVISIBLE:'gridVisible',IDS_COLUMNSEQUENCE:'columnSequence',IDS_COLUMNCONFIG:'columnConfig',IDS_STARTCOLUMN:'startColumn',IDS_LABEL:'label',IDS_VALUEFORMAT:'valueFormat',IDS_ENDCOLUMN:'endColumn',IDS_HIGHCOLUMN:'highColumn',IDS_LOWCOLUMN:'lowColumn',IDS_LINECONFIG:'lineConfig',IDS_MARKERS:'markers',IDS_FILLVISIBLE:'fillVisible',IDS_REFINEVISIBLE:'reflineVisible',IDS_MODE:'mode',IDS_TITLE:'title',IDS_TEXT:'text',IDS_GRIDLINE:'gridline',IDS_SHOWFIRSTLINE:'showFirstLine',IDS_TYPE:'type',IDS_FORMAT:'format',IDS_POSITION:'position',IDS_BORDER:'border',IDS_STARTCOLOR:'startcolor',IDS_ENDCOLOR:'endcolor'};
  var currentId = 'dev', defaultLanguage = 'en';
  var manager = 
    /** @lends sap.viz.lang.langManager */
  {    /**
       * @constructs
       */
      constructor : function(){
        return;
      },
      /**
       * The file paths of language folder. 
       * 
       * @default ["../../../resources/langs/"]
       */
      loadPath : ["../../../resources/langs/"],
       /**
       * Return current applied language Id.
       * 
       * @returns {String}
       */
      current : function() {
          return currentId;
      },
      
      /**
       * Register new language.
       * 
       * @param {Object...}
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      register : function(obj) {
            currentId = obj.id;
          currentLanguage = languageSetting[obj.id] = ObjectUtils.extend(true, languageSetting[obj.id], obj.value);
          return manager;
      },
      
       /**
       * Apply(switch) language.
       * 
       * @param {String}
       *          id the language id
       * @param {Function}
       *          [cb] the call back function. It will be executed after language
       *          is applied successfully with current language as parameter. *
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      apply : function(id, callback) {
        if(id){
          loadResources(manager.loadPath, 0, id, function(){
            onLocaleChanged(callback);
          }, function(){
            loadResources(manager.loadPath, 0, defaultLanguage, function(){
              onLocaleChanged(callback);
              FunctionUtils.error('Loading language {0} failed.', id);
            }, function(){
               currentId = 'dev', currentLanguage = languageSetting['dev'];
               onLocaleChanged(callback);
               FunctionUtils.error('Loading language {0}, {1} failed.', id, defaultLanguage);
            });
            
          });
        }
         return manager;
      },
      
      /**
       * Get globalization value.
       * 
       * @param {String} 
       *       id of labels
       * 
       * @returns {String}  globalization value
       */
      get: function(ids){
        if(currentLanguage[ids])
          return currentLanguage[ids];
        return languageSetting['dev'][ids];
      },
      
      /**
       * Add a listener which will be executed when current language is changed.
       * 
       * @param {Object}
       *          listener
       * @param {Function}
       *          listener.fn the listener function
       * @param {Object}
       *          listener.scope the "this" object in the listener function
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      addListener : function(listener) {
          listeners.push(listener);
          return manager;
       },
       
       /**
       * Remove the listener.
       * 
       * @param {Object} listener
       *          the listener reference
       * 
       * @returns {Object} {@link sap.viz.lang.langManager}
       */
      removeListener : function(listener) {
        var index = listeners.indexOf(listener);
        if (index != -1)
          listeners.splice(index, 1);
        return manager;
      }
  };
  
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
}
],
 function Setup(ObjUtils){
   
   var DataContainer = function(uid){
     this._uId = uid; 
     this._isFake = false;
     this._infos = null;
   };
        
  
   DataContainer.prototype.getId = function(){
           return this._uId;
     };
     
     DataContainer.prototype.fake = function(_){
       if (!arguments.length)
         return this._isFake;
       
       this._isFake = _;
     };
       
     DataContainer.prototype.infos = function(_){
         if (!arguments.length)
           return this._infos;
           
         this._infos = _;
     };

  return DataContainer;
 });sap.riv.module(
{
  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.0'
}
],
function Setup(ObjUtils, DataContainer){
   
  
     var DimensionLabels = ObjUtils.derive(DataContainer, {
      
       /**
          * @name sap.viz.data.description.DimensionLabels
          * @param   uid    identifier of dimension labels, usually name 
        */
      
       constructor : function ( uid, type, values ) {
           this._type = type;
           this._values = values;
       },
       
       getValues : function(){
           return this._values;
         },
         
         getType : function(){
           
           return this._type;
         }
       
    
    });
     
     
     return DimensionLabels;
  });sap.riv.module(
{
  qname : 'sap.viz.data.feed.feed',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
 function Setup(FunctionUtils){
   
   return function(feedId, feedName, type, min, max, aaIndex, acceptMND, mgIndex, maxStackedDims){
     
         var _feedId = feedId;
         var _feedName = feedName;
         var _type = type;
         var _min = min;
         var _max = max;
         var _aaIndex = aaIndex;
         var _acceptMND = acceptMND;
         var _mgIndex = mgIndex;
         var _maxStackedDims = maxStackedDims;
         
         var _data = [];
     
       function feed() {
           
         return feed;
       };
       
       feed.feedId = function(_){  
         if (!arguments.length)
         return _feedId;
        
         _feedId = _;
         
         return feed;
       };
       
       feed.feedName = function(_){
         if (!arguments.length)
         return _feedName;
         
         _feedName = _; 
         
         return feed;
       };
       
       feed.type = function(_){
         if (!arguments.length)
         return _type;
         
        _type = _;
        
        return feed;
       };
       
       feed.min = function(_){    
         if (!arguments.length)
         return _min;
         
         _min =  _;
         return feed;;
       };
       
       feed.max = function(_){
         if (!arguments.length)
         return _max;
         
         _max = _;
         
         return feed; 
       };
       
       feed.analysisAxisIndex = function(_){
         if (!arguments.length)
         return _aaIndex;
         
         _aaIndex = _;
         
         return feed;
       };
      
       feed.measureGroupIndex = function(_){
         if (!arguments.length)
         return _mgIndex;
         
         _mgIndex = _;
         
         return feed;
       };
       
       feed.acceptMND = function(_){
         if (!arguments.length)
         return _acceptMND;
         
         _acceptMND = _;
         
         return feed;
       };
       
       feed.maxStackedDims = function(_){
         if (!arguments.length)
         return _maxStackedDims;
         
         _maxStackedDims = _;
         
         return feed;
       };
       
       feed.data = function(_){
         if (!arguments.length)
           return _data;
         
         _data = _;
         
         return feed;
       };
       
       
       feed.addData = function(_){
         _data.push(_);
         return feed;
       };
       
       feed.getMeasureNames = function(){
         
         var mgIndex  =  _mgIndex - 1;
         var measureNames = [];
         for(var i = 0; i < _data.length; i++){
           measureNames.push({'val':_data[i]['name'],'ctx': {'mg': mgIndex, 'mi': i}});
         }
         
         return measureNames;
       };
       
         feed.getMeasureValues = function(){
         var values = [];
         if(_data.length > 0)
          return _data[0].getMeasureValues();
         
         return values;
           
       };
       
         feed.getMeasureCount = function(){
            return _data.length;
       };
     
       /**
        * @returns check if the feed has been feeded MND
        */
       feed.hasMNDFeeded = function(){
          
          var data = feed.data();
          for(var i = 0; i < data.length; i++){
            if(data[i].getType() == "measureNamesDimension")
             return true;
          }
          
          return false;
       };
       
       feed.hasFeeded = function(){
          return feed.data().length > 0 ?  true : false;
       };
       
       feed.getIndex = function(){
          return feed.analysisAxisIndex() ? feed.analysisAxisIndex() : feed.measureGroupIndex();
       };
       
       feed.getDataCount = function(){
         if(feed.type() == "Dimension")
          return feed.data().length;
         else
          return feed.data().length > 0 ? feed.data()[0].getMeasureValues().length : 0;
       };
       
     return feed;
   };
  
 });sap.riv.module(
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.data.feed.feed',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.0'
}
],
 function Setup(Feed, FunctionUtils, TypeUtils, DimensionLabels){
   
   return function(feedDefs, crossTableDS, feedingInfo){
    
     var FEED_D = 'Dimension';
     var FEED_M = 'Measure';
     
     var FEEDID = "feedId";
     
     var BINDTO = "binding";
     var TYPE = "type";
     var INDEX = "index";
     
     var _aaMap = []; // analysis axis index to feed map, _aamap[0] point to feed of axis 1 
     var _mgMap = []; // measure group index to feed map, _mgMap[0] point to feed of measure value group 1
     var _feeds = [];
     var _feedsMap = {};
     
     var _aaBindingInfo = [];
     
       function feeder() {
         
           return feeder;
       };
       
       feeder.init = function(){
         initFeeds(feedDefs);
         
         //TODO separate validation and init
         if(crossTableDS){
           if(feedingInfo){
             manualFeed(crossTableDS, feedingInfo);
           }else{
             autoFeed(crossTableDS);
           }
           
           feeder.checkValid();
         }
       };
       
       /**
        * @returns {feed}
        */
       feeder.getFeeds = function(){
         return _feeds;
       };
       
       /**
        * @param feedId
        *        feed id
        *        
        * @returns {feed}
        *           undefined if no feed matched
        * 
        */
       feeder.findFeed = function(feedId){
           return _feedsMap[feedId];
       };
       
      
       feeder.getAnalysisAxisIndex = function(feed){
        
         for(var i = 0; i < _aaMap.length; i++){
           if(_aaMap[i] == feed)
            return i;
         }
         
       };
       
       feeder.getMeasureValuesGroupIndex = function(feed){
          
         for(var i = 0; i < _mgMap.length; i++){
           if(_mgMap[i] == feed)
            return i;
         }
         
       };
       
       /**
        * TODO: add description
        */
       feeder.getMeasureValuesGroupFeeds = function(){
        
         return _mgMap;
       };
       
       /**
        * Check if meta data and raw data are matched. If not match, throw exception 
        */
       feeder.checkValid = function(){
         for(var i = 0; i < _feeds.length; i++){
           var feed = _feeds[i];
           if(feed.type() == "Dimension"){
            var dataLength = feed.getDataCount();
            if(dataLength < feed.min() || (feed.max() != Number.POSITIVE_INFINITY && dataLength > feed.max())) 
               FunctionUtils.error(feed.feedId() + ": does not meet min or max number of feed definition");
                
           }else if(feed.type() == "Measure"){
             var dataLength = feed.getDataCount();
             if(dataLength < feed.min() || (feed.max() != Number.POSITIVE_INFINITY && dataLength > feed.max())) 
               FunctionUtils.error(feed.feedId() + ": does not meet min or max number of feed definition");
             
           }else{
             FunctionUtils.error(feed.feedId() + ": wrong feed type");
           }
             
           
         }
         
        
       };
       
       feeder.getBindingInfo = function(){
        
         return _aaBindingInfo;
       };
       
       /**
        * TODO: add desc
        */
       function initFeeds(feedDefinitions){
           if( TypeUtils.isArray(feedDefinitions) ){
             
             var dimensonNumber  = 0;
             
             for(var i = 0; i < feedDefinitions.length; i++){
               
               var feedType = feedDefinitions[i]['type'];
               var aaIndex = feedDefinitions[i]['aaIndex'];
               var feedId = feedDefinitions[i]['id'];
                 
               if(feedType != FEED_D && feedType != FEED_M ){
                 FunctionUtils.error('wrong feed type in feed definition: ' + feedDefinitions[i]['id']); 
               }
               
                if(feedDefinitions[i]['type'] == FEED_D){
                 if(feedDefinitions[i]['aaIndex'] <= 0){
                    FunctionUtils.error('wrong analysis axis index in feed definition: ' + feedDefinitions[i]['id']);
                 }
                 
                 dimensonNumber++;
               }
                
                if(feedDefinitions[i]['type'] == FEED_M){
                 if(feedDefinitions[i]['mgIndex'] <= 0){
                    FunctionUtils.error('wrong  measure axis index in feed definition: ' + feedDefinitions[i]['id']);
                 }
                 
               }
              
               
               var arrayLength = _feeds.push(Feed(feedId, feedDefinitions[i]['name'],
                                         feedType, feedDefinitions[i]['min'],
                                         feedDefinitions[i]['max'], aaIndex,
                                         feedDefinitions[i]['acceptMND'], feedDefinitions[i]['mgIndex'],
                                         feedDefinitions[i]['maxStackedDims']));
               
               _feedsMap[feedId] = _feeds[arrayLength - 1];
               
               }
             
             for(i = 0; i < dimensonNumber; i++){
               _aaBindingInfo[i] = false; 
             }
           }
           
       }
       
             
       function autoFeed(crosstableDS){
         var axes = crosstableDS.getAnalysisAxisCount();
         for(var i = 0; i < axes; i++){
           var feed = searchFeed(_feeds, FEED_D, i + 1);
           if(feed){
             var axis = crosstableDS.getAnalysisAxisByIdx(i);
             if(feed.maxStackedDims() != undefined && axis.getDimensionLabels().length > feed.maxStackedDims())
              FunctionUtils.error("Invalid Feeding: exceed max stacked dimension number " + feed.feedId() + " feed");
             
             
            _aaMap[i] = feed;
            _aaBindingInfo[i] = true;
            feed.addData(axis);
           }
         }
         
         var mvgs = crosstableDS.getMeasureValuesGroupCount();
         for(i = 0; i < mvgs; i++){
           var feed = searchFeed(_feeds, FEED_M, i + 1);
           if(feed){
            _mgMap[i] = feed;
            feed.addData(crosstableDS.getMeasureValuesGroupByIdx(i));
           }
           
         }
       }
       
       function searchFeed(feeds, type, index){
          for(var i = 0; i < feeds.length; i++){
            if(feeds[i].type() == type && feeds[i].getIndex() == index)
             return feeds[i];
          }
      
            return null;
       }
       
       function manualFeed(crosstableDS, feedList){
         for(var i = 0; i < feedList.length; i++){
           var feeding = feedList[i];
           var feedId = feeding[FEEDID];
           if(!feedId)
               FunctionUtils.error("Invalid Feeding: no feed id");
              
           var feed = _feedsMap[feedId];
           if(!feed)
             FunctionUtils.error("Invalid Feeding: no " + feedId + " feed");
           
           var bindings = feeding[BINDTO];
           for(var j = 0; j < bindings.length; j++){
             var type = bindings[j][TYPE];
             var index = bindings[j][INDEX];
             
             if( type == "analysisAxis"){
               var aa =  crosstableDS.getAnalysisAxisByIdx(index - 1);
               if(!aa)
                FunctionUtils.error("could not find axis " + index +  " in data set" + feedId + " feed");
               
               if(feed.maxStackedDims() != undefined && aa.getDimensionLabels().length > feed.maxStackedDims())
                FunctionUtils.error("Invalid Feeding: exceed max stacked dimension number " + feedId + " feed");
               
               var dataLength = feed.getDataCount();
               if(feed.max() != Number.POSITIVE_INFINITY && dataLength >= feed.max())
                FunctionUtils.error(feedId + " feed could not accept more data containers");
               
                 feed.addData(aa);  
                 _aaMap[index - 1] = feed;
                 _aaBindingInfo[feed.getIndex() - 1] = true;
               
             }else if(type == "measureValuesGroup"){
               
               var mvg = crosstableDS.getMeasureValuesGroupByIdx(index - 1);
               if(!mvg)
                 FunctionUtils.error("could not find measure values group " + index +  " in data set" + feedId + " feed");
               
               var dataLength = feed.getDataCount();
               if(feed.max() != Number.POSITIVE_INFINITY && dataLength >= feed.max())
                  FunctionUtils.error(feedId + " feed could not accept more data containers");
               
               feed.addData(mvg);
               _mgMap[index-1] = feed;
               
             }else if(type == "measureNamesDimension"){
               if(feed.acceptMND() < 0)
                FunctionUtils.error("could not accpet MeasureNamesDimension " + feedId + " feed");
               
               var dataLength = feed.getDataCount();
               if(feed.max() != Number.POSITIVE_INFINITY && dataLength >= feed.max())
                  FunctionUtils.error(feedId + " feed could not accept more data containers");
               
               feed.addData(new DimensionLabels("", "measureNamesDimension", ""));
               
             }else{
               FunctionUtils.error("Invalid Binding");
             }
           }
           
         }
         
       }
       
       feeder.init();
       
     return feeder;
   };
   
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(feeder , langManager,Constants) {
  var tooltipDataHandler = function() {
    var _buffer = [];
    
    var my = {};
    
    var defaultString = langManager.get('IDS_ISNOVALUE');
    
    var handleNull = function(_){
      if (_ === null || _ === undefined)
        return defaultString;
      else 
        return _;
    };

    /**
     * 
     * @param data
     * @param seriesData
     * @param aai1
     * @param colorPalette
     * @param shapePalette
     * @param postProcess 
     *       {Function} you can round the data or other thing.
     * @returns TOOD: add desc
     */
    my.generateTooltipData = function(data, seriesData, aai1,
        colorPalette, shapePalette, postProcess) {
      
      var parseFeedsData = function(data) {

        var MNDHandler = mndHandler(data);
        
        var barGroupValue;
        var isStacked = false;
        if(seriesData[aai1][0] !== undefined && seriesData[aai1][0].length > 0){
          barGroupValue = d3.merge([seriesData[aai1][0],seriesData[aai1][1]]);
          isStacked = true;
        }else{
          barGroupValue = seriesData[aai1];
        }

        

            var tooltipData = {
                'body':[],
                'footer':[],
            };
            var valueLength = barGroupValue.length;
            var isDual = false;
            var division = 0;
            if (data.getMeasureValuesGroupDataByIdx(0) && data.getMeasureValuesGroupDataByIdx(1)){
              isDual = true;
              division = data.getMeasureValuesGroupDataByIdx(0).values.length;
            }
            var isMNDbeforeCate = false;
          var MNDLength;

          if (!MNDHandler.hasMNDonCate && ! MNDHandler.hasMNDonColor){
            //MND does not feed on either category or color

            if(data.getAnalysisAxisDataByIdx(1)){
                var measureIndex = 0;
                if (data.getMeasureValuesGroupDataByIdx(0)){
                  for (var i = 0; i < data.getMeasureValuesGroupDataByIdx(0).values.length; ++i){
                    var body = {
                        'name': handleNull(data.getMeasureValuesGroupDataByIdx(0).values[i].col),
                        'val': []
                    };
                    for (var j = 0, len = data.getMeasureValuesGroupDataByIdx(0).values[i].rows.length; j < len; ++j){
                      var valueIndex = measureIndex * len + j;
                      var itemLabel = null;
                      for (var k = 0; k < data.getAnalysisAxisDataByIdx(1).values.length; ++k){
                        itemLabel = itemLabel ? itemLabel + ' / ' + handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val)
                            :handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val);
                      }
                      var item = {
                        'shape': shapePalette[valueIndex % shapePalette.length],
                        'color': colorPalette[valueIndex % colorPalette.length],
                        'label': itemLabel,
                        'value': barGroupValue[valueIndex].val === ' '? defaultString
                            :postProcess == null ? handleNull(barGroupValue[valueIndex].val): postProcess(barGroupValue[valueIndex].val)
                      };
                      body.val.push(item);
                    }
                    tooltipData.body.push(body);
                    ++measureIndex;
                  }
                }
                //for dual chart
                if (data.getMeasureValuesGroupDataByIdx(1)){
                  for (var i = 0; i < data.getMeasureValuesGroupDataByIdx(1).values.length; ++i){
                    var body = {
                        'name': handleNull(data.getMeasureValuesGroupDataByIdx(1).values[i].col),
                        'val': []
                    };
                    for (var j = 0, len = data.getMeasureValuesGroupDataByIdx(1).values[i].rows.length; j < len; ++j){
                      var valueIndex = measureIndex * len + j;
                      var itemLabel = null;
                      for (var k = 0; k < data.getAnalysisAxisDataByIdx(1).values.length; ++k){
                        itemLabel = itemLabel ? itemLabel + ' / ' + handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val)
                            :handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val);
                      }
                      var item = {
                        'shape': shapePalette[valueIndex % shapePalette.length],
                        'color': colorPalette[valueIndex % colorPalette.length],
                        'label': itemLabel,
                        'value': barGroupValue[valueIndex].val === ' '? defaultString
                            :postProcess == null ? handleNull(barGroupValue[valueIndex].val): postProcess(barGroupValue[valueIndex].val)
                      };
                      body.val.push(item);
                    }
                    tooltipData.body.push(body);
                    ++measureIndex;
                  }
                }
            } else {
                var body = {
                    'name': data.getMeasureValuesGroupDataByIdx(0).values[0].col,
                    'val':[]
                };
                var item = {
                'shape': shapePalette[0 % shapePalette.length],
                'color': colorPalette[0 % colorPalette.length],
                'label': null,
                'value': barGroupValue[0].val === ' '? defaultString
                    :postProcess == null ? handleNull(barGroupValue[0].val): postProcess(barGroupValue[0].val)
                };
                body.val.push(item);
                tooltipData.body.push(body);
              }
          for (var i = 0, len = data.getAnalysisAxisDataByIdx(0).values.length; i < len; ++i){
              var footer = {
                  'label': handleNull(data.getAnalysisAxisDataByIdx(0).values[i].col.val),
                  'value': handleNull(data.getAnalysisAxisDataByIdx(0).values[i].rows[aai1].val)
              };
              tooltipData.footer.unshift(footer);
          }
           
          }else if (MNDHandler.hasMNDonColor){
              //MND feeds on color
              for (var i = 0; i < data.getAnalysisAxisDataByIdx(1).values.length; ++i){
                if (data.getAnalysisAxisDataByIdx(1).values[i].type == 'MND'){
                  MNDLength = data.getAnalysisAxisDataByIdx(1).values[i].rows.length;
                  if (i == 0){
                    isMNDbeforeCate = true;
                  }
                  break;
                }
              }

              var measureIndex = 0;
              if (data.getMeasureValuesGroupDataByIdx(0)){
                for (var i = 0; i < data.getMeasureValuesGroupDataByIdx(0).values.length; ++i){
                  var body = {
                      'name': handleNull(data.getMeasureValuesGroupDataByIdx(0).values[i].col),
                      'val': []
                  };
                  for (var j = 0, len = data.getMeasureValuesGroupDataByIdx(0).values[i].rows.length; j < len; ++j){
                    var valueIndex;
                    var colorIndex = undefined;
                    if (isMNDbeforeCate)
                      valueIndex = measureIndex * len + j;
                    else if(!isStacked || !isDual)
                      valueIndex = j * MNDLength + measureIndex;
                    else {
                      valueIndex = j * division + measureIndex;
                      colorIndex = j * MNDLength + measureIndex;
                    }
                    var itemLabel = null;
                    for (var k = 0; k < data.getAnalysisAxisDataByIdx(1).values.length; ++k){
                      if (data.getAnalysisAxisDataByIdx(1).values[k].type != 'MND'){
                        itemLabel = itemLabel ? itemLabel + ' / ' + handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val)
                            :handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val);
                      }
                    }
                    var item = {
                      'shape': colorIndex !== undefined? shapePalette[colorIndex % shapePalette.length]:shapePalette[valueIndex % shapePalette.length],
                      'color': colorIndex !== undefined? colorPalette[colorIndex % colorPalette.length]:colorPalette[valueIndex % colorPalette.length],
                      'label': itemLabel,
                      'value': barGroupValue[valueIndex].val === ' '? defaultString
                          :postProcess == null ? handleNull(barGroupValue[valueIndex].val): postProcess(barGroupValue[valueIndex].val)
                    };
                    body.val.push(item);
                  }
                  tooltipData.body.push(body);
                  ++measureIndex;
                }
              }
              //for dual chart
              if (data.getMeasureValuesGroupDataByIdx(1)){
                for (var i = 0; i < data.getMeasureValuesGroupDataByIdx(1).values.length; ++i){
                  var body = {
                      'name': handleNull(data.getMeasureValuesGroupDataByIdx(1).values[i].col),
                      'val': []
                  };
                  for (var j = 0, len = data.getMeasureValuesGroupDataByIdx(1).values[i].rows.length; j < len; ++j){
                    var valueIndex;
                    var colorIndex = undefined;
                    if (isMNDbeforeCate)
                      valueIndex = measureIndex * len + j;
                    else if(!isStacked || !isDual)
                      valueIndex = j * MNDLength + measureIndex;
                    else {
                      valueIndex = j * (MNDLength - division) + measureIndex - division 
                      + parseInt(valueLength * division / MNDLength);
                      colorIndex = j * MNDLength + measureIndex;
                    }

                    var itemLabel = null;
                    for (var k = 0; k < data.getAnalysisAxisDataByIdx(1).values.length; ++k){
                      if (data.getAnalysisAxisDataByIdx(1).values[k].type != 'MND'){
                        itemLabel = itemLabel ? itemLabel + ' / ' + handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val)
                            :handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val);
                      }
                    }
                    var item = {
                      'shape': colorIndex !== undefined? shapePalette[colorIndex % shapePalette.length]:shapePalette[valueIndex % shapePalette.length],
                      'color': colorIndex !== undefined? colorPalette[colorIndex % colorPalette.length]:colorPalette[valueIndex % colorPalette.length],
                      'label': itemLabel,
                      'value': barGroupValue[valueIndex].val === ' '? defaultString
                          :postProcess == null ? handleNull(barGroupValue[valueIndex].val): postProcess(barGroupValue[valueIndex].val)
                    };
                    body.val.push(item);
                  }
                  tooltipData.body.push(body);
                  ++measureIndex;
                }
              } 
          for (var i = 0, len = data.getAnalysisAxisDataByIdx(0).values.length; i < len; ++i){
              var footer = {
                  'label': handleNull(data.getAnalysisAxisDataByIdx(0).values[i].col.val),
                  'value': handleNull(data.getAnalysisAxisDataByIdx(0).values[i].rows[aai1].val)
              };
              tooltipData.footer.unshift(footer);
          }

            } else {
              //MND feeds on category axis
              var bodyName = null;
              var categoryLength;
              for (var i = 0; i < data.getAnalysisAxisDataByIdx(0).values.length; ++i){
                if (data.getAnalysisAxisDataByIdx(0).values[i].type == 'MND'){
                  MNDLength = data.getAnalysisAxisDataByIdx(0).values[i].rows.length;
                  var groupCount = 0;
                  if (seriesData.length !== undefined){
                    groupCount = seriesData.length;
                  } else {
                    for (var j in seriesData){
                      ++groupCount;
                    }
                  }
                  
                  categoryLength = groupCount / MNDLength;
                  if (i == 0){
                    isMNDbeforeCate = true;
                    bodyName = handleNull(data.getAnalysisAxisDataByIdx(0).values[i].rows[parseInt(aai1 / categoryLength)].val);
                  } else {
//                    isMNDbeforeCate = false;
                    bodyName = handleNull(data.getAnalysisAxisDataByIdx(0).values[i].rows[aai1 % MNDLength].val);
                  }
                  break;
                }
              }
              var body = {
                  'name': bodyName,
                  'val':[]
              };
              
              if (data.getAnalysisAxisDataByIdx(1)){
                //there exists color feeds.
//                var measureIndex = 0;
                if (data.getMeasureValuesGroupDataByIdx(0)){
                  for (var j = 0, len = data.getMeasureValuesGroupDataByIdx(0).values[0].rows.length; j < len; ++j){
                    var valueIndex = j;
                    var itemLabel = null;
                    for (var k = 0; k < data.getAnalysisAxisDataByIdx(1).values.length; ++k){
                      itemLabel = itemLabel ? itemLabel + ' / ' + handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val)
                          :handleNull(data.getAnalysisAxisDataByIdx(1).values[k].rows[j].val);
                    }
                    var item = {
                      'shape': shapePalette[valueIndex % shapePalette.length],
                      'color': colorPalette[valueIndex % colorPalette.length],
                      'label': itemLabel,
                      'value': barGroupValue[valueIndex].val === ' '? defaultString
                          :postProcess == null ? handleNull(barGroupValue[valueIndex].val): postProcess(barGroupValue[valueIndex].val)
                    };
                    body.val.push(item);
                  }
                }
              } else{      
                //otherwise...
                var item = {
                'shape': shapePalette[0 % shapePalette.length],
                'color': colorPalette[0 % colorPalette.length],
                'label': null,
                'value': barGroupValue[0].val === ' '? defaultString
                    :postProcess == null ? handleNull(barGroupValue[0].val): postProcess(barGroupValue[0].val)
                };
                body.val.push(item);
              }
              tooltipData.body.push(body);
          for (var i = 0, len = data.getAnalysisAxisDataByIdx(0).values.length; i < len; ++i){
            if (data.getAnalysisAxisDataByIdx(0).values[i].type != 'MND'){
                var footer = {
                    'label': handleNull(data.getAnalysisAxisDataByIdx(0).values[i].col.val),
                    'value': null
                };              
              if(isMNDbeforeCate){
                footer.value = handleNull(data.getAnalysisAxisDataByIdx(0).values[i].rows[aai1 % categoryLength].val);
              } else {
                footer.value = handleNull(data.getAnalysisAxisDataByIdx(0).values[i].rows[parseInt(aai1 / MNDLength)].val);
              }
                tooltipData.footer.unshift(footer);
            }
          }

            }
          return tooltipData;
      };
      
      var help = function(index) {
        if (_buffer[index] === undefined) {
          _buffer[index] = parseFeedsData(data);
        }
        return _buffer[index];
      };
      
      return help(aai1);
    };
    return my;
  };
  
  function mndHandler(data){
    var hasMNDonCate = false;
    if (data.getAnalysisAxisDataByIdx(0))
      for (var j = 0, len = data.getAnalysisAxisDataByIdx(0).values.length; j < len; ++j)
        if (data.getAnalysisAxisDataByIdx(0).values[j].type && data.getAnalysisAxisDataByIdx(0).values[j].type === 'MND')
          hasMNDonCate = true;
    var hasMNDonColor = false;
    if (!hasMNDonCate) {
      if (data.getAnalysisAxisDataByIdx(1))
        for ( var j = 0, len = data.getAnalysisAxisDataByIdx(1).values.length; j < len; ++j)
          if (data.getAnalysisAxisDataByIdx(1).values[j].type
              && data.getAnalysisAxisDataByIdx(1).values[j].type === 'MND')
            hasMNDonColor = true;
    }
    return {
      hasMNDonCate: hasMNDonCate,
      hasMNDonColor: hasMNDonColor
    };
  }
  
  tooltipDataHandler.formatTooltipData = function (data){
    var tooltipEventData = {
        name: Constants.Module.Event.TooltipShow.name,
        data: data,       
    };
    return tooltipEventData;
  };
  
  tooltipDataHandler.dataTransform = function (obj) {
    var data1 = obj['MG1'];
    var data2 = obj['MG2'];

    var transferredDataSet = [];
    if (obj.hasMND && obj.MNDOnColor && obj.MNDInner) {
      var mg1mnum = 0, mg2mnum = 0, colorAxisDataNum = 0;
      if (obj['MG1Number']) { 
        mg1mnum = obj['MG1Number'];
        colorAxisDataNum = data1.length / mg1mnum;
      }
      if (obj['MG2Number']) {
        mg2mnum = obj['MG2Number'];
        colorAxisDataNum = data2.length / mg2mnum;
      }
      
      for (var i=0; i<colorAxisDataNum; i++) {
        for (var j=0; j<mg1mnum; j++) {
          transferredDataSet.push(data1[i*mg1mnum+j]);
        }
        for (var j=0; j<mg2mnum; j++) {
          transferredDataSet.push(data2[i*mg2mnum+j]);
        }
      }
    } else {
      if (data1) {
        for(var i=0; i<data1.length; i++){
          transferredDataSet.push(data1[i]);
        }
      }
      if (data2) {
        for(i=0; i<data2.length; i++){
          transferredDataSet.push(data2[i]);
        }
      }
    }
    
    
    var stackedBarGroup = [];
    // the number of bar in each group
    var barGroupNumber;
    if (data1.length != 0){
      barGroupNumber =  data1[0].length;
    } else {
      barGroupNumber =  data2[0].length;
    }      
    for(var j=0; j < barGroupNumber; j++){
      var ds = [];
      for(i=0; i< transferredDataSet.length; i++){
        ds.push(transferredDataSet[i][j]);
      }
      stackedBarGroup.push(ds);
    }
   
    return stackedBarGroup;
  };

  return tooltipDataHandler;
});sap.riv.module(
{
  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, FunctionUtils){


   /**
    * @name sap.viz.data.MultiAxesDataAdapter
    * @constructor
      */
   function MultiAxesDataAdapter(bindingInfo){
     this._bindingInfo = bindingInfo;
     this._aa  = [];
     this._mg  = [];
     this._fakeData = false;
     this._dataPointCount = 0;
   }
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#addAnalysisAxis
    * @function
    * @param {Object} aa
    */
   MultiAxesDataAdapter.prototype.addAnalysisAxis = function(aa){
        if(aa)
           this._aa.push(aa);
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#addMeasureValuesGroup
    * @function 
    * @param {Object} mg
    */
   MultiAxesDataAdapter.prototype.addMeasureValuesGroup = function(mg){
        if(mg)
          this._mg.push(mg);
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#getAnalysisAxisDataByIdx
    * @function 
    * @param {Object} index
    */
   MultiAxesDataAdapter.prototype.getAnalysisAxisDataByIdx = function(idx){
     if(!arguments.length)
      return this._aa;
     
     for(var i = 0; i < this._aa.length; i++){
       if(this._aa[i].index == idx)
        return this._aa[i];
     }
     
     return null;
   };
   
   /**
    * @name sap.viz.data.MultiAxesDataAdapter#getMeasureValuesGroupDataByIdx
    * @function 
    * @param {Object} index
    */
   MultiAxesDataAdapter.prototype.getMeasureValuesGroupDataByIdx = function(idx){
     if(!arguments.length)
      return this._mg;
     
     for(var i = 0; i < this._mg.length; i++){
       if(this._mg[i].index == idx)
        return this._mg[i];
     }
     
     return null;
   };
   
   MultiAxesDataAdapter.prototype.createDataAdapterForModule = function(ctx){
     
      var subDataAdapter = new MultiAxesDataAdapter();
      if(ctx && ctx.aa){
        for(var i = 0; i < ctx.aa.length; i++){
          var aa = this.getAnalysisAxisDataByIdx(ctx.aa[i] - 1);
          if(aa)
             subDataAdapter.addAnalysisAxis({index:i, values: aa.values});
        } 
      }
      
      if(ctx && ctx.mg){
        for(var i = 0; i < ctx.mg.length; i++){
          var mg = this.getMeasureValuesGroupDataByIdx(ctx.mg[i] - 1);
          if(mg)
             subDataAdapter.addMeasureValuesGroup({index: i, values: mg.values});
        }
      }
      
      return subDataAdapter;
     
   };
   
   MultiAxesDataAdapter.prototype.getBindingInfo = function(){
        return this._bindingInfo;
   };
   
   MultiAxesDataAdapter.prototype.fakeData = function(_){
     if (!arguments.length)
       return this._fakeData;
     
     this._fakeData = _;
   };
   

   MultiAxesDataAdapter.prototype.dataPointCount = function(_){
     if (!arguments.length)
       return this._dataPointCount;
     
     this._dataPointCount = _;
   };
   
   return MultiAxesDataAdapter;
   
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'},
[

],
function Setup() 
{

  return function(data) 
  {
    var dataset1;
    var dataset2;
    var hasMND = false;
    var bMNDOnColor = true;
    var bMNDInner = false; 
    var bDualAxis = false;
    var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
    var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
    var regionColorFeed = data.getAnalysisAxisDataByIdx(1);
    var categoryFeed = data.getAnalysisAxisDataByIdx(0);

    if((measureFeed2 && measureFeed2.values && measureFeed2.values.length > 0))
    {
      bDualAxis = true;
    }
    if(categoryFeed && categoryFeed.values && categoryFeed.values.length > 0)
    {
      if (categoryFeed.values[0].type == 'MND')
      {
        hasMND = true;
        bMNDOnColor = false;
        bMNDInner = false;
      }else if(categoryFeed.values[categoryFeed.values.length - 1].type == 'MND')
      {
        hasMND = true;
        bMNDOnColor = false;
        bMNDInner = true;
      }
    }

    if(regionColorFeed && regionColorFeed.values && regionColorFeed.values.length > 0)
    {
      if(regionColorFeed.values[0].type == 'MND')
      {
        hasMND = true;
        bMNDInner = false;
      }else if(regionColorFeed.values[regionColorFeed.values.length - 1].type == 'MND')
      {
        hasMND = true;
        bMNDInner = true;
      }
    }

    // MND on axis label
    function processOneAxisValue(feed)
    {
      var dataset = [];
      if (feed.values.length <= 0)
        return dataset;

      if (hasMND && !bMNDOnColor)
      {
        for(var j = 0; j < feed.values[0].rows.length; ++j)
        {    
          var measureData = new Array(feed.values.length * feed.values[0].rows[0].length);
          for(var k = 0; k < feed.values[0].rows[0].length; ++k)
          {
            for(var i = 0 ; i < feed.values.length; ++i)
            {
              var dataPoint = {};
              dataPoint.val = feed.values[i].rows[j][k].val;
              dataPoint.ctx = feed.values[i].rows[j][k].ctx;
              if(bMNDInner)
                measureData[k * feed.values.length + i] = dataPoint;
              else
                measureData[i * feed.values[0].rows[0].length + k] = dataPoint; 
            }
          }
          dataset.push(measureData);
        }  
      }
      else // MND on Region color or no MND
      {
        dataset = new Array(feed.values.length * feed.values[0].rows.length);

        for(var i = 0 ; i < feed.values.length; ++i)
        {
          for(var j = 0; j < feed.values[0].rows.length; ++j)
          {    
            var measureData = feed.values[i].rows[j];
            if(!hasMND || !bMNDInner)
              dataset[i * feed.values[0].rows.length + j] = measureData;
            else
              dataset[j * feed.values.length + i] = measureData;
          }
        }
      }

      return dataset;
    };

    function addOneMeasure(dataset, measure)
    {
      for(var i = 0; i < measure.length; ++i)
      {
        dataset[i] = dataset[i].concat(measure[i]);
      }
    }

    function mergeTwoAxis(result)
    {
      var colors = [];
      var measure1Num = measureFeed1.values.length;
      var measure2Num = measureFeed2.values.length;
      var columnNum  = measureFeed1.values[0].rows[0].length;
      dataset = new Array(measureFeed1.values[0].rows.length); 
      var curColumn = 0;
      for(var i = 0; i < dataset.length; ++i)
        dataset[i] = [];
      if(bMNDInner){
        var rowNum = measureFeed1.values[0].rows.length;
        for(var i = 0; i < columnNum; ++i)
        {

          for(var j = 0; j < measure1Num; ++j)
          {
            for(var k = 0; k < rowNum; ++k)
              dataset[k][curColumn] = measureFeed1.values[j].rows[k][i];
            colors[curColumn] = 0;
            ++curColumn;
          }
          for(var j = 0; j < measure2Num; ++j)
          {
            for(var k = 0; k < rowNum; ++k)
              dataset[k][curColumn] = measureFeed2.values[j].rows[k][i];
            colors[curColumn] = 1;
            ++curColumn;
          }
        }
      }else{
        for(var i = 0; i < measure1Num; ++i)
        {
          for(var j = 0; j < columnNum; ++j)
          {
            colors[curColumn++] = 0; 
          }
          addOneMeasure(dataset, measureFeed1.values[i].rows);
        }
        for(var i = 0; i < measure2Num; ++i)
        {
          for(var j = 0; j < columnNum; ++j)
          {
            colors[curColumn++] = 1; 
          }
          addOneMeasure(dataset, measureFeed2.values[i].rows);
        }
      }
      result['MG1'] = dataset;
      result["MG1Number"] = measureFeed1.values.length;
      result['color'] = colors;
    };

    var result = {};

    if(bDualAxis && !bMNDOnColor)
    {
      mergeTwoAxis(result);
    }else{
      dataset1 = processOneAxisValue(measureFeed1);
      result["MG1Number"] = measureFeed1.values.length;
      if(bDualAxis){
        dataset2 = processOneAxisValue(measureFeed2);
        result["MG2Number"] = measureFeed2.values.length;
      }
      result["MG1"] = dataset1;
      result["MG2"] = dataset2;
    }
    result["hasMND"] = hasMND;
    result["MNDOnColor"] = bMNDOnColor;
    result['MNDInner'] = bMNDInner;
    return result;

  };
});sap.riv.module(
{
  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(constants) {
    var ColorSeriesGenerator = {
      /**
       * return d3 ordinal scale of sap standard color palette 
       */
      sap32 : function(){
      return d3.scale.ordinal().range(constants.SAPColorSingleAxis);
      },
      sap32dualaxis1 : function(){
            return d3.scale.ordinal().range(constants.SAPColorDualAxis1);
        },
        sap32dualaxis2 : function(){
            return d3.scale.ordinal().range(constants.SAPColorDualAxis2);
        },      
    }

    return ColorSeriesGenerator;
});sap.riv.module(
{
  qname : 'sap.viz.manifest',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, FunctionUtils, ObjectUtils) {
  /**
   * <pre>
   * Manifest is an internal collection to store all definitions/configurations.
   * There are three built-in categories:
   *      feeds: store definitions of all feed groups
   *      module: store definitions of all modules
   *      viz: store definitions of all charts
   * </pre>
   * @module sap.viz.manifest
   * @example
   * 
   * var Manifest = sap.viz.manifest;
   * @ignore
   */
  
  var manifest = {};
  /**
   * <pre>
   * register a new category in manifest.
   * Once a category is registered, you can access it by Manifest[name] or Manifest.name
   * </pre>
   * @method sap.viz.manifest#registerCategory
   * @param {String}name name of the new category
   * @param {Function} factory optional and if provided,it will become "item factory function" of this category
   * @param {Object} factoryThisObj optional and if provided, it will become the object executed by item factory function
   * @returns {[Object] category} the new category {link sap.viz.manifest.xxxcategory} 
   * @example
   * manifest.registerCategory("feeds", function(obj) {
   *
   * var feeds = {};
   *  obj.feeds.forEach(function(o) {
   *    feeds[o.id] = o;
   *  });
   *
   * Object.defineProperty(obj, "feedsMap", {
   *    value : feeds,
   *    writable : false,
   *    enumerable : false,
   *    configurable : false
   *  });
   *
   *  return obj;
   * });
   * @ignore
   */
  manifest.registerCategory = function(name, factory, factoryThisObj) {
    if (!TypeUtils.isNonEmptyString(name))
      FunctionUtils.error("The category name must be a non-empty string.");

    if (factory && !TypeUtils.isFunction(factory))
      FunctionUtils.error("The category factory must be a function.");

    if (manifest.hasOwnProperty(name))
      FunctionUtils.error("There is already a category named \"{0}\"", name);

    var collection = d3.map();
    /**
     * xxx represents feeds, module and viz. The three categories have been registered into manifest and could provide some common APIs. 
     * @class sap.viz.manifest.xxx
     * @ignore
     */
    var category = {
        /**
           * Load an item from category by id.</br>
           * </br>
           * If the item is a Built-in_Manifest_Objects, it will provide some other APIs.Please see the corresponding object in Built-in_Manifest_Objects.</br>
           * @see Built-in_Manifest_Objects
           * @method sap.viz.manifest.xxx#get
           * @param {String} id the id of item
           * @param {Object} throwErrorIfNull optional, a exception type
           * @returns {Object} the item loaded from category by id
           * @example
           * 
           * var moduleFeeds =  manifest.feeds.get(id);//xxx represents feeds
           * var barModule = manifest.module.get(barId);//xxx represents module
           * var lineChart = manifest.viz.get(lineChartId);//xxx represents viz
           * @ignore
           */
      get : function(id, throwErrorIfNull) {
        var result = collection.get(id);
        if (result === undefined && throwErrorIfNull)
          FunctionUtils.error("Cannot find \"{0}\" in category \"{1}\"", id,
              name);
        return result;
      },
      /**
       * <pre>
       * Iterate whole category execute callback function for every item which has been registered into xxx. 
       * </pre>
       * @method sap.viz.manifest.xxx#each
       * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
       * @param {Object} thisObj optional and default value is obj self
       * @return {Object} manifest
       * @example
       * 
       * manifest.xxx.each(function(obj, id){
       *   .... 
       * });
       * @ignore
       */
      each : function(callback, thisObj) {
        collection.forEach(function(id, obj) {
          callback.call(thisObj, obj, id);
        });
        return manifest;
      },
      /**
       * Register an item into category
       * @method sap.viz.manifest.xxx#register 
       * @param {Object} newItems variable parameters, at least need one item to be registered into category
       * @return {Object} manifest
       * @example
       * 
       * manifest.viz.register(chartOne);//xxx represents viz
       * ....
       * manifest.viz.register(chartOne,chartTwo,chartThree);
       * ....
       * manifest.module.register(tooltip);//xxx represents module
       * @ignore
       */
      register : function() {
        Array.prototype.forEach.call(arguments, function(obj) {
          if (TypeUtils.isUndefined(obj))
            FunctionUtils.error("Cannot register a undefined object.");

          var idStr = obj.id;

          if (!TypeUtils.isNonEmptyString(idStr))
            FunctionUtils.error("Cannot register without a valid id.");

          if (collection.has(idStr))
            FunctionUtils.error(
                "There is already an item named \"{0}\" in category \"{1}\".",
                idStr, name);

          var isAbstract = obj["abstract"] === true;
          obj = ObjectUtils.extend(true, null, obj.base != null ? category.get(
              obj.base, true) : null, obj);

          Object.defineProperty(obj, "abstract", {
            value : isAbstract,
            enumerable : false
          });

          if (factory && !isAbstract)
            factory.call(factoryThisObj, obj, manifest);

          collection.set(idStr, obj);
        });

        return manifest;
      }
    };

    manifest[name] = category;
    return category;
  };
  /**
   * {@link sap.viz.manifest.feeds} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.feeds
   */
  /**
  * Load an item from {@link sap.viz.manifest.feeds}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.feeds} will provide some API.</br>
  * @method sap.viz.manifest.feeds#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.feedsManifest}
  * @example
  * 
  * var moduleFeeds =  manifest.feeds.get(id);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.feeds} category execute callback function for every item which has been registered into {@link sap.viz.manifest.feeds}. 
  * 
  * @method sap.viz.manifest.feeds#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.feeds}
  * @example
  * 
  * manifest.feeds.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.feeds} category
   * @method sap.viz.manifest.feeds#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.feeds}
   * @example
   * 
   * manifest.feeds.register(chartOneFeeds);
   * manifest.feeds.register(chartTwoFeeds,chartThreeFeeds);
   */

   /**
   * {@link sap.viz.manifest.viz} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.viz
   */
  /**
  * Load an item from {@link sap.viz.manifest.viz}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.viz} will provide some API.</br>
  * @method sap.viz.manifest.viz#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.vizManifest}
  * @example
  * 
  * var lineChart =  manifest.viz.get(lineChartId);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.viz} category execute callback function for every item which has been registered into {@link sap.viz.manifest.viz}. 
  * 
  * @method sap.viz.manifest.viz#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.viz}
  * @example
  * 
  * manifest.viz.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.viz} category
   * @method sap.viz.manifest.viz#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.viz}
   * @example
   * 
   * manifest.viz.register(lineChart);
   * manifest.viz.register(pieChart,radarChart);
   */

   /**
   * {@link sap.viz.manifest.module} is a category which have been registered into manifest. It could provide some common APIs. 
   * @class sap.viz.manifest.module
   */
  /**
  * Load an item from {@link sap.viz.manifest.module}  by id.</br>
  * </br>
  * The item loaded from {@link sap.viz.manifest.module} will provide some API.</br>
  * @method sap.viz.manifest.module#get
  * @param {String} id the id of item
  * @param {Object} throwErrorIfNull optional, a exception type
    * @returns {Object} {@link Built-in_Manifest_Objects.moduleManifest}
  * @example
  * 
  * var lineModule =  manifest.viz.get(lineModuleId);
  */
  /**
  * 
    * Iterate whole {@link sap.viz.manifest.module} category execute callback function for every item which has been registered into {@link sap.viz.manifest.module}. 
  * 
  * @method sap.viz.manifest.module#each
  * @param {Function} callback a callback function will be executed for every item.This function must accept two parameters.The first one is an object and the second one is the id.
  * @param {Object} thisObj optional and default value is obj self
  * @return {Object} {@link sap.viz.manifest.module}
  * @example
  * 
  * manifest.module.each(function(obj, id){
  *   .... 
  * });
  */
  /**
   * Register an item into {@link sap.viz.manifest.module} category
   * @method sap.viz.manifest.module#register 
   * @param {Object} newItems variable parameters, at least need one item to be registered into category
   * @return {Object} {@link sap.viz.manifest.module}
   * @example
   * 
   * manifest.module.register(lineModule);
   * manifest.module.register(pieModule,radarModule);
   */
  return manifest;
});sap.riv.module(
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0',
  exported : true
},
[

],
function Setup() {
  return d3.dispatch;
});sap.riv.module(
{
  qname : 'sap.viz.modules.combination',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(dispatch, Manifest, ColorSeries, MNDHandler, TypeUtils, ObjUtils, MultiAxesDataAdapter, TooltipDataHandler, Scaler, NumberUtils) {
  var combination = function(manifest) {
    function module(selection) {
      _tooltipDataHandler = TooltipDataHandler();
      selection.each(
        function(inputData) {
          if (inputData !== undefined) {
            prepareData(inputData);
          }
          _d3root = d3.select(this);
          
          redraw();
        }
      );//each
      return module;
    }

    /**
     * set/get width
     */
    module.width = function(_) {
      if (!arguments.length)
        return _width;
      _width =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata))
        computeScales();
      return module;
    };
    /**
     * set/get height
     */
    module.height = function(_) {
      if (!arguments.length)
        return _height;
      _height =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata))
        computeScales();
      return module;
    };
    /**
     * set/get size
     * 
     * @param {Object}
     *            {'width':Num, 'height':Num}
     */
    module.size = function(_) {
      if (!arguments.length)
        return {
          width : _width,
          height: _height
        };
      _width = _.width;
      _height = _.height;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata))
        computeScales();
      return module;
    };

    /**
     * set/get properties
     */
    module.properties = function(_) {
      if (!arguments.length)
        return getProperty();
      _props = setProperty(manifest.props(_));
      prepareColor();
      return module;
    };

    /**
     * set/get data
     */
    module.data = function(_) {
      if (!arguments.length)
        return _rawdata;
        prepareData(_);
      return module;
    };

    module.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      module.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };

    /**
     * set/get effect manager
     */
    module.effectManager = function(_){
        if (!arguments.length){
            return _effectManager;
       }
          
        _effectManager = _;
        
       return module;        
    };
     
      module.dispatch = function(_){
        if(!arguments.length)
          return _eDispatch;
        _eDispatch = _;
        return module;
      };

      module.primaryScale = function(scale)
      {
        if(!arguments.length)
        {
          return _valueAxis1.scale;
        }
        _valueAxis1.scale = scale;
        return module;
      };
      
      module.secondaryScale = function(scale)
      {
        if(!arguments.length)
        {
          return _valueAxis2.scale;
        }
        _valueAxis2.scale = scale;
        return module;
      };
      
      module.categoryScale = function(scale)
      {
        if(!arguments.length)
        {
          return _xScale;
        }
        _xScale = scale;
        return module;
      };
    
    module.primaryAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.primaryValuesColorPalette[0];
      } else {
        return null;
      }
    };
    
    module.secondAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.secondaryValuesColorPalette[0];
      } else {
        return null;
      }
    };

      module.colorPalette = function(Palette){
        if (!arguments.length){
          return _colorPalette;
         }
         return module;
      };

      module.shapePalette = function(Palette){
        if (!arguments.length){
          return _shapePalette;
         }
         return module;
      };

    module.parent = function () {
      return _d3root;
    };
    
    module.clear = function (gray) {
      for (var i in _module)
      {
        if (gray == null) {
          _module[i].module.clear();
        } else {
          _module[i].module.clear('grayall');
        }
      }
    };

    module.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      if (elementArray.length == 0) {
        return;
      }
      for (var i in _module) {
        _module[i].highlightArray = [];
      }

      for (var i in elementArray) {
        var element = elementArray[i];
        for (var j in _module) {
          var dpa = _module[j].dataPointElements;
          if (isExist(dpa, element)) {
            _module[j].highlightArray.push(element);
            break;
          }
        }
      }

      for (var i in _module) {
        _module[i].module.highlight(_module[i].highlightArray);
      }
    };

    module.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements
      } else {
        elementArray = [];
        elementArray.push(elements);
      }    
      for (var i in _module) {
        _module[i].unhighlightArray = [];
      }

      for (var i in elementArray) {
        var element = elementArray[i];
        for (var j in _module) {
          var dpa = _module[j].dataPointElements;
          if (isExist(dpa, element)) {
            _module[j].unhighlightArray.push(element);
            break;
          }
        }
      }
      
      for (var i in _module) {
        _module[i].module.unhighlight(_module[i].unhighlightArray);
      }      
    };
    
    module.hoverOnPoint = function( point ) {
      if (_props.tooltip.enabled) {
        var point0= point.x, point1 = point.y;
  
        if(point0 < 0 || point0 > _width)
          return;

        var xIndex = getCategoryIndex(point0);
        if(_preMouseMoveXIndex == xIndex)
          return;

        _preMouseMoveXIndex = xIndex;

        var tData = _tooltipDataHandler.generateTooltipData(_rawdata, 
                                   _tooltipdata, 
                                   xIndex, 
                                   _colorPalette, 
                                   _shapePalette);
        var matrix = _d3root.node().getTransformToElement(_d3root.node().ownerSVGElement);                                   
        tData.point = {
            x: _xScale.rangeBand()*(xIndex + 0.5) + matrix.e,
            y: _height / 4 + matrix.f
        };
        _eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
      
      for (var i in _module) {
        _module[i].module.hoverOnPoint(point);
      }
      return true;
    };

    module.blurOut = function( ) {
      if (_props.tooltip.enabled) {
        _eDispatch.hideTooltip();
        _preMouseMoveXIndex = -1;
      }
      for (var i in _module) {
        _module[i].module.blurOut();
      }      
      return true;
    };  

      var _xScale = d3.scale.ordinal(),
        _valueAxis1 = {
        scale: d3.scale.linear()
      },
      _valueAxis2 = {
        scale: d3.scale.linear()
      };

    
    //private field
    var _tooltipDataHandler;
    var _eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    //property
    var _width, _height;
    var _props = {
      measureMapY1: ['verticalbar', 'line', 'line'],
      measureMapY2: ['line', 'line', 'line'],
      priorityMap : {
        'stackedverticalbar' : 6,
        'verticalbar' : 5,
        'line' : 0
      },
      defaultModuleType : 'line',
      tooltip : { enabled : true}, 
      MNDOnCategory : false,
      MNDInner : false,
    }
    var _effectManager;
    //data
    var _rawdata, _tooltipdata;
    var _d3root;
    var _colorPalette, _shapePalette;
    
    //module
    var _module;

    var _preMouseMoveXIndex = -1;

    var dummyDispatch = function (_) {
      this.mtype = _;
    };
    dummyDispatch.prototype.initialized = function() {
      _dummyDispatchHelper.initialized(this.mtype);
    };

    var _dummyDispatchHelper = {
      initialized : function(mtype) {
        _module[mtype].isCompleteAnimation = true;
        for (var i in _module) {
          if (!_module[i].isCompleteAnimation)
            return true;
        }
        _eDispatch.initialized();
        return true;
      }
    };

    setProperty(manifest.props(null));
    return module;

    function init() {
      _module = {};
    }
    function prepareData ( rawdata ) {
      if ((rawdata === undefined) || (_rawdata == rawdata))
        return;
      
      init();
      _rawdata = rawdata;

        var obj = MNDHandler(_rawdata );
      _props.MNDInner = obj.MNDInner;
      _valueAxis1.data = obj['MG1'];
      _valueAxis2.data = obj['MG2'];
      _tooltipdata = TooltipDataHandler.dataTransform(obj);

      if (obj.color) {
        var tempData = obj['MG1'];
        var data0 = [];
        var data1 = [];
        for (var i=0; i<tempData.length; i++) {
          var temp0 = [];
          var temp1 = [];
          var temp = tempData[i];
          for (var j=0; j<temp.length; j++) {
            if (obj.color[j] == 0) {
              temp0.push(temp[j]);
            } else if (obj.color[j] == 1) {
              temp1.push(temp[j]);
            }
          }
          data0.push(temp0);
          data1.push(temp1);
        }
        _valueAxis1.data = data0;
        _valueAxis2.data = data1;
      }
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata))
        computeScales();

      if (obj.hasMND && !obj.MNDOnColor) {
        var mtype = _props.measureMapY1[0];
        if (mtype === undefined) {
          mtype = _props.defaultModuleType;
        }
        if (_module[mtype] === undefined) {
          _module[mtype] = {};
        }
        _module[mtype].data = _rawdata;
        _props.MNDOnCategory = true;
      } else {
        _props.MNDOnCategory = false;
        var daa1 = _rawdata.getAnalysisAxisDataByIdx(0);
        var daa2 = _rawdata.getAnalysisAxisDataByIdx(1);
        var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        for (var i=0; i<dva1.values.length; i++) {
          var mtype = _props.measureMapY1[i];
          if (mtype === undefined) {
            mtype = _props.defaultModuleType;
          }
          if (_module[mtype] === undefined) {
            _module[mtype] = {m1Num:0, m2Num:0};
          }
          var tm = _module[mtype];
          tm.m1Num ++;
          if (tm.data === undefined) {
            tm.data = new MultiAxesDataAdapter();
            tm.data.addAnalysisAxis(daa1);
            tm.data.addAnalysisAxis(daa2);
            tm.data.addMeasureValuesGroup({
              index: dva1.index,
              values: []
            });
            if (dva2) {
              tm.data.addMeasureValuesGroup({
                index: dva2.index,
                values: []
              });
            }
          }
          var tva1 = tm.data.getMeasureValuesGroupDataByIdx(0);
          tva1.values.push(dva1.values[i]);
        }
        
        if (dva2) {
          for (var i=0; i<dva2.values.length; i++) {
            var mtype = _props.measureMapY2[i];
            if (mtype === undefined) {
              mtype = _props.defaultModuleType;
            }
            if (_module[mtype] === undefined) {
              _module[mtype] = {m1Num:0, m2Num:0};
            }
            var tm = _module[mtype];
            tm.m2Num ++;
            if (tm.data === undefined) {
              tm.data = new MultiAxesDataAdapter();
              tm.data.addAnalysisAxis(daa1);
              tm.data.addAnalysisAxis(daa2);
              tm.data.addMeasureValuesGroup({
                index: dva1.index,
                values: []
              });
              if (dva2) {
                tm.data.addMeasureValuesGroup({
                  index: dva2.index,
                  values: []
                });
              }
            }
            var tva2 = tm.data.getMeasureValuesGroupDataByIdx(1);
            tva2.values.push(dva2.values[i]);
          }
        }
      }
      prepareColor();
    }
    
    function prepareColor() {
      if (_rawdata === undefined) return;
      
      var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
      var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
      var valueAxis1ColorPalette;
      var valueAxis2ColorPalette;

      if (dva2 && !_props.MNDOnCategory) {
        valueAxis1ColorPalette = _props.primaryValuesColorPalette;  
      }else{
        valueAxis1ColorPalette = _props.colorPalette;
      }
      
      valueAxis2ColorPalette = _props.secondaryValuesColorPalette;
      
      _colorPalette = [];
      _shapePalette = [];
      for (var i in _module) {
          _module[i].colorPaletteY1 = [];
        _module[i].currentM1Index = -1;
        if (dva2) {
          _module[i].colorPaletteY2 = [];
          _module[i].currentM2Index = -1;
        }
      }
      
      if (_props.MNDOnCategory) {
        var mtype = _props.measureMapY1[0];
        var rowslength = dva1.values[0].rows.length;
        for (var x=0; x<rowslength; x++) {
          _module[mtype].colorPaletteY1.push(valueAxis1ColorPalette[(x) % valueAxis1ColorPalette.length]);
          _shapePalette.push(getShape(mtype));
          _colorPalette.push(valueAxis1ColorPalette[(x) % valueAxis1ColorPalette.length]);
        }
      } else {
        var measure1Num = dva1.values.length;
        var measure2Num = 0;
        if (dva2) {
          measure2Num = dva2.values.length;
        }
        var measureNum = measure1Num + measure2Num;
        var colorAxisDataNum = dva1.values[0].rows.length;
        for (var i=0; i<measure1Num; i++) {
          var mtype = _props.measureMapY1[i];
          if (mtype === undefined) {
            mtype = _props.defaultModuleType;
          }
          var tm = _module[mtype];
          tm.currentM1Index ++;
          for (var x=0; x<colorAxisDataNum; x++) {
            if (_props.MNDInner) {
              var color = valueAxis1ColorPalette[(i+x*measure1Num ) % valueAxis1ColorPalette.length];
              tm.colorPaletteY1[tm.currentM1Index+x*tm.m1Num] = color;
              _shapePalette[i+x*measureNum] = getShape(mtype);
              _colorPalette[i+x*measureNum] = color;
            } else {
              var color = valueAxis1ColorPalette[(i*colorAxisDataNum+x) % valueAxis1ColorPalette.length];
              _module[mtype].colorPaletteY1.push(color);
              _shapePalette.push(getShape(mtype));
              _colorPalette.push(color);
            }
          }
        }

        if (dva2) {
          for (var i=0; i<measure2Num; i++) {
            var mtype = _props.measureMapY2[i];
            if (mtype === undefined) {
              mtype = _props.defaultModuleType;
            }
            var tm = _module[mtype];
            tm.currentM2Index ++;
            for (var x=0; x<colorAxisDataNum; x++) {
              if (_props.MNDInner) {
                var color = valueAxis2ColorPalette[(i+x*measure2Num ) % valueAxis2ColorPalette.length];
                tm.colorPaletteY2[tm.currentM2Index+x*tm.m2Num] = color;
                _shapePalette[measure1Num+i+x*measureNum] = getShape(mtype);
                _colorPalette[measure1Num+i+x*measureNum] = color;
              } else {
                var color = valueAxis2ColorPalette[(i*colorAxisDataNum+x) % valueAxis2ColorPalette.length];
                _module[mtype].colorPaletteY2.push(color);
                _shapePalette.push(getShape(mtype));
                _colorPalette.push(color);
              }
            }
          }
        }
      } // _props.MNDOnCategory
    }
    function moduleSortHelp(a, b) {
      return (_props.priorityMap[b] - _props.priorityMap[a]);
    }
    function prepareModule() {
      var tempA = [];
      for (var i in _module) {
        tempA.push(i);
      }
      tempA.sort(moduleSortHelp);
      _d3root.selectAll('.module').remove(); //TODO: should not always remove all
      var d3modules = _d3root.selectAll('.module').data(tempA);
      d3modules.enter().append('svg:g').attr('class', 'module');
      d3modules.exit().remove();
      
      d3modules.each(function(d) {
        _module[d].d3root = d3.select(this);
      });
      
      for (var i in _module) {
        _module[i].module = getModule(i); //TODO: should not always new module instance
        var props = {
          colorPalette: _module[i].colorPaletteY1,
          primaryValuesColorPalette : _module[i].colorPaletteY1,
          tooltip : {enabled : false},
          animation : { 'dataLoading' : _props.animation.dataLoading },
          drawingEffect: _props.drawingEffect
        };
        if (_module[i].colorPaletteY2) {
          props.secondaryValuesColorPalette = _module[i].colorPaletteY2;
        }
        switch (i) {
        case 'line' :
          props.hoverline = { visible : false };
          ObjUtils.extend(props, _props.line);
          break;
        case 'verticalbar' :
        case 'stackedverticalbar' :
          props.animation.dataUpdating = _props.animation.dataLoading; 
          ObjUtils.extend(props, _props.bar);
          break;
        default :
          break;
        }

        _module[i].props = props;
        _module[i].module.dispatch(new dummyDispatch(i));
        _module[i].module.effectManager(_effectManager);
      }
    }

    function redraw() {
      prepareModule();

      for (var i in _module) {
        var m = _module[i];
        m.module.width(_width).height(_height).data(m.data)
            .properties(m.props).primaryScale(_valueAxis1.scale)
            .categoryScale(_xScale);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        if (dva2) {
          switch(i) {
          case 'verticalbar' :
          case 'stackedverticalbar' :
            m.module.secondScale(_valueAxis2.scale); break;
          case 'line' :
          default:
            m.module.secondaryScale(_valueAxis2.scale); break;
          }
        }
        m.d3root.call(m.module);
        m.dataPointElements = [];
        m.d3root.selectAll('.datapoint').each(function(){m.dataPointElements.push(this)});
      }
    }

    function getCategoryIndex(val)
    {
      var index = val / _xScale.rangeBand();
      index = Math.floor(index);
      return index;
    }

      function computeScales() {
      var domain = [];
      var categoryNum = 0;
      if (_props.MNDOnCategory) {
        if (_valueAxis1.data && _valueAxis1.data.length > 0) {
          categoryNum += _valueAxis1.data[0].length;
        }
        if (_valueAxis2.data && _valueAxis2.data.length > 0) {
          categoryNum += _valueAxis2.data[0].length;
        }        
      } else {
        if (_valueAxis1.data && _valueAxis1.data.length > 0) {
          categoryNum = _valueAxis1.data[0].length;
        } else {
          categoryNum = _valueAxis2.data[0].length;  
        }
      }
      for (var i=0; i < categoryNum; i++) {
         domain.push(i);
      }      
        _xScale.domain(domain).rangeBands([0, _width]);

        calculateScale(_valueAxis1, _valueAxis1.scale);
      calculateScale(_valueAxis2, _valueAxis2.scale);
      if (_valueAxis1.data && _valueAxis1.data.length > 0 &&
        _valueAxis2.data && _valueAxis2.data.length > 0) {
        Scaler.perfectDual(_valueAxis1.scale, _valueAxis2.scale);
      }
      }

    function calculateScale(axisValue, scale) {
        if(axisValue.data && axisValue.data.length > 0) {
        if(axisValue.topValue == null) {
          var minMax = calculateMinMax(axisValue);
          if(!minMax)
            scale.domain([0, 0]).range ([_height, 0]);
          else
            scale.domain([minMax.min, minMax.max]).range ([_height, 0]).nice();
        } else {
          scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([_height, 0]).nice();
        }

                Scaler.perfect(scale);
        } else {
          scale.domain([0,0]).range(0,0);
        }
      }

    function getProperty() {
      var temp = {};
      temp.tooltip.enabled = _props.tooltip.enabled;
      temp.primaryValuesColorPalette = _props.primaryValuesColorPalette;
      temp.secondaryValuesColorPalette = _props.secondaryValuesColorPalette;
      temp.colorPalette = _props.colorPalette;
      temp.drawingEffect = _props.drawingEffect;
      temp.animation = { 'dataLoading' : _props.animation.dataLoading };
      temp.bar = {};
      ObjUtils.extend(true, temp.bar, _props.bar);
      temp.line = {};
      ObjUtils.extend(true, temp.line, _props.line);
  
      return temp;
    }

    function setProperty (props) {
      _props.tooltip.enabled = props.tooltip.enabled; 
      _props.primaryValuesColorPalette = props.primaryValuesColorPalette;
      _props.secondaryValuesColorPalette = props.secondaryValuesColorPalette;
      _props.drawingEffect = props.drawingEffect;
      _props.colorPalette = props.colorPalette;
      _props.animation = {dataLoading : props.animation.dataLoading,};
      _props.bar = {};
      ObjUtils.extend(true, _props.bar, props.bar);
      _props.line = {};
      ObjUtils.extend(true, _props.line, props.line);

      return _props;
    }
    function getModule(mtype) {
      var result;
      switch (mtype) {
      case 'stackedverticalbar' :
        result = Manifest.module.get("sap.viz.modules.stackedverticalbar"); break;
      case 'verticalbar':
        result = Manifest.module.get("sap.viz.modules.verticalbar"); break;
      case 'line':
      default:
        result = Manifest.module.get("sap.viz.modules.line"); break;
      }
      return result.fn(result);
    }
    
    function getShape(mtype) {
      var result;
      switch (mtype) {
      case 'line':
        result = _props.line.marker.shape;
        break;
      case 'stackedverticalbar' :
      case 'verticalbar':
      default:
        result = 'squareWithRadius'; break;
      }
      return result;
    }

    function isExist(ao, element) {
      for (var n=0; n<ao.length; n++) {
        if (ao[n] == element) {
          return true;
        }
      }
      return false;
    }

    function calculateMinMax(axisValue)
    {
      if(!axisValue.data || axisValue.data.length == 0)
        return null;
        
      var minMax = {
          min: null,
          max: null
      };
      minMax.max = d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      });
      minMax.min = d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      });
      if(NumberUtils.isNoValue(minMax.max )) return null;
      if(minMax.min >= 0) {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / _height ;
      } else if(minMax.max <= 0) {
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ _height;
      } else {
        var temp = (minMax.max - minMax.min) * 5 / _height;
        minMax.min -= temp;
        minMax.max += temp;
      }
    
      return minMax;
    }
  
  };
  return combination;
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalcombination',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(dispatch, Manifest, ColorSeries, MNDHandler, TypeUtils, ObjUtils, MultiAxesDataAdapter, TooltipDataHandler, Scaler, NumberUtils) {
  var combination = function(manifest) {
    function module(selection) {
      _tooltipDataHandler = TooltipDataHandler();
      selection.each(
        function(inputData) {
          if (inputData !== undefined) {
            prepareData(inputData);
          }
          _d3root = d3.select(this);
          
          redraw();
        }
      );//each
      return module;
    }

    /**
     * set/get width
     */
    module.width = function(_) {
      if (!arguments.length)
        return _width;
      _width =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata))
        computeScales();
      return module;
    };
    /**
     * set/get height
     */
    module.height = function(_) {
      if (!arguments.length)
        return _height;
      _height =  _ ;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata))
        computeScales();
      return module;
    };
    /**
     * set/get size
     * 
     * @param {Object}
     *            {'width':Num, 'height':Num}
     */
    module.size = function(_) {
      if (!arguments.length)
        return {
          width : _width,
          height: _height
        };
      _width = _.width;
      _height = _.height;
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata))
        computeScales();
      return module;
    };

    /**
     * set/get properties
     */
    module.properties = function(_) {
      if (!arguments.length)
        return getProperty();
      _props = setProperty(manifest.props(_));
      prepareColor();
      return module;
    };

    /**
     * set/get data
     */
    module.data = function(_) {
      if (!arguments.length)
        return _rawdata;
        prepareData(_);
      return module;
    };

    module.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      module.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _rawdata.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };

    /**
     * set/get effect manager
     */
    module.effectManager = function(_){
        if (!arguments.length){
            return _effectManager;
       }
          
        _effectManager = _;
        
       return module;        
    };
     
      module.dispatch = function(_){
        if(!arguments.length)
          return _eDispatch;
        _eDispatch = _;
        return module;
      };

      module.primaryScale = function(scale)
      {
        if(!arguments.length)
        {
          return _valueAxis1.scale;
        }
        _valueAxis1.scale = scale;
        return module;
      };
      
      module.secondaryScale = function(scale)
      {
        if(!arguments.length)
        {
          return _valueAxis2.scale;
        }
        _valueAxis2.scale = scale;
        return module;
      };
      
      module.categoryScale = function(scale)
      {
        if(!arguments.length)
        {
          return _xScale;
        }
        _xScale = scale;
        return module;
      };
    
    module.primaryAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.primaryValuesColorPalette[0];
      } else {
        return null;
      }
    };
    
    module.secondAxisColor = function() 
    {
      if (!_props.MNDOnCategory) {
        return _props.secondaryValuesColorPalette[0];
      } else {
        return null;
      }
    };

      module.colorPalette = function(Palette){
        if (!arguments.length){
          return _colorPalette;
         }
         return module;
      };

      module.shapePalette = function(Palette){
        if (!arguments.length){
          return _shapePalette;
         }
         return module;
      };

    module.parent = function () {
      return _d3root;
    };
    
    module.clear = function (gray) {
      for (var i in _module)
      {
        if (gray == null) {
          _module[i].module.clear();
        } else {
          _module[i].module.clear('grayall');
        }
      }
    };

    module.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      if (elementArray.length == 0) {
        return;
      }
      for (var i in _module) {
        _module[i].highlightArray = [];
      }

      for (var i in elementArray) {
        var element = elementArray[i];
        for (var j in _module) {
          var dpa = _module[j].dataPointElements;
          if (isExist(dpa, element)) {
            _module[j].highlightArray.push(element);
            break;
          }
        }
      }

      for (var i in _module) {
        _module[i].module.highlight(_module[i].highlightArray);
      }
    };

    module.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements
      } else {
        elementArray = [];
        elementArray.push(elements);
      }    
      for (var i in _module) {
        _module[i].unhighlightArray = [];
      }

      for (var i in elementArray) {
        var element = elementArray[i];
        for (var j in _module) {
          var dpa = _module[j].dataPointElements;
          if (isExist(dpa, element)) {
            _module[j].unhighlightArray.push(element);
            break;
          }
        }
      }
      
      for (var i in _module) {
        _module[i].module.unhighlight(_module[i].unhighlightArray);
      }      
    };
    
    module.hoverOnPoint = function( point ) {
      if (_props.tooltip.enabled) {
        var point0= point.x, point1 = point.y;
  
        if(point1 < 0 || point1 > _height)
          return;

        var xIndex = getCategoryIndex(point1);
        if(_preMouseMoveXIndex == xIndex)
          return;

        _preMouseMoveXIndex = xIndex;

        var tData = _tooltipDataHandler.generateTooltipData(_rawdata, 
                                   _tooltipdata, 
                                   xIndex, 
                                   _colorPalette, 
                                   _shapePalette);
        var matrix = _d3root.node().getTransformToElement(_d3root.node().ownerSVGElement);                                   
        tData.point = {
            y: (_height - _xScale.rangeBand()*(xIndex + 0.5)) + matrix.f,
            x: _width*3/4 + matrix.e
        };
        _eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
      
      for (var i in _module) {
        _module[i].module.hoverOnPoint(point);
      }
      return true;
    };

    module.blurOut = function( ) {
      if (_props.tooltip.enabled) {
        _eDispatch.hideTooltip();
        _preMouseMoveXIndex = -1;
      }
      for (var i in _module) {
        _module[i].module.blurOut();
      }      
      return true;
    };  

      var _xScale = d3.scale.ordinal(),
        _valueAxis1 = {
        scale: d3.scale.linear()
      },
      _valueAxis2 = {
        scale: d3.scale.linear()
      };

    
    //private field
    var _tooltipDataHandler;
    var _eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    //property
    var _width, _height;
    var _props = {
      measureMapY1: ['bar', 'horizontalline', 'horizontalline'],
      measureMapY2: ['horizontalline', 'horizontalline', 'horizontalline'],
      priorityMap : {
        'stackedbar' : 6,
        'bar' : 5,
        'horizontalline' : 0
      },
      tooltip: { enable : true},
      defaultModuleType : 'horizontalline',
      MNDOnCategory : false,
      MNDInner : false,
    };
    
    var _effectManager;
    //data
    var _rawdata, _tooltipdata;
    var _d3root;
    var _colorPalette, _shapePalette;
    
    //module
    var _module;

    var _preMouseMoveXIndex = -1;

    var dummyDispatch = function (_) {
      this.mtype = _;
    };
    dummyDispatch.prototype.initialized = function() {
      _dummyDispatchHelper.initialized(this.mtype);
    };

    var _dummyDispatchHelper = {
      initialized : function(mtype) {
        _module[mtype].isCompleteAnimation = true;
        for (var i in _module) {
          if (!_module[i].isCompleteAnimation)
            return true;
        }
        _eDispatch.initialized();
        return true;
      }
    };

    setProperty(manifest.props(null));
    return module;

    function init() {
      _module = {};
    }
    function prepareData ( rawdata ) {
      if ((rawdata === undefined) || (_rawdata == rawdata))
        return;
      
      init();
      _rawdata = rawdata;

        var obj = MNDHandler(_rawdata );
      _props.MNDInner = obj.MNDInner;
      _valueAxis1.data = obj['MG1'];
      _valueAxis2.data = obj['MG2'];
      _tooltipdata = TooltipDataHandler.dataTransform(obj);

      if (obj.color) {
        var tempData = obj['MG1'];
        var data0 = [];
        var data1 = [];
        for (var i=0; i<tempData.length; i++) {
          var temp0 = [];
          var temp1 = [];
          var temp = tempData[i];
          for (var j=0; j<temp.length; j++) {
            if (obj.color[j] == 0) {
              temp0.push(temp[j]);
            } else if (obj.color[j] == 1) {
              temp1.push(temp[j]);
            }
          }
          data0.push(temp0);
          data1.push(temp1);
        }
        _valueAxis1.data = data0;
        _valueAxis2.data = data1;
      }
      if(TypeUtils.isExist(_width) && TypeUtils.isExist(_height)&& TypeUtils.isExist(_rawdata))
        computeScales();

      if (obj.hasMND && !obj.MNDOnColor) {
        var mtype = _props.measureMapY1[0];
        if (mtype === undefined) {
          mtype = _props.defaultModuleType;
        }
        if (_module[mtype] === undefined) {
          _module[mtype] = {};
        }
        _module[mtype].data = _rawdata;
        _props.MNDOnCategory = true;
      } else {
        _props.MNDOnCategory = false;
        var daa1 = _rawdata.getAnalysisAxisDataByIdx(0);
        var daa2 = _rawdata.getAnalysisAxisDataByIdx(1);
        var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        for (var i=0; i<dva1.values.length; i++) {
          var mtype = _props.measureMapY1[i];
          if (mtype === undefined) {
            mtype = _props.defaultModuleType;
          }
          if (_module[mtype] === undefined) {
            _module[mtype] = {m1Num:0, m2Num:0};
          }
          var tm = _module[mtype];
          tm.m1Num ++;
          if (tm.data === undefined) {
            tm.data = new MultiAxesDataAdapter();
            tm.data.addAnalysisAxis(daa1);
            tm.data.addAnalysisAxis(daa2);
            tm.data.addMeasureValuesGroup({
              index: dva1.index,
              values: []
            });
            if (dva2) {
              tm.data.addMeasureValuesGroup({
                index: dva2.index,
                values: []
              });
            }
          }
          var tva1 = tm.data.getMeasureValuesGroupDataByIdx(0);
          tva1.values.push(dva1.values[i]);
        }
        
        if (dva2) {
          for (var i=0; i<dva2.values.length; i++) {
            var mtype = _props.measureMapY2[i];
            if (mtype === undefined) {
              mtype = _props.defaultModuleType;
            }
            if (_module[mtype] === undefined) {
              _module[mtype] = {m1Num:0, m2Num:0};
            }
            var tm = _module[mtype];
            tm.m2Num ++;
            if (tm.data === undefined) {
              tm.data = new MultiAxesDataAdapter();
              tm.data.addAnalysisAxis(daa1);
              tm.data.addAnalysisAxis(daa2);
              tm.data.addMeasureValuesGroup({
                index: dva1.index,
                values: []
              });
              if (dva2) {
                tm.data.addMeasureValuesGroup({
                  index: dva2.index,
                  values: []
                });
              }
            }
            var tva2 = tm.data.getMeasureValuesGroupDataByIdx(1);
            tva2.values.push(dva2.values[i]);
          }
        }
      }
      prepareColor();
    }
    
    function prepareColor() {
      if (_rawdata === undefined) return;
      
      var dva1 = _rawdata.getMeasureValuesGroupDataByIdx(0);
      var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
      var valueAxis1ColorPalette;
      var valueAxis2ColorPalette;

      if (dva2 && !_props.MNDOnCategory) {
        valueAxis1ColorPalette = _props.primaryValuesColorPalette;  
      }else{
        valueAxis1ColorPalette = _props.colorPalette;
      }
      
      valueAxis2ColorPalette = _props.secondaryValuesColorPalette;
      
      _colorPalette = [];
      _shapePalette = [];
      for (var i in _module) {
          _module[i].colorPaletteY1 = [];
        _module[i].currentM1Index = -1;
        if (dva2) {
          _module[i].colorPaletteY2 = [];
          _module[i].currentM2Index = -1;
        }
      }
      
      if (_props.MNDOnCategory) {
        var mtype = _props.measureMapY1[0];
        var rowslength = dva1.values[0].rows.length;
        for (var x=0; x<rowslength; x++) {
          _module[mtype].colorPaletteY1.push(valueAxis1ColorPalette[(x) % valueAxis1ColorPalette.length]);
          _shapePalette.push(getShape(mtype));
          _colorPalette.push(valueAxis1ColorPalette[(x) % valueAxis1ColorPalette.length]);
        }
      } else {
        var measure1Num = dva1.values.length;
        var measure2Num = 0;
        if (dva2) {
          measure2Num = dva2.values.length;
        }
        var measureNum = measure1Num + measure2Num;
        var colorAxisDataNum = dva1.values[0].rows.length;
        for (var i=0; i<measure1Num; i++) {
          var mtype = _props.measureMapY1[i];
          if (mtype === undefined) {
            mtype = _props.defaultModuleType;
          }
          var tm = _module[mtype];
          tm.currentM1Index ++;
          for (var x=0; x<colorAxisDataNum; x++) {
            if (_props.MNDInner) {
              var color = valueAxis1ColorPalette[(i+x*measure1Num ) % valueAxis1ColorPalette.length];
              tm.colorPaletteY1[tm.currentM1Index+x*tm.m1Num] = color;
              _shapePalette[i+x*measureNum] = getShape(mtype);
              _colorPalette[i+x*measureNum] = color;
            } else {
              var color = valueAxis1ColorPalette[(i*colorAxisDataNum+x) % valueAxis1ColorPalette.length];
              _module[mtype].colorPaletteY1.push(color);
              _shapePalette.push(getShape(mtype));
              _colorPalette.push(color);
            }
          }
        }

        if (dva2) {
          for (var i=0; i<measure2Num; i++) {
            var mtype = _props.measureMapY2[i];
            if (mtype === undefined) {
              mtype = _props.defaultModuleType;
            }
            var tm = _module[mtype];
            tm.currentM2Index ++;
            for (var x=0; x<colorAxisDataNum; x++) {
              if (_props.MNDInner) {
                var color = valueAxis2ColorPalette[(i+x*measure2Num ) % valueAxis2ColorPalette.length];
                tm.colorPaletteY2[tm.currentM2Index+x*tm.m2Num] = color;
                _shapePalette[measure1Num+i+x*measureNum] = getShape(mtype);
                _colorPalette[measure1Num+i+x*measureNum] = color;
              } else {
                var color = valueAxis2ColorPalette[(i*colorAxisDataNum+x) % valueAxis2ColorPalette.length];
                _module[mtype].colorPaletteY2.push(color);
                _shapePalette.push(getShape(mtype));
                _colorPalette.push(color);
              }
            }
          }
        }
      } // _props.MNDOnCategory
    }
    function moduleSortHelp(a, b) {
      return (_props.priorityMap[b] - _props.priorityMap[a]);
    }
    function prepareModule() {
      var tempA = [];
      for (var i in _module) {
        tempA.push(i);
      }
      tempA.sort(moduleSortHelp);
      _d3root.selectAll('.module').remove(); //TODO: should not always remove all
      var d3modules = _d3root.selectAll('.module').data(tempA);
      d3modules.enter().append('svg:g').attr('class', 'module');
      d3modules.exit().remove();
      
      d3modules.each(function(d) {
        _module[d].d3root = d3.select(this);
      });
      
      for (var i in _module) {
        _module[i].module = getModule(i); //TODO: should not always new module instance
        var props = {
          colorPalette : _module[i].colorPaletteY1,
          primaryValuesColorPalette : _module[i].colorPaletteY1,
          tooltip : {enabled : false},
          animation : { 'dataLoading' : _props.animation.dataLoading },
          drawingEffect: _props.drawingEffect
        };
        if (_module[i].colorPaletteY2) {
          props.secondaryValuesColorPalette = _module[i].colorPaletteY2;
        }
        switch (i) {
        case 'horizontalline' :
          props.hoverline = { visible : false };
          ObjUtils.extend(props, _props.line);
          break;
        case 'bar' :
        case 'stackedbar' :
          props.animation.dataUpdating = _props.animation.dataLoading; 
          ObjUtils.extend(props, _props.bar);
          break;
        default :
          break;
        }

        _module[i].props = props;
        _module[i].module.dispatch(new dummyDispatch(i));
        _module[i].module.effectManager(_effectManager);
      }
    }

    function redraw() {
      prepareModule();

      for (var i in _module) {
        var m = _module[i];
        m.module.width(_width).height(_height).data(m.data)
            .properties(m.props).primaryScale(_valueAxis1.scale)
            .categoryScale(_xScale);
        var dva2 = _rawdata.getMeasureValuesGroupDataByIdx(1);
        if (dva2) {
          switch(i) {
          case 'bar' :
          case 'stackedbar' :
            m.module.secondScale(_valueAxis2.scale); break;
          case 'horizontalline' :
          default:
            m.module.secondaryScale(_valueAxis2.scale); break;
          }
        }
        m.d3root.call(m.module);
        m.dataPointElements = [];
        m.d3root.selectAll('.datapoint').each(function(){m.dataPointElements.push(this)});
      }
    }

    function getCategoryIndex(val)
    {
      var categoryNum = _xScale.domain().length;
      var index = val / _xScale.rangeBand();
        index = Math.floor(index);
       
      return categoryNum - 1 - index;
    }

      function computeScales() {
      var domain = [];
      var categoryNum = 0;
      if (_props.MNDOnCategory) {
        if (_valueAxis1.data && _valueAxis1.data.length > 0) {
          categoryNum += _valueAxis1.data[0].length;
        }
        if (_valueAxis2.data && _valueAxis2.data.length > 0) {
          categoryNum += _valueAxis2.data[0].length;
        }        
      } else {
        if (_valueAxis1.data && _valueAxis1.data.length > 0) {
          categoryNum = _valueAxis1.data[0].length;
        } else {
          categoryNum = _valueAxis2.data[0].length;  
        }
      }
      for (var i=0; i < categoryNum; i++) {
         domain.push(i);
      }      
        _xScale.domain(domain).rangeBands([_height, 0]);

        calculateScale(_valueAxis1, _valueAxis1.scale);
      calculateScale(_valueAxis2, _valueAxis2.scale);
      if (_valueAxis1.data && _valueAxis1.data.length > 0 &&
        _valueAxis2.data && _valueAxis2.data.length > 0) {
        Scaler.perfectDual(_valueAxis1.scale, _valueAxis2.scale);
      }
      }

    function calculateScale(axisValue, scale) {
        if(axisValue.data && axisValue.data.length > 0) {
        if(axisValue.topValue == null) {
          var minMax = calculateMinMax(axisValue);
          if(!minMax) 
            scale.domain([0, 0]).range ([0, _width]);
          else
            scale.domain([minMax.min, minMax.max]).range ([0, _width]).nice();
        } else {
          scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([0, _width]).nice();
        }

                Scaler.perfect(scale);
        } else {
          scale.domain([0,0]).range(0,0);
        }
      }

    function getProperty() {
      var temp = {};
      temp.tooltip.enabled = _props.tooltip.enabled;
      temp.primaryValuesColorPalette = _props.primaryValuesColorPalette;
      temp.secondaryValuesColorPalette = _props.secondaryValuesColorPalette;
      temp.colorPalette = _props.colorPalette;
      temp.drawingEffect = _props.drawingEffect;
      temp.animation = { 'dataLoading' : _props.animation.dataLoading };
      temp.bar = {};
      ObjUtils.extend(true, temp.bar, _props.bar);
      temp.line = {};
      ObjUtils.extend(true, temp.line, _props.line);
  
      return temp;
    }

    function setProperty (props) {
      _props.tooltip.enabled = props.tooltip.enabled;
      _props.primaryValuesColorPalette = props.primaryValuesColorPalette;
      _props.secondaryValuesColorPalette = props.secondaryValuesColorPalette;
      _props.drawingEffect = props.drawingEffect;
      _props.colorPalette = props.colorPalette;
      _props.animation = {dataLoading : props.animation.dataLoading,};
      _props.bar = {};
      ObjUtils.extend(true, _props.bar, props.bar);
      _props.line = {};
      ObjUtils.extend(true, _props.line, props.line);

      return _props;
    }

    function getModule(mtype) {
      var result;
      switch (mtype) {
      case 'stackedbar' :
        result = Manifest.module.get("sap.viz.modules.stackedbar"); break;
      case 'bar':
        result = Manifest.module.get("sap.viz.modules.bar"); break;
      case 'horizontalline':
      default:
        result = Manifest.module.get("sap.viz.modules.horizontalline"); break;
      }
      return result.fn(result);
    }
    
    function getShape(mtype) {
      var result;
      switch (mtype) {
      case 'horizontalline':
        result = _props.line.marker.shape;
        break;
      case 'stackedbar' :
      case 'bar':
      default:
        result = 'squareWithRadius'; break;
      }
      return result;
    }

    function isExist(ao, element) {
      for (var n=0; n<ao.length; n++) {
        if (ao[n] == element) {
          return true;
        }
      }
      return false;
    }

    function calculateMinMax(axisValue)
    {
      if(!axisValue.data || axisValue.data.length == 0)
        return null;
        
      var minMax = {
          min: null,
          max: null
      };
      minMax.max = d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      });
      minMax.min = d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      });
      if(NumberUtils.isNoValue(minMax.max )) return null;
      if(minMax.min >= 0) {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / _width;
      } else if(minMax.max <= 0) {
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ _width;
      } else {
        var temp = (minMax.max - minMax.min) * 5 / _width;
        minMax.min -= temp;
        minMax.max += temp;
      }
    
      return minMax;
    }
  
  };
  return combination;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * Iterator for LinkedHashMap, to get an iterator for a linkedHashMap
	 * instance, use {@link sap.viz.base.utils.LinkedHashMap#getIterator}
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator
	 * @constructor
	 */
	var lhmItr = function(lhm, reverseOrder) {
		this._lhm = lhm;
		this._reverse = reverseOrder || false;
		this._count = lhm._length;
		this._cursor = this._reverse ? this._lhm._last : this._lhm._head;
		if (this._reverse) {
			this.hasMore = this._hasMoreInReverse;
		} else {
			this.hasMore = this._hasMoreInOrder;
		}
	};

	lhmItr.prototype._hasMoreInOrder = function() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._head;
			} else {
				this._cursor = this._cursor.next;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	};

	lhmItr.prototype._hasMoreInReverse = function() {
		if (this._count !== 0) {
			if (this._count === this._lhm._length) {
				this._cursor = this._lhm._last;
			} else {
				this._cursor = this._cursor.prev;
			}
			this._count--;
			return true;
		} else {
			return false;
		}
	};
	/**
	 * Find if there is more item to iterate, calling this method will move the
	 * cursor forward to next item
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#hasMore
	 * @function
	 * @returns {Boolean}
	 */
	lhmItr.prototype.hasMore = FuncUtils.noop;

	/**
	 * Get the entry at the current cursor, calling this method without calling
	 * hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#next
	 * @function
	 * @returns {Object} with key & value property indicating the entry's key
	 *          and value object
	 */
	lhmItr.prototype.next = function() {
		var ret = {
			key : this._cursor.key,
			value : this._cursor.value
		};
		return ret;
	};
	/**
	 * Get the value of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#nextValue
	 * @function
	 * @returns {Object}
	 */
	lhmItr.prototype.nextValue = function() {
		return this._cursor.value;
	};
	/**
	 * Get the key of entry at the current cursor, calling this method without
	 * calling hasMore method will return the same entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#nextKey
	 * @function
	 * @returns {String}
	 */
	lhmItr.prototype.nextKey = function() {
		return this._cursor.key;
	};
	/**
	 * Reset the iterator to initial state
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap.Iterator#reset
	 * @function
	 */
	lhmItr.prototype.reset = function() {
		this._count = this._lhm._length;
	};
	/**
	 * Create an empty LinkedHashMap
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap
	 * @constructor
	 */
	var LinkedHashMap = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	var lhmp = LinkedHashMap.prototype;

	/**
	 * Add one entry, if the key for the entry is already existing, then the old
	 * value will be replaced.
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#add
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @returns {undefined|Object} undefined if key is new, otherwise will be
	 *          the replaced value
	 */
	lhmp.add = function(key, value) {
		var m = this._map;
		var ret = null;
		var node = {
			prev : null,
			key : key,
			value : value,
			next : null
		};
		if (!this._length) {
			this._head = this._last = node;
		}
		if (!m.hasOwnProperty(key)) {
			m[key] = node;
			this._length++;
			node.prev = this._last;
			this._last.next = node;
			this._last = node;
			this._last.next = this._head;
			this._head.prev = this._last;
		} else {
			ret = m[key].value;
			m[key].value = value;
		}
		return ret;
	};
	/**
	 * Add entries from an existing linked hash map, the duplicated entry will
	 * be replaced silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#addAll
	 * @function
	 * @param {sap.viz.base.utils.LinkedHashMap}
	 *            linkedHashMap another linkedHashMap to added
	 */
	lhmp.addAll = function(linkedHashMap) {
		var itr = linkedHashMap.getIterator();
		var entry;
		while (itr.hasMore()) {
			entry = itr.next();
			this.add(entry.key, entry.value);
		}
	};
	/**
	 * Insert the entry before one entry, if the inserted entry exists or the
	 * entry to be inserted before doesn't exist, insertion will fail silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#insertBefore
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            beforeKey the key of the entry to be inserted before
	 * @returns {Object} the value inserted
	 */
	lhmp.insertBefore = function(key, value, beforeKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(beforeKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[beforeKey];
			if (anode !== this._head) {
				nnode.prev = anode.prev;
				anode.prev.next = nnode;
			} else {
				this._head = nnode;
				nnode.prev = this._last;
			}
			nnode.next = anode;
			anode.prev = nnode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Insert the entry after one entry, if the inserted entry exists or the
	 * entry to be inserted after doesn't exist, insertion will fail silently
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#insertAfter
	 * @function
	 * @param {String}
	 *            key the key for the entry
	 * @param {Object}
	 *            value the value for the entry
	 * @param {String}
	 *            afterKey the key of the entry to be inserted after
	 * @returns {Object} the value inserted
	 */
	lhmp.insertAfter = function(key, value, afterKey) {
		var m = this._map;
		if (!m.hasOwnProperty(key) && m.hasOwnProperty(afterKey)) {
			var nnode = {
				prev : null,
				key : key,
				value : value,
				next : null
			};
			var anode = m[afterKey];
			if (anode !== this._last) {
				nnode.next = anode.next;
				anode.next.prev = nnode;
			} else {
				this._last = nnode;
				this._last.next = this._head;
			}
			anode.next = nnode;
			nnode.prev = anode;
			m[key] = nnode;
			this._length++;
			return value;
		}
	};
	/**
	 * Replace the existing entry with new entry, including key in place
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#replace
	 * @function
	 * @param {String}
	 *            key the key for the entry to be replaced
	 * @param {withKey}
	 *            withKey the key for the entry to be added
	 * @param {Object}
	 *            andValue the value of the entry to be added
	 * @returns {Object} the value to be replaced
	 */
	lhmp.replace = function(key, withKey, andValue) {
		var m = this._map;
		if (!m.hasOwnProperty(withKey) && m.hasOwnProperty(key)) {
			var nnode = {
				prev : null,
				key : withKey,
				value : andValue,
				next : null
			};
			var rnode = m[key];
			nnode.prev = rnode.prev;
			nnode.next = rnode.next;
			rnode.prev.next = nnode;
			rnode.next.prev = nnode;
			if (this._head === rnode)
				this._head = nnode;
			if (this._last === rnode)
				this._last = nnode;
			m[withKey] = nnode;
			delete m[key];
			return rnode.value;
		}
	};
	/**
	 * Get the value for the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#get
	 * @function
	 * @param {String}
	 *            key the key for the entry to get
	 * 
	 * @returns {undefined|Object} the value for the key or undefined if key is
	 *          non-existing
	 */
	lhmp.get = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key)) {
			return m[key].value;
		}
		return null;
	};
	/**
	 * Get the first inserted entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getFirstInsert
	 * @function
	 * 
	 * @returns {Object} the value first inserted
	 */
	lhmp.getFirstInsert = function() {
		return this._head ? this._head.value : null;
	};
	/**
	 * Get the last inserted entry
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getLastInsert
	 * @function
	 * 
	 * @returns {Object} the value last inserted
	 */
	lhmp.getLastInsert = function() {
		return this._last ? this._last.value : null;
	};
	/**
	 * Move entry associated with key to the last of the link
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#moveToLast
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 */
	lhmp.moveToLast = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._last.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.prev = this._last;
			node.next = this._last.next;
			this._last.next = node;
			this._last = node;
			this._head = node.next;
			this._head.prev = node;

		}
	};
	/**
	 * Move entry associated with key to the first of the link
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#moveToFirst
	 * @function
	 * @param {String}
	 *            key the key of the entry to move
	 */
	lhmp.moveToFirst = function(key) {
		var m = this._map;
		if (m.hasOwnProperty(key) && this._head.key !== key) {
			var node = m[key];
			node.prev.next = node.next;
			node.next.prev = node.prev;
			node.next = this._head;
			node.prev = this._head.prev;
			this._head.prev = node;
			this._head = node;
			this._last = node.prev;
			this._last.next = node;
		}
	};
	/**
	 * Check whether having the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#has
	 * @function
	 * @param {String}
	 *            key the key of the entry to check
	 * @returns {Boolean}
	 */
	lhmp.has = function(key) {
		var m = this._map;
		return m.hasOwnProperty(key);
	};
	/**
	 * Remove the entry associated with the key
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#remove
	 * @function
	 * @param {String}
	 *            key the key of the entry to remove
	 * @returns {undefined|Object} the removed item or undefined if key is
	 *          non-existing
	 */
	lhmp.remove = function(key) {
		var m = this._map;
		var ret;
		if (m.hasOwnProperty(key)) {
			var node = m[key];
			ret = node.value;
			if (node === this._head) {
				this._head = node.next;
			} else if (node === this._last) {
				this._last = node.prev;
			} else {
				node.prev.next = node.next;
				node.next.prev = node.prev;
			}
			delete m[key];
			this._length--;
			if (this._length === 0) {
				this._head = this._last = undefined;
			}
			return ret;
		}
	};
	/**
	 * Remove all entries added before
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#purgeAll
	 * @function
	 * 
	 */
	lhmp.purgeAll = function() {
		this._map = {};
		this._head = undefined;
		this._last = undefined;
		this._length = 0;
	};
	/**
	 * Whether the map is empty
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#isEmpty
	 * @function
	 * 
	 * @returns {Boolean}
	 */
	lhmp.isEmpty = function() {
		return this._length == 0;
	};
	/**
	 * Length of the map
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#length
	 * @function
	 * @returns {Integer}
	 */
	lhmp.length = function() {
		return this._length;
	};
	/**
	 * Get the iterator of the map
	 * 
	 * @name sap.viz.base.utils.LinkedHashMap#getIterator
	 * @function
	 * @param {Boolean}
	 *            reverseOrder whether iterate in reverse order
	 * @returns {sap.viz.base.utils.LinkedHashMap.Iterator}
	 */
	lhmp.getIterator = function(reverseOrder) {
		return new lhmItr(this, reverseOrder);
	};
	return LinkedHashMap;
});sap.riv.module(
{
  qname : 'sap.viz.util.LogAnalyzer',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'
}
],

function Setup(LinkedHashMap) {
    
    var firstChartStartTime;
    var chartStartTime = {};
    var chartAppMap = {};
    var chartAppComMap = {};
    var chartMap = new LinkedHashMap();
    var chartStartP = /Chart\[(.+?)\]\sinitializing\./;
    var chartMapP = /Chart\[(.+?)\]application\[(.+?)\]\sinitialized\./;
    var chartAppComMapP = /application\[(.+?)\]component\[(.+?)\]\sinitialized\./;
    var chartSubP = /chartComponent\[(.+?)\]subComponent\[(.+?)\]initialized\./;
    var comP = /layer\[(.+?)\]rendering\send\./;
    var timeP = /#(\d+)#/;

    function chartFinished(comItr) {
        while(comItr.hasMore()) {
            if(comItr.nextValue() === -1)
                return false;
        }
        return true;
    }

    function max(nums) {
        var m = nums[0];
        var length = nums.length;
        for(var i = 1; i < length; i++) {
            m = nums[i] > m ? nums[i] : m;
        }
        return m;
    }
    
    function formatMsg(logTime, logLevel, logCate, logMsg) {
        return '#' + logTime + '#' + logMsg;
    }

    var LogAnalyzer = {
        analyze : function(logTime, logLevel, logCate, logMsg) {
            if(logCate!=="perf")
                return;
            var log = formatMsg(logTime, logLevel, logCate, logMsg);
            var m = chartStartP.exec(log);
            if(m) {
                var st = timeP.exec(log)[1];
                chartStartTime[m[1]] = st;
                firstChartStartTime = firstChartStartTime || st;
                return;
            }
            m = chartAppComMapP.exec(log);
            if(m) {
                chartAppComMap[m[2]] = m[1];
                return;
            }
            m = chartMapP.exec(log);
            if(m) {
                chartAppMap[m[2]] = m[1];
                return;
            }
            m = chartSubP.exec(log);
            if(m) {
                if(!chartMap.has(m[1])) {
                    chartMap.add(m[1], new LinkedHashMap());
                }
                chartMap.get(m[1]).add(m[2], -1);
                return;
            }
            m = comP.exec(log);
            if(m) {
                var timeStamp = timeP.exec(log)[1];
                var chartItr = chartMap.getIterator();
                while(chartItr.hasMore()) {
                    var chart = chartItr.next();
                    var componentMap = chart.value;
                    if(componentMap.has(m[1]) && componentMap.get(m[1]) === -1) {
                        componentMap.add(m[1], timeStamp);
                        var comItr = componentMap.getIterator();
                        if(chartFinished(comItr)) {
                            comItr.reset();
                            var endTimes = [];
                            while(comItr.hasMore()) {
                                endTimes.push(comItr.nextValue());
                            }
                            var chartKey = chartAppMap[chartAppComMap[chart.key]];
                            var start = chartStartTime[chartKey], end = timeStamp;
                            chartMap.remove(chart.key);
                            return ("chart[" + chartKey + "] start time:" + start + " end time:" + end + " time consume[" + (end - start) + "] total consume["+(end - firstChartStartTime)+"]");
                        }
                    }
                }
            }
        }
    };
    return LogAnalyzer;
});sap.riv.module(
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'},
[

],

function Setup() {
	var devicePixRatio = window.devicePixelRatio || 1;
	var versionSearchString;
	var searchString = function(data) {
		for ( var i = 0; i < data.length; i++) {
			var dataString = data[i].string;
			var dataProp = data[i].prop;
			versionSearchString = data[i].versionSearch || data[i].identity;
			if (dataString) {
				if (dataString.indexOf(data[i].subString) != -1) {
					return data[i].identity;
				}
			} else if (dataProp) {
				return data[i].identity;
			}
		}
	};
	var seps = [ ';', ' ' ];
	var searchVersion = function(dataString) {
		var index = dataString.indexOf(versionSearchString);
		if (index == -1)
			return;
		var versionStr = dataString.substring(index + versionSearchString.length + 1);
		var i = 0, l = seps.length, sepIndex = -1;
		while (sepIndex === -1 && i < l)
			sepIndex = versionStr.indexOf(seps[i++]);
		if (sepIndex !== -1)
			versionStr = versionStr.slice(0, sepIndex);
		return versionStr;
	};
	var dataBrowser = [ {
		string : navigator.userAgent,
		subString : "Chrome",
		identity : "Chrome"
	}, {
		string : navigator.userAgent,
		subString : "OmniWeb",
		versionSearch : "OmniWeb/",
		identity : "OmniWeb"
	}, {
		string : navigator.userAgent,
		subString : "RIV",
		versionSearch : "RIV/",
		identity : "RIV"
	}, {
		string : navigator.userAgent,
		subString : "Safari",
		identity : "Safari",
		versionSearch : "Version"
	}, {
		string : navigator.userAgent,
		subString : "Apple",
		identity : "UIWebView",
		versionSearch : "AppleWebKit"
	}, {
		prop : window.opera,
		identity : "Opera",
		versionSearch : "Version"
	}, {
		string : navigator.vendor,
		subString : "iCab",
		identity : "iCab"
	}, {
		string : navigator.vendor,
		subString : "KDE",
		identity : "Konqueror"
	}, {
		string : navigator.userAgent,
		subString : "Firefox",
		identity : "Firefox"
	}, {
		string : navigator.vendor,
		subString : "Camino",
		identity : "Camino"
	}, {// for newer Netscapes (6+)
		string : navigator.userAgent,
		subString : "Netscape",
		identity : "Netscape"
	}, {
		string : navigator.userAgent,
		subString : "MSIE",
		identity : "Explorer",
		versionSearch : "MSIE"
	}, {
		string : navigator.userAgent,
		subString : "Gecko",
		identity : "Mozilla",
		versionSearch : "rv"
	}, {// for older Netscapes (4-)
		string : navigator.userAgent,
		subString : "Mozilla",
		identity : "Netscape",
		versionSearch : "Mozilla"
	} ];

	var dataOS = [ {
		string : navigator.platform,
		subString : "Win",
		identity : "Windows"
	}, {
		string : navigator.platform,
		subString : "Mac",
		identity : "Mac"
	}, {
		string : navigator.userAgent,
		subString : "iPhone",
		identity : "iPhone/iPod"
	}, {
		string : navigator.userAgent,
		subString : "iPad",
		identity : "iPad"
	}, {
		string : navigator.platform,
		subString : "Linux",
		identity : "Linux"
	} ];

	var dataRenderEngine = [ {
		string : navigator.userAgent,
		subString : "Presto",
		identity : "Presto"
	}, {
		string : navigator.userAgent,
		subString : "KHTML",
		identity : "KHTML"
	}, {
		string : navigator.userAgent,
		subString : "Gecko",
		identity : "Gecko"
	}, {
		string : navigator.userAgent,
		subString : "Trident",
		identity : "Trident"
	}, {
		string : navigator.userAgent,
		subString : "RivKit",
		identity : "RivKit"
	} ];
	var _userAgent = searchString(dataBrowser) || "An unknown browser", _version = searchVersion(navigator.userAgent)
			|| searchVersion(navigator.appVersion) || "an unknown version", _isIE = searchString(dataBrowser) === "Explorer", _isFirefox = searchString(dataBrowser) === 'Firefox', _isChrome = searchString(dataBrowser) === 'Chrome', _isSafari = searchString(dataBrowser) === 'Safari', _isUIWebView = searchString(dataBrowser) === 'UIWebView', _os = searchString(dataOS)
			|| "an unknown OS", _renderEngine = searchString(dataRenderEngine) || "An unknown RenderEngine";
	var UADetector = {
		userAgent : function() {
			return _userAgent;
		},
		version : function() {
			return _version;
		},
		isIE : function() {
			return _isIE;
		},
		isFirefox : function() {
			return _isFirefox;
		},
		isChrome : function() {
			return _isChrome;
		},
		isSafari : function() {
			return _isSafari;
		},
		isUIWebView : function() {
			return _isUIWebView;
		},
		os : function() {
			return _os;
		},
		devicePixelRatio : function() {
			return devicePixRatio;
		},
		renderEngine : function() {
			return _renderEngine;
		}
	};
	return (UADetector);
});sap.riv.module(
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
}
],
function Setup(TypeUtils, UADetector) {
  var ns = "http://www.w3.org/2000/svg";
  var node;
  var sensitiveStyle = [ "font", "font-family", "font-size",
      "font-size-adjust", "font-stretch", "font-style", "font-variant",
      "font-weight", "letter-spacing", "word-spacing", "alignment-baseline",
      "baseline-shift", "dominant-baseline" ];
  var textSizeCache = [];

  function getNode() {
    if (!node) {
      var svg = document.body.appendChild(document.createElementNS(ns, "svg"));
      svg.style.cssText = "position:absolute;left:-1000px;top:-1000px;z-index:-9000;width:1px;height:1px";
      node = svg.appendChild(document.createElementNS(ns, "text"));
    }

    return node;
  }

  function applyText(text, style) {
    var node = getNode();

    if (!style)
      node.removeAttribute("style");
    else {
      if (!TypeUtils.isString(style)) {
        var computedStyle = UADetector.isIE() ? style.ownerSVGElement
            .getComputedStyle(style) : getComputedStyle(style);

        var cssText = "";
        sensitiveStyle.forEach(function(i) {
          var s = computedStyle.getPropertyValue(i);
          if (s != null)
            cssText += i + ":" + s + ";";
        });
        style = cssText;
      }
      node.style.cssText = style;
    }
    if (text == null)
      text = "";

    node.textContent = text;
    return node;
  }

  function ellipsis(text, textNode, expectedLength, cssStyle, textApplied) {
    if (expectedLength > 0) {
      var node = textApplied ? getNode() : applyText(text, (cssStyle != null ? cssStyle : textNode));
      if (node.getComputedTextLength() <= expectedLength) {
        textNode.textContent = text;
        return;
      }

      node.textContent = "...";
      expectedLength -= node.getComputedTextLength();
      node.textContent = text;

      if (expectedLength > 0) {
        var charNumber = text.length;
        var i = 0;
        while (++i < charNumber) {
          if (node.getSubStringLength(0, charNumber - i) <= expectedLength) {
            textNode.textContent = text.substring(0, charNumber - i) + "...";
            textNode.appendChild(document.createElementNS(
                textNode.namespaceURI, "title")).textContent = text;
            return;
          }
        }
      }
    }
    textNode.textContent = "";
  }
  return {
    /**
     * Measure the dimension of the text in given style
     * 
     * @param {String}
     *          text the text to be measured
     * @param style
     *          the style definition text or a DOM node. If it is a node, its
     *          style will be used to measure text.
     * @returns {Object}
     */
    measure : function(text, style) {
        if (text === '') {
            return {
                width : 0,
                  height : 0,
                  x : 0,
                  y : 0
            };
        }
      var box = applyText(text, style).getBBox();
      return {
        width : box.width,
        height : box.height,
        x : box.x,
        y : box.y
      };
    },

    /**
     * Fast measure the dimension of the text in given fontSize, fontWeight and
     * fontFamily
     * 
     * @param {String}
     *          text the text to be measured
     * @param {String}
     *          fontSize
     * @param {String}
     *          fontWeight
     * @param {String}
     *          fontFamily
     * @returns {Object}
     */
    fastMeasure : function(text, tFontSize, tFontWeight, tFontFamily) {
      var index = text + tFontSize + tFontWeight + tFontFamily;
      var cachedSize = textSizeCache[index];
      if (!cachedSize) {
        textSizeCache[index] = this.measure(text, "font-size:" + tFontSize
            + "; font-weight:" + tFontWeight + "; font-family:" + tFontFamily);

        cachedSize = textSizeCache[index];
      }
      return cachedSize;
    },

    /**
     * Ellipsis long text.
     * 
     * @param {String}
     *          text the text to be processed
     * @param {Node}
     *          textNode the svg:text which will be display text
     * @param {Number}
     *          maxLength the max text length
     */
    ellipsis : function(text, textNode, maxLength, cssStyle) {
      ellipsis(text, textNode, maxLength, cssStyle, false);
    },
    

    /**
     * Ellipsis long text in a circle area.
     * 
     * @param {String}
     *          text the text to be processed
     * @param {Node}
     *          textNode the svg:text which will be display text
     * @param {Number}
     *          r the radius of circle
     * @param {Number}
     *          h the offset from center of circle
     */
    ellipsisInCircle : function(text, textNode, r, h) {
      var node = applyText(text, textNode);

      var maxLength = Math.sqrt(Math.pow(r, 2)
          - Math.pow(h + node.getBBox().height / 2, 2)) * 2;
      ellipsis(text, textNode, maxLength, null, true);
    },

    verticalCentralOffset : function(text, textNode) {
      var tmpNode = applyText(text, textNode);
      var box = tmpNode.getBBox();
      var actualHeight = -box.y;
      var fontSize = parseInt(tmpNode.ownerSVGElement.getComputedStyle(tmpNode)["fontSize"]);
      return (actualHeight - (box.height - fontSize)) / 2;
    }
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis.DataModule',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TextUtils, NumberUtils) {

    var reBuildDataModule = function(_options)
    {
        var dataModule = null;
        console.log("reBuildDataModule");
        return dataModule;
    };

    return ({
        //public functions
        reBuildDataModule : reBuildDataModule,
    });
});sap.riv.module(
{
  qname : 'sap.viz.base.Repository',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(){
	var generateId = function() {//guid generator
		return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {var r = Math.random()*16|0,v=c=='x'?r:r&0x3|0x8;return v.toString(16);});
	};
	var ExType = {
		ID_REGISTERED 		: 1,
		OBJ_REGISTERED 		: 2,
		ID_NEEDED			: 3,
		ID_NOT_REGISTERED 	: 4,
		OBJ_NULL			: 5
	}
	var createEx = function(type, param1) {
		var ex = {};
		ex.type = type;
		switch (type) {
			case ExType.ID_REGISTERED:
				ex.message = "ID '" + param1 + "' has been registered.";
				break;
			case ExType.OBJ_REGISTERED:
				ex.message = "The vizObj has been registered, its Id is '" + param1 + "'.";
				break;
			case ExType.ID_NEEDED:
				ex.message = "Please specify Id";
				break;
			case ExType.ID_NOT_REGISTERED:
				ex.message = "No vizObj was registered with Id '" + param1 + "'";
				break;
			case ExType.OBJ_NULL:
				ex.message = "Null object is not allowed";
				break;
		}
		return ex;
	}
	
	var registry = {};
	/*member functions of Repository*/
	/*
	 * register a viz object with its ID 
	 * @param id optional, id of vizObj, if null a new id will be generated
	 * @param vizObj
	 * @return id of vizObj
	 * @throws id is registered; vizObj is registered;
	 */
	var registerFunc = function(id, vizObj) {
		if (!vizObj) {
			throw createEx(ExType.OBJ_NULL);
		}
		id = id ? id : generateId();
		//check Id
		if (registry[id]) {
			throw createEx(ExType.ID_REGISTERED, id);
		}
		//check vizObj
		for (var x in registry) {
			if (vizObj == registry[x]) {
				throw createEx(ExType.OBJ_REGISTERED, x);
			}
		}
		registry[id] = vizObj;
		return id;
	};
	/*
	 * unregister a viz object with its ID
	 * @param id id of vizObj
	 * @return
	 * @throws id is null; No vizObj is registered with id;
	 */
	var unregisterFunc = function(id) {
		if (!id) {
			throw createEx(ExType.ID_NEEDED);
		}
		if (!registry[id]) {
			throw createEx(ExType.ID_NOT_REGISTERED, id);
		}
		delete registry[id];
	};
	/*
	 * get a viz object by its ID
	 * @param id id of vizObj
	 * @return vizObj
	 * @throws id is null;
	 */
	var getFunc = function(id) {
		if (!id) {
			throw createEx(ExType.ID_NEEDED, id);
		}
		return registry[id];
	};
	/*
	 * get Ids of all viz objects in repository
	 * @return Id array
	 */
	var getAllFunc = function() {
		var ids = [];
		for (var x in registry) {
			ids.push(x);
		}
		return ids;
	};
	/*
	 * generate a new unique ID beginning with prefix. 
	 * @param prefix
	 * @return id
	 */
	var newIdFunc = function(prefix) {
		var id = generateId();
		return prefix ? prefix + "_" + id : id;
	};
	var Repository = {
		register 	: registerFunc,
		unregister 	: unregisterFunc,
		get 		: getFunc,
		getAll 		: getAllFunc,
		newId 		: newIdFunc
	};
	return Repository;
});sap.riv.module(
{
  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.0'},
[

],
function Setup() {
  var MeasureBasedColoring = {
    getScale : function(minVal, maxVal, ticksCount, startColor, endColor) {
      var t1 = getAccFormat(minVal), t2 = getAccFormat(maxVal);
      var totalPrecision = t1 > t2 ? t1 : t2;
      
      var colorScale = d3.scale.linear().domain([ minVal, maxVal ])
        .range([ startColor, endColor ]).nice();
      
      var niceDomain = colorScale.domain();
      niceDomain = formatRange(niceDomain, totalPrecision);
      
      minVal = niceDomain[0];
      maxVal = niceDomain[1];
      
      if(minVal === maxVal){
        //only one value in range.
        ticksCount = 1;
      }
      var span = maxVal - minVal, ticks = [], step, precision = 0;
      if(span / ticksCount > 1){
        if (span % ticksCount === 0) {
          // divied properly
          step = format(span / ticksCount, totalPrecision + 1);
          precision = getAccFormat(step);
          
          for ( var i = 0; i < ticksCount + 1; i++) {
            ticks.push(minVal + format(i * step, precision));
          }
        } else {
          step = Math.ceil(span / ticksCount);
          precision = getAccFormat(step);
          var start = Math.floor(minVal / step) * step;
          if(start === 0 || (start + step*ticksCount < maxVal)) start = minVal;
          
          for ( var i = 0; i < ticksCount + 1; i++) {
            ticks.push(start + format(i * step, precision));
          }
        }
      }else{
        //Can't be divided with integrate. 
        start = minVal, step = format(span / ticksCount, totalPrecision + 1);
        precision = getAccFormat(step);
        
        for(var i = 0; i < ticksCount; i++){
          ticks.push(start + format(i * step, precision));
        }
        ticks.push(format(maxVal, precision));
      }
      
      //format all values
      for(var i = 0, len = ticks.length; i < len; i++){
        ticks[i] = format(ticks[i], precision);
      }
      
      //reset color scale
      colorScale = d3.scale.linear().domain([ 0, ticksCount-1 ]).range([ startColor, endColor ]);
      
      var domainRg = [], rangeRg = [];
      for ( var i = 0, len = ticks.length - 1; i < len; i++) {
        domainRg.push([ ticks[i], ticks[i + 1] ]);
        rangeRg.push(colorScale(i));
      }

      var fontColorScale = d3.scale.ordinal().domain(domainRg).range(rangeRg);
      return fontColorScale;
    }
  };
  
  var formatRange = function(range, precision){
    for(var i = 0, len = range.length; i < len; i++){
      range[i] = format(range[i], precision);
    }
    return range;
  };
  
  var getAccFormat = function(value){
    var t = value.toString().split(".");
    return t.length > 1 ? t[1].length : 0;
  };
  
  var format = function(value, precision){
    return Math.round(Math.pow(10, precision) * value) / Math.pow(10, precision);
  };
  
  return MeasureBasedColoring;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.wordleLayout',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TextRuler, NumberUtils) {
  var wordleLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';

    var wordle = function() {

    };
    wordle.width = function(_) {
      if (!arguments.length)
        return width;
      width = _;
      return wordle;
    };

    wordle.height = function(_) {
      if (!arguments.length)
        return height;
      height = _;
      return wordle;
    };

    wordle.data = function(_) {
      if (!arguments.length)
        return chartData;

      _.sort(function(a, b) {
        if (a.wordSize && b.wordSize) {
          return b.wordSize.val - a.wordSize.val;
        }
      });
      chartData = _;
      return wordle;
    };

    wordle.font = function(_) {
      if (!arguments.length)
        return font;
      font = _;
      return wordle;
    };

    wordle.layout = function() {
      var relayout = false, layoutCount = 0;
      while (!relayout) {
        relayout = _layout(++layoutCount);
      }
      return wordle;
    };

    var _layout = function(layoutCount) {
      var tagArr = chartData, textSize, d, root;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];

        if (NumberUtils.isNoValue(d.fontSize)) {
          continue;
        }

        textSize = TextRuler.fastMeasure(tagArr[i].word.val + 'i',
            tagArr[i].fontSize + 'px', 'normal', font);

        d.width = textSize.width;
        d.height = textSize.height;

        d.x = undefined;
        d.y = undefined;

        d.rect = new rect(d.width, d.height);

        var flag;
        if (!root) {
          var rotate;
          if (d.width <= width && d.height <= height) {
            rotate = false;
          } else if (d.height <= width && d.width <= height) {
            rotate = true;
          }
          if (rotate != null) {
            root = d;
            if (rotate)
              d.rect.rotate();
            d.rect.position(width / 2, height / 2);
            flag = true;
          }

        } else {
          var list = [];
          list.push(root);
          while (list.length != 0) {
            var parent = list.shift();

            if (parent.child)
              parent.child.forEach(function(c) {
                if (c)
                  list.push(c);
              });

            flag = placeTag(d, parent, root);
            if (flag)
              break;
          }
        }

        if (flag) {
          d.x = d.rect.x;
          d.y = d.rect.y;
          d.rotate = d.rect.rotated ? 90 : 0;
        }
      }

      tagArr.forEach(function(d) {
        delete d.child;
        delete d.rect;
      });

      return true;
    };

    function placeTag(tag, parent, root) {
      var rect = tag.rect;
      var child = parent.child;
      if (!child) {
        child = [];
        parent.child = child;
      }
      for ( var j = 0; j < 2; j++) {
        if (j == 1) {
          rect.rotate();
        }

        for ( var i = 0; i < 4; i++) {
          if (child[i])
            continue;

          var x, y;
          switch (i) {
          case 0:
            x = parent.x;
            y = parent.rect.y0 - rect.h / 2;
            break;
          case 1:
            y = parent.y;
            x = parent.rect.x1 + rect.w / 2;
            break;
          case 2:
            x = parent.x;
            y = parent.rect.y1 + rect.h / 2;
            break;
          case 3:
            y = parent.y;
            x = parent.rect.x0 - rect.w / 2;
            break;
          }

          rect.position(x, y);

          if (rect.x0 >= 0 && rect.y0 >= 0 && rect.x1 <= width
              && rect.y1 <= height) {
            if (validPosition(rect, parent, root)) {
              child[i] = tag;
              return true;
            }
          }
        }
      }

      rect.rotate();

      return false;
    }

    function validPosition(rect, parent, root) {
      if (root != parent)
        if (!rect.notInterects(root.rect))
          return false;

      for ( var i = 0, child = root.child, len = child ? child.length : 0; i < len; i++) {
        if (child[i] && !validPosition(rect, parent, child[i]))
          return false;
      }

      return true;
    }

    function rect(w, h) {
      this.w = w;
      this.h = h;
      this.rotated = false;
    }

    rect.prototype = {
      position : function(x, y) {
        this.x = x;
        this.y = y;

        var _x = this.w / 2, _y = this.h / 2;
        this.x0 = x - _x;
        this.x1 = x + _x;
        this.y0 = y - _y;
        this.y1 = y + _y;
      },

      notInterects : function(rect) {
        return this.x1 <= rect.x0 || this.x0 >= rect.x1 || this.y1 <= rect.y0
            || this.y0 >= rect.y1;
      },

      rotate : function() {
        this.rotated = !this.rotated;
        var t = this.h;
        this.h = this.w;
        this.w = t;
      },
    };

    return wordle;
  };
  return wordleLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.columnLayout',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TextRuler, NumberUtils) {
  var columnLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';

    var column = function() {

    };
    column.width = function(_) {
      if (!arguments.length)
        return width;
      width = _;
      return column;
    };

    column.height = function(_) {
      if (!arguments.length)
        return height;
      height = _;
      return column;
    };

    column.data = function(_) {
      if (!arguments.length)
        return chartData;
      chartData = _;
      return column;
    };

    column.font = function(_) {
      if (!arguments.length)
        return font;
      font = _;
      return column;
    };

    column.layout = function() {
      _layout();
      return column;
    };

    var _layout = function() {
      var tagArr = chartData;
      var d, textSize;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        textSize = TextRuler.fastMeasure(tagArr[i].word.val+'i', tagArr[i].fontSize+'px', 'normal', font);
        d.width = textSize.width;
        d.height = textSize.height;
      }

      var startX = 0, startY = 0;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        if(NumberUtils.isNoValue(tagArr[i].fontSize)){
          continue;
        }
        startY = startY + d.height;
        d.x = startX;
        d.y = startY;
      }
    };
    return column;
  };
  return columnLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud.rowLayout',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TextRuler, NumberUtils) {
  var rowLayout = function() {
    var width = 300, height = 300, chartData = [], font = '';

    var row = function() {

    };
    row.width = function(_) {
      if (!arguments.length)
        return width;
      width = _;
      return row;
    };

    row.height = function(_) {
      if (!arguments.length)
        return height;
      height = _;
      return row;
    };

    row.data = function(_) {
      if (!arguments.length)
        return chartData;
      chartData = _;
      return row;
    };

    row.font = function(_) {
      if (!arguments.length)
        return font;
      font = _;
      return row;
    };

    row.layout = function() {
      _layout();
      return row;
    };

    var _layout = function() {
      var tagArr = chartData;
      var d, textSize;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        textSize = TextRuler.fastMeasure(tagArr[i].word.val+'i', tagArr[i].fontSize+'px', 'normal', font);
        d.width = textSize.width;
        d.height = textSize.height;
      }

      var startX = 0;
      var maxRowHeight = tagArr[0].height, startY = 0, newLineIndex = 0;
      for ( var i = 0, len = tagArr.length; i < len; i++) {
        d = tagArr[i];
        
        if(NumberUtils.isNoValue(tagArr[i].fontSize)){
          continue;
        }
        
        if (startX + d.width > width) {
          // New Row
          startX = 0;
          _adjustLastLineTagPosition(newLineIndex, i, startY + maxRowHeight);
          
          newLineIndex = i;
          startY = startY + maxRowHeight;
          maxRowHeight = tagArr[i].height;
        }
        if(d.height > maxRowHeight){
          maxRowHeight = d.height;
        }
        d.x = startX;
        d.y = startY;
        startX = startX + d.width;
      }
      _adjustLastLineTagPosition(newLineIndex, i, startY + maxRowHeight);
    };
    
    /*
     * Set last line tag position.
     */
    var _adjustLastLineTagPosition = function(startIndex, endIndex, newYPosition){
      var dArr;
      for(var j = startIndex; j < endIndex; j++){
        dArr = chartData[j];
        dArr.y = newYPosition;
      }
    };
    return row;
  };
  return rowLayout;
});sap.riv.module(
{
  qname : 'sap.viz.modules.tagcloud',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tagcloud.rowLayout',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tagcloud.columnLayout',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tagcloud.wordleLayout',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, ColorSeries, RowLayout, ColumnLayout, WordleLayout, MeasureBasedColoring, NumberUtils, Repository, tooltipDataHandler) {
  var tagCloud = function(manifest) {
    var width = 400, height = 200, wrap = null, chartData = {}, tagArr = [], maxfont = 48, minfont = 12, fontColorScale = undefined, selectionList = [], effectManager = null;
    var randomSuffix = Repository.newId();
    var minFontFamily = Number.MAX_VALUE, maxFontFamily = Number.MIN_VALUE, hasNullValue = false, tooltipVisible = true, isDatasetChanged = false;
    var tagStyle = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'color' : '#c0c0c0'
    };
    var options, opacity = 1;
    var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'); //, 'showTooltip', 'hideTooltip'
      
    var decorativeShape = null;
    
    var chart = function(selection) {
      selection.each(function() {
        _calculateTagPosition();
        
        if(decorativeShape == null){
          decorativeShape = selection.append('rect').attr('fill', 'rgba(133,133,133, 0.2)').style('visibility', 'hidden');
        }else{
          decorativeShape.attr('width', 0).attr('height', 0).attr('x', 0).attr('y', 0).style('visibility', 'hidden');
        }
        
        //filter hidden data
        var labelsData = _filterData();
        
        wrap = d3.select(this);

        //remove old data item while updateing dataset
        if(isDatasetChanged && !wrap.selectAll('g.word').empty()){
          wrap.selectAll('g.word').remove();
        }
        
        wrap.attr('style', 'cursor:default');//.on('click', clickHandler).on('mouseover', mouseOverHandler).on('mouseout', mouseOutHandler);
        var wordsWrap = wrap.selectAll('g.word').data(labelsData, function(d, i){
          return (d.word ? d.word.val : "") + " " + (d.wordFontFamily ? d.wordFontFamily.val : "") + " " + (d.wordSize ? d.wordSize.val : "");
        });
        
        wordsWrap.selectAll('text').data(function(d, i){
          return d;
        }).text(function(d, i){ 
          return d.word.val;
        });
        
        var wordsWrapEnter = wordsWrap.enter().append('g').attr('class', 'word').append('text').text(function(d, i){ 
            return d.word.val;
          })
          .attr('id', function(d, i){
            return 'TAG_ID_' + i + randomSuffix;
          })
          .attr('class', 'datapoint')
          .attr('visibility', function(d, i){
            var isVisible = 'visible';
            if(NumberUtils.isNoValue(d.fontSize) || d.x === undefined || d.y === undefined){
              isVisible = 'hidden';
            }
            return isVisible;
          })  
          .attr('font-size', function(d, i){
            return d.fontSize;
          }).attr('fill', function(d, i){
            var color;
            if(fontColorScale && d.wordFontFamily != null && d.wordFontFamily.val !== null){
              var i, len, domain = fontColorScale.domain();
              for(i = 0, len = domain.length - 1; i < len; i++){
                if(d.wordFontFamily.val!=null && (domain[i][1] > d.wordFontFamily.val)){
                  break;
                }
              }
              color = fontColorScale(domain[i]);
            }else{
              color = tagStyle.color;
            }  
            var parameter = {
              fillColor:color,
              drawingEffect:"normal"
            };
            return effectManager.register(parameter);
          }).attr('font-family', tagStyle.fontfamily)
          .attr('text-anchor', function(){
            if(options.layout === 'Wordle'){
              return 'middle';
            }else{
              return 'start';
            }
          });
//        wordsWrap.exit().remove();
        
//        wordsWrap.transition().attr('dx', function(d, i){
//            return d.x;
//          }).attr('dy', function(d, i){
//            return d.y;
//          }).duration(800).delay(100);
        
//        wordsWrap.append('line').attr('stroke', 'red').attr('x1', function(d, i){
//              return d.x + d.x0;
//            }).attr('y1', function(d, i){
//              return d.y;
//            }).attr('x2', function(d, i){
//              return d.x + d.x1;
//            }).attr('y2', function(d, i){
//              return d.y;
//            }).attr('fill', 'none');
        wordsWrap.exit().attr('transform', 'translate(-1000, -1000)');
        
        wordsWrap.selectAll('text').attr('fill-opacity', opacity);
        
        if(options.animation.dataLoading){
          wordsWrap.transition().attr('transform', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined && d.y < height && d.x < width){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            return translate;
          }).duration(800).delay(100).each('end', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined && d.y < height && d.x < width){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            this.setAttribute('transform', translate);
            
            if(i === labelsData.length-1){
              eDispatch.initialized();
            }
          });
        }else{
          wordsWrap.attr('transform', function(d, i){
            var translate = '';
            if(d.x !== undefined && d.y !== undefined){
              translate = 'translate('+[d.x, d.y]+')';
            }else{
              translate = 'translate(-1000, -1000)';
            }
            if(d.rotate){
              translate = translate + " rotate(" + d.rotate + ")";
            }
            return translate;
          });
          eDispatch.initialized(); 
        }
      });
    };
      
      /**
      * set/get width
      */
      chart.width = function(_){
          if (!arguments.length){
            return width;
          }
          width = _;
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(_){
        if (!arguments.length){
          return height;
         }
        height = _;
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
      chart.data = function(_){
        if (!arguments.length){
          return chartData;
         }
        var data = {};
        data.words = _.getAnalysisAxisDataByIdx(0).values[0];

        var wordsData = _.getMeasureValuesGroupDataByIdx(0);
        if(wordsData && _.getMeasureValuesGroupDataByIdx(0).values.length > 0){
          data.wordsSize = _.getMeasureValuesGroupDataByIdx(0).values[0];
        }else{
          data.wordsSize = undefined;
        }
        
        var wordsFontFamilySata = _.getMeasureValuesGroupDataByIdx(1);
        if(wordsFontFamilySata && wordsFontFamilySata.values.length > 0){
          data.wordsFontFamily = _.getMeasureValuesGroupDataByIdx(1).values[0];
        }else{
          data.wordsFontFamily = undefined;
          fontColorScale = undefined;
        }
        _parseData(data);
        
        //Check dataset is changed.
        isDatasetChanged = _isDatasetChanged(data);
        chartData = data;
         return chart;        
      };

      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return options;
         }
         options = manifest.props(props);
         tooltipVisible = options.tooltip.enabled;
      if (fontColorScale) {
        _calculateFontFamily(minFontFamily, maxFontFamily, hasNullValue);
      }
         return chart;
      };
      
      /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return chart;
      };
      
      /**
      * get/set your color palette if you support color palette
      */
      chart.colorPalette = function(_){
        if(!arguments.length){
          return colorPalette;
        }
        colorPalette = _;
        return chart;
      };
      
      /*
       * Font color scale.
       */
      chart.mbcLegendInfo = function(){
        var title = chartData.wordsFontFamily ? chartData.wordsFontFamily.col : '';
        return {
          'colorScale' : fontColorScale,
          'title' : title
        };
      };
      
      
      /*
       * Add mouse interaction functions.
       */
      chart.parent = function(){
        return wrap;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
//            opacity = 0.2;
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
//          opacity = 0.2;
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          wrap.selectAll('.datapoint').attr('fill-opacity', 1);
          opacity = 1;
        }else{
          wrap.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      chart.mouseover = function(point){
        var item = d3.select(d3.event.target);
        var clickedItemID = item.attr('id');
        if(clickedItemID && tooltipVisible){
          var tooltipData = generateTooltipData(item.datum());
          var transform = wrap.node().getTransformToElement(wrap.node().ownerSVGElement);
          var svgRect = wrap.node().ownerSVGElement.getBoundingClientRect();
          var itemRect = item.node().getBoundingClientRect(), wrapRect = wrap.node().getBoundingClientRect();
          
          decorativeShape.attr('width', itemRect.width).attr('height', itemRect.height).attr('x', itemRect.left - wrapRect.left).attr('y', itemRect.top - wrapRect.top).style('visibility', 'visible');
          tooltipData.point = {
            x: itemRect.left - svgRect.left + itemRect.width/2,
            y: itemRect.top - svgRect.top
          };
          
          tooltipData.plotArea = {
            x : transform.e,
          y : transform.f,
          width : width,
          height : height
          };
          
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      };
      
      chart.mouseout = function(){
        decorativeShape.attr('width', 0).attr('height', 0).attr('x', 0).attr('y', 0).style('visibility', 'hidden');
        if(tooltipVisible){
          eDispatch.hideTooltip();
        }
      };
      
      /**
       * interfaces for MBC legend selection
       * @param {Object} selectedData 
       * <pre>
       * {
       * ctx: {
       *   ranges: {
       *    endValue:100
       *    isLeftOpen:false
       *    isRightOpen:true
       *    startValue:84
       *   }
       * },
       * val: 84   
       * }
       * @returns {Array} d3 selections in the given range  
       */
      chart.getDatapointsByRange = function(selectedData){
        var datapoints = d3.selectAll('.datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
        for(var i = 0, len = datapoints.length; i < len; i++){
          data = datapoints[i].__data__.wordFontFamily.val;
          if (NumberUtils.isNoValue(selectedData.val)) {
          if (NumberUtils.isNoValue(data)) {
            ctxDatapoints.push(datapoints[i]);
          }
        } else {
          if (data < ranges.endValue && data > ranges.startValue) {
            ctxDatapoints.push(datapoints[i]);
          } else {
            if (!ranges.isLeftOpen && data === ranges.startValue) {
              ctxDatapoints.push(datapoints[i]);
            } else if (!ranges.isRightOpen
                && data === ranges.endValue) {
              ctxDatapoints.push(datapoints[i]);
            }
          }
        }
        }
        return ctxDatapoints;
      };
      
      /**
     * set/get effect manager
     */
        chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return chart;        
    };
    
    var _isDatasetChanged = function(newData){
      var oldData = chartData, isDatasetChanged = false;
      if(oldData.words && newData.words){
        if(oldData.words.rows.length != newData.words.rows.length){
          isDatasetChanged = true;
        }else if((oldData.wordsFontFamily && !newData.wordsFontFamily) || (!oldData.wordsFontFamily && newData.wordsFontFamily)){
          isDatasetChanged = true;
        }else{
          var oldWords = oldData.words.rows, newWords = newData.words.rows;
          for(var i = 0, iLen = oldWords.length; i < iLen; i++){
            if(oldWords[i].val !== newWords[i].val){
              isDatasetChanged = true;
              break;
            }
          }
        }
      }
      return isDatasetChanged;
    };
      
    var _filterData = function(){
      var labelsData = [], item;
      for(var i = 0, len = tagArr.length; i < len; i++){
        item = tagArr[i];
        if(!(NumberUtils.isNoValue(item.fontSize) || item.x === undefined || item.y === undefined || item.y > height || item.x > width)){
          //Hide this tag, remove it.
          labelsData.push(item);
        }
      }
      return labelsData;
    };
    
      var generateTooltipData = function(data){
        var tooltipData = {
            body: [],
            footer: []
        };
        
        if(chartData.wordsSize){
          tooltipData.body.push({
            name: chartData.wordsSize.col,
            val:[{
              value: data.wordSize.val
            }]
          });
        }
        
        if(chartData.wordsFontFamily){
          tooltipData.body.push({
            name:chartData.wordsFontFamily.col,
            val:[{
              value: data.wordFontFamily.val
            }]
          });
        }
        
        if(chartData.words){
          tooltipData.footer.push({
            label: chartData.words.col.val,
            value: data.word.val
          });
        }
        
        return tooltipData;
      };
        
      var _parseData = function(data){
      tagArr = [];
      var minFontSize = undefined, maxFontSize = undefined, fontfamilyValue;
      minFontFamily = undefined, maxFontFamily = undefined, hasNullValue = false;
      
      for(var i=0, len = data.words.rows.length; i < len; i++){
        tagArr[i] = {};
        tagArr[i].word = data.words.rows[i];
        tagArr[i].wordSize = (data.wordsSize ? data.wordsSize.rows[0][i] : undefined);
        tagArr[i].wordFontFamily = (data.wordsFontFamily ? data.wordsFontFamily.rows[0][i] : undefined);
        
        //For selection event data.
        tagArr[i].val = [data.words.rows[i].val];
        tagArr[i].ctx = [data.words.rows[i].ctx];
        
        if(tagArr[i].word && tagArr[i].word.val === null){
          tagArr[i].word.val = 'Null';
        }
        
        if(tagArr[i].wordSize){
          tagArr[i].val.push(data.wordsSize.rows[0][i].val);
          tagArr[i].ctx.push(data.wordsSize.rows[0][i].ctx);
          
          if(tagArr[i].wordSize.val !== null){
            if(minFontSize === undefined || tagArr[i].wordSize.val < minFontSize){
              minFontSize = tagArr[i].wordSize.val; 
            }
            if(maxFontSize === undefined || tagArr[i].wordSize.val > maxFontSize){
              maxFontSize = tagArr[i].wordSize.val; 
            }
          }
        }
        
        if(tagArr[i].wordFontFamily){
          tagArr[i].val.push(tagArr[i].wordFontFamily.val);
          tagArr[i].ctx.push(tagArr[i].wordFontFamily.ctx);
          
          fontfamilyValue = tagArr[i].wordFontFamily.val;
          
          if(fontfamilyValue === null){
            hasNullValue = true;
          }else{
            if(minFontFamily === undefined || fontfamilyValue < minFontFamily){
              minFontFamily = tagArr[i].wordFontFamily.val; 
            }
            if(maxFontFamily === undefined || fontfamilyValue > maxFontFamily){
              maxFontFamily = tagArr[i].wordFontFamily.val; 
            }
          }
        }
      }
      
      //Linear font weight scale. Add more scale type here.
      _calculateFontSize(minFontSize, maxFontSize);
      if(data.wordsFontFamily){
        _calculateFontFamily(minFontFamily, maxFontFamily, hasNullValue);
      }else{
        fontColorScale = undefined;
      }
    };
    
    /*
     * Calculate font size by font-weight
     */
    var _calculateFontSize = function(min, max){
      //Generate font size arguments
      var count = tagArr.length;
      var a, b, fsize;
      
      if (min == 0){
              min = 1;
              max += 1;
          }
      
      if (count > 1) {
        b = (maxfont - (minfont * (max / min))) / (1 - (max / min));
        a = (minfont - b) / min;
      } else {
        b = 0;
        a = maxfont / (min < 0 ? -min : min);
      }
      
      for(var i=0, len = tagArr.length; i < len; i++){
        //Set Font Size
        if(tagArr[i].wordSize && min != max){
          fsize = Math.round(a * tagArr[i].wordSize.val + b);
        }else{
          fsize = minfont;
        }
        tagArr[i].fontSize = (tagArr[i].wordSize.val === null) ? null : fsize;
      }
    };
    
    /*
     * Calculate font color family.
     */
    var _calculateFontFamily = function(minVal, maxVal, hasNullValue){
      if(minVal === undefined && maxVal === undefined){
        fontColorScale = d3.scale.ordinal().domain([[]]).range([tagStyle.color]);
      }else{
        fontColorScale = MeasureBasedColoring.getScale(minVal, maxVal, 5, options.startColor, options.endColor);
        
        if(hasNullValue){
          var domains = fontColorScale.domain();
          var ranges = fontColorScale.range();
          domains.push([]);
          ranges.push(tagStyle.color);
        }
      }
    };
    
    var _calculateTagPosition = function(){
      var layout = undefined;
      if(options.layout === 'Column'){
        layout = ColumnLayout();
      } else if(options.layout === 'Row'){
        layout = RowLayout();
      } else if(options.layout === 'Wordle'){
        layout = WordleLayout();
      }
      
      if(layout !== undefined){
        //TODO remove me
        var start = (new Date()).valueOf();
        layout.width(width).height(height).data(tagArr).font(tagStyle.fontfamily).layout();
        var end = (new Date()).valueOf();
        //console.log(options.layout, start, end, end-start);
      }
    };
    options = manifest.props(null);
      return chart;
  };
  return tagCloud;
});sap.riv.module(
{
  qname : 'sap.viz.modules.background',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
}
],
function Setup(Repository, dispatch) {
  return function(manifest) {
 
     var CSSCLASS_BORDER = 'viz-plot-background-border',
      CSSCLASS_BACKGROUND = 'viz-plot-background';
    var randomSuffix = Repository.newId();
    var width = 0, 
      height = 0;
    var effectManager,
      properties,
      d3root;
    var eDispatch = new dispatch('initialized');
    
    function background(selection) {
      d3root = selection;
      
      if (properties.visible) {
        var d3rect = d3root.select('#' + 'background-rect-' + randomSuffix);
        if (d3rect.empty()) {
          d3rect = d3root.append('svg:rect').attr('id', 'background-rect-' + randomSuffix);
        }
        var fillID = effectManager.register({
          graphType : 'background',
          fillColor : properties.style.fillColor,
          drawingEffect : properties.drawingEffect,
          direction : properties.direction,
        });
        d3rect.attr('x', 0).attr('y', 0).attr('width', width).attr('height', height).attr('fill', fillID);
        
        var borderData = [];
        if (properties.border.left.visible) {
          borderData.push({
            x1: 0, y1: 0, x2: 0, y2: height,
          });
        }
        if (properties.border.right.visible) {
          borderData.push({
            x1: width, y1: 0, x2: width, y2: height,
          });
        }
        if (properties.border.top.visible) {
          borderData.push({
            x1: 0, y1: 0, x2: width, y2: 0,
          });
        }
        if (properties.border.bottom.visible) {
          borderData.push({
            x1: 0, y1: height, x2: width, y2: height,
          });
        }
        
        drawCSS();
        var d3border = selection.selectAll("." + CSSCLASS_BORDER).data(borderData);
        d3border.enter().append('svg:line').attr('class', CSSCLASS_BORDER);
        d3border.exit().remove();
        d3border.attr('x1', function(d){return d.x1}).attr('y1', function(d){return d.y1})
          .attr('x2', function(d){return d.x2}).attr('y2', function(d){return d.y2});
      } else {
        d3root.remove();
      }
      
      //currently, we do not have animation. If it has, should fire initialized event after animation complete.
      eDispatch.initialized();
      
      return background;
    }
    
    background.properties = function(_){
      if (!arguments.length){
        return properties;
       }
      properties = manifest.props(_);
      getCSSStyle();
      return background;
    };
    background.size = function(_size) {
      if (arguments.length == 0)
        return {
            "width" : width,
            "height": height,
          };
      width = _size.width;
      height = _size.height;
      return background;
    };
    background.width = function(_width) {
      if (arguments.length == 0)
        return width;
      width = _width;
      return background;
    };
    background.height = function(_height) {
      if (arguments.length == 0)
        return height;
      height = _height;
      return background;
    };
    background.data = function(_) {
      if(!arguments.length) {
        return {};
      }
      return background;
    };
    background.parent = function() {
      return null;
    };
    /**
     * set/get effect manager
     */
    background.effectManager = function(_){
      if (!arguments.length){
        return effectManager;
       }
      effectManager = _;
       return background;
     };

     background.dispatch = function(_){
           if(!arguments.length)
             return eDispatch;
           eDispatch = _;return background;
         };
          
    background.properties(null);
    return background;
    
    function drawCSS () {
      var d3defs = d3root.select('#' + 'background-defs-' + randomSuffix);
      if (d3defs.empty()) {
        d3defs = d3root.insert('defs', ':first-child').attr('id', 'background-defs-' + randomSuffix);
      }
      
      var d3style = d3defs.select('style');
      if (d3style.empty()) {
        d3style = d3defs.insert('style', ':first-child');
        d3style[0][0].setAttribute('type', 'text/css');
      }
      var cssStr = '.' + CSSCLASS_BORDER + '{' + manifest.cssText(CSSCLASS_BORDER) + '}';
      d3style[0][0].textContent = cssStr;
    }
    
    function getCSSStyle() {
      if (!properties.style)
        properties.style = {};
      var cssDef;
      if (cssDef = manifest.style(CSSCLASS_BACKGROUND)) {
        if (cssDef['fill']) {
          properties.style.fillColor = cssDef['fill'];
        }
      }
    }

  };
});sap.riv.module(
{
  qname : 'sap.viz.config',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FunctionUtils) {
  
  var configs = {};
  
  var enableCanvg = false; 
  
  var manager = {
      
      constructor : function(){
        return;
      },
      
      enableCanvg : function(_) {
          if(!arguments.length){
            return enableCanvg;
          }
          enableCanvg = _;
          return manager;
      },
      
      register : function(obj) {
          if(configs[obj.id]){
            return;
          }
          configs[obj.id] = obj.value;
          return manager;
      },
        
      get: function(ids){
        if(configs[ids]){
          return configs[ids];
        }
      }
  };
  
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.base.Logger',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FncUtils) {
    var noop = FncUtils.noop;
    // var noop = function() {
    // };
    Date.now = Date.now ||
    function() {
        return +new Date();
    };

    var dispatcherIdleCounter = 0;

    function callAppender(appender) {
        var logTime, logLevel, logCate, logMsg, appenderLevel;

        if(logBuffer[0].length > 0) {
            if(appender) {
                appenderLevel = appender.getLevel();
                for(var i = 0, bl = logBuffer[0].length; i < bl; i++) {
                    logTime = logBuffer[0][i];
                    logLevel = logBuffer[1][i];
                    logCate = logBuffer[2][i];
                    logMsg = logBuffer[3][i];
                    if(logBuffer[1][i] >= appenderLevel)
                        appender.doAppend(logTime, logLevel, logCate, logMsg);
                }
                return;
            }

            //call all appenders
            //var appender;
            var appenderLevelMap = {};
            for(var appenderKey in appenders) {
                if(appenders.hasOwnProperty(appenderKey)) {
                    appenderLevelMap[appenderKey] = appenders[appenderKey].getLevel();
                }
            }
            while(logBuffer[0].length) {
                logTime = logBuffer[0].shift();
                logLevel = logBuffer[1].shift();
                logCate = logBuffer[2].shift();
                logMsg = logBuffer[3].shift();
                for(appenderKey in appenders) {
                    if(appenders.hasOwnProperty(appenderKey)) {
                        appender = appenders[appenderKey];
                        if(logLevel >= appenderLevelMap[appenderKey])
                            appender.doAppend(logTime, logLevel, logCate, logMsg);
                    }
                }
            }
            return;
        } else if(++dispatcherIdleCounter === 3)
            //pause on third time loop an empty Buffer
            pause();
    }

    function dispatcher() {
        callAppender();
        if(!paused)
            setTimeout(function() {
                dispatcher();
            }, 100);
    }

    var ConsoleAppender = function() {
        this.threshold = Logger.LEVEL.INFO;
        this.layout = new Logger.DefaultLayout();
        this.print = typeof console !== undefined ? function(msg) {
            console.log(msg);
        } : noop;
    };
    ConsoleAppender.prototype = {
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.print(this.layout.format(logTime, logLevel, logCate, logMsg));
        },
        setLayout : function(layout) {
            layout.format && (this.layout = layout);
        },
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        }
    };
    var DefaultLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    DefaultLayout.prototype.format = function(logTime, logLevel, logCate, logMsg) {
        return "[" + logTime + "]" + "[" + getLevelStr(logLevel) + "]" + "[" + (logCate || "main") + "]-" + logMsg;
    };
    var DivAppender = function(div) {
        if(!$) {
            throw "need jQuery";
        }
        this.threshold = Logger.LEVEL.INFO;
        this.divSl = $(div);
        this.layout = new HTMLLayout();
    };
    DivAppender.prototype = {
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        },
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.divSl.append(this.layout.format(logTime, logLevel, logCate, logMsg));
        }
    };
    var HTMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    HTMLLayout.prototype = {
        getStyle : function(logLevel) {
            var style;
            if(logLevel === Logger.LEVEL.ERROR) {
                style = 'color:red';
            } else if(logLevel === Logger.LEVEL.WARN) {
                style = 'color:orange';
            } else if(logLevel === Logger.LEVEL.DEBUG) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.TRACE) {
                style = 'color:green';
            } else if(logLevel === Logger.LEVEL.INFO) {
                style = 'color:grey';
            } else {
                style = 'color:yellow';
            }
            return style;
        },
        format : function(logTime, logLevel, logCate, logMsg) {
            return "<div style=\"" + this.getStyle(logLevel) + "\">[" + logTime + "]" + "[" + getLevelStr(logLevel) + "][" + (logCate || "main") + "]-" + logMsg + "</div>";
        }
    };
    var FifoBuffer = function() {
        this.array = [];
    };

    FifoBuffer.prototype = {

        /**
         * @param {Object} obj any object added to buffer
         */
        push : function(obj) {
            this.array[this.array.length] = obj;
            return this.array.length;
        },
        /**
         * @return first putted in Object
         */
        pull : function() {
            if(this.array.length > 0) {
                var firstItem = this.array[0];
                for(var i = 0; i < this.array.length - 1; i++) {
                    this.array[i] = this.array[i + 1];
                }
                this.array.length = this.array.length - 1;
                return firstItem;
            }
            return null;
        },
        length : function() {
            return this.array.length;
        }
    };
    var AjaxAppender = function(url) {
        this.loggingUrl = url;
        this.isInProgress = false;
        this.threshold = Logger.LEVEL.INFO;
        this.bufferSize = 20;
        this.timeout = 2000;
        this.loggingEventMap = [];
        this.layout = new Logger.JSONLayout();
        this.httpRequest = null;
        this.timer = undefined;
    };
    function tryAppend() {
        var appender = this;
        if(this.isInProgress === true) {
            setTimeout(function() {
                tryAppend.call(appender);
            }, 100);
        }else{
            this.send();
        }
    }


    AjaxAppender.prototype = {
        getLevel : function() {
            return this.threshold;
        },
        setLevel : function(level) {
            this.threshold = level;
        },
        doAppend : function(logTime, logLevel, logCate, logMsg) {
            this.loggingEventMap.push([logTime, logLevel, logCate, logMsg]);
            if(this.loggingEventMap.length <= this.bufferSize || this.isInProgress === true) {
                var appender = this;
                if(this.timer === undefined) {
                    this.timer = setTimeout(function() {
                        tryAppend.call(appender);
                    }, 100);
                }
            }

            if(this.loggingEventMap.length >= this.bufferSize && this.isInProgress === false) {
                //if bufferSize is reached send the events and reset current bufferSize
                if(this.timer !== undefined)
                    clearTimeout(this.timer);
                this.send();
            }
        },
        send : function() {
            if(this.loggingEventMap.length > 0) {
                this.isInProgress = true;
                var a = [];
                var loggingEvent;
                for(var i = 0, lml = this.loggingEventMap.length; i < lml && i < this.bufferSize; i++) {
                    loggingEvent = this.loggingEventMap.shift();
                    a.push(this.layout.format(loggingEvent[0], loggingEvent[1], loggingEvent[2], loggingEvent[3]));
                }

                var content = this.layout.getHeader();
                content += a.join(this.layout.getSeparator());
                content += this.layout.getFooter();

                var appender = this;
                if(this.httpRequest === null) {
                    this.httpRequest = this.getXmlHttpRequest();
                }
                this.httpRequest.onreadystatechange = function() {
                    appender.onReadyStateChanged.call(appender);
                };

                this.httpRequest.open("POST", this.loggingUrl, true);
                // set the request headers.
                this.httpRequest.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                this.httpRequest.setRequestHeader("Content-length", content.length);
                //this.httpRequest.setRequestHeader("Content-type", this.layout.getContentType());
                this.httpRequest.send(content);
                appender = this;

                try {
                    setTimeout(function() {
                        appender.httpRequest.onreadystatechange = function() {
                        };
                        appender.httpRequest.abort();
                        //this.httpRequest = null;
                        appender.isInProgress = false;

                        if(appender.loggingEventMap.length > 0) {
                            appender.send();
                        }
                    }, this.timeout);
                } catch (e) {
                }
            }
        },
        onReadyStateChanged : function() {
            var req = this.httpRequest;
            if(this.httpRequest.readyState !== 4) {
                return;
            }

            var success = (( typeof req.status === "undefined") || req.status === 0 || (req.status >= 200 && req.status < 300));

            if(success) {

                //ready sending data
                this.isInProgress = false;

            } else {
            }
        },
        getXmlHttpRequest : function() {

            var httpRequest = false;

            try {
                if(window.XMLHttpRequest) {// Mozilla, Safari, IE7...
                    httpRequest = new XMLHttpRequest();
                    if(httpRequest.overrideMimeType) {
                        httpRequest.overrideMimeType(this.layout.getContentType());
                    }
                } else if(window.ActiveXObject) {// IE
                    try {
                        httpRequest = new ActiveXObject("Msxml2.XMLHTTP");
                    } catch (e) {
                        httpRequest = new ActiveXObject("Microsoft.XMLHTTP");
                    }
                }
            } catch (e) {
                httpRequest = false;
            }

            if(!httpRequest) {
                throw "browser don't support AJAX";
            }

            return httpRequest;
        }
    };
    var JSONLayout = function() {

    };
    JSONLayout.prototype = {
        /**
         * Implement this method to create your own layout format.
         * @param {Log4js.LoggingEvent} loggingEvent loggingEvent to format
         * @return formatted String
         * @type String
         */
        format : function(logTime, logLevel, logCate, logMsg) {

            var jsonString = "{\n \"LoggingEvent\": {\n";
            jsonString += "\t\"category\": \"" + (logCate || "main") + "\",\n";
            jsonString += "\t\"level\": \"" + getLevelStr(logLevel) + "\",\n";
            jsonString += "\t\"message\": \"" + logMsg + "\",\n";
            // jsonString += "\t\"referer\": \"" + referer + "\",\n";
            // jsonString += "\t\"useragent\": \"" + useragent + "\",\n";
            jsonString += "\t\"timestamp\": \"" + logTime + "\"\n";
            jsonString += "}\n}";

            return jsonString;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/json";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "{" + "\"ClientInfo\" : {\n" + "\t\"useragent\": \"" + useragent + "\",\n" + "\t\"referer\": \"" + referer + "\"\n},\n" + "\"VizLogger\": [\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "\n]}";
        },
        getSeparator : function() {
            return ",\n";
        }
    };

    /**
     * Get the XMLHttpRequest object independent of browser.
     * @private
     */
    var XMLLayout = function() {
        // this.df = Logger.dateFormatter;
    };
    XMLLayout.prototype = {
        format : function(logTime, logLevel, logCate, logMsg) {

            var content = "<vizLogger:event category=\"";
            content += (logCate || "main") + "\" level=\"";
            content += getLevelStr(logLevel) + "\" timestamp=\"";
            content += logTime + "\">\n";
            content += "\t<vizLogger:message><![CDATA[" + this.escapeCdata(logMsg) + "]]></vizLogger:message>\n";
            content += "</vizLogger:event>";

            return content;
        },
        /**
         * Returns the content type output by this layout.
         * @return The base class returns "text/xml".
         * @type String
         */
        getContentType : function() {
            return "text/xml";
        },
        /**
         * @return Returns the header for the layout format. The base class returns null.
         * @type String
         */
        getHeader : function() {
            var useragent = "unknown";
            try {
                useragent = navigator.userAgent;
            } catch(e) {
                useragent = "unknown";
            }

            var referer = "unknown";
            try {
                referer = location.href;
            } catch(e) {
                referer = "unknown";
            }
            return "<vizLogger:eventSet useragent=\"" + useragent + "\" referer=\"" + referer.replace(/&/g, "&amp;") + "\">\n";
        },
        /**
         * @return Returns the footer for the layout format. The base class returns null.
         * @type String
         */
        getFooter : function() {
            return "</vizLogger:eventSet>\n";
        },
        getSeparator : function() {
            return "\n";
        },
        /**
         * Escape Cdata messages
         * @param str {String} message to escape
         * @return {String} the escaped message
         * @private
         */
        escapeCdata : function(str) {
            return str.replace(/\]\]>/, "]]>]]&gt;<![CDATA[");
        }
    };

    function getLevelStr(levelInt) {
        switch(levelInt) {
            case Logger.LEVEL.TRACE:
                return "TRACE";
            case Logger.LEVEL.DEBUG:
                return "DEBUG";
            case Logger.LEVEL.INFO:
                return "INFO";
            case Logger.LEVEL.WARN:
                return "WARN";
            case Logger.LEVEL.ERROR:
                return "ERROR";
        }
    }

    var enabled = false;
    var paused = false;
    var logBuffer = [[/*logTime*/], [/*level*/], [/*category*/], [/*message*/]];
    var MaxBufferSize = 2000;
    var doLog = function(level, category, message) {
        if(logBuffer[0].length === MaxBufferSize)
            callAppender();
        logBuffer[0].push(Date.now());
        logBuffer[1].push(level);
        logBuffer[2].push(category);
        logBuffer[3].push(message.toString());
    };
    var awakeThenLog = function(level, category, message) {
        resume();
        doLog(level, category, message);
    };
    var log = noop;
    var pause = function() {
        paused = true;
        log = awakeThenLog;
    };
    var resume = function() {
        paused = false;
        log = doLog;
        setTimeout(function() {
            dispatcher();
        }, 100);
    };
    // id for appender
    var id = 0;
    var nextId = function() {
        return id++;
    };
    var appenders = {};
    /*
     * singleton Logger
     *
     */
    var Logger = {
        LEVEL : {
            TRACE : 5000,
            DEBUG : 10000,
            INFO : 20000,
            WARN : 30000,
            ERROR : 40000,
            NO : Number.MAX_VALUE
        },
        isEnabled : function() {
            return enabled;
        },
        enable : function() {
            log = doLog;
            enabled = true;
            setTimeout(function() {
                dispatcher();
            }, 100);
        },
        disable : function() {
            callAppender();
            log = noop;
            enabled = false;
        },
        toggleEnable : function() {
            if(enabled)
                this.disable();
            else
                this.enable();
        },
        addAppender : function(/*[key,] appender*/) {
            var _nextId = nextId();
            var key, appender;
            if(arguments.length === 1) {
                key = _nextId;
                appender = arguments[0];
            } else if(arguments.length >= 2) {
                key = arguments[0];
                appender = arguments[1];
            }
            if( typeof appender === "object" && appender.doAppend) {
                if(appenders[key] !== undefined)
                    return;
                callAppender();
                appenders[key] = appender;
                return key;
            }

        },
        setAppenders : function(apds) {
            appenders = [];
            for(var i = 0, l = apds.length; i < l; i++) {
                var appender = apds[i];
                if(appender.appenderKey)
                    this.addAppender(appender.appenderKey, appender.appender);
                else
                    this.addAppender(appender.appender);
            }
        },
        removeAppender : function(key) {
            if(appenders[key] === undefined)
                return false;
            //append immediately before remove
            callAppender(appenders[key]);
            return (
            delete appenders[key]);
        },
        getAppender : function(key) {
            return appenders[key];
        },
        ConsoleAppender : ConsoleAppender,
        DivAppender : DivAppender,
        AjaxAppender : AjaxAppender,
        //[time][level][category]-message [yyyy-MM-ddThh:mm:ss:ms][INFO][function1]-this is a piece of log.
        DefaultLayout : DefaultLayout,
        HTMLLayout : HTMLLayout,
        XMLLayout : XMLLayout,
        JSONLayout : JSONLayout,
        trace : function(message, category) {
            log(Logger.LEVEL.TRACE, category, message);
        },
        debug : function(message, category) {
            log(Logger.LEVEL.DEBUG, category, message);
        },
        info : function(message, category) {
            log(Logger.LEVEL.INFO, category, message);
        },
        warn : function(message, category) {
            log(Logger.LEVEL.WARN, category, message);
        },
        error : function(message, category) {
            log(Logger.LEVEL.ERROR, category, message);
        }
    };
    appenders["[default]"] = new Logger.ConsoleAppender();
    return Logger;
});sap.riv.module(
{
  qname : 'sap.viz.env',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Logger',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.config',
  version : '4.0.0'
}
],
function Setup(TypeUtils, LOG, langManager, config) {
    var _setLogLevel = function(_level) {
        if(TypeUtils.isExist(_level)) {
            LOG.setLevel(_level);
        }
    };
    var _initLogger = function(options) {
        if(!options)
            return;
        if(options.enable)
            LOG.enable();
        if(!options.appenders)
            return;
        for(var i = 0, l = options.appenders.length; i < l; i++) {
            var appender = options.appenders[i];
            if(appender.appenderKey)
                LOG.addAppender(appender.appenderKey, appender.appender);
            else
                LOG.addAppender(appender.appender);
        }
        // LOG.addAppender('analyzerAppender', new AnalyzerAppender());
        // LOG.addAppender("ajaxApp", new LOG.AjaxAppender("http://localhost:8800"));
        // LOG.getAppender("ajaxApp").setLevel(LOG.LEVEL.DEBUG);
        //LOG.getAppender("[default]").setLevel(_level);
    };
    
    var _initLocal = function(options, callback){
      langManager.apply(options.locale, callback);
    };
    
    var env =
    /**
     * @lends sap.viz.Environment
     */
    {
        /**
         * @constructs
         */
        constructor : function() {

        },
        /**
         * initialize visualization environment
         * @param {Object}
         *            option {locale:'en_US'}
         *
         */
        initialize : function(option, callback) {
          if(!option)return;
            _initLogger(option.log);
            if(option.locale){
              _initLocal(option, callback);
            }else{
              if(callback)callback.call();
            }
            config.enableCanvg(option.enableCanvg);
            // _setLogLevel(option.log);
        },
        
        /**
         * @ignore
         * @param enable
         */
        setLoggerEnable : function(enable) {
            if(enable === true)
                LOG.enable();
            else if(enable === false)
                LOG.disable();
        },
        
        /**
         * @ignore
         * @returns TODO: add desc
         */
        addLogAppender : function() {
            if(arguments.length === 1)
                return LOG.addAppender(arguments[0]);
            else if(arguments.length === 2)
                return LOG.addAppender(arguments[0], arguments[1]);
        },
        
        /**
         * @ignore
         * @param key
         * @returns TODO: add desc
         */
        removeLogAppender : function(key) {
            return LOG.removeAppender(key);
        },
    };

    return env;
});sap.riv.module(
{
  qname : 'sap.viz.modules.layout',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils) {
  
  /*
   * Function set that represents a light-weight layout manager
   * who calculates optimal component layout data, rather than
   * operating on components directly.
   */
  return function ( spec ) {
    
    var defaults = {
      resize : true,
      type : 'grid',
      padding : [0,0,0,0],
      hgap : 0,
      vgap : 0
    };  
  
    var hgap = spec.hgap || defaults.hgap,
        vgap = spec.vgap || defaults.vgap,
        padding = spec.padding || defaults.padding,
        bias = spec.bias || 'none';
    
    //Jimmy8/7/2012, different layout function may return different layoutSolution
    //so initialize it in each layout function
    var layoutSolution; // returning data
    
    switch ( spec.type ) {
    case 'border' : 
      border(spec.prefs);
      break;
    case 'grid' :
      grid(spec.prefs);
      break;
    case 'table' :
      //FIXME Elliott/Jimmy 8/7/2012, table layout has some special options
      //here we will read spec inside table layout function directly. consider
      //making it consistent with others 
    table();
    break;
    default :
      grid(spec.prefs);
    }
    
    /**
     * Represents a border-docking layout method which assigns components
     * with spaces of omni-directional border insets. Padding is leaved
     * prior to layout. Component marked as a bias will be processed first
     * to embody the predominance of it. North and South parts are naturally
     * biased against other parts due to the nature of border layout. So
     * the bias attribute supports up to two values: 'west', 'east' or both
     * (in an array and order matters). The center part is under passive 
     * control and queued last to be processed.
     * 
     * ---------------------------------------
     * |               Padding               |
     * |   -------------------------------   |
     * |   |     |     North       |     |   |
     * |   -------------------------------   |
     * |   |     |                 |     |   |
     * |   |  W  |                 |  E  |   |
     * |   |  e  |     Center      |  a  |   |
     * |   |  s  |                 |  s  |   |
     * |   |  t  |                 |  t  |   |
     * |   |     |                 |     |   |
     * |   |     |                 |     |   |
     * |   -------------------------------   |
     * |   |     |     South       |     |   |
     * |   -------------------------------   |
     * |                                     |
     * ---------------------------------------
     */
    function border( options ) {
    layoutSolution = {};
      var packedSize = {}; // Size without paddings.
      packedSize.width = spec.size.width - padding[1] - padding[3];
      packedSize.height = spec.size.height - padding[0] - padding[2];
      
      // Enclosing dimension bounds
      var minX = padding[3],
          minY = padding[0],
          maxX = spec.size.width - padding[1],
          maxY = spec.size.height - padding[2];

      var queue = new Array, i;
      
      // Layout ordering rule
      if ( bias instanceof Array ) {
        queue[0] = bias[0];
        queue[1] = bias[1];
        queue[2] = 'north';
        queue[3] = 'south';
      } else {
        switch ( bias ) {
        case 'west' :
          queue[0] = 'west';
          queue[1] = 'north';
          queue[2] = 'south';
          queue[3] = 'east';
          break;
        case 'east' :
          queue[0] = 'east';
          queue[1] = 'north';
          queue[2] = 'south';
          queue[3] = 'west';
          break;
        default :
          queue[0] = 'north';
          queue[1] = 'south';
          queue[2] = 'east';
          queue[3] = 'west';
        }
      }
      queue[4] = 'center';
      
      for ( i = 0; i < queue.length; i++ ) {
        doLayout(queue[i]);
      }
      
      function doLayout( division ) {
          
                function getAvailableSpacings(maxSize) {
                    if (arguments.length < 2) {
                        return 0;
                    }
                    var spacings = Array.prototype.slice.apply(arguments).slice(1);
                    var spacingsByOrder = [];
                    for (var i = 0; i < spacings.length; i++) {
                        if (spacings[i].length > 1) {
                            spacingsByOrder[i] = spacings[i].slice(1);
                            spacingsByOrder[i].push(spacings[i][0]);
                        }
                    }
                    
                    var availableSpacings = 0;
                    var availableSpacingsSum = 0;
                    for (var i = 0; i < spacingsByOrder[0].length; i++) {
                        for (var j = 0; j < spacingsByOrder.length; j++) {
                            availableSpacingsSum += spacingsByOrder[j][i];
                        }
                        if (availableSpacingsSum > maxSize) {
                            return availableSpacings;
                        }
                        availableSpacings += spacingsByOrder[0][i];
                    }
                    return availableSpacings;
                }

        var node = {}, preferredSize = {};
        if ( division === 'north' && options.north ) {
          node = layoutSolution.north = {};
          preferredSize = options.north.size;
          var nodeHeight = preferredSize.height;
          var heightSum = nodeHeight;
          if (preferredSize.spacings && options.south && options.south.size.spacings) {
              heightSum += options.south.size.height;
          }
          
          if (preferredSize.maxSizeConstant && heightSum > packedSize.height * preferredSize.maxSizeConstant) {
              if (preferredSize.hideOversize) {
                  nodeHeight = 0;
              } else if (preferredSize.spacings) {
                  if (options.south && options.south.size.spacings) {
                      nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings, options.south.size.spacings);
                  } else {
                      nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings);
                  }
              } else {
                  nodeHeight = packedSize.height * preferredSize.maxSizeConstant;
              }
          }
          node.bounds = { 
            x : minX, 
            y : minY,
            width  : maxX - minX,
            height : nodeHeight
          };
          minY += (node.bounds.height + hgap);
          if (node.bounds.height == 0) {
              layoutSolution.north = null;
          }
        }
        
        if ( division === 'east' && options.east ) {
          node = layoutSolution.east = {};
          preferredSize = options.east.size;
          var nodeWidth = preferredSize.width;
          var widthSum = nodeWidth;
          if (preferredSize.spacings && options.west && options.west.size.spacings) {
              widthSum += options.west.size.width;
          }
          if (preferredSize.maxSizeConstant && widthSum > packedSize.width * preferredSize.maxSizeConstant) {
              if (preferredSize.hideOversize) {
                  nodeWidth = 0;
              } else if (preferredSize.spacings) {
                  if (options.west && options.west.size.spacings) {
                      nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings, options.west.size.spacings);
                  } else {
                      nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings);
                  }
              } else {
                  nodeWidth = packedSize.width * preferredSize.maxSizeConstant;
              }
          }
          if (nodeWidth < preferredSize.minWidth) {
              nodeWidth = 0;
          }
          node.bounds = { 
            x : maxX - nodeWidth,
            y : minY,
            width : nodeWidth,
            height : maxY - minY
          };
          
          if (node.bounds.height < preferredSize.minHeight) {
              node.bounds.width = 0;
          }
          
          maxX -= (node.bounds.width - vgap);
          if (node.bounds.width == 0) {
              layoutSolution.east = null;
          }
        }
        
        if ( division === 'south' && options.south ) {
          node = layoutSolution.south = {};
          preferredSize = options.south.size;
          var nodeHeight = preferredSize.height;
          var heightSum = nodeHeight;
          if (preferredSize.spacings && options.north && options.north.size.spacings) {
              heightSum += options.north.size.height;
          }
          if (preferredSize.maxSizeConstant && heightSum > packedSize.height * preferredSize.maxSizeConstant) {
              if (preferredSize.hideOversize) {
                  nodeHeight = 0;
              } else if (preferredSize.spacings) {
                  if (options.north && options.north.size.spacings) {
                      nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings, options.north.size.spacings);
                  } else {
                      nodeHeight = getAvailableSpacings(packedSize.height * preferredSize.maxSizeConstant, preferredSize.spacings);
                  }
              } else {
                  nodeHeight = packedSize.height * preferredSize.maxSizeConstant;
              }
          }
          node.bounds = {
            x : minX,
            y : (maxY - nodeHeight) < minY ? minY : (maxY - nodeHeight),
            width  : maxX - minX
          };
          node.bounds.height = nodeHeight;
          maxY -= (node.bounds.height - hgap);
          if (node.bounds.height == 0) {
              layoutSolution.south = null;
          }
        }
        
        if ( division === 'west' && options.west ) {
          node = layoutSolution.west = {};
          preferredSize = options.west.size;
          var nodeWidth = preferredSize.width;
          var widthSum = nodeWidth;
          if (preferredSize.spacings && options.east && options.east.size.spacings) {
              widthSum += options.east.size.width;
          }
          if (preferredSize.maxSizeConstant && widthSum > packedSize.width * preferredSize.maxSizeConstant) {
              if (preferredSize.hideOversize) {
                  nodeWidth = 0;
              } else if (preferredSize.spacings) {
                  if (options.east && options.east.size.spacings) {
                      nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings, options.east.size.spacings);
                  } else {
                      nodeWidth = getAvailableSpacings(packedSize.width * preferredSize.maxSizeConstant, preferredSize.spacings);
                  }
              } else {
                  nodeWidth = packedSize.width * preferredSize.maxSizeConstant;
              }
          }
          node.bounds = {
            x : minX,
            y : minY,
            width  : nodeWidth,
            height : (minY + preferredSize.height) > maxY ? maxY : (minY + preferredSize.height)
          };
          minX += (node.bounds.width + vgap);
          if (node.bounds.width == 0) {
              layoutSolution.west = null;
          }
        }
        
        if ( division === 'center' && options.center ) {
          node = layoutSolution.center = {};
          node.bounds = {
            x : minX,
            y : minY,
            width  : maxX - minX,
            height : maxY - minY
          };
        }
      }
    }
    
    function grid( options ) {}
    
    /**
     * compared to HTML table, currently we only support cellpadding. we don't (need) support cellspacing 
   * @param {Object} options
     */
    function table( options ) {
      layoutSolution = [];//return layout solution by column * row
      //table layout options
      var columns = TypeUtils.isExist(spec.columns) ? spec.columns : 3;
      var rows = TypeUtils.isExist(spec.rows) ? spec.rows : 2;
      var cellpadding = TypeUtils.isExist(spec.cellpadding) ? spec.cellpadding : 5;
      var paddingThreshold = TypeUtils.isExist(spec.paddingThreshold) ? spec.paddingThreshold : 0.1;
      
      var packedSize = {}; // Size without paddings.
        packedSize.width = spec.size.width - padding[1] - padding[3];
        packedSize.height = spec.size.height - padding[0] - padding[2];
        
        var avgWidth = packedSize.width/columns;
        var avgHeight = packedSize.height/rows;
        //don't make the cellPadding too large
        if (cellpadding > avgWidth * paddingThreshold || cellpadding > avgHeight * paddingThreshold){
          cellpadding = 2;
        }
        var cellWidth = (packedSize.width - 2 * columns * cellpadding)/columns;
        cellWidth = cellWidth > 0 ? cellWidth : 0;
        var cellHeight = (packedSize.height - 2 * rows * cellpadding)/rows;
        cellHeight = cellHeight > 0 ? cellHeight : 0;
      
        // Enclosing dimension bounds
        var minX = padding[3],
        minY = padding[0],
        maxX = spec.size.width - padding[1],
        maxY = spec.size.height - padding[2];
        
        for( var col = 0; col < columns; col++ ){
          var colia = [];//column iteration array
          for( var row = 0; row < rows; row++ ){
            var node = {};
            node.bounds = {
              x: col * avgWidth + avgWidth/2 - cellWidth/2,
              y: row * avgHeight + avgHeight/2 - cellHeight/2,
              width: cellWidth,
              height: cellHeight
            };
            colia.push(node);
          }
          layoutSolution.push(colia);
        }
        
    }
    
    return layoutSolution;
  };
  
});sap.riv.module(
{
  qname : 'sap.viz.data.description.AnalysisAxis',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.data.description.DimensionLabels',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
 function Setup(DimensionLabels, FunctionUtils){
   
   var AnalysisAxis = function(data){
     this._dimensionLabels = new Array();
     this.init(data);
    
   };
   
   AnalysisAxis.prototype.init = function(data){
     
       for(var i = 0; i < data.length; i++){
         this._dimensionLabels[i] = new DimensionLabels(data[i]["name"], data[i]["type"]? data[i]["type"] : "Dimension",
                                                    data[i]["values"] );
         
         this._dimensionLabels[i].fake( data[i]["isFake"] ? data[i]["isFake"] : false);
         this._dimensionLabels[i].infos( data[i]["infos"] ? data[i]["infos"] : null);
       }
   };
   
   AnalysisAxis.prototype.getDimensionLabels = function(){
     return this._dimensionLabels;
   };
   
   AnalysisAxis.prototype.getType = function(){
     return "analysisAxis";
   };
   
   AnalysisAxis.prototype.validate  = function(){
      
      var labels = 1;
      var dimensions = this.getDimensionLabels();
      for(var i = 0; i < dimensions.length;i++){
        if(i == 0){
           labels = dimensions[i].getValues().length;
           if(dimensions[i].infos() != null && labels != dimensions[i].infos().length){
              FunctionUtils.error(dimensions[i].getId() + " wrong infos count");
           }
        }
        else{
         if(labels != dimensions[i].getValues().length)
          FunctionUtils.error(dimensions[i].getId() + " wrong dimension labels count");
         
         if(dimensions[i].infos() != null && labels != dimensions[i].infos().length){
                FunctionUtils.error(dimensions[i].getId() + " wrong infos count");
         }
        }
      }
      
      return labels;
     
   };
   
   AnalysisAxis.prototype.hasFakeData = function(){
      var dimensions = this.getDimensionLabels();
      for(var i = 0; i < dimensions.length;i++){
        if(dimensions[i].fake())
         return true;
      }
      
      return false;
   };
   
   return AnalysisAxis;
 });sap.riv.module(
{
  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],

function Setup(FunctionUtils){
  
  var MeasureValuesDataHandler = {
      
      makeMeasureValues: function(ctx, mvg, axisIndex, maxAxisNumber, matchMeasure){
          
          var values = [];
          for(var i = 0; i < mvg.values.length; i++){
            if(matchMeasure && i != ctx.path.mi)
               continue;
            
            var value = {};
            var mv = mvg.values[i];
            var rows = mv["rows"];
          value["col"] = mv["col"];
          if(ctx)
               value["rows"] = this.createMeasureValues(ctx, rows, axisIndex, maxAxisNumber);
          else
             value["rows"] = this.createMeasureValuesWithoutCtx(rows, axisIndex, maxAxisNumber);
          
            values.push(value);
           }
          
          return values;
        },
       
        /**
         * Create Measure values without context
         *   
         * @param rows
         * @param axisIndex
         * @returns {Array}
         */
        createMeasureValuesWithoutCtx_1_2 : function(rows, axisIndex){
          var values = [];
          if(axisIndex[0] == 1){
           var row = [];
           for(var j = 0; j < rows[0].length; j++){
             row.push(rows[0][j]);
           }   
           values.push(row);
           
         }else if(axisIndex[0] == 2){     
           for(var j = 0; j < rows[0].length; j++){
             var row = [];
             row.push(rows[0][j]);
             values.push(row);
           }   
         }else{
           FunctionUtils.error("Not supported");
         } 
          
          return values;
        },
        
        createMeasureValuesWithoutCtx_1_3 : function(rows, axisIndex){
           var values = [];
           if(axisIndex[0] == 1){
           var row = [];
           for(var j = 0; j < rows[0].length; j++){
             row.push(rows[0][j]);
           }   
           values.push([row]);
           
         }else if(axisIndex[0] == 2){
           var row = [];
           for(var j = 0; j < rows[0].length; j++){
             row.push([rows[0][j]]);
           }
           values.push(row);
           
         }else if(axisIndex[0] == 3){   
           for(var j = 0; j < rows[0].length; j++){
             var row = [];
             row.push([rows[0][j]]);
             values.push(row);
           }
         }else{
           FunctionUtils.error("Not supported");
         }  
           
           return values;
        },
        
        createMeasureValuesWithoutCtx : function(rows, axisIndex, maxAxisNumber){
         if(axisIndex.length == 1){
           if(maxAxisNumber == 1 || maxAxisNumber == 2){
            return this.createMeasureValuesWithoutCtx_1_2(rows, axisIndex); 
           }else if(maxAxisNumber == 3){
              return this.createMeasureValuesWithoutCtx_1_3(rows, axisIndex);
           }else{
             FunctionUtils.error("Not supported");
           }
         }else if(axisIndex.length == 2){
           if(maxAxisNumber == 2)
              return rows;
           else if(maxAxisNumber == 3){
            return this.createMeasureValues_2_3(rows, axisIndex); 
           }else{
             FunctionUtils.error("Not supported");
           } 
           
         }else{
           FunctionUtils.error("Not supported");
         }
         
         return values;
      },
      
      /**
         * Create Measure values without context
         *   
         * @param rows
         * @param axisIndex
         * @returns {Array}
         */
        createMeasureValues_1_2 : function(ctx, rows, axisIndex){
          var values = [];
           if(axisIndex[0] == 1){
           var row = [];
           for(var j = 0; j < rows.length; j++){
             row.push(rows[j][ctx.path.dii]);
           }   
           values.push(row);
           
         }else if(axisIndex[0] == 2){
           
           for(var j = 0; j < rows.length; j++){
             var row = [];
             row.push(rows[j][ctx.path.dii]);
             values.push(row);
           }  
           
         }else{
           FunctionUtils.error("Not supported");
         } 
          
          return values;
        },
        
        createMeasureValues_1_3 : function(ctx, rows, axisIndex){
          var values = [];
          if(axisIndex[0] == 1){
             
           var row = [];
           for(var j = 0; j < rows.length; j++){
             row.push(rows[j][ctx.path.dii]);
           }   
           values.push([row]);
           
         }else if(axisIndex[0] == 2){
           var row = [];
           for(var j = 0; j < rows.length; j++){
             
             row.push([rows[j][ctx.path.dii]]);
             
           }  
           values.push(row);
           
         }else if(axisIndex[0] == 3){
           
           for(var j = 0; j < rows.length; j++){
             var row = [];
             row.push([rows[j][ctx.path.dii]]);
             values.push(row);
           }
           
         }else{
           FunctionUtils.error("Not supported");
         }
           
           return values;
        },
      
      createMeasureValues : function(ctx, rows, axisIndex, maxAxisNumber){
         var values = [];
         if(axisIndex.length == 1){
           if(maxAxisNumber == 1 || maxAxisNumber == 2){
            return this.createMeasureValues_1_2(ctx, rows, axisIndex); 
           }else if(maxAxisNumber == 3){
             return this.createMeasureValues_1_3(ctx, rows, axisIndex);
           }else{
              FunctionUtils.error("Not supported");
           }
         }else if(axisIndex.length == 2){
           if(maxAxisNumber == 2)
            return rows;
           else if(maxAxisNumber == 3){
            return this.createMeasureValues_2_3(rows, axisIndex);
           }
           else{
            FunctionUtils.error("Not supported");
           }
           
         }else{
           FunctionUtils.error("Not supported");
         }
           
         
           return values;
      },
     
        createMeasureValues_2_3 : function(rows, axisIndex){
          if(axisIndex[0] == 1 && axisIndex[1] == 2){
            return [rows];
          }else if(axisIndex[0] == 1 && axisIndex[1] == 3){
            var values = [];
            for( var i = 0 ; i < rows.length; i++){
              values.push([rows[i]]);
            }
            return values;
            
          }else if(axisIndex[0] == 2 && axisIndex[1] == 3){
            var values = [];
            for( var i = 0 ; i < rows.length; i++){
              var value = [];
              var cols = rows[i];
              for(var j = 0; j < cols.length; j++){
                var col = cols[j];
                value.push([col]);
              }
              values.push(value);
            }
            
            return values;
          }else{
            FunctionUtils.error("Not supported");
          }
        }
        
     };
  
  return MeasureValuesDataHandler;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.mbcLegendArea',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(TextRuler, langManager) {
  var mbcLegendArea = function(manifest){
    
    var width = 400, height = 200, valueLabelFont = {
        'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
        'fontsize' : '12px',
        'fontweight' : 'normal',
        'color' : '#333333'
      }, chartData = undefined, colors = [], markerSize = {width: 18, height : 20}, valuePaddingLeft = 10, paddingBottom = 1,
        selectedItem = [], selectionMode = 'selectionMode', posInfo = {
        markerPaddingRight : 0.5,
        paddingTop : 1,
        maxValueSpace : 1.6,
        minValueSpace : 0.5,
        minMarkerHeight : 10,  //10pixel
        space : 0
      }, nullLabelIndex = -1, textHeight = 20, minimized = false, noValueString = langManager.get('IDS_ISNOVALUE');
    var effectManager = null;
        
    var chart = function(selection){
      selection.each(function(){
        getThemeStyleDef();
        
        //Calculate marker size.
        _calMarkerSize();
        
        var labelsData = chartData, textElements, y = 0, visible = 'visible';
        var wrap = d3.select(this);
        
        var indicatedRectElement = wrap.selectAll('rect.indicatedRect');
        if(indicatedRectElement.empty()){
          indicatedRectElement = wrap.append('rect').attr('class', 'indicatedRect');
        }
        indicatedRectElement.attr('visibility', 'hidden')
          .attr('width', markerSize.width + 8).attr('height', markerSize.height+2);
        
        var gWrap = wrap.selectAll('g.row').data(labelsData, function(d, i){
          return d.val;
        });
        
        gWrap.exit().remove();
        var gEnterWrap = gWrap.enter().append('g').attr('class', 'row');
        gEnterWrap.append('rect').attr('class', function(d, i){
          return 'marker ID_' + i;
        });
        gEnterWrap.append('text');

        var rectElements = gWrap.selectAll('rect.marker').attr('width', markerSize.width).attr('height', markerSize.height);
        var parameter, fillID;
        for(var j = 0, jlen = rectElements.length; j < jlen; j++){
          y = (markerSize.height + paddingBottom) * ((nullLabelIndex != -1) ? (j-1) : j);
          if(labelsData[j].val === 'N/A'){
            y = (markerSize.height + paddingBottom)*(jlen > 1 ? jlen : 0);
          }
          rectElements[j][0].setAttribute('y', y);
          
          parameter = {
            drawingEffect : 'normal',
            fillColor : colors[labelsData.length - j - 1],
          };
          fillID = effectManager.register(parameter);
          rectElements[j][0].setAttribute('fill', fillID);
        }

        textElements = gWrap.selectAll('text').text(function(d, i){
          var txt = d.val;
          if(txt === 'N/A')
            txt = noValueString;
          return txt;
        }).attr('x', markerSize.width + valuePaddingLeft);
        y = 0;
        for(var j = 0, jlen = textElements.length; j < jlen; j++){
          y = markerSize.height*((nullLabelIndex != -1) ? j : (j+1)) + textHeight/2;
          if(labelsData[j].val === 'N/A'){
            y = (markerSize.height + paddingBottom)*(jlen > 1 ? jlen : 0) + textHeight/2 + markerSize.height/2;
          }
          if(minimized && j !== jlen-1 && (labelsData[j].val !== 'N/A')){
            visible = 'hidden';
          }else {
            visible = 'visible';
          }
          
          textElements[j][0].setAttribute('y', y);
          textElements[j][0].setAttribute('visibility', visible);
        }
        
        
        if(labelsData.length > 1){
          //Add top text
          var topTextElements = wrap.selectAll('text.topText');
          if(topTextElements.empty()){
            topTextElements = wrap.append('text').attr('class', 'topText');
          }
          var topTextLabel;
          if(nullLabelIndex != -1){
            topTextLabel = labelsData[1].ctx.ranges.endValue;
          }else{
            topTextLabel = labelsData[0].ctx.ranges.endValue;
          }
          topTextElements.text(topTextLabel).attr('x', markerSize.width + valuePaddingLeft).attr('y', textHeight/2);
        }else if(labelsData.length === 1){
          textElements[0][0].setAttribute('y', textHeight/2 + markerSize.height/2);
        }
        
        wrap.attr('style', 'font-size: '+valueLabelFont.fontsize+'; font-family:'+valueLabelFont.fontfamily+'; font-weight:'+valueLabelFont.fontweight+'; fill: '+valueLabelFont.color+";");
        wrap.on('mouseover', hoverHandler).on('mouseout', blurHandler).on('mousedown', itemClicked).on('mouseup', blurHandler);
      });
    };
    
    var hoverHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy) return;
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1) return;
        var x = item.attr('x'), y = item.attr('y');
        
      var indicatedItem = d3.selectAll('.indicatedRect');
      indicatedItem.attr('visibility', 'visible').attr('fill', '#cccccc').attr('x', x - 4).attr('y', y- 1);
    };
    
    var blurHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy) return;
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1) return;
        
      var indicatedItem = d3.selectAll('.indicatedRect');
      indicatedItem.attr('visibility', 'hidden');
    };
    
    var itemClicked = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy) return;
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('marker') === -1) return;
        var x = item.attr('x'), y = item.attr('y');
        
      var indicatedItem = d3.selectAll('.indicatedRect');
      indicatedItem.attr('visibility', 'visible').attr('fill', '#808080').attr('x', x - 4).attr('y', y- 1);
    };
    
    chart.clickHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy) return;
      
      if(d3.event.type === 'touchstart'){
        //VD effect
        itemClicked();
      }  
      
      var isSelected = false;
      
      if(_contains(selectedItem, d3.event.target)){
        //has been selected.
        isSelected = true;
      }else{
        //New selected item
        selectedItem.push(d3.event.target);
      }
      return isSelected;
    };
    
    chart.width = function(_) {
      if(!arguments.length)
        return width;
      width = _;
      return chart;
    };

    
    chart.height = function(_) {
      if(!arguments.length)
        return height;
      height = _;
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length)
        return options;
      //TODO use extends...
      options = properties;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length)
        return chartData;
      chartData = _;
      return chart;
    };
    
    chart.setSelectionMode = function(_){
      selectionMode = _;
    };
    
    chart.getPreferredSize = function() {
      var maxWidth = 0, maxHeight = 0, minHeight = 0, data = chartData;
      if(data){
        //reset N/A flag
        nullLabelIndex = -1;
        
        getThemeStyleDef();
        
        var maxValueWidth = -1, labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        var len = data.length;
        for ( var i = 0; i < len; i++) {
          if(data[i].val === 'N/A'){
            valueSize = TextRuler.measure(noValueString, labelFont);
            nullLabelIndex = i;
          }else{
            valueSize = TextRuler.measure(data[i].val, labelFont);
          }
          if ((valueSize === undefined)
              || (valueSize.width > maxValueWidth)) {
            maxValueWidth = valueSize.width;
          }
        }
        
        textHeight = parseInt(valueLabelFont.fontsize); //1em
        var h = (posInfo.maxValueSpace + 1) * textHeight;
        
        maxWidth = markerSize.width + posInfo.markerPaddingRight * textHeight + maxValueWidth;
        if(nullLabelIndex !== -1){
          maxHeight = (h + paddingBottom) * (len+1) + textHeight;
          minHeight = (posInfo.minMarkerHeight + paddingBottom) * (len+1) + textHeight;
        }else{
          maxHeight = (h + paddingBottom) * len + textHeight;
          minHeight = (posInfo.minMarkerHeight + paddingBottom) * len + textHeight;
        }
      }
      return {
        minHeight: minHeight,
        minWidth: maxWidth,
        width: maxWidth,
        height: maxHeight
      };
    };
    
    chart.color = function(_) {
      if(!arguments.length)
        return colors;
      colors = _;  
      return chart;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length)
        return effectManager;
      effectManager = _;

      return chart;
    };
    
    var _calMarkerSize = function(){
      var len = chartData.length, h = 0, space = 0;
      minimized = false;
      if(nullLabelIndex != -1){
        space = (height - (len + 2) * textHeight)/(len+1);
      }else{
        space = (height - (len + 1) * textHeight)/len;
      }
      h = space + textHeight;
      
      var maxValueSpace = posInfo.maxValueSpace * textHeight;
      if(space > maxValueSpace){
        space = maxValueSpace;
        h = space + textHeight;
      }else {
        var minValueSpace = posInfo.minValueSpace * textHeight;
        if(space < minValueSpace){
          h = posInfo.minMarkerHeight;
          space = 0;
          minimized = true;
        }
      }
      posInfo.space = space;
      markerSize.height = h;
    };
    
    //Utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = manifest.style('viz-legend-valueLabel');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    return chart;
  };
  return mbcLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.sizeLegendArea',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(TextRuler, langManager) {
  var colorLegendArea = function(manifest){
    
    var width = 400, height = 200, valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '14px',
      'fontweight' : 'normal',
      'color' : '#333333'
    }, chartData=[0, 0, 0], scale = undefined, guildeLineWidth = 10, valuePaddingLeft = 15, valueLabelHeight = 0;
    
    var effectManager  = null;
    
    var chart = function(selection){
      selection.each(function(){
        if(scale === undefined) return;
        
        getThemeStyleDef();
        
        //Smart value label management.
        var visibleData = [], labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        if(valueLabelHeight === 0){
          valueLabelHeight = TextRuler.measure('M', labelFont).height;
        }
        var visibleCount = Math.round(height / valueLabelHeight);
        switch(visibleCount){
        case 0:
        case 1:
        case 2:
        case 3:
          visibleData.push(chartData[0]);
          break;
        case 4:
          visibleData.push(chartData[0]);
          if(chartData.length > 1){
            visibleData.push(chartData[chartData.length -1]);
          }
          break;
        default :
          visibleData = chartData;
        }
        
        var bubbleSizeArr = [], maxWidth = -1, dataWidth, value;
        for(var i = 0, len = visibleData.length; i < len; i++){
          bubbleSizeArr.push(scale(visibleData[i])/2);
          value = _isNullValue(visibleData[i]);
          dataWidth = TextRuler.measure(value, labelFont).width;
          if(dataWidth > maxWidth){
            maxWidth = dataWidth;
          }
        }
        var maxBubbleSize = bubbleSizeArr[0];
        var wrap = d3.select(this);
        var textHeight = parseInt(valueLabelFont.fontsize); //1em
        var circlesWrap = wrap.selectAll('g.legend.circles');
        if(circlesWrap.empty()){
          circlesWrap = wrap.append('g').attr('class', 'legend circles').data([bubbleSizeArr]);
        }
        circlesWrap.attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize+textHeight)+ ')');
        
        var parameter = {
          drawingEffect : options.drawingEffect,
          graphType : 'circle',
          fillColor : '#748CB2'
        };
        var fillID = effectManager.register(parameter);
        var circleElements = circlesWrap.selectAll('circle').data(bubbleSizeArr, function(d, i){
          return d;
        });
        circleElements.exit().remove();
        circleElements.enter().append('circle').attr('stroke', 'white').attr('stroke-width', 1).attr('fill', fillID).attr('opacity', '0.85');
        circleElements.attr('r', function(d, i){ return d;})
          .attr('cx', function(d, i){
            return 0;
          }).attr('cy', function(d, i){
            return maxBubbleSize-d;
          });
        
        var labelsWrap = wrap.selectAll('g.legend.valueLabels');
        if(labelsWrap.empty()){
          labelsWrap = wrap.append('g').attr('class', 'legend valueLabels').data([visibleData]);
        }
        var labelX = (maxBubbleSize*2+valuePaddingLeft+guildeLineWidth+maxWidth) > width ? width : (maxBubbleSize*2+valuePaddingLeft+guildeLineWidth+maxWidth);
        labelsWrap.attr('transform', 'translate('+ labelX +', '+(maxBubbleSize+textHeight*3/2)+')');
        var valueElements = labelsWrap.selectAll('text').data(visibleData, function(d, i){
          return d;
        });
        valueElements.exit().remove();
        valueElements.enter().append('text').attr('text-anchor', 'end');
        valueElements.attr('font-family', valueLabelFont.fontfamily).attr('font-size', valueLabelFont.fontsize)
          .attr('font-weight', valueLabelFont.fontweight).attr('fill', valueLabelFont.color).text(function(d, i){
            var value = _isNullValue(d);
            return value;
          }).attr('dx', 0).attr('dy', function(d, i){
            var dy = (i-1)*maxBubbleSize - 2;
            if(visibleData.length === 2 && i === 1){
              dy = maxBubbleSize - 2;
            }
            return dy;
          });
        
        var guidelineWrap = wrap.selectAll('g.legend.guideLines');
        if(!guidelineWrap.empty()){
          //Empty
          guidelineWrap.remove();
        }
        guidelineWrap = wrap.append('g').attr('class', 'legend guideLines').attr('transform', 'translate(' + maxBubbleSize + ',' + (maxBubbleSize+textHeight)+ ')');
        if(visibleData.length > 0){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ -maxBubbleSize +' L '+(maxBubbleSize+guildeLineWidth)+" "+ -maxBubbleSize);
        }
        if(visibleData.length > 1){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ maxBubbleSize +'L'+(maxBubbleSize+guildeLineWidth)+" "+ maxBubbleSize);
        }
        if(visibleData.length > 2){
          guidelineWrap.append('path').attr('stroke', 'gray').attr('d', 'M 0 '+ (maxBubbleSize - bubbleSizeArr[1]) +' L '+maxBubbleSize+" 0"+  ' M '+ maxBubbleSize + " 0 " + " L "+ (maxBubbleSize + guildeLineWidth) +" 0");
        }
      });
        
    };
    
    chart.width = function(_) {
      if(!arguments.length)
        return width;
      width = _;
      rowPosArr = [];
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length)
        return height;
      height = _;
      rowPosArr = [];
      return chart;
    };
    
    chart.color = function(_) {
      if(!arguments.length)
        return colors;
      colors = _;  
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length)
        return shapes;
      shapes = _;
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length)
        return options;
      //TODO use extends...
      options = properties;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length)
        return chartData;
      chartData = _;
      return chart;
    };
    
    chart.scale = function(_){
      if(!arguments.length)
        return scale;
      scale = _;
      return chart;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length)
        return effectManager;

      effectManager = _;
      return chart;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = manifest.style('viz-legend-valueLabel');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    chart.getPreferredSize = function(chartSize, layoutSpace, legendSpace, containerInfo, bubbleScale, bubbleSpace, hasHeightFeed){
      if(chartSize)
        getThemeStyleDef();
      var maxWidth = 0, maxHeight = 0, minWidth = 0;
      if(scale && layoutSpace){
        valueLabelHeight = 0;
        
        var maxValueWidth = -1, maxBubbleSize = undefined, valueSize = undefined, value = null,
          data = chartData, labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        for(var i = 0, len = data.length; i < len; i++){
          value = _isNullValue(data[i]);
          valueSize = TextRuler.measure(value, labelFont);
          if((valueSize === undefined) || (valueSize.width > maxValueWidth)) {
            maxValueWidth = valueSize.width;
          }
        }
        
        var space =  maxValueWidth + valuePaddingLeft + guildeLineWidth;
        maxBubbleSize = chartSize ? (chartSize.width - layoutSpace
            - legendSpace - space - containerInfo.space - containerInfo.number
            * bubbleSpace)
            / (1 + (1 / bubbleScale) * containerInfo.number) : scale(data[0]);
          valueLabelHeight = valueSize.height;
        

        if (!hasHeightFeed && containerInfo.plotHeight) {
          maxBubbleSize = Math.min((containerInfo.plotHeight - bubbleSpace)
              * bubbleScale, maxBubbleSize);
        }
        
        maxHeight = maxBubbleSize + valueSize.height * 2;
        maxWidth = maxBubbleSize + space;
        minWidth = maxBubbleSize + valuePaddingLeft;
      }
      
      return {
        minHeight: maxHeight,
        minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
    };
    
    return chart;
  };
    
  var _isNullValue = function(value){
    return (value === null) ? langManager.get('IDS_ISNOVALUE') : value;
  };
  
  return colorLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'},
[

],

function Setup() {

  var DrawUtil = {

  };

  /**
   *  props = {
   *    type: 
   *    rx:
   *    ry:
   *  }
   *  @return path "d" for D3 
   */
  DrawUtil.createMarkerData = function (props){
    // TODO Maybe we can use hashmap to cache here
    //if(symbolMap[props]) return symbolMap[props];
    var result;
    var temp = props.borderWidth / 2;
    switch(props.type)
    {
    case "circle" :
      result = "M" + (-props.rx - temp)  + ",0 A" + (props.rx + temp) + "," + (props.ry + temp) + " 0 1,0 " + (props.rx + temp) + ",0 A"
      + (props.rx + temp) + "," + (props.ry + temp) + " 0 1,0 " + (-props.rx -temp) + ",0z";
      break;
    case "cross" :
      result = "M" + (-props.rx - temp) + "," + (-props.ry/3 - temp) + "H" + (-props.rx/3  - temp) + "V" + (-props.ry - temp)+ "H" + (props.rx/3 +temp)
      + "V" + (-props.ry/3 - temp) + "H" + (props.rx + temp) + "V" + (props.ry/3 + temp) + "H" + (props.rx/3 + temp) 
      + "V" + (props.ry +temp) + "H" + (-props.rx/3 - temp) + "V" + (props.ry/3 + temp) + "H" + (-props.rx -temp) + "Z";
      break;
    case "diamond" :
      result = "M0," + (-props.ry -temp)  + "L" + (props.rx + temp) + ",0" + " 0," + (props.ry + temp) + " " + (-props.rx -temp) + ",0" + "Z";
      break;
    case "square" :
      result = "M" + (-props.rx - temp) + "," + (-props.ry - temp) + "L" + (props.rx + temp) + ","
      + (-props.ry - temp) + "L" + (props.rx + temp) + "," + (props.ry + temp) + "L" + (-props.rx - temp) + "," + (props.ry + temp) + "Z";                        
      break;
    case "triangle-down" :
      result = "M0," + (props.ry + temp) + "L" + (props.rx + temp) + "," + -(props.ry + temp) + " " + -(props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "triangle-up" :
      result =  "M0," + -(props.ry + temp) + "L" + (props.rx + temp) + "," + (props.ry + temp) + " " + -(props.rx + temp) + "," + (props.ry + temp) + "Z";
      break;
    case "triangle-left" :
      result = "M" + -(props.rx + temp) + ",0L" + (props.rx + temp) + "," + (props.ry + temp) + " " + (props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "triangle-right" :
      result = "M" + (props.rx + temp) + ",0L" + -(props.rx + temp) + "," + (props.ry + temp) + " " + -(props.rx + temp) + "," + -(props.ry + temp) + "Z";
      break;
    case "intersection" :
      result = "M" + (props.rx + temp) + "," + (props.ry + temp) + "L" +  (props.rx/3 + temp) + ",0L" + (props.rx + temp) + "," + -(props.ry +temp) + "L" +
      (props.rx / 2 - temp) + "," + -(props.ry + temp) + "L0," + (-props.ry/3 - temp) + "L" + (-props.rx / 2 + temp) + "," + -(props.ry + temp) + "L" + 
      -(props.rx + temp) + "," + -(props.ry +temp) + "L" + -(props.rx/3 + temp) + ",0L" + -(props.rx + temp) + "," + (props.ry + temp) + "L" +
      (-props.rx/2 + temp) + "," + (props.ry + temp) + "L0," + (props.ry/3 + temp) + "L" + (props.rx/2 - temp) + "," + (props.ry + temp) + "Z";
      break;
    case 'squareWithRadius' : 
      var r = props.rx;
      var radius = r - 3;
      result = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r
      + "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
      break;
    }
    //symbolMap[props] = result;
    return result;

  };

  function getAnimationInitData(props)
  {
    var result;
    switch(props.type)
    {
    case "circle" :
      result = "M0,0A0,0 0 1,0 0,0A0,0 0 1,0 0,0z"; 
      break;
    case "cross" :
      result = "M0,0H0V0H0V0H0V0H0V0H0V0H0Z";
      break;
    case "diamond" :
      result = "M0,0L0,0 0,0 0,0Z";
      break;

    case "triangle-down" :

    case "triangle-up" :
    case "triangle-left" :
    case "triangle-right" :  
      result = "M0,0L0,0 0,0Z";
      break;
    case "intersection" :
      result = "M0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0L0,0Z";
      break;
    case 'squareWithRadius' : 
      result = "M0,0L0,0Q0,0 0,0L0,0Q0,0 0,0L0,0Q0,0 0,0L0,0Q0,0 0,0Z";
      break;  
    case "square" :
    default:
      result = "M0,0L0,0L0,0L0,0Z";                        
    break;
    }
    return result;
  }

  DrawUtil.createElements = function(d3Enter, props)
  {
    return d3Enter.append("path").attr("class", props.className);
  };
  
  DrawUtil.createElement = function(d3Parent, props, effectManager)
  {
    var d3Element = d3Parent.append("path").attr("class", props.className);
    props.node = d3Element;
    drawGraph(props, effectManager);
    return d3Element;
  };

  /**
   * props = {
   *   node: current d3 svg element,
   *  graphType : marker type
   *  drawingEffect: drawingEffect
   *  direction : direction
   *   rx : size
   *  ry: size
   *  fillColor: color
   *  borderWidth:
   *  borderColor,
   *  visibility: "visible" or "hidden"
   *  animateTime: total time for animation in ms 
   *  endFunc: callback function, when animation complete, it will be called
   * }
   *  effectManager: current effectManager
   */
  DrawUtil.drawGraph =  function (props, effectManager)
  {
    var para = {
        type: props.graphType,
        rx:Math.round(props.rx),
        ry:Math.round(props.ry),
        borderWidth: props.borderWidth ? Math.round(props.borderWidth) : 0
    };
    var data = DrawUtil.createMarkerData(para);

    var fillId = effectManager.register(props);
    props.node.attr("fill", fillId).attr("stroke-width", props.borderWidth).attr("stroke", props.borderColor).attr("visibility", props.visibility);
    if(props.animateTime && props.animateTime > 0)
    {
      props.node.attr("d", getAnimationInitData(para));
      props.node.transition().duration(props.animateTime).attr("d", data).each('end', props.endFunc);
    }
    else 
      props.node.attr("d", data);
    return  props.node;
  };

  return DrawUtil;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend.colorLegendArea',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(TextRuler, dispatch, DrawUtil, Repository) {
  var colorLegendArea = function(manifest){
    var width = 400, height = 200, valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '12px',
      'fontweight' : 'normal',
      'color' : '#333333'
    }, options = {
      isHierarchy : undefined,
      position : 'right',
      legendType : 'ColorLegend'
    }, colorLabelSize = 1, shapes = [], colors = [], colorFeedLength = 0, shapeFeedLength = 0, 
    textHeight = 20, colorLabelMarginRight = 0.5, rowMarginBottom = 0.6, selectedItem = [], selectionMode = 'multiple';
    
    var effectManager = null;
    
    //alex su
    //These are two cursors to depict legend rows to be shown.
    var randomSuffix = Repository.newId();
    var startRow = 0;
    var endRow = Infinity;
    
    //Each row's position [{x: 10, y: 10}, {...}...]
    var rowPosArr = [], chartData = {};
    
    var chart = function(selection){
      selection.each(function(){
        getThemeStyleDef();
        
        var labelsData = getLabelData();  

        var isItemsOverflow =  false;
        if(labelsData.length > 0 && labelsData.length < chartData.length){
          isItemsOverflow = true;
        }

        var wrap = d3.select(this);
        wrap.attr('style', 'font-family:'+valueLabelFont.fontfamily+'; font-size:'+valueLabelFont.fontsize
            +'; font-weight:'+valueLabelFont.fontweight+';fill:'+valueLabelFont.color+";");
        //Create each row
        var gEnterRow = wrap.selectAll('g.row').data(labelsData, function(d, i){
          return d.val;
        });
        gEnterRow.exit().remove();
        
        var rectEnterRow = gEnterRow.enter().append('g').attr('class', function(d, i) {
          return 'legend '+randomSuffix+' row ID_' + i;
        });
        
        
        //alex su
        //Add 'rect' element to indicate selected/hover item.
        var indicatedItems = rectEnterRow.append('rect').attr('class', function(d, i){
          return 'legend indicatedRect-'+randomSuffix+'-ID_' +i;
        });
        var rectMargin = rowMarginBottom * textHeight/2;
        indicatedItems.attr('width', width+10).attr('height', textHeight + rectMargin*2).attr('fill', 'rgba(255, 255, 255, 0)').attr('x', -5).attr('y', -rectMargin);

        if((options.legendType !== 'BubbleColorLegend') && options.isHierarchy) {
          //Legend with hierarchy
          var labelItem, rowItems, rowWrap, lastRowLabel = [], itemXPos = 0, itemYPos = 0;

          for(var i = 0, len = labelsData.length; i < len; i++) {
            itemXPos = 0, itemYPos = 0;
            
            //'China / 2001 / Car - Profit' TO ['China', '2001', 'Car', 'Profit']
            labelItem = labelsData[i].val;
            labelItem = labelItem.replace('-', '/');
            rowItems = labelItem.split(' / ');
            rowWrap = d3.select(this).select("g.row.ID_" + i);
            //Create each row's sub elements.
            var isShowWholeItem = false;
            for(var j = 0, jLen = rowItems.length - 1; j < jLen; j++) {
              if(lastRowLabel[j] !== rowItems[j]) {
                //Only with last label and color label
                isShowWholeItem = true;
                break;
              }
            }
            
            var t = rowWrap.selectAll('g').data(rowItems);
            t.enter().append('g').attr('class', function(d, i) {
              return 'legend '+randomSuffix+' label ID_' + i;
            });

            for(var j = 0, jLen = rowItems.length; j < jLen; j++) {
              var gWrap = undefined;
              if(j === jLen - 1) {
                //With legend marker
                gWrap = createRowWithColorLabel(rowWrap.select('g.label.ID_'+j), i, true, rowItems[j]);
                gWrap.attr('transform', function(d, index) {
                  itemXPos = 10 * j;
                  if(isShowWholeItem){
                    itemYPos = textHeight + itemYPos + rowMarginBottom * textHeight;                    
                  }
                  return 'translate(' + itemXPos + ',' + itemYPos + ')';
                });
              } else {
                if(isShowWholeItem) {
                  //No legend marker
                  gWrap = createRowWithColorLabel(rowWrap.select('g.label.ID_'+j), i, false, rowItems[j]);
                  gWrap.attr('transform', function(d, index) {
                    itemXPos = 10 * j;
                    if(j > 0){
                      itemYPos = textHeight + itemYPos + rowMarginBottom * textHeight;
                    }
                    return 'translate(' + itemXPos + ',' + itemYPos + ')';
                  });
                }
              }
              if(gWrap){
                gWrap.attr('visibility', function(d, index){
                  var visible = 'visible';
                  if((rowPosArr[i] === undefined) || (rowPosArr[i].y + itemYPos > height - textHeight)){
                    visible = 'hidden';
                    isItemsOverflow = true;
                  }
                  return visible;
                });
              }
              lastRowLabel[j] = rowItems[j];
            }
          }
          
          gEnterRow.attr('transform', function(d, i){
            if(rowPosArr[i]){
              return 'translate('+ rowPosArr[i].x + ',' + rowPosArr[i].y + ')';
            }
          });
        } else {
          //Create each row
          for(var i = 0, len = labelsData.length; i < len; i++) {
            var rowWrap = d3.select(this).selectAll("g.row.ID_" + i);
            createRowWithColorLabel(rowWrap, i, true, labelsData[i].val);
          }

          //Each row position
          gEnterRow.attr('transform', function(d, i) {
            if(rowPosArr[i]){
              return 'translate(' + rowPosArr[i].x + ',' + rowPosArr[i].y + ')';
            }
          }).attr('visibility', function(d, index){
            var visible = 'visible';
            if((rowPosArr[index] === undefined) || (rowPosArr[index].y > height - 2*textHeight)){
              visible = 'hidden';
              isItemsOverflow = true;
            }
            return visible;
          });
        }
        
        //Add 'rect' element to handle click event.
        var eventItems = rectEnterRow.append('rect').attr('class', function(d, i){
          return 'legend eventRect-'+randomSuffix+'-ID_' +i;
        });
        eventItems.attr('width', width).attr('height', textHeight).attr('fill', 'rgba(255, 255, 255, 0)');
        
        //Much items ellipsis
        var itemsEllipsis = d3.select(this).selectAll('text.itemsEllipsis');
        if(itemsEllipsis.empty()){
          itemsEllipsis = d3.select(this).append('text').attr('class', 'itemsEllipsis').text('...')
            .attr('text-anchor', 'middle');
        }
        itemsEllipsis.attr('dx', width/2).attr('dy', height).attr('visibility', function(){
          var visible = 'hidden';
          if(isItemsOverflow){
            visible = 'visible';
          }
          return visible;
        });
        
        d3.select(this).on('mouseover', hoverHandler).on('mouseout', blurHandler)
          .on('mousedown', itemClicked).on('mouseup', blurHandler).on('touchend', blurHandler);
      });
    };
    
    chart.width = function(_) {
      if(!arguments.length)
        return width;
      width = _;
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length)
        return height;
      height = _;
      return chart;
    };
    
    chart.color = function(_) {
      if(!arguments.length)
        return colors;
      colors = _;  
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length)
        return shapes;
      shapes = _;
      return chart;
    };
    
    chart.colorFeedLength = function(_){
      colorFeedLength = _;
      return chart;
    };
    
    chart.shapeFeedLength = function(_){
      shapeFeedLength = _;
      return chart;
    };
    
    chart.data = function(_){
      if(!arguments.length)
        return chartData;
      chartData = _;
      return chart;
    };
    
    chart.properties = function(properties) {
      if(!arguments.length)
        return options;
      //TODO use extends...
      options = properties;
      return chart;
    };
    
    chart.getPreferredSize = function(wholeSize) {
      getThemeStyleDef();
      return _calculateRowPosition(wholeSize);
    };
    
    chart.setSelectionMode = function(_){
      selectionMode = _;
    };
    
    chart.effectManager = function(_) {
      if(!arguments.length)
        return effectManager;
      effectManager = _;

      return chart;
    };
    
    var getLabelData = function(){
      var labelsData = [], len = rowPosArr.length;
      if(chartData.length > 0){
        //Split items
        labelsData = chartData.slice(0, len);
        startRow = 0;
        endRow = len;
      }
      return labelsData;
    };
    
    var getThemeStyleDef = function(){
      var valueLabelStyle = manifest.style('viz-legend-valueLabel');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    var hoverHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy) return;
      
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('eventRect') === -1) return;
        
      var id = clickedItemClass.split('ID_')[1];
      var indicatedItem = d3.selectAll('.indicatedRect-'+randomSuffix+'-ID_'+id);
      indicatedItem.attr('fill', '#cccccc');
    };
    
    var blurHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy) return;
      
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('eventRect') === -1) return;
        
        var id = clickedItemClass.split('ID_')[1];
        var indicatedItem = d3.selectAll('.indicatedRect-'+randomSuffix+'-ID_'+id);
      indicatedItem.attr('fill', 'rgba(0,0,0,0)');
    };
    
    var itemClicked = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy) return;
      
      var item = d3.select(d3.event.target);
        var clickedItemClass = item.attr('class');
        
        if(!clickedItemClass || clickedItemClass.search('eventRect') === -1) return;
        
        var id = clickedItemClass.split('ID_')[1];
        var indicatedItem = d3.selectAll('.indicatedRect-'+randomSuffix+'-ID_'+id);
      indicatedItem.attr('fill', '#808080');
    };
    
    chart.clickHandler = function(){
      if(selectionMode === 'single' || selectionMode === 'none' || options.isHierarchy) return;
      
      //TODO
      if(d3.event.type === 'touchstart'){
        //VD effect
        itemClicked();
      }  
      
      var isSelected = false;
      
      if(_contains(selectedItem, d3.event.target)){
        //has been selected.
        isSelected = true;
      }else{
        //New selected item
        selectedItem.push(d3.event.target);
      }
      return isSelected;
    };
    
    chart.deselectByCtx = function(deselectedData){
      if(!deselectedData){
        //deslected All items. Remove all selected legend items.
        selectedItem = [];
//        d3.selectAll('.indicatedRect').attr('fill', 'rgba(0,0,0,0)');
      }else{
        var itemData, isSame = true;
        for(var i = 0, len = selectedItem.length; i < len; i++){
          isSame = true;
          itemData = selectedItem[i].__data__.ctx.path;
          if(!itemData){
            itemData = selectedItem[i].__data__.ctx.ranges;
            if(itemData != deselectedData.ctx.ranges){
              isSame = false;
            }
          }else{
            for(var k in itemData){
              if(deselectedData.ctx.path[k] != undefined){
                if(deselectedData.ctx.path[k].length > 0){
                  if(deselectedData.ctx.path[k] !== itemData[k]){
                    isSame = false;
                  }
                }else{
                  if(deselectedData.ctx.path[k] !== itemData[k]){
                    isSame = false;
                  }
                }
              }
            }
          }
          
          if(isSame === true){
            //remove the deselected item.
            selectedItem.splice(i, 1);
            break;
          }
        }
      }
    };
    
    //Utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return true;
            }
        }
        return false;
    };
    
    /*
     * Calculate legend row position and return legend max size. 
     */
    var _calculateRowPosition = function(wholeSize) {
      var maxHeight = 0, maxWidth = 0, minWidth = 0,
        maxRowTextSize = {'width':0, 'height':0}, 
        labelsData = chartData,
        maxRowWidth = 0;
      if(labelsData){
        var labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
        
        var rowLabelSize = [], xPos = 0, yPos = 0; //each row text width
        textHeight = parseInt(valueLabelFont.fontsize); //1em
        rowPosArr = [];
        
        //Measure labels size
        //If colors feed don't have MND, can't show legend in hierarchy.
        if((options.legendType !== 'BubbleColorLegend') && options.isHierarchy){
          //Measure hierarchy legend
          var labelItem, rowItems, rowItemSize, maxRowItemSize = {'width' : 0, 'height': 0}, lastRowLabel = [];
          for(var i = 0, len = labelsData.length; i < len; i++) {
            //'China / 2001 / Car - Profit' TO ['China', '2001', 'Car', 'Profit']
            labelItem = labelsData[i].val;
            labelItem = labelItem.replace('-', '/');
            rowItems = labelItem.split(' / ');
            
            //Create each row's sub elements.
            var isShowWholeItem = false;
            for(var j = 0, jLen = rowItems.length - 1; j < jLen; j++) {
              if(lastRowLabel[j] !== rowItems[j]) {
                //Only with last label and color label
                isShowWholeItem = true;
                break;
              }
            }
            
            //Calculate each row's max item size
            var itemHeight = 0;
            for(var j = 0, jLen = rowItems.length; j < jLen; j++) {
              rowItemSize = TextRuler.measure(rowItems[j], labelFont);
              if(j === jLen - 1){
                rowItemSize.width = rowItemSize.width + (colorLabelSize + colorLabelMarginRight)*textHeight;
                itemHeight = itemHeight + (rowMarginBottom+1) * textHeight;
              }else if(isShowWholeItem){
                itemHeight = itemHeight + (rowMarginBottom+1) * textHeight;
              }
              rowItemSize.width = rowItemSize.width + 10*j;
              if(rowItemSize.width > maxRowItemSize.width) maxRowItemSize = rowItemSize; 
              lastRowLabel[j] = rowItems[j];
            }
            if(maxRowItemSize.width > maxRowWidth) maxRowWidth = maxRowItemSize.width;
            rowLabelSize.push(itemHeight);
            
            //Calculate each row's position
            // if(options.position === 'left' || options.position === 'right') {
              if(i > 0){
                yPos = yPos + rowLabelSize[i-1];              
              }
              if(yPos + textHeight > wholeSize.height) break;
            // }else{
  //             
            // }
            rowPosArr.push({x: xPos, y: yPos});
          }
          maxWidth = xPos + maxRowWidth;
          maxHeight = yPos + rowLabelSize[rowLabelSize.length - 1];
          
          minWidth = TextRuler.measure('M...', labelFont).width;
        }else{
          var labelText, rowTextSize;
          //Calculate each row's position
          if(options.position === 'left' || options.position === 'right') {
            var rowTextLength;
            for(var i = 0, len = labelsData.length; i < len; i++){
              //Set Y-Position
              if(i > 0){
                yPos = yPos + textHeight + textHeight*rowMarginBottom;
              }
              if(yPos + textHeight > wholeSize.height) break;
              rowPosArr.push({x: xPos, y: yPos});
              
              //Set max text length
              labelText = labelsData[i].val;
              if(labelsData[i].size === undefined){
                labelsData[i].size = TextRuler.measure(labelText, labelFont);
              }
              rowTextLength = labelsData[i].size;
              if(rowTextLength.width > maxRowTextSize.width){
                maxRowTextSize = rowTextLength;
              }
              
//              rowTextLength = labelText.length;
//              //Get longest text item
//              if(rowTextLength > maxRowTextLength){
//                maxRowTextLength = rowTextLength;
//                maxRowTextIndex = i;
//              } else if(rowTextLength === maxRowTextLength){
//                var a = TextRuler.measure(labelsData[maxRowTextIndex].val, labelFont).width;
//                var b = TextRuler.measure(labelsData[i].val, labelFont).width;
//                if(b > a){
//                  maxRowTextIndex = i;
//                }
//              }
            }
//            if(labelsData[maxRowTextIndex]){
//              maxRowTextSize = TextRuler.measure(labelsData[maxRowTextIndex].val, labelFont);
//            }
          }else{
            for(var i = 0, len = labelsData.length; i < len; i++){
              labelText = labelsData[i].val;
              rowTextSize = TextRuler.measure(labelText, labelFont);
              rowLabelSize.push(rowTextSize.width);
              
              //Calculate each row's position
              if(i > 0){
                xPos = xPos + (colorLabelSize + colorLabelMarginRight) * textHeight + rowLabelSize[i-1];              
              }
              if(xPos + textHeight > wholeSize.height) break;
              rowPosArr.push({x: xPos, y: yPos});
            }
          }
          
          //Calculation final row text size.
          maxRowWidth = (colorLabelSize + colorLabelMarginRight) * textHeight + maxRowTextSize.width;
          if(options.position === 'left' || options.position === 'right') {
            maxWidth = xPos + maxRowWidth;
            maxHeight = yPos + textHeight;
          }else{
            maxWidth = xPos + rowLabelSize[rowLabelSize.length -1] + (colorLabelSize + colorLabelMarginRight) * textHeight;
            maxHeight = maxRowTextSize.height;          
          }
          minWidth = xPos + (colorLabelSize + colorLabelMarginRight) * textHeight + TextRuler.measure('M...', labelFont).width; 
        }
      }
      if(minWidth > maxWidth){
        minWidth = maxWidth;
      }
      return {
        minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
    };
    
    var createRowWithColorLabel = function(wrap, index, isShowColorLabel, labelText) {
      var dx = 0, colorLabelType;
      var markerSize = colorLabelSize * textHeight;

      if(isShowColorLabel) {
        if(shapeFeedLength > 0){
          colorLabelType = shapes[index % (shapes.length > shapeFeedLength ? shapeFeedLength : shapes.length)];
        }else{
          if(options.legendType === 'BubbleColorLegend'){
            colorLabelType = (shapes[0] == undefined) ? 'square' : shapes[0];
          }else{
            var tmpShape = shapes[index % shapes.length];
            colorLabelType = (tmpShape == undefined) ? 'square' : tmpShape;
            if(colorLabelType === 'square'){
              colorLabelType = "squareWithRadius";
            }
          }
        }
        var symbolPath = getSymbolPath(colorLabelType, markerSize);
        
        var centerPos = textHeight / 2; 
        var path = wrap.selectAll('path').data([labelText]);
        DrawUtil.createElements(path.enter(),{shape: colorLabelType, className: null} );
        path.attr("transform", function(d,i)
        {
          var color;
          if(shapeFeedLength > 0) {
            var i = Math.floor(index / shapeFeedLength);
            var t = colors.length > colorFeedLength ? colorFeedLength : colors.length;
            if(t > 0){
              color = colors[i % t];
            }else{
              color = colors[0];
            }
          } else {
            color = colors[index % (colors.length > colorFeedLength ? colorFeedLength : colors.length)];
          }
          var parameter = {
              drawingEffect:options.drawingEffect,
              graphType:colorLabelType,
              fillColor : color,
              direction : 'vertical',
              rx: markerSize / 2,
              ry: markerSize / 2,
              borderWidth: 0,
              borderColor: "transparent",
              node:d3.select(this),
//              visibility: "visible"
          };
          DrawUtil.drawGraph(parameter, effectManager);
          return 'translate(' + centerPos + ',' + centerPos + ')';
          
        });
        dx = markerSize + colorLabelMarginRight * textHeight;
      }
      // item text label
      var text = wrap.selectAll('text').data([labelText]);
      text.enter().append('text');
      text.attr('x', dx).attr('y', textHeight).text(function(d) {
          return d;
        });
      
      var labelFont = "font-size:" + valueLabelFont.fontsize + "; font-weight:" + valueLabelFont.fontweight + "; font-family:" + valueLabelFont.fontfamily;
      text.each(function(d) {
        TextRuler.ellipsis(d, this, width-dx, labelFont);
      });
      return wrap;
    };
    return chart;
  };
  
  var getSymbolPath = function(type, size){
    var symbolPath = '', r; 
    switch(type){
      case 'circle' :
        r = size / 2;
        symbolPath = "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
        break;
      case "cross" :
                var rx = size / 6, ry = size / 6;
                symbolPath = "M" + -3 * rx + "," + -ry + "H" + -rx + "V" + -3 * ry + "H" + rx + "V" + -ry + "H" + 3 * rx + "V" + ry + "H" + rx + "V" + 3 * ry + "H" + -rx + "V" + ry + "H" + -3 * rx + "Z";
                break;
      case "triangle-down" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
                break;
            case "triangle-up" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
                break;
            case "diamond" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
                break;
            case 'squareWithRadius' : 
              r = size / 2;
              var radius = r - 3;
        symbolPath = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r
          + "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
        break;
            case 'square' :
              default : 
        r = size / 2;
        symbolPath = "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        break;
          case "triangle-left" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M" + -rx + ",0L" + rx + "," + ry + " " + rx + "," + -ry + "Z";
                break;
            case "triangle-right" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M" + rx + ",0L" + -rx + "," + ry + " " + -rx + "," + -ry + "Z";
                break;
            case "intersection" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M" + rx + ',' + ry + ' ' +  rx/3 + ',0 ' + rx + ',' + -ry + ' ' + rx / 2 + ',' + -ry + ' 0,' + -ry/3 + ' ' + -rx / 2 + ',' + -ry + ' ' + -rx + ',' + -ry + ' ' + -rx/3 + ',0 ' + -rx + ',' + ry + ' ' + -rx/2 + ',' + ry + ' 0,' + ry/3 + ' ' + rx/2 + ',' + ry;
                break;
    }
    return symbolPath;
  };
  
  return colorLegendArea;
});sap.riv.module(
{
  qname : 'sap.viz.modules.legend',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.legend.colorLegendArea',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.legend.sizeLegendArea',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.legend.mbcLegendArea',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(Manifest, TextRuler, TypeUtils, dispatch, ObjectUtils, ColorLegendArea, SizeLegendArea, MBCLegendArea, langManager) {
  var legend = function(manifest) {
    var width = undefined, height = undefined, preferenceSize = {width: 200, height: 200}, position = 'right', titleFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '14px',
      'fontweight' : 'bold',
      'color' : '#333333'
    }, valueLabelFont = {
      'fontfamily' : "'Open Sans', Arial, Helvetica, sans-serif",
      'fontsize' : '12px',
      'fontweight' : 'normal',
      'color' : '#333333'
    },options = {}, isVisible = true, isHidden = false, shapes = [], colors = [], textHeight = 20, 
    margin = {
      top : 0,
      right : 0,
      bottom : 0,
      left : 1.15
    }, titleMarginBottom = 0.5, legendAreaPos = {x:0, y:0}, sizeScale = undefined, sizeBubbleScale, sizeBubbleSpace, sizeBubbleHasHeightFeed, colorScale = undefined, hideTitle = false;
    
    //Each row's position [{x: 10, y: 10}, {...}...]
    var chartData = {title:'', labels:''}, bubleSizeData = [], data = null, shapeFeeds = [], colorFeeds = [], colorFeedLength = 0, shapeFeedLength = 0, relayout = true;
    var legendArea = ColorLegendArea(manifest);
    var eDispatch = new dispatch('highlightedByLegend');
    var effectManager = null;
        
    var chart = function(selection) {
      selection.each(function() {
        if(isColorLegend() || isBubbleColorLegend()){
          if(chartData.labels.length === 0){
            isVisible = false;
          }
        }
        
        if(isVisible && !isHidden){
          getThemeStyleDef();
          
          if(relayout){
            _calculateRowPosition({'width': width, 'height' : height});
          }

          var xPos = margin.left * textHeight, yPos = margin.top * textHeight;
          
          var wrap = d3.select(this).selectAll('g.content').data([chartData]);
          wrap.enter().append('g').attr('class', 'legend content');//.attr('clip-path', 'url(#legend-edge-clip)');
          
          //Legend Title
          if(options.isShowTitle && !hideTitle) {
            var titleTextHeight = parseInt(titleFont.fontsize);
            var titleStyle = 'font-weight: ' + titleFont.fontweight +'; fill:' + titleFont.color + '; font-family: ' + titleFont.fontfamily + '; font-size: '+titleFont.fontsize+";";
            var titleLabel = (options.titleText===undefined) ? chartData.title : options.titleText;
            
            var labelTitleElement = wrap.selectAll('text.labelTitle');
            if(labelTitleElement.empty()){
              labelTitleElement = wrap.append('text').attr('class', 'legend labelTitle');
            }
            labelTitleElement.text(titleLabel).attr('dx', xPos).attr('dy', yPos + titleTextHeight).attr('style', titleStyle).attr('visibility', 'visible');
            
            //Show ... in title 
            labelTitleElement.each(function(d) {
              TextRuler.ellipsis(titleLabel, this, width-xPos, titleStyle);
            });
          }else{
            wrap.selectAll('text.labelTitle').attr('visibility', 'hidden');
            if (hideTitle) {
                hideTitle = false;
              } 
          }
  
          var labelsData = chartData.labels;
          // Create Legend Groups
          var gEnterCol = wrap.selectAll('g.groups').data([labelsData]);
          gEnterCol.enter().append('g').attr('class', 'legend groups');
          gEnterCol.attr('transform', 'translate('+legendAreaPos.x+','+legendAreaPos.y+')');
  
          var tmpWidth = ((width===undefined) ? preferenceSize.width : width) - xPos;
          var tmpHeight = ((height===undefined) ? preferenceSize.height : height) - yPos;
          //TODO Need to handle legend in the top/bottom side.
          legendArea.properties(options).width(tmpWidth).height(tmpHeight-legendAreaPos.y).effectManager(effectManager);
          if(isSizeLegend()){
            legendArea.data(bubleSizeData).scale(sizeScale);
          }else if(isMeasureBasedColoringLegend()){
            legendArea.data(labelsData).color(colorScale.range());
          }else{
            legendArea.data(labelsData).color(colors).colorFeedLength(colorFeedLength).shapeFeedLength(shapeFeedLength);
          }
          //Bind click handler in legend labels
          gEnterCol.call(legendArea).on('click', clickHandler).on('touchstart', clickHandler);
          
          //Vertical align to center
          if(options.position === 'left' || options.position === 'right') {
            switch(options.alignment){
              case 'end':
                wrap.attr('transform', 'translate(0, '+(((height-preferenceSize.height) > 0) ? ((height-preferenceSize.height)) : 0)+')');
                break;
              case 'middle':
                wrap.attr('transform', 'translate(0, '+(((height-preferenceSize.height)/2 > 0) ? ((height-preferenceSize.height)/2) : 0)+')');
                break;
            }
          }
        }else{
          //Handle visible is false.
                    var elements = d3.select(this).selectAll('g.content');
                    if (!elements.empty()) {
                        elements.remove();
                    }
//          var clipPathWrap = d3.select(this).select('#legend-edge-clip');
//          if(!clipPathWrap.empty()){
//            clipPathWrap.remove();
//          }
        }
        isHidden = false;
      });
    };

    var clickHandler = function(data){
      if(options.isHierarchy) return;
      
      var className = d3.select(d3.event.target).attr('class');
      //TODO Use class name to check clicked item. Color legend and mbc legend use the same class name.
      if(className){
        var isSelected = legendArea.clickHandler();
        var index = parseInt(d3.select(d3.event.target).attr('class').split('ID_')[1]);
        if(chartData.labels[index] !== undefined){
          eDispatch.highlightedByLegend(chartData.labels[index], isSelected);
        }
      }
    };
    
    chart.deselectLegend = function(deselectedData){
      //TODO MBC support legend interaction.
      if(!(isMeasureBasedColoringLegend() || isSizeLegend())){
        legendArea.deselectByCtx(deselectedData);
      }
    };
    
    chart.width = function(_) {
      if(!arguments.length)
        return width;
      width = _;
      relayout = true;
      return chart;
    };

    chart.height = function(_) {
      if(!arguments.length)
        return height;
      height = _;
      relayout = true;
      return chart;
    };

    chart.position = function(_) {
      if(!arguments.length)
        return position;
      position = _;
      return chart;
    };

    chart.colorPalette = function(_) {
      if(!arguments.length)
        return colors;
      colors = _;  
      legendArea.color(_);
      return chart;
    };

    chart.shapes = function(_) {
      if(!arguments.length)
        return shapes;
      shapes = _;
      legendArea.shapes(_);
      return chart;
    };

    chart.properties = function(props) {
      if(!arguments.length)
        return options;
      //TODO use extends...
      var properties = manifest.props(props);
      options.visible = properties.visible;
      isVisible = options.visible;
      options.isShowTitle = properties.title.visible;
      options.titleText = properties.title.text;
      options.isHierarchy = properties.isHierarchical;
      options.position = properties.position;
      if(options.legendType != properties.type){
        options.legendType = properties.type;
        if(data && chartData.labels){
          parseFeedsData(data);
          legendArea.data(chartData.labels);
        }
      }
      options.alignment = properties.alignment;
      options.drawingEffect = properties.drawingEffect;
      
      if(isSizeLegend()){
        legendArea = SizeLegendArea(manifest);
      }else if (isMeasureBasedColoringLegend()){
        legendArea = MBCLegendArea(manifest);
      }
      legendArea.properties(options);
      return chart;
    };

    chart.getPreferredSize = function(wholeSize, layoutSpace, containerInfo) {
      getThemeStyleDef();
      return _calculateRowPosition(wholeSize, layoutSpace, containerInfo);
    };
    
    chart.data = function(_) {
      if(!arguments.length)
        return data;
      data = _;
      parseFeedsData(_);
      legendArea.data(chartData.labels);
      return chart;
    };
    
    chart.sizeLegendInfo = function(_){
      if(!arguments.length)
        return sizeScale;
      //Size scale
      sizeScale = _.scale;
      legendArea.scale(sizeScale);
      
      sizeBubbleScale = _.bubbleScale;
      
      sizeBubbleSpace = _.space;
      
      sizeBubbleHasHeightFeed = _.hasHeightFeed;
      
      //Size data
      if(_.data.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
        bubleSizeData = _.data;
        legendArea.data(bubleSizeData);
      }
      
      //Size legend title
      chartData.title = handleNull(_.title);
      
      return chart;
    };
    
    chart.hideTitle = function() {
        hideTitle = true;
        return chart;
    },
    
    chart.hide = function(_) {
        isHidden = _;
        return chart;
    },
    
    /*
     * Measure based coloring
     */
    chart.mbcLegendInfo = function(_){
      if(!arguments.length)
        return colorScale;
      if(_.colorScale === undefined){
        isVisible = false;
      }else{
        isVisible = options.visible;
        colorScale = _.colorScale;
        //Legend title
        chartData.title = handleNull(_.title);
        _parseMeasureBasedColoringLegend();
        legendArea.data(chartData.labels);
      }
      return chart;
    };
    
    chart.setSelectionMode = function(_){
      if(!(isMeasureBasedColoringLegend() || isSizeLegend())){
        legendArea.setSelectionMode(_);
      }
    };
    
    /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return chart;
      };
      
      chart.effectManager = function(_) {
      if(!arguments.length)
        return effectManager;
      effectManager = _;
      return chart;
    };
    
      //alex su
      chart.isVisible = function(){
        return isVisible;
      };
      
    var getThemeStyleDef = function(){
      var titleStyle = manifest.style('viz-legend-title');
      if(titleStyle){
        if(titleStyle['fill']){
          titleFont.color = titleStyle['fill'];
        }
        if(titleStyle['font-family']){
          titleFont.fontfamily = titleStyle['font-family'];
        }
        if(titleStyle['font-size']){
          titleFont.fontsize = titleStyle['font-size'];
        }
        if(titleStyle['font-weight']){
          titleFont.fontweight = titleStyle['font-weight'];
        }
      }
      
      var valueLabelStyle = manifest.style('viz-legend-valueLabel');
      if(valueLabelStyle){
        if(valueLabelStyle['fill']){
          valueLabelFont.color = valueLabelStyle['fill'];
        }
        if(valueLabelStyle['font-family']){
          valueLabelFont.fontfamily = valueLabelStyle['font-family'];
        }
        if(valueLabelStyle['font-size']){
          valueLabelFont.fontsize = valueLabelStyle['font-size'];
        }
        if(valueLabelStyle['font-weight']){
          valueLabelFont.fontweight = valueLabelStyle['font-weight'];
        }
      }
    };
    
    var buildColorShapeFeeds = function(feed){
      if(isColorFeeds(feed.key)) {
        colorFeeds = feed.values;
      } else {
        if(isShapeFeeds(feed.key)) {
          shapeFeeds = feed.values;
        }
      }
    };
    
    var parseFeedsData = function(data) {
      if(!data) return;
      colorFeeds = [];
      shapeFeeds = [];
      var aa = data.getAnalysisAxisDataByIdx(0);
      if(aa) 
        colorFeeds = aa.values;
      
      aa = data.getAnalysisAxisDataByIdx(1);
      if(aa)
        shapeFeeds = aa.values;
      
      if(isBubbleColorLegend()){
        _parseBubbleColorLegendFeeds();
      }else if(!(isSizeLegend())){
        _parseColorLegendFeeds();
      }
    };
    
    var _parseMeasureBasedColoringLegend = function(){
      var labels = [], item = {
        'val' : undefined,
        'ctx' : {}
      };
      var mbcDomains = colorScale.domain();
      for(var len = mbcDomains.length, i = 0, j = len-1; i < len; i++){
        if(mbcDomains[i].length > 0){
//          item.val = '[ ' + mbcDomains[i][0] + ' ; ' + mbcDomains[i][1] + ( i===len-1 ? ' ]' : ' [');
          item.val = mbcDomains[i][0];
          item.ctx.ranges = {
            startValue : mbcDomains[i][0],
            endValue : mbcDomains[i][1],
            isRightOpen : true,
            isLeftOpen : false
          };
        }else{
          item.val = 'N/A';
          item.ctx.ranges = {};
          if(labels[j+1] != undefined){
            labels[j+1].ctx.ranges.isRightOpen = false;
          }
        }
        if(j === 0){
          item.ctx.ranges.isRightOpen = false;
        }
        labels[j] = {};
        ObjectUtils.extend(true, labels[j--], item);
      }
      
      chartData.labels = labels;
    };
    
    var _parseBubbleColorLegendFeeds = function(){
      var labels = [], title ='', tmpVal = '', j = 0, tmpLabel={
        'val' : undefined,
        'ctx' : {
          'path' : {}
        }
      };
      colorFeedLength = 0, shapeFeedLength = 0;
      
      if(colorFeeds && colorFeeds.length > 0 && colorFeeds[0].rows.length > 0){
        var firstColorFeed = colorFeeds[0];
        title = handleNull(firstColorFeed.col.val);
        
        var dii = 'dii_a'+(firstColorFeed.rows[0].ctx.path.aa+1);
        tmpLabel = {
          'val' : firstColorFeed.rows[0].val,
          'ctx' : {
            'path' : { }
          }
        };
        tmpLabel.ctx.path[dii] = [firstColorFeed.rows[0].ctx.path.dii];
        
        for(var i = 1, len = firstColorFeed.rows.length; i < len; i++){
          tmpVal = firstColorFeed.rows[i].val;
          if(tmpVal == tmpLabel.val || _containsVal(labels, tmpVal)){
            tmpLabel.ctx.path[dii].push(firstColorFeed.rows[i].ctx.path.dii);
          }else{
            labels[j] = {};
            tmpLabel.val = handleNull(tmpLabel.val);
            ObjectUtils.extend(true, labels[j++], tmpLabel);
            //New color label. Add it to uniqueColorLabel and assign its new color
            tmpLabel.val = tmpVal;
            tmpLabel.ctx = {
              path : { }
            };
            tmpLabel.ctx.path[dii] = [firstColorFeed.rows[i].ctx.path.dii];
          }
        }
        //Add the last one
        labels[j] = {};
        tmpLabel.val = handleNull(tmpLabel.val);
        ObjectUtils.extend(true, labels[j], tmpLabel);
        
        colorFeedLength = labels.length;
      }
      
      if(shapeFeeds && shapeFeeds.length > 0) {
        var firstShapeFeed = shapeFeeds[0], shapeLabels=[];
        title = (title === '') ? handleNull(firstShapeFeed.col.val) : title + " / " + handleNull(firstShapeFeed.col.val);
        
        var dii = 'dii_a'+(firstShapeFeed.rows[0].ctx.path.aa+1);
        tmpLabel = {
          'val' : firstShapeFeed.rows[0].val,
          'ctx' : {
            'path' : {}
          }
        }, j = 0;
        tmpLabel.ctx.path[dii] = [firstShapeFeed.rows[0].ctx.path.dii];
        
        for(var i = 1, len = firstShapeFeed.rows.length; i < len; i++){
          tmpVal = firstShapeFeed.rows[i].val;
          if(tmpVal == tmpLabel.val || _containsVal(shapeLabels, tmpVal)){
            tmpLabel.ctx.path[dii].push(firstShapeFeed.rows[i].ctx.path.dii);
          }else{
            shapeLabels[j] = {};
            tmpLabel.val = handleNull(tmpLabel.val);
            ObjectUtils.extend(true, shapeLabels[j++], tmpLabel);
            //New shape label. Add it to uniqueColorLabel and assign its new color
            tmpLabel.val = tmpVal;
            tmpLabel.ctx = {
              path : {}
            };
            tmpLabel.ctx.path[dii] = [firstShapeFeed.rows[i].ctx.path.dii];
          }
        }
        //Add the last one
        shapeLabels[j] = {};
        tmpLabel.val = handleNull(tmpLabel.val);
        ObjectUtils.extend(true, shapeLabels[j], tmpLabel);

        shapeFeedLength = shapeLabels.length;
        if(labels.length > 0){
          labels = getCartesian([labels, shapeLabels], ' / ');
        }else{
          labels = shapeLabels;
        }
      }
      
      if(labels.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
      }
      chartData = {
        'title' : title,
        'labels' : labels
      };
    };
    
    var _parseColorLegendFeeds = function(){
      var title = undefined, labels = [];
      var colorData = _parseLegendFeed(title, colorFeeds, colorFeedLength);
      colorFeedLength = colorData.feedsLength;
      var shapeData = _parseLegendFeed(title, shapeFeeds, shapeFeedLength);
      shapeFeedLength = shapeData.feedsLength;
      
      //Color and Shape Cartesian
      if(shapeData.labels.length > 0){
        if(colorData.labels.length > 0){
          if(colorData.MNDInfo.MNDIndex === undefined && shapeData.MNDInfo.MNDIndex === undefined){
            //Has color and shape feed and no MND. So use '/'
            labels = getCartesian([colorData.labels, shapeData.labels], ' / ');
            title = colorData.title + " / " + shapeData.title;
          }else {
            if((colorData.MNDInfo.MNDIndex !== undefined && !colorData.MNDInfo.hasOnlyMND) || (shapeData.MNDInfo.MNDIndex !== undefined && !shapeData.MNDInfo.hasOnlyMND)){
              labels = getCartesian([colorData.labels, shapeData.labels], ' - ');
              title = colorData.title + " - " + shapeData.title;
            } else if (colorData.MNDInfo.MNDIndex !== undefined && colorData.MNDInfo.hasOnlyMND){
              labels = shapeData.labels;
              title = shapeData.title;
            } else {
              labels = colorData.labels;
              title = colorData.title;
            }
              
          } 
        }else{
          labels = shapeData.labels;
          title = shapeData.title;
        }
      }else{
        labels = colorData.labels;
        title = colorData.title;
      }

      if(labels.length === 0){
        isVisible = false;
      }else{
        isVisible = options.visible;
      }
      chartData = {
        'title' : title,
        'labels' : labels
      };
    };
    
    var _parseLegendFeed = function(title, feeds, feedsLength){
      var labels = [], rows = [], dimensionTag = ' / ', measureTag = ' - ';
      var MNDIndex = undefined, hasOnlyMND = false;
      //Handle colors feeds
      if(feeds && feeds.length > 0){
        for(var i = 0, len = feeds.length; i < len; i++) {
          if(feeds[i].type !== 'MND') {
            if(title === undefined) {
              title = handleNull(feeds[i].col.val);
            } else {
              title = title + dimensionTag + handleNull(feeds[i].col.val);
            }
            
            rows = feeds[i].rows;
            for(var j = 0; j < rows.length; j++) {
              if(labels[j] === undefined) {
                labels[j] = {};
                labels[j].val = handleNull(rows[j].val);
                labels[j].ctx = {
                  path : _setPathByaa(rows[j].ctx.path)
                };
              } else {
                labels[j].val = labels[j].val + dimensionTag + handleNull(rows[j].val);
              }
            }
          } else {
            MNDIndex = i;
          }
        }
        feedsLength = labels.length;
      }
      
      //Handle Colors with MND
      if(MNDIndex !== undefined) {
        //Save color feed with MND status.
        if(labels.length > 0){
          if(feeds[MNDIndex].rows.length > 1){
            if(MNDIndex === 0) {
              title = langManager.get('IDS_DEFAULTMND') + measureTag + title; 
              //MND is the first feed type. Legend label should be 'MND - A/B/C'
              labels = getCartesian([handleNullInArray(feeds[MNDIndex].rows), labels], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } else if(MNDIndex === feeds.length - 1) {
              title = title + measureTag + langManager.get('IDS_DEFAULTMND');
              //MND is the last feed type. Legend label should be 'A/B/C - MND'
              labels = getCartesian([labels, handleNullInArray(feeds[MNDIndex].rows)], measureTag);
              feedsLength = feedsLength * feeds[MNDIndex].rows.length;
            } else {
//              console.log('MND is not correct');
            }
          }
        }else{
          title = langManager.get('IDS_DEFAULTMND');
          rows = feeds[MNDIndex].rows;
          for(var j = 0; j < rows.length; j++) {
            labels.push(rows[j]);
          }
          feedsLength = rows.length;
          if(rows.length === 1){
            hasOnlyMND = true;
          }
        }
      }
      
      return {
        'title' : title,
        'labels' : labels,
        'feedsLength' : feedsLength,
        'MNDInfo' : {
          'MNDIndex' : MNDIndex,
          'hasOnlyMND': hasOnlyMND //Only has MND, no cartesian
        }
      };
    };
    
    var _setPathByaa = function(path){
      var pathObj = {};
      switch(path.aa){
        case 0:
          pathObj.dii_a1 = path.dii;
          break;
        case 1:
          pathObj.dii_a2 = path.dii;
          break;
        case 2:
          pathObj.dii_a3 = path.dii;
          break;
      }
      return pathObj;
    };
    
    /*
     * Calculate legend row position and return legend max size. 
     */
    var _calculateRowPosition = function(wholeSize, layoutSpace, containerInfo) {
      var maxHeight = 0, maxWidth = 0, minWidth = 0, minHeight = 0, titleSize = {width:0, height:0}, legendAreaSize = {};
      
      //Cal legend size and position.
      if(options.visible){
        var labelFont = "font-size:" + titleFont.fontsize + "; font-weight:" + titleFont.fontweight + "; font-family:" + titleFont.fontfamily;
        
        textHeight = parseInt(valueLabelFont.fontsize); //1em
        
        var xPos = margin.left * textHeight, yPos = margin.top * textHeight;
        
        //Measure title size
        if(options.isShowTitle) {
          titleSize = TextRuler.measure(((options.titleText===undefined) ? chartData.title : options.titleText), labelFont);
          if (!hideTitle) {
              yPos = yPos + titleSize.height + titleMarginBottom * textHeight;
          }
        }
        
        //Legend Area Position
        legendAreaPos = { x : xPos, y: yPos};
        
        legendAreaSize = legendArea.getPreferredSize({height: wholeSize.height-xPos, width: wholeSize.width}, layoutSpace, xPos, containerInfo, sizeBubbleScale, sizeBubbleSpace, sizeBubbleHasHeightFeed);
        
        //Measure labels size
        //If colors feed don't have MND, can't show legend in hierarchy.
        if(!isBubbleColorLegend() && options.isHierarchy){
          maxWidth = xPos + ((titleSize.width > legendAreaSize.width) ? titleSize.width : legendAreaSize.width);
          maxHeight = yPos + legendAreaSize.height;
        }else{
          if(options.position === 'left' || options.position === 'right') {
            maxWidth = xPos + ((titleSize.width > legendAreaSize.width && !isSizeLegend()) ? titleSize.width : legendAreaSize.width);
            maxHeight = yPos + legendAreaSize.height;
          }else{
            maxWidth = xPos + legendAreaSize.width;
            maxHeight = titleSize.height + titleMarginBottom * textHeight + textHeight;          
          }
        }
        minWidth = xPos + (legendAreaSize.minWidth ? legendAreaSize.minWidth : 0);
        minHeight = yPos + (legendAreaSize.minHeight ? legendAreaSize.minHeight : 0);
        
        relayout = false;
      }
      
      //create preference size object.
      preferenceSize = {
          maxSizeConstant : 1 / 3,
          titleSize : titleSize,
          minWidth: minWidth,
        height: maxHeight,
        width: maxWidth
      };
      if(legendAreaSize.minHeight){
        preferenceSize.minHeight = minHeight;
      }
      return preferenceSize;
    };
    
    var _containsVal = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i].val === obj) {
                return true;
            }
        }
        return false;
    };
    
    var getCartesian = function(arrays, symbol) {
      var result = arrays[0];
      for(var i = 1; i < arrays.length; i++) {
        fff(arrays[i]);
      }
      function fff(arr) {
        var ar = result;
        result = [];
        for(var i = 0; i < ar.length; i++) {
          for(var j = 0; j < arr.length; j++) {
            var t1 = (ar[i].val === undefined) ? ar[i].val : ar[i].val, t2 = (arr[j].val === undefined) ? arr[j].val : arr[j].val;
            var ctx = {
              path : {}
            };
            ObjectUtils.extend(ctx.path, ar[i].ctx.path, arr[j].ctx.path);
            result.push({
              'val': t1 + symbol + t2, 
              'ctx': ctx
            });
          }
        }
      }

      return result;
    };
    
    var isColorFeeds = function(feedName){
      var result = false;
//      if(Manifest.feeds[feedName].semantic === 'COLOR'){
//        result = true;
//      }
      if(feedName.search('color') !== -1){
        result = true;
      }
      return result;
    };
    
    var isShapeFeeds = function(feedName){
      var result = false;
//      if(Manifest.feeds[feedName].semantic === 'SHAPE'){
//        result = true;
//      }
      if(feedName.search('shape') !== -1){
        result = true;
      }
      return result;
    };
    
    var isColorLegend = function(){
      var result = false;
      if(options.legendType === 'ColorLegend'){
        result = true;
      }
      return result;  
    };
    
    var isSizeLegend = function(){
      var result = false;
      if(options.legendType === 'SizeLegend'){
        result = true;
      }
      return result;  
    };
    
    var isBubbleColorLegend = function(){
      var result = false;
      if(options.legendType === 'BubbleColorLegend'){
        result = true;
      }
      return result;  
    };
    
    var isMeasureBasedColoringLegend = function(){
      var result = false;
      if(options.legendType === 'MeasureBasedColoringLegend'){
        result = true;
      }
      return result;  
    };
    
    //alex su
    var handleNull = function(_){
      var defaultString = langManager.get('IDS_ISNOVALUE');
      if (_ === null || _ === undefined)
        return defaultString;
      else 
        return _;
    };
    
    var handleNullInArray = function(array){
      for (var i = 0; i < array.length; ++i)
        array[i].val = handleNull(array[i].val);
      return array;
    };
    
//    var handleNullInArray = function(array){
//      var newArray = cloneObject(array);
//      for (var i = 0; i < newArray.length; ++i)
//        newArray[i].val = handleNull(newArray[i].val);
//      return newArray;
//    };
//    
//    var cloneObject = function(object){
//
//          if(typeof(object)!='object') return object;
//          if(object==null) return object;
//          
//          var o=Object.prototype.toString.call(object)==='[object Array]'?[]:{};
//
//          for(var i in object){
//                  if(typeof object[i] === 'object'  ){
//                          o[i]=cloneObject(object[i]);
//                  }else o[i]=object[i];
//          }
//          
//          return o;
//    };
    
    chart.properties(null);
    return chart;
  };
  return legend;
});sap.riv.module(
{
  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'},
[

],

function Setup() {
  var boundingbox = {};
  boundingbox.getBBox = function (node, rootNode) {
    var matrix;
    if (arguments.length === 1) {
      matrix = node.getCTM();
    } else {
      matrix = node.getTransformToElement(rootNode);
    }
    return boundingbox.getBBoxHelp(node, matrix);
  };

  boundingbox.getBBoxHelp = function (node, matrix) {
    var box = node.getBBox();
    var corners = new Array();
    var point = d3.select('svg')[0][0].createSVGPoint();
    point.x = box.x;
    point.y = box.y;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x + box.width;
    point.y = box.y;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x + box.width;
    point.y = box.y + box.height;
    corners.push(point.matrixTransform(matrix));
    point.x = box.x;
    point.y = box.y + box.height;
    corners.push(point.matrixTransform(matrix));
    var minX = corners[0].x;
    var maxX = corners[0].x;
    var minY = corners[0].y;
    var maxY = corners[0].y;
    for (var i = 1; i < corners.length; i++) {
      var x = corners[i].x;
      var y = corners[i].y;
      if (x < minX) {
        minX = x;
      } else if (x > maxX) {
        maxX = x;
      }
      if (y < minY) {
        minY = y;
      } else if (y > maxY) {
        maxY = y;
      }
    }

    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY - minY
    };
  };

  // return true if the two boxes intersect
  boundingbox.intersects = function(a, b) {
    return (a.x <= (b.x + b.width) &&
        b.x <= (a.x + a.width) &&
        a.y <= (b.y + b.height) &&
        b.y <= (a.y + a.height));
  };

  // returns a box representing the intersection of box1 and box2 if it exists, otherwise null
  boundingbox.intersection = function(box1, box2) {
    if (boundingbox.intersects(box1, box2)) {
      var x1 = Math.max(box1.x, box2.x),
          x2 = Math.min(box1.x + box1.width, box2.x + box2.width),
          y1 = Math.max(box1.y, box2.y),
          y2 = Math.min(box1.y + box1.height, box2.y + box2.height);

      return {
        x: x1,
        y: y1,
        width: x2 - x1,
        height: y2 - y1
      };
    }

    return null;
  };

  return boundingbox;
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.lasso',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(TextUtils, dispatch, ObjectUtils, TypeUtils, BoundingBox,Constants) {
  return function(){
    var eDispatch = null;
    var g, m, eventshape, props, domElement, modules, plots = [], lastSelected = [], selectionMode = 'multiple', lastLassoed = [];
    var startPos,  //point on client position
      lassoHelper, //a rect holder
      hitTestRect = {}, eFilter = '.datapoint', 
      isLassoStart = false,
      selectWithCtrlKey = false;
    
    var unhighlightTarget = null, lastOvered = [], eventLayer = null, lastHovered = [];
    
    var reset = function(){
      plots = [];
    };
    
    //selection is the contain of main
    var lasso = function(){
      return lasso;
    };
    
    lasso.lastOvered = function(_){
      if(!arguments.length){
        return lastOvered;
      }
      lastOvered = _;
      return lasso;
    };
    
    lasso.unhighlightTarget = function(_){
      if(!arguments.length){
        return unhighlightTarget;
      }
      unhighlightTarget = _;
      return lasso;
    };
    
    lasso.lastHovered = function(_){
      if(!arguments.length){
        return lastHovered;
      }
      lastHovered = _;
      return lasso;
    };
    
    lasso.eventLayer = function(_){
      if(!arguments.length){
        return eventLayer;
      }
      eventLayer = _;
      return lasso;
    };
    
    lasso.registerEvent = function(){
      var temp = m.modules();
      for(var i in temp){
        if(temp.hasOwnProperty(i) && !(temp[i] instanceof Array) && temp[i].parent()){
          plots.push(temp[i]);
        }
      }
      
      g.on('mousedown.lasso', lassoStart, true);
      g.on('mousemove.lasso', lassoMove, true);
      g.on('mouseup.lasso', lassoEnd, true);
      
      $(g.node()).mouseleave(mouseleaveHandler);
    };
    
    lasso.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return lasso;
    };
    
    lasso.properties = function(_){
      if(!arguments.length){
        return props;
      }
      props = _;
      selectionMode = props.selectability && props.selectability.mode ? props.selectability.mode: 'multiple';
      selectWithCtrlKey = props.selectability && props.selectability.selectWithCtrlKey;
      return lasso;
    };
    
    lasso.isLasso = function(){
      return isLassoStart;
    };
    
    lasso.selected = function(_){
      if(!arguments.length){
        return lastSelected;
      }
      lastSelected = _;
      return lasso;
    };
    
    lasso.module = function(_){
      if(!arguments.length){
        return m;
      }
      reset();
      m = _, g = m.parent(), domElement = g.node();
      return lasso;
    };

    /*
     * alternative to mouse
     * reason: the result is incorrect in chrome/ie9 when browser zoom != 1
     */
    var mouse = function() {
      var e = d3.event,
          // geo needs to use eventLayer due to the fact that domElement will a bounding rect
          // that is greater than the viewport
          node = !eventLayer.empty() ? eventLayer.node() : domElement, 
          rect = node.getBoundingClientRect(),
          x = e.clientX - rect.left,
          y = e.clientY - rect.top;

      return [ x, y ];
    };

    // return a bounding box for the provided node
    var getBoundingBox = function(node) {
      var rect = node.getBoundingClientRect();
      return { x: rect.left, y: rect.top, height: rect.height, width: rect.width };
    };

    var stopEvent = function() {
      if(d3.event){
        d3.event.stopPropagation();
        d3.event.preventDefault();
      }
    };
    
    //filter the selectees to see whether the shape intersect with hitTestRect. 
    var filter = function(selectees, hitTestRect){
      var res = [];
      
      selectees.filter(function(d, m){
        var rect = getBoundingBox(this);
        if(BoundingBox.intersects(rect , hitTestRect)){
          res.push(this);
        }
      });

      return res;
    };
    
    var lassoStart = function(){
      if (selectionMode !== 'multiple')
        return;

      if (selectWithCtrlKey && !(d3.event.ctrlKey)) {
        return;
      }

      startPos = mouse();
      
      lassoHelper = g.append('rect')
        .attr('x', startPos[0])
        .attr('y', startPos[1])
        .attr('width', 0)
        .attr('height', 0)
        .attr('pointer-events', 'none')
        .attr('fill', 'rgba(64,176,240, 0.4)')
        .style('stroke-width', '2px')
        .attr('stroke', 'rgb(64, 176, 240)');
      
      isLassoStart = true;
      stopEvent();
    };
    
    var clearPlots  = function(_){
      for(var i = 0; i< plots.length; i++){
        if(plots[i].clear){
          plots[i].clear(_);
        }
      }
    };
    
    var lassoMove = function(){
      if(selectionMode !== 'multiple' || !isLassoStart)
        return;
      
      var pos = mouse(),
        x = Math.min(pos[0], startPos[0]),
        y = Math.min(pos[1], startPos[1]),
        width = Math.abs(pos[0] - startPos[0]),
        height = Math.abs(pos[1] - startPos[1]);

      lassoHelper.attr('x', x).attr('y', y).attr('width', width).attr('height', height);
    };
    
    var lassoEnd = function(){
      var clientPoint = {
          x : d3.event.clientX,
          y:  d3.event.clientY
      };
      lassoEndHandler(clientPoint);
    };

    var lassoEndHandler = function(clientPoint){
      if(selectionMode !== 'multiple' || !isLassoStart)
        return;
      
      isLassoStart = false;

      var bnode = lassoHelper.node(), box = getBoundingBox(bnode), bwidth = parseFloat(bnode.getAttribute('width')), bheight = parseFloat(bnode.getAttribute('height')),
          selectedData = [], 
          deselectedData = [];

      // remove the lasso element after this function executes
      setTimeout(function() {
        lassoHelper.remove();
      }, 0);
    
      if(bwidth || bheight){
        var plot, candidates, isInShape = false, selectees = null, selectedObj = [], 
            plotSubLayer = null,
            plotBox = null,
            intersectedBox = null;
        for(var i = 0, len= plots.length; i< len; i++) {
          plot = plots[i];
          candidates = null;

          if (TypeUtils.isFunction(plot.getDatapointsInRect)) {
            // if the plot supports this function, use it to retrieve datapoints within the 
            // bounds of the lasso element
            candidates = plot.getDatapointsInRect(lassoHelper.node());
          }
          else {
            // get a rectangle that represent the viewbox of the plot module
            plotSubLayer = plot.parent().select('rect.viz-event-sub-layer').node();

            // find the intersection of the plot rectangle with the lasso rectangle
            plotBox = plotSubLayer ? getBoundingBox(plotSubLayer) : null;
            intersectedBox = plotBox ? BoundingBox.intersection(plotBox, box) : box; // fall back to lasso rect if plot rectangle not available

            if (!intersectedBox) {
              // this is null if the lasso was not over the plot's area
              // no need to check datapoints for this plot
              continue;
            }

            selectees = plot.parent().selectAll('.datapoint');

            if(selectees[0].length > 0){
              candidates = filter( selectees , intersectedBox );
            }
          }

          if(candidates && candidates.length > 0 ){
            selectedObj.push({
              plot: plot,
              selected: candidates
            });
          }
        }
        
        if(selectedObj.length > 0){
          
          if(lastSelected.length  == 0){
            
            unhighlightTarget(lastSelected, false);
            
            clearPlots(true);
          }
          
          //if the length of lastSelect is large than 0, it means that the chart is in highlight status, do not need to clear the chart to gray
          var plot = null, selected = null, isHighlight = false, lastSelectedBack = ObjectUtils.extend(true , [], lastSelected);
          for(var i=0, len= selectedObj.length; i < len; i++){
            plot = selectedObj[i].plot, selected = selectedObj[i].selected;
            for(var j=0, jlen = selected.length; j < jlen; j++){
              for(var t =0, tlen = lastSelectedBack.length; t < tlen; t++){
                if(selected[j] == lastSelectedBack[t]){
                  isHighlight = true;
                  break;
                }
              }
              
              //If the shape is not in queue of lastSelected
              //maybe we should deselect the shape which is already in highlight status, currently, do not need
              if(isHighlight){
                //lastSelected.splice((t - 1, 1));
                selectedData.push(selected[j]); // only fire the change the data
              }else{
                lastSelected.push(selected[j]);
                selectedData.push(selected[j]); // only fire the change the data
              }
              
              isHighlight = false;
            }
            //highlight selected shapes
            plot.highlight(selected);
          }
        }else{
          //there are no shapes selected
          if(lastSelected.length > 0){
            //if there are selected before, clear all
            unhighlightTarget(lastSelected, false);

            
            clearPlots();
          }
          
          deselectedData  = deselectedData.concat(lastSelected);
          
          lastSelected.splice(0, lastSelected.length);
        }
        
        //eDispatch.lassoEnd(candidates);
        if(selectedData.length > 0){
          fireSelectDataEvent(selectedData);
        }
        
        if(deselectedData.length >0){
          fireDeselectDataEvent(deselectedData);
        }
        
        //clear lastOvered effect
        for(var i =0, len = lastOvered.length; i< len;i++){
          if(lastOvered[i].plot.mouseout){
            lastOvered[i].plot.mouseout(lastOvered[i].target, true);
          }
        }
        
        lastOvered.splice(0, lastOvered.length);
        
        stopEvent();
      }
    };
    
    var mouseleaveHandler = function(evt){
      if(isLassoStart){
        var clientPoint = {
            x: evt.clientX,
            y: evt.clientY
        };
        lassoEndHandler(clientPoint);
        
        isLassoStart = false;
      }
      
      for(var i=0, len = lastHovered.length; i <len; i++){
        if(lastHovered[i].blurOut){
          lastHovered[i].blurOut();
        }
      }
      
      lastHovered.splice(0, lastHovered.length);
    };
    
    function fireSelectDataEvent(selectedShapes){
      var selectData = [];
      for(var i=0, len= selectedShapes.length; i < len; i++){
        var tarData = [], value = selectedShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen= value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: selectedShapes[i].__data__.val,
            ctx: selectedShapes[i].__data__.ctx
          });
        }
        selectData.push({
          target: selectedShapes[i],
          data: tarData
        });
      }
      
      eDispatch.selectData({
        name: Constants.Module.Event.SelectData.name,
        data: selectData
      });
    };
    
    function fireDeselectDataEvent(deselectShapes){
      var deselectData = [];
      for(var i=0, len= deselectShapes.length; i < len; i++){
        var tarData = [], value = deselectShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen=value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: deselectShapes[i].__data__.val,
            ctx: deselectShapes[i].__data__.ctx
          });
        }
        deselectData.push({
          target: deselectShapes[i],
          data: tarData
        });
      }
      
      eDispatch.deselectData({
        name: Constants.Module.Event.DeSelectData.name,
        data: deselectData
      });
    };
    
    return lasso;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.controller.interaction',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.controller.lasso',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(TextUtils, dispatch, lassoHelp, TypeUtils,Constants) {
  return function(){
    
    var g = null, m, lastSelected = [], selectionMode = 'multiple', plots = [], subeventLayers = [], props = null, lasso = lassoHelp(), supportedEventNames = []; 
    var supportLassoEvent = true, lastHovered = [], eventLayer = null, lastOvered = [];
    var eDispatch = new dispatch('selectData', 'deselectData', 'deselectLegend');
    var mouseEventHandler = {
        'mouseup' :  null,
        'mousemove' : null,
        'mouseout' : null,
        'mouseover' : null,
        'touchstart' : null
    }, isRegister = false, defaultSupportedEventNames = ['mouseup', 'mousemove', 'mouseout', 'mouseover','touchstart'],
      mousedownPos = null,
      preserveSelectionWhenDragging = false;
    
    var enableMouseMove = true, enableMouseOver = true, enableMouseOut = true, holdSelection = false;
    
    var reset = function(){
      isRegister = false;
      plots = [];
      lastSelected.splice(0, lastSelected.length);
      lastHovered.splice(0, lastHovered.length);
      lastOvered.splice(0, lastOvered.length);
      for(var i =0, len = subeventLayers.length; i<len;i++){
        subeventLayers[i].remove();
      }
      subeventLayers = [];
    };
    
    var selection = function(){
      
      lasso.dispatch(eDispatch).selected(lastSelected).lastOvered(lastOvered).lastHovered(lastHovered).unhighlightTarget(unhighlightTarget);
      
      return selection;
    };
    
    var clearPlots  = function(_){
      for(var i = 0; i< plots.length; i++){
        if(plots[i].clear){
          plots[i].clear(_);
        }
      }
    };

    var pointInPlot = function(t, plot){
      var p = plot.parent()[0][0].getBoundingClientRect();
      return (t.x >= p.left && t.x <= p.left + p.width && t.y >= p.top && t.y <= p.top + p.height);
    };

    // returns an array of the plot's parent nodes, in the same order as the "plots" array
    var getPlotNodes = function() {
      var nodes = [];
      for (var i = 0, len = plots.length; i < len; i++) {
        if (plots[i].parent()) {
          nodes.push(plots[i].parent().node());
        }
      }
      return nodes;
    };

    // returns the index of the plot (in the "plots" array) that contains the target element
    // nodes is optional and should contain the container elements for the plots
    var plotIndexContainingTarget = function(target, nodes) {
      var n = target,
        plotNodes = nodes || getPlotNodes(),
        idx;

      for (; n && n.ownerSVGElement; n = n.parentNode) {
        idx = plotNodes.indexOf(n);
        if (idx !== -1) {
          return idx;
        }
      }

      return -1;
    };

    // returns the plot module object that contains the target element
    var plotContainingTarget = function(target, nodes) {
      var plotIdx = plotIndexContainingTarget(target, nodes);

      if (plotIdx !== -1) {
        return plots[plotIdx];
      }

      return null;
    };

    // returns the input targets, organized by their parent plot
    // the result object is an array, with each entry corresponding to a plot in the "plot" array
    // each entry is an array of targets
    var groupTargetsByPlot = function(targets) {
      var plotNodes = getPlotNodes(),
          results = [];

      for (var i = 0, len = plots.length; i < len; i++) {
        results.push([]);
      }

      for (var i = 0, len = targets.length; i < len; i++) {
        var target = targets[i],
          idx = plotIndexContainingTarget(target, plotNodes),
          plotTargets;

        if (idx !== -1) {
          plotTargets = results[idx];
          plotTargets.push(target);
        }
        else {
          // log/throw error?
        }
      }

      return results;
    };

    var highlightTarget = function(target) {
      var plot = plotContainingTarget(target);
      if (plot && plot.highlight) {
        plot.highlight(target);
      }
    };
    
    // CTIsDatapoint means the current target is datapoint shape or not
    // target can be an array or a single element
    var unhighlightTarget = function(target, CTIsDatapoint) {
      var targets = TypeUtils.isArray(target) ? target : [ target ],
          targetsGroupedByPlot = groupTargetsByPlot(targets);

      for (var i = plots.length - 1; i >= 0; i--) {
        var plot = plots[i],
            plotTargets = targetsGroupedByPlot[i];

        if (plotTargets && plotTargets.length > 0 && plot.unhighlight) {
          plot.unhighlight(plotTargets, CTIsDatapoint);
        }
      }
    };
    
    selection.registerEvent = function(){
      //TODO, [Ian] register event function will be called more than once as in multi chart, modules will fire more than one complete animation event.
      if(isRegister == false){
        isRegister = true;
        
        
        var temp = m.modules();
        for(var i in temp){
          if(temp.hasOwnProperty(i) && !(temp[i] instanceof Array) && temp[i].parent()){
            var height, width;
            if (temp[i].getPreferredSize && temp[i].getPreferredSize()){
              height = temp[i].getPreferredSize().height;
              width = temp[i].getPreferredSize().width;
            } else {
              height = temp[i].height();
              width = temp[i].width();
            }
            var subeventLayer = temp[i].parent().insert('rect', 'g').attr('width', width).attr('height', height).attr('opacity', '0').attr('class', 'viz-event-sub-layer');
            subeventLayers.push(subeventLayer);

            plots.push(temp[i]);
          }
        }
        
        if(!eventLayer){
          eventLayer = g.insert("rect", "g").attr("x", 0).attr("y", 0).attr("fill-opacity", 0);
          lasso.eventLayer(eventLayer);
        }
        eventLayer.attr("width", m.width()).attr("height", m.height());
        if(supportedEventNames != null && supportedEventNames instanceof Array){
          for(var i=0, len = supportedEventNames.length; i< len; i++){
            if(mouseEventHandler[supportedEventNames[i]]){
              g.on(supportedEventNames[i] + '.interaction', mouseEventHandler[supportedEventNames[i]]);
            }
          }
        }
        
        if(supportLassoEvent == true){
          lasso.registerEvent();
        }
        if (preserveSelectionWhenDragging === true) {
          g.on('mousedown.preserveSelectionWhenDragging', function() {
              mousedownPos = d3.mouse(g.node());
            }, true);
        }
      }else{
        eventLayer.attr('width', m.width()).attr('height', m.height());
        lasso.eventLayer(eventLayer);
        
        //reset the size of subevent layer
        for(var i=0, len= subeventLayers.length; i<len; i++){
          subeventLayers[i].attr('width', plots[i].width()).attr('height', plots[i].height());
        }
        
        for(var i=0, len =lastHovered.length; i<len; i++){
          if(lastHovered[i].blurOut){
            lastHovered[i].blurOut();
          }
        }
        lastHovered.splice(0, lastHovered.length);
        
        for(var i=0, len =lastOvered.length; i< len; i++){
          if(lastOvered[i].plot.mouseout){
            lastOvered[i].plot.mouseout();
          }
        }
        lastOvered.splice(0, lastOvered.length);
        
        if(holdSelection == false){
          lastSelected.splice(0, lastSelected.length);
        }
      }
      
    };
    
    //[2012/09/11 Christy] Get selection mode for legend.
    selection.getSelectionMode = function(){
      return selectionMode;
    };
    
    //[2012/09/10 Christy] Legend is selected.  
    selection.highlightedByLegend = function(selectedData, isSelected){
      if(selectionMode === 'single' || selectionMode === 'none'){
        //Doesn't work in single mode.
        return;
      }
      var datapoints = [], itemData, isSame = true, ctxDatapoints = [], isDeselected = true, selectedObjs = [], selectDatas = [], deselectDatas = [], selectDatapoints = [], deselectDatapoints = [];
      for(var i = 0, len = plots.length; i < len; i++){
        //Reset datapoints arrary which contains selectedData ctx.
        ctxDatapoints = [];
        
        if(selectedData.ctx.ranges){
          //MBC legend
          if(plots[i].getDatapointsByRange){
            ctxDatapoints = plots[i].getDatapointsByRange(selectedData);
            selectedObjs.push({
              plot: plots[i],
              ctxDatapoints : ctxDatapoints
            });
          }
        } else { 
          if (plots[i].getDatapointsByLegend) {
            ctxDatapoints = plots[i].getDatapointsByLegend(selectedData);
            selectedObjs.push({
              plot: plots[i],
              ctxDatapoints : ctxDatapoints
            });
          } else {
            datapoints = plots[i].parent().selectAll('.datapoint')[0];
            
            for(var j = 0, jLen = datapoints.length; j < jLen; j++){
              if(datapoints[j].__data__ && datapoints[j].__data__.ctx){
                if(datapoints[j].__data__.ctx.path) {
                  itemData = datapoints[j].__data__.ctx.path;
                }else{
                  //Multi measures. For bubble or tagcloud.
                  itemData = datapoints[j].__data__.ctx[0].path;
                }
                
                //Check selectedData contains this ctx.
                isSame = true;
                for(var k in itemData){
                  if(selectedData.ctx.path[k] != undefined){
                    if(selectedData.ctx.path[k].length > 0){
                      if(_contains(selectedData.ctx.path[k], itemData[k]) === false){
                        isSame = false;
                      }
                    }else{
                      if(selectedData.ctx.path[k] !== itemData[k]){
                        isSame = false;
                      }
                    }
                  }
                }
                if(isSame === true){
                  //Push datapoint which has the same ctx with selectedData.
                  ctxDatapoints.push(datapoints[j]);
                }
              }
            }
          
            if(datapoints.length > 0){
              selectedObjs.push({
                plot: plots[i],
                ctxDatapoints : ctxDatapoints
              });
            }
          }
        }
      }

      //Deselected this series datapoint or not.
      if(lastSelected.length === 0){
        isDeselected = false;
      } else {
        var numOfDataPoints = 0;
        
        for(var i = 0, len = selectedObjs.length; i < len; i++){
          ctxDatapoints = selectedObjs[i].ctxDatapoints;
          var kLen = ctxDatapoints.length;
          numOfDataPoints += kLen;
          for(var k= 0; k < kLen; k++){
            if(_contains(lastSelected, ctxDatapoints[k]) === false){
              //One ctxDatapoint is not selected. Highlight this series datapoints.
              isDeselected = false;
              break;
            }
          }
        }
        if (isDeselected && !numOfDataPoints) {
          isDeselected = false;
        }
      }
      
      for(var i = 0, len = selectedObjs.length; i < len; i++){
        ctxDatapoints = selectedObjs[i].ctxDatapoints;  
        selectDatapoints = [], deselectDatapoints = [];
        for(var k= 0, kLen = ctxDatapoints.length; k < kLen; k++){
          var index = _contains(lastSelected, ctxDatapoints[k]);
          if(isDeselected){
            //deselected
            deselectDatapoints.push(ctxDatapoints[k]);
            lastSelected.splice(index, 1);
            deselectDatas.push(ctxDatapoints[k]);
          }else{
            //selected
            if(lastSelected.length == 0){
              clearPlots(true);
            }
            selectDatapoints.push(ctxDatapoints[k]);
            selectDatas.push(ctxDatapoints[k]);
            if(index === false){
              lastSelected.push(ctxDatapoints[k]);
            }
          }
        }
        
        //update highlight and unhighlight effect.
        if(deselectDatapoints.length > 0){
          selectedObjs[i].plot.unhighlight(deselectDatapoints, false);
        }
        if(selectDatapoints.length > 0){
          selectedObjs[i].plot.highlight(selectDatapoints, false);
        }
        
        if(isDeselected){
          //remove legend selected effect.
          eDispatch.deselectLegend(selectedData);
        }
        if(lastSelected.length === 0){
          clearPlots();
        }
      }
      
      //Send select/deselect event
      if(selectDatas.length > 0){
          fireSelectDataEvent(selectDatas);
        }
        
        if(deselectDatas.length > 0){
          fireDeselectDataEvent(deselectDatas);
        }
        
      return isDeselected;
    };
    
    //[2012/09/10 Christy] utility method.
    var _contains = function(a, obj){
      for (var i = 0; i < a.length; i++) {
            if (a[i] === obj) {
                return i;
            }
        }
        return false;
    };
    
    selection.dispatch = function(_){
      if(!arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return selection;
    };
    
    mouseEventHandler['mousemove'] = function(){
      if(lasso.isLasso() || enableMouseMove == false){
        return;
      }
      var cp = {
          x: d3.event.clientX,
          y: d3.event.clientY
      };
      var hoveredplots = [];
      for(var i =0, len = plots.length; i< len; i++){
        if(plots[i].parent() && pointInPlot(cp, plots[i])){
          hoveredplots.push(plots[i]);
        }
      }
      
      var isHovered = false;
      for(var i =0, len= lastHovered.length; i< len; i++){
        for(var j=0, jlen = hoveredplots.length; j< jlen; j++){
          if(lastHovered[i] == hoveredplots[j]){
            isHovered = true;
            break;
          }
        }
        if(isHovered == false && lastHovered[i].blurOut){
          lastHovered[i].blurOut();
        }
        isHovered = false;
      }
      
      for(var i=0, len= hoveredplots.length; i < len; i++){
        if(hoveredplots[i].hoverOnPoint){
            var cb = hoveredplots[i].parent().node().getBoundingClientRect();
             
             hoveredplots[i].hoverOnPoint({
               x : cp.x - cb.left,
               y : cp.y - cb.top
             });
        }
      }
      
      lastHovered.splice(0, lastHovered.length);
      for(var i=0, len = hoveredplots.length; i<len;i++){
        lastHovered.push(hoveredplots[i]);
      }
    };
    
    mouseEventHandler['mouseover'] = function(){
      if(lasso.isLasso() || enableMouseOver == false){
        return;
      }
      
       var target =d3.event.target, classname = target.getAttribute('class');
       
       if(classname != null && classname.indexOf('datapoint') != -1){
         
         var isHighlighted = false;
         for(var i=0, len = lastSelected.length; i < len; i++){
           if(target === lastSelected[i]){
             isHighlighted = true;
             break;
           }
         }
        
         if(lastSelected.length == 0 ){
          isHighlighted = true;
        }

        var plot = plotContainingTarget(target);
        if (plot) {
          lastOvered.push({
               plot: plot,
               target: target
            });

          if(plot.mouseover){
            plot.mouseover(target, isHighlighted);
          }
        }
       }
       
    };
    
    mouseEventHandler['mouseout'] = function(){
      if(lasso.isLasso() || enableMouseOut == false){
        return;
      }
      
       var target =d3.event.target, classname = target.getAttribute('class');
       
       if(classname != null && classname.indexOf('datapoint') != -1){
         
         var isHighlighted = false;
         for(var i=0, len = lastSelected.length; i < len; i++){
           if(target === lastSelected[i]){
             isHighlighted = true;
             break;
           }
         }
         
        if(lastSelected.length == 0 ){
          isHighlighted = true;
        }
         
        var plot = plotContainingTarget(target);

        for (var i = 0, len = lastOvered.length; i < len; i++) {
          var lastOver = lastOvered[i];

          // FIXME always invoke mouseout event handler on plot?
          if (lastOver.target === target/* && lastOver.plot === plot*/) {
            lastOvered.splice(i, 1);
            if (plot.mouseout) {
              plot.mouseout(target, isHighlighted);
            }
            break;
          }
        }
       }
    };
    
    mouseEventHandler['mouseup'] = function(){
      if (preserveSelectionWhenDragging && mousedownPos) {
        var pos = d3.mouse(g.node());

        // cheap mechanism to cancel the 'mouseup' event handler when dragging the mouse
        // for example, when panning the geocharts
        if (Math.abs(pos[0] - mousedownPos[0]) > 5 ||
            Math.abs(pos[1] - mousedownPos[1]) > 5) {
          return;
        }
      }
      if(selectionMode !== 'none'){
          
          var target = d3.event.target, classname = target.getAttribute('class'), selectDatas = [], deselectDatas = [];
          //if  the click is on eventLayer, deselect all
          if( classname == null || classname.indexOf('datapoint') == -1){
            
            unhighlightTarget(lastSelected, false);

            clearPlots();
            deselectDatas = deselectDatas.concat(lastSelected);
            lastSelected.splice(0, lastSelected.length);
            
            //[2012/09/11 Christy] deselect all legend items.
            eDispatch.deselectLegend();
          }else{
            var isHighlighted = false;
            for(var i =0, len = lastSelected.length; i<len; i++){
              if(target == lastSelected[i]){
                isHighlighted = true;
                break;
              }
            }
            if(lastSelected.length == 0){ //it means the isHighlighted false
              
              clearPlots(true);
              highlightTarget(target);
              lastSelected.push(target);
              
              selectDatas.push(target);
            }else{
              if(isHighlighted){
                if(selectionMode == 'single'){
                  unhighlightTarget(lastSelected[0]);
                  
                  clearPlots();
                  lastSelected.splice(0, lastSelected.length);
                  
                  deselectDatas.push(target);
                }else{
                  var changeSelected = lastSelected.splice((i),1);
                  deselectDatas = deselectDatas.concat(changeSelected);
                  
                  if(lastSelected.length == 0){
                    unhighlightTarget(target);
                    clearPlots();
                  }else{
                    unhighlightTarget(target);
                    deselectDatas.push(target);
                  }
                }
              }else{
                if(selectionMode == 'single'){
                  unhighlightTarget(lastSelected[0]);
                  deselectDatas.push(lastSelected[0]);
                  
                  highlightTarget(target);
                  selectDatas.push(target);
                  
                  lastSelected[0] = target;
                }else{
                  
                  selectDatas.push(target);
                  highlightTarget(target);
                  
                  lastSelected.push(target);
                }
              }
            }
          }
          
          if(selectDatas.length > 0){
            fireSelectDataEvent(selectDatas);
          }
          
          if(deselectDatas.length > 0){
            fireDeselectDataEvent(deselectDatas);
          }
          
        }
    };
    
    mouseEventHandler['touchstart'] = mouseEventHandler['mouseup'];
    
    function fireSelectDataEvent(selectedShapes){
      var selectData = [];
      for(var i=0, len= selectedShapes.length; i < len; i++){
        var tarData = [], value = selectedShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen= value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: selectedShapes[i].__data__.val,
            ctx: selectedShapes[i].__data__.ctx
          });
        }
        selectData.push({
          target: selectedShapes[i],
          data: tarData
        });
      }
      
      eDispatch.selectData({
        name: Constants.Module.Event.SelectData.name,
        data: selectData
      });
    };
    
    function fireDeselectDataEvent(deselectShapes){
      var deselectData = [];
      for(var i=0, len= deselectShapes.length; i < len; i++){
        var tarData = [], value = deselectShapes[i].__data__;
        if(value.val instanceof Array){
          for(var j=0, jlen=value.val.length; j< jlen; j++ ){
            tarData.push({
              val: value.val[j],
              ctx: value.ctx[j]
            });
          }
        }else{
          tarData.push({
            val: deselectShapes[i].__data__.val,
            ctx: deselectShapes[i].__data__.ctx
          });
        }
        deselectData.push({
          target: deselectShapes[i],
          data: tarData
        });
      }
      
      eDispatch.deselectData({
        name: Constants.Module.Event.DeSelectData.name,
        data: deselectData
      });
    };
    
    
    selection.properties = function(_){
      if(!arguments.length){
        return props;
      }
      props = _;
      lasso.properties(props);
      selectionMode = props.selectability && props.selectability.mode ? props.selectability.mode : 'multiple';
      supportedEventNames = props.supportedEventNames ? props.supportedEventNames : defaultSupportedEventNames;
      enableMouseMove = props.enableMouseMove != null? props.enableMouseMove:true;
      enableMouseOver = props.enableMouseOver != null? props.enableMouseOver:true;
      enableMouseOut = props.enableMouseOut != null? props.enableMouseOut: true;
      supportLassoEvent = props.supportLassoEvent != null? props.supportLassoEvent : true;
      holdSelection = props.holdSelection != null? props.holdSelection : false;
      preserveSelectionWhenDragging = Boolean(props.preserveSelectionWhenDragging);
    };
    
    selection.module = function(_){
      if(!arguments.length){
        return m;
      }
      reset();//clear flag to have another chance to register event
      m = _, g = m.parent();
      lasso.module(_);
      return selection;
    };
    return selection;
  };
});sap.riv.module(
{
  qname : 'sap.viz.mvc.CSSParserUtility',
  version : '4.0.0'},
[

],
function Setup() {
    var CSSParserUtility = function() {
    }
    
    var cp = CSSParserUtility.prototype;
    
    /*
     * split string
     */
    cp.split = function(str, splitter) {
        if (/['"]/.test(splitter)) throw '\' " is not allowed in splitter.';
        if (str == '') return [str];
        var stack = [];
        var res = [];
        var start = 0;
        var sl = splitter.length;
        var l = str.length;
        for (var i = 0; i < l; i++) {
            var c = str.charAt(i);
            if (c == "'" || c == '"') {
                if (stack.length > 0) {
                    var c2 = stack.pop();
                    if (c != c2) {
                        stack.push(c2);
                        stack.push(c);
                    } 
                } else {
                    stack.push(c);
                }
                continue;
            }
            if (stack.length > 0) continue;
            var sub = str.substring(i, i + sl);
            if (sub == splitter) {
                res.push(str.substring(start, i));
                i = start = i + sl;
            }
        }
        if (start < l) res.push(str.substring(start));
        return res;
    }
    /*
     * is the string a color
     */
    cp.COLORS = ['aqua', 'black', 'blue', 'fuchsia', 'gray', 'green', 'lime', 'maroon', 'navy', 'olive', 'orange', 'purple', 'red', 'silver', 'teal', 'white', 'yellow', 'transparent'];
    cp.isColor = function(colorStr) {
        colorStr = colorStr.toLowerCase();
        //color name
        if (this.COLORS.indexOf(colorStr) >= 0) return true;
        //starts with #
        if (colorStr.charAt(0) == '#') {
            var l = colorStr.length;
            if (l != 4 && l != 7) return false;
            return ! /[^0-9a-f]/.test(colorStr.substring(1));
        }
        //rgb()
        var num = '-?[0-9\\.]+%?';
        var rgbRE = RegExp('^rgb\\(' + num + ',' + num + ',' + num + '\\)$');
        if (rgbRE.test(colorStr)) return true;
        return false;
    }
    cp.NUM_RE_STR = '[0-9]+|[0-9]*\\.[0-9]+';
    /*
     * is the string a length
     */
    cp.isLength = function(lengthStr) {
        lengthStr = lengthStr.toLowerCase();
        var lengthRE =  new RegExp('^(' + this.NUM_RE_STR + ')(em|ex|in|cm|mm|pt|pc|px)$');
        return lengthRE.test(lengthStr);
    }
    /*
     * is percentage
     */
    cp.isPercentage = function(str) {
        var re = new RegExp('^' + this.NUM_RE_STR + '%$');
        return re.test(str);
    }
    /*
     * is the string a width
     */
    cp.WIDTHS = ['thin', 'medium', 'thick'];
    cp.isWidth = function(widthStr) {
        return this.WIDTHS.indexOf(widthStr) >=0 || this.isLength(widthStr);
    }
    /*
     * is the string a border style
     */
    cp.BORDER_STYLES = ['none', 'hidden', 'dotted', 'dashed', 'solid', 'double', 'groove', 'ridge', 'inset', 'outset'];
    cp.isBorderStyle = function(styleStr) {
        styleStr = styleStr.toLowerCase();
        return this.BORDER_STYLES.indexOf(styleStr) >= 0;
    }
    /*
     * is font style
     */
    cp.FONT_STYLES = ['italic', 'oblique'];
    cp.isFontStyle = function(str) {return this.FONT_STYLES.indexOf(str.toLowerCase()) >= 0;}
    /*
     * is font variant
     */
    cp.isFontVariant = function(str) {return 'small-caps' == str;}
    /*
     * is font weight
     */
    cp.FONT_WEIGHTS = ['bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900'];
    cp.isFontWeight = function(str) {return this.FONT_WEIGHTS.indexOf(str.toLowerCase()) >= 0;}
    
    cp.TYPE_COLOR = 'color';
    cp.TYPE_WIDTH = 'width';
    cp.TYPE_BORDERSTYLE = 'borderstyle';
    cp.TYPE_FONTSTYLE = 'font-style';
    cp.TYPE_FONTVARIANT = 'font-variant';
    cp.TYPE_FONTWEIGHT = 'font-weight';
    cp.TYPE_UNKNOWN = 'unknown';
    cp.valueType = function(valStr) {
        if (this.isColor(valStr)) return this.TYPE_COLOR;
        if (this.isWidth(valStr)) return this.TYPE_WIDTH;
        if (this.isBorderStyle(valStr)) return this.TYPE_BORDERSTYLE;
        if (this.isFontStyle(valStr)) return this.TYPE_FONTSTYLE;
        if (this.isFontVariant(valStr)) return this.TYPE_FONTVARIANT;
        if (this.isFontWeight(valStr)) return this.TYPE_FONTWEIGHT;
        return this.TYPE_UNKNOWN;
    }
    
    //validator
    cp.FONT_SIZES = ['xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'smaller', 'larger'];
    cp.validateFontSize = function(str) {
        return this.FONT_SIZES.indexOf(str) >=0 || this.isLength(str) || this.isPercentage(str);
    }
    cp.validateMargin = function(str) {
        return str == 'auto' || this.isLength(str) || this.isPercentage(str);
    }
    cp.validatePadding = function(str) {
        return this.isLength(str) || this.isPercentage(str);
    }
    
    return CSSParserUtility;	
});sap.riv.module(
{
  qname : 'sap.viz.mvc.CSSParser',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.mvc.CSSParserUtility',
  version : '4.0.0'
}
],
function Setup(CSSParserUtility) {
	
    var parser=(function(){var parser={trace:function trace(){},yy:{},symbols_:{error:2,theme:3,ruleset:4,rule:5,selector_list:6,"{":7,declaration_list:8,"}":9,selector:10,",":11,"class":12,".":13,IDENT:14,declaration:15,";":16,property:17,":":18,expr:19,prio:20,IMPORTANT_SYM:21,term:22,operator:23,"/":24,signed_term:25,STRING:26,URI:27,HASH:28,"function":29,NUMBER:30,PERCENTAGE:31,LENGTH:32,EMS:33,EXS:34,ANGLE:35,TIME:36,FREQ:37,unary_operator:38,FUNCTION:39,")":40,"-":41,"+":42,"$accept":0,"$end":1},terminals_:{2:"error",7:"{",9:"}",11:",",13:".",14:"IDENT",16:";",18:":",21:"IMPORTANT_SYM",24:"/",26:"STRING",27:"URI",28:"HASH",30:"NUMBER",31:"PERCENTAGE",32:"LENGTH",33:"EMS",34:"EXS",35:"ANGLE",36:"TIME",37:"FREQ",39:"FUNCTION",40:")",41:"-",42:"+"},productions_:[0,[3,1],[4,1],[4,2],[5,4],[6,1],[6,3],[10,1],[10,2],[12,2],[8,1],[8,3],[8,2],[15,3],[15,2],[17,1],[20,1],[19,1],[19,2],[19,3],[23,1],[23,1],[22,1],[22,1],[22,1],[22,1],[22,1],[22,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,1],[25,2],[29,3],[38,1],[38,1]],performAction:function anonymous(yytext,yyleng,yylineno,yy,yystate,$$,_$){var $0=$$.length-1;switch(yystate){case 1:return $$[$0];break;case 2:this.$=[$$[$0]];break;case 3:this.$=$$[$0-1];this.$.push($$[$0]);break;case 4:this.$={selector:$$[$0-3],declaration:$$[$0-1]};break;case 5:this.$=[$$[$0]];break;case 6:this.$=$$[$0-2];this.$.push($$[$0]);break;case 7:this.$=$$[$0];break;case 8:this.$=$$[$0-1]+$$[$0];break;case 9:this.$=$$[$0-1]+$$[$0];break;case 10:this.$=[$$[$0]];break;case 11:this.$=$$[$0-2];this.$.push($$[$0]);break;case 12:this.$=$$[$0-1];break;case 13:this.$={name:$$[$0-2],value:$$[$0]};break;case 14:this.$=$$[$0-1];this.$.important=true;break;case 18:this.$=$$[$0-1]+" "+$$[$0];break;case 19:this.$=$$[$0-2]+$$[$0-1]+$$[$0];break;case 36:this.$=$$[$0-1]+$$[$0];break;case 37:this.$=$$[$0-2]+$$[$0-1]+$$[$0];break}},table:[{3:1,4:2,5:3,6:4,10:5,12:6,13:[1,7]},{1:[3]},{1:[2,1],5:8,6:4,10:5,12:6,13:[1,7]},{1:[2,2],13:[2,2]},{7:[1,9],11:[1,10]},{7:[2,5],11:[2,5],12:11,13:[1,7]},{7:[2,7],11:[2,7],13:[2,7]},{14:[1,12]},{1:[2,3],13:[2,3]},{8:13,14:[1,16],15:14,17:15},{10:17,12:6,13:[1,7]},{7:[2,8],11:[2,8],13:[2,8]},{7:[2,9],11:[2,9],13:[2,9]},{9:[1,18],16:[1,19]},{9:[2,10],16:[2,10],20:20,21:[1,21]},{18:[1,22]},{18:[2,15]},{7:[2,6],11:[2,6],12:11,13:[1,7]},{1:[2,4],13:[2,4]},{9:[2,12],14:[1,16],15:23,16:[2,12],17:15},{9:[2,14],16:[2,14],21:[2,14]},{9:[2,16],16:[2,16],21:[2,16]},{14:[1,28],19:24,22:25,25:26,26:[1,27],27:[1,29],28:[1,30],29:31,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43]},{9:[2,11],16:[2,11],20:20,21:[1,21]},{9:[2,13],11:[1,47],14:[1,28],16:[2,13],21:[2,13],22:44,23:45,24:[1,46],25:26,26:[1,27],27:[1,29],28:[1,30],29:31,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43]},{9:[2,17],11:[2,17],14:[2,17],16:[2,17],21:[2,17],24:[2,17],26:[2,17],27:[2,17],28:[2,17],30:[2,17],31:[2,17],32:[2,17],33:[2,17],34:[2,17],35:[2,17],36:[2,17],37:[2,17],39:[2,17],40:[2,17],41:[2,17],42:[2,17]},{9:[2,22],11:[2,22],14:[2,22],16:[2,22],21:[2,22],24:[2,22],26:[2,22],27:[2,22],28:[2,22],30:[2,22],31:[2,22],32:[2,22],33:[2,22],34:[2,22],35:[2,22],36:[2,22],37:[2,22],39:[2,22],40:[2,22],41:[2,22],42:[2,22]},{9:[2,23],11:[2,23],14:[2,23],16:[2,23],21:[2,23],24:[2,23],26:[2,23],27:[2,23],28:[2,23],30:[2,23],31:[2,23],32:[2,23],33:[2,23],34:[2,23],35:[2,23],36:[2,23],37:[2,23],39:[2,23],40:[2,23],41:[2,23],42:[2,23]},{9:[2,24],11:[2,24],14:[2,24],16:[2,24],21:[2,24],24:[2,24],26:[2,24],27:[2,24],28:[2,24],30:[2,24],31:[2,24],32:[2,24],33:[2,24],34:[2,24],35:[2,24],36:[2,24],37:[2,24],39:[2,24],40:[2,24],41:[2,24],42:[2,24]},{9:[2,25],11:[2,25],14:[2,25],16:[2,25],21:[2,25],24:[2,25],26:[2,25],27:[2,25],28:[2,25],30:[2,25],31:[2,25],32:[2,25],33:[2,25],34:[2,25],35:[2,25],36:[2,25],37:[2,25],39:[2,25],40:[2,25],41:[2,25],42:[2,25]},{9:[2,26],11:[2,26],14:[2,26],16:[2,26],21:[2,26],24:[2,26],26:[2,26],27:[2,26],28:[2,26],30:[2,26],31:[2,26],32:[2,26],33:[2,26],34:[2,26],35:[2,26],36:[2,26],37:[2,26],39:[2,26],40:[2,26],41:[2,26],42:[2,26]},{9:[2,27],11:[2,27],14:[2,27],16:[2,27],21:[2,27],24:[2,27],26:[2,27],27:[2,27],28:[2,27],30:[2,27],31:[2,27],32:[2,27],33:[2,27],34:[2,27],35:[2,27],36:[2,27],37:[2,27],39:[2,27],40:[2,27],41:[2,27],42:[2,27]},{9:[2,28],11:[2,28],14:[2,28],16:[2,28],21:[2,28],24:[2,28],26:[2,28],27:[2,28],28:[2,28],30:[2,28],31:[2,28],32:[2,28],33:[2,28],34:[2,28],35:[2,28],36:[2,28],37:[2,28],39:[2,28],40:[2,28],41:[2,28],42:[2,28]},{9:[2,29],11:[2,29],14:[2,29],16:[2,29],21:[2,29],24:[2,29],26:[2,29],27:[2,29],28:[2,29],30:[2,29],31:[2,29],32:[2,29],33:[2,29],34:[2,29],35:[2,29],36:[2,29],37:[2,29],39:[2,29],40:[2,29],41:[2,29],42:[2,29]},{9:[2,30],11:[2,30],14:[2,30],16:[2,30],21:[2,30],24:[2,30],26:[2,30],27:[2,30],28:[2,30],30:[2,30],31:[2,30],32:[2,30],33:[2,30],34:[2,30],35:[2,30],36:[2,30],37:[2,30],39:[2,30],40:[2,30],41:[2,30],42:[2,30]},{9:[2,31],11:[2,31],14:[2,31],16:[2,31],21:[2,31],24:[2,31],26:[2,31],27:[2,31],28:[2,31],30:[2,31],31:[2,31],32:[2,31],33:[2,31],34:[2,31],35:[2,31],36:[2,31],37:[2,31],39:[2,31],40:[2,31],41:[2,31],42:[2,31]},{9:[2,32],11:[2,32],14:[2,32],16:[2,32],21:[2,32],24:[2,32],26:[2,32],27:[2,32],28:[2,32],30:[2,32],31:[2,32],32:[2,32],33:[2,32],34:[2,32],35:[2,32],36:[2,32],37:[2,32],39:[2,32],40:[2,32],41:[2,32],42:[2,32]},{9:[2,33],11:[2,33],14:[2,33],16:[2,33],21:[2,33],24:[2,33],26:[2,33],27:[2,33],28:[2,33],30:[2,33],31:[2,33],32:[2,33],33:[2,33],34:[2,33],35:[2,33],36:[2,33],37:[2,33],39:[2,33],40:[2,33],41:[2,33],42:[2,33]},{9:[2,34],11:[2,34],14:[2,34],16:[2,34],21:[2,34],24:[2,34],26:[2,34],27:[2,34],28:[2,34],30:[2,34],31:[2,34],32:[2,34],33:[2,34],34:[2,34],35:[2,34],36:[2,34],37:[2,34],39:[2,34],40:[2,34],41:[2,34],42:[2,34]},{9:[2,35],11:[2,35],14:[2,35],16:[2,35],21:[2,35],24:[2,35],26:[2,35],27:[2,35],28:[2,35],30:[2,35],31:[2,35],32:[2,35],33:[2,35],34:[2,35],35:[2,35],36:[2,35],37:[2,35],39:[2,35],40:[2,35],41:[2,35],42:[2,35]},{25:48,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,41:[1,42],42:[1,43]},{14:[1,28],19:49,22:25,25:26,26:[1,27],27:[1,29],28:[1,30],29:31,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43]},{30:[2,38],31:[2,38],32:[2,38],33:[2,38],34:[2,38],35:[2,38],36:[2,38],37:[2,38],41:[2,38],42:[2,38]},{30:[2,39],31:[2,39],32:[2,39],33:[2,39],34:[2,39],35:[2,39],36:[2,39],37:[2,39],41:[2,39],42:[2,39]},{9:[2,18],11:[2,18],14:[2,18],16:[2,18],21:[2,18],24:[2,18],26:[2,18],27:[2,18],28:[2,18],30:[2,18],31:[2,18],32:[2,18],33:[2,18],34:[2,18],35:[2,18],36:[2,18],37:[2,18],39:[2,18],40:[2,18],41:[2,18],42:[2,18]},{14:[1,28],22:50,25:26,26:[1,27],27:[1,29],28:[1,30],29:31,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],41:[1,42],42:[1,43]},{14:[2,20],26:[2,20],27:[2,20],28:[2,20],30:[2,20],31:[2,20],32:[2,20],33:[2,20],34:[2,20],35:[2,20],36:[2,20],37:[2,20],39:[2,20],41:[2,20],42:[2,20]},{14:[2,21],26:[2,21],27:[2,21],28:[2,21],30:[2,21],31:[2,21],32:[2,21],33:[2,21],34:[2,21],35:[2,21],36:[2,21],37:[2,21],39:[2,21],41:[2,21],42:[2,21]},{9:[2,36],11:[2,36],14:[2,36],16:[2,36],21:[2,36],24:[2,36],26:[2,36],27:[2,36],28:[2,36],30:[2,36],31:[2,36],32:[2,36],33:[2,36],34:[2,36],35:[2,36],36:[2,36],37:[2,36],39:[2,36],40:[2,36],41:[2,36],42:[2,36]},{11:[1,47],14:[1,28],22:44,23:45,24:[1,46],25:26,26:[1,27],27:[1,29],28:[1,30],29:31,30:[1,32],31:[1,33],32:[1,34],33:[1,35],34:[1,36],35:[1,37],36:[1,38],37:[1,39],38:40,39:[1,41],40:[1,51],41:[1,42],42:[1,43]},{9:[2,19],11:[2,19],14:[2,19],16:[2,19],21:[2,19],24:[2,19],26:[2,19],27:[2,19],28:[2,19],30:[2,19],31:[2,19],32:[2,19],33:[2,19],34:[2,19],35:[2,19],36:[2,19],37:[2,19],39:[2,19],40:[2,19],41:[2,19],42:[2,19]},{9:[2,37],11:[2,37],14:[2,37],16:[2,37],21:[2,37],24:[2,37],26:[2,37],27:[2,37],28:[2,37],30:[2,37],31:[2,37],32:[2,37],33:[2,37],34:[2,37],35:[2,37],36:[2,37],37:[2,37],39:[2,37],40:[2,37],41:[2,37],42:[2,37]}],defaultActions:{16:[2,15]},parseError:function parseError(str,hash){throw new Error(str)},parse:function parse(input){var self=this,stack=[0],vstack=[null],lstack=[],table=this.table,yytext="",yylineno=0,yyleng=0,recovering=0,TERROR=2,EOF=1;this.lexer.setInput(input);this.lexer.yy=this.yy;this.yy.lexer=this.lexer;this.yy.parser=this;if(typeof this.lexer.yylloc=="undefined"){this.lexer.yylloc={}}var yyloc=this.lexer.yylloc;lstack.push(yyloc);var ranges=this.lexer.options&&this.lexer.options.ranges;if(typeof this.yy.parseError==="function"){this.parseError=this.yy.parseError}function popStack(n){stack.length=stack.length-2*n;vstack.length=vstack.length-n;lstack.length=lstack.length-n}function lex(){var token;token=self.lexer.lex()||1;if(typeof token!=="number"){token=self.symbols_[token]||token}return token}var symbol,preErrorSymbol,state,action,a,r,yyval={},p,len,newState,expected;while(true){state=stack[stack.length-1];if(this.defaultActions[state]){action=this.defaultActions[state]}else{if(symbol===null||typeof symbol=="undefined"){symbol=lex()}action=table[state]&&table[state][symbol]}_handle_error:if(typeof action==="undefined"||!action.length||!action[0]){var errStr="";if(!recovering){expected=[];for(p in table[state]){if(this.terminals_[p]&&p>2){expected.push("'"+this.terminals_[p]+"'")}}if(this.lexer.showPosition){errStr="Parse error on line "+(yylineno+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+expected.join(", ")+", got '"+(this.terminals_[symbol]||symbol)+"'"}else{errStr="Parse error on line "+(yylineno+1)+": Unexpected "+(symbol==1?"end of input":("'"+(this.terminals_[symbol]||symbol)+"'"))}this.parseError(errStr,{text:this.lexer.match,token:this.terminals_[symbol]||symbol,line:this.lexer.yylineno,loc:yyloc,expected:expected})}if(recovering==3){if(symbol==EOF){throw new Error(errStr||"Parsing halted.")}yyleng=this.lexer.yyleng;yytext=this.lexer.yytext;yylineno=this.lexer.yylineno;yyloc=this.lexer.yylloc;symbol=lex()}while(1){if((TERROR.toString()) in table[state]){break}if(state===0){throw new Error(errStr||"Parsing halted.")}popStack(1);state=stack[stack.length-1]}preErrorSymbol=symbol==2?null:symbol;symbol=TERROR;state=stack[stack.length-1];action=table[state]&&table[state][TERROR];recovering=3}if(action[0] instanceof Array&&action.length>1){throw new Error("Parse Error: multiple actions possible at state: "+state+", token: "+symbol)}switch(action[0]){case 1:stack.push(symbol);vstack.push(this.lexer.yytext);lstack.push(this.lexer.yylloc);stack.push(action[1]);symbol=null;if(!preErrorSymbol){yyleng=this.lexer.yyleng;yytext=this.lexer.yytext;yylineno=this.lexer.yylineno;yyloc=this.lexer.yylloc;if(recovering>0){recovering--}}else{symbol=preErrorSymbol;preErrorSymbol=null}break;case 2:len=this.productions_[action[1]][1];yyval.$=vstack[vstack.length-len];yyval._$={first_line:lstack[lstack.length-(len||1)].first_line,last_line:lstack[lstack.length-1].last_line,first_column:lstack[lstack.length-(len||1)].first_column,last_column:lstack[lstack.length-1].last_column};if(ranges){yyval._$.range=[lstack[lstack.length-(len||1)].range[0],lstack[lstack.length-1].range[1]]}r=this.performAction.call(yyval,yytext,yyleng,yylineno,this.yy,action[1],vstack,lstack);if(typeof r!=="undefined"){return r}if(len){stack=stack.slice(0,-1*len*2);vstack=vstack.slice(0,-1*len);lstack=lstack.slice(0,-1*len)}stack.push(this.productions_[action[1]][0]);vstack.push(yyval.$);lstack.push(yyval._$);newState=table[stack[stack.length-2]][stack[stack.length-1]];stack.push(newState);break;case 3:return true}}return true}};var lexer=(function(){var lexer=({EOF:1,parseError:function parseError(str,hash){if(this.yy.parser){this.yy.parser.parseError(str,hash)}else{throw new Error(str)}},setInput:function(input){this._input=input;this._more=this._less=this.done=false;this.yylineno=this.yyleng=0;this.yytext=this.matched=this.match="";this.conditionStack=["INITIAL"];this.yylloc={first_line:1,first_column:0,last_line:1,last_column:0};if(this.options.ranges){this.yylloc.range=[0,0]}this.offset=0;return this},input:function(){var ch=this._input[0];this.yytext+=ch;this.yyleng++;this.offset++;this.match+=ch;this.matched+=ch;var lines=ch.match(/(?:\r\n?|\n).*/g);if(lines){this.yylineno++;this.yylloc.last_line++}else{this.yylloc.last_column++}if(this.options.ranges){this.yylloc.range[1]++}this._input=this._input.slice(1);return ch},unput:function(ch){var len=ch.length;var lines=ch.split(/(?:\r\n?|\n)/g);this._input=ch+this._input;this.yytext=this.yytext.substr(0,this.yytext.length-len-1);this.offset-=len;var oldLines=this.match.split(/(?:\r\n?|\n)/g);this.match=this.match.substr(0,this.match.length-1);this.matched=this.matched.substr(0,this.matched.length-1);if(lines.length-1){this.yylineno-=lines.length-1}var r=this.yylloc.range;this.yylloc={first_line:this.yylloc.first_line,last_line:this.yylineno+1,first_column:this.yylloc.first_column,last_column:lines?(lines.length===oldLines.length?this.yylloc.first_column:0)+oldLines[oldLines.length-lines.length].length-lines[0].length:this.yylloc.first_column-len};if(this.options.ranges){this.yylloc.range=[r[0],r[0]+this.yyleng-len]}return this},more:function(){this._more=true;return this},less:function(n){this.unput(this.match.slice(n))},pastInput:function(){var past=this.matched.substr(0,this.matched.length-this.match.length);return(past.length>20?"...":"")+past.substr(-20).replace(/\n/g,"")},upcomingInput:function(){var next=this.match;if(next.length<20){next+=this._input.substr(0,20-next.length)}return(next.substr(0,20)+(next.length>20?"...":"")).replace(/\n/g,"")},showPosition:function(){var pre=this.pastInput();var c=new Array(pre.length+1).join("-");return pre+this.upcomingInput()+"\n"+c+"^"},next:function(){if(this.done){return this.EOF}if(!this._input){this.done=true}var token,match,tempMatch,index,col,lines;if(!this._more){this.yytext="";this.match=""}var rules=this._currentRules();for(var i=0;i<rules.length;i++){tempMatch=this._input.match(this.rules[rules[i]]);if(tempMatch&&(!match||tempMatch[0].length>match[0].length)){match=tempMatch;index=i;if(!this.options.flex){break}}}if(match){lines=match[0].match(/(?:\r\n?|\n).*/g);if(lines){this.yylineno+=lines.length}this.yylloc={first_line:this.yylloc.last_line,last_line:this.yylineno+1,first_column:this.yylloc.last_column,last_column:lines?lines[lines.length-1].length-lines[lines.length-1].match(/\r?\n?/)[0].length:this.yylloc.last_column+match[0].length};this.yytext+=match[0];this.match+=match[0];this.matches=match;this.yyleng=this.yytext.length;if(this.options.ranges){this.yylloc.range=[this.offset,this.offset+=this.yyleng]}this._more=false;this._input=this._input.slice(match[0].length);this.matched+=match[0];token=this.performAction.call(this,this.yy,this,rules[index],this.conditionStack[this.conditionStack.length-1]);if(this.done&&this._input){this.done=false}if(token){return token}else{return}}if(this._input===""){return this.EOF}else{return this.parseError("Lexical error on line "+(this.yylineno+1)+". Unrecognized text.\n"+this.showPosition(),{text:"",token:null,line:this.yylineno})}},lex:function lex(){var r=this.next();if(typeof r!=="undefined"){return r}else{return this.lex()}},begin:function begin(condition){this.conditionStack.push(condition)},popState:function popState(){return this.conditionStack.pop()},_currentRules:function _currentRules(){return this.conditions[this.conditionStack[this.conditionStack.length-1]].rules},topState:function(){return this.conditionStack[this.conditionStack.length-2]},pushState:function begin(condition){this.begin(condition)}});lexer.options={flex:true,"case-insensitive":true};lexer.performAction=function anonymous(yy,yy_,$avoiding_name_collisions,YY_START){var YYSTATE=YY_START;switch($avoiding_name_collisions){case 0:break;case 1:break;case 2:break;case 3:return"CDO";break;case 4:return"CDC";break;case 5:return"INCLUDES";break;case 6:return"DASHMATCH";break;case 7:return 26;break;case 8:return"BAD_STRING";break;case 9:return 14;break;case 10:return 28;break;case 11:return"IMPORT_SYM";break;case 12:return"PAGE_SYM";break;case 13:return"MEDIA_SYM";break;case 14:return"CHARSET_SYM";break;case 15:return 21;break;case 16:return 33;break;case 17:return 34;break;case 18:return 32;break;case 19:return 32;break;case 20:return 32;break;case 21:return 32;break;case 22:return 32;break;case 23:return 32;break;case 24:return 35;break;case 25:return 35;break;case 26:return 35;break;case 27:return 36;break;case 28:return 36;break;case 29:return 37;break;case 30:return 37;break;case 31:return"DIMENSION";break;case 32:return 31;break;case 33:return 30;break;case 34:return 27;break;case 35:return 27;break;case 36:return"BAD_URI";break;case 37:return 39;break;case 38:return yy_.yytext;break;case 39:console.log(yy_.yytext);break}};lexer.rules=[/^(?:([ \t\r\n\f]+))/i,/^(?:\/\*[^*]*\*+([^/*][^*]*\*+)*\/)/i,/^(?:((\/\*[^*]*\*+([^/*][^*]*\*+)*)|(\/\*[^*]*(\*+[^/*][^*]*)*)))/i,/^(?:<!--)/i,/^(?:-->)/i,/^(?:~=)/i,/^(?:\|=)/i,/^(?:(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*")|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*')))/i,/^(?:(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*\\?)|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*\\?)))/i,/^(?:([-]?([_a-zA-Z]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))([_a-zA-Z0-9-]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*))/i,/^(?:#(([_a-zA-Z0-9-]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))+))/i,/^(?:@([iI])([mM])([pP])([oO])([rR])([tT]))/i,/^(?:@([pP])([aA])([gG])([eE]))/i,/^(?:@([mM])([eE])([dD])([iI])([aA]))/i,/^(?:@charset )/i,/^(?:!((([ \t\r\n\f]+)?)|(\/\*[^*]*\*+([^/*][^*]*\*+)*\/))*([iI])([mM])([pP])([oO])([rR])([tT])([aA])([nN])([tT]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([eE])([mM]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([eE])([xX]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([pP])([xX]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([cC])([mM]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([mM])([mM]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([iI])([nN]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([pP])([tT]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([pP])([cC]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([dD])([eE])([gG]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([rR])([aA])([dD]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([gG])([rR])([aA])([dD]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([mM])([sS]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([sS]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([hH])([zZ]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([kK])([hH])([zZ]))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)([-]?([_a-zA-Z]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))([_a-zA-Z0-9-]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*))/i,/^(?:([0-9]+|[0-9]*\.[0-9]+)%)/i,/^(?:([0-9]+|[0-9]*\.[0-9]+))/i,/^(?:url\((([ \t\r\n\f]+)?)(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*")|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*'))(([ \t\r\n\f]+)?)\))/i,/^(?:url\((([ \t\r\n\f]+)?)(([!#$%&*-~]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*)(([ \t\r\n\f]+)?)\))/i,/^(?:((url\((([ \t\r\n\f]+)?)([!#$%&*-\[\]-~]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*(([ \t\r\n\f]+)?))|(url\((([ \t\r\n\f]+)?)(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*")|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*'))(([ \t\r\n\f]+)?))|(url\((([ \t\r\n\f]+)?)(("([^\n\r\f\\"]|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*\\?)|('([^\n\r\f\\']|\\(\n|\r\n|\r|\f)|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*\\?)))))/i,/^(?:([-]?([_a-zA-Z]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))([_a-zA-Z0-9-]|([\240-\377])|((\\([0-9a-f]){1,6}(\r\n|[ \t\r\n\f])?)|\\[^\r\n\f0-9a-f]))*)\()/i,/^(?:.)/i,/^(?:.)/i];lexer.conditions={INITIAL:{rules:[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39],inclusive:true}};return lexer})();parser.lexer=lexer;function Parser(){this.yy={}}Parser.prototype=parser;parser.Parser=Parser;return new Parser})();if(typeof require!=="undefined"&&typeof exports!=="undefined"){exports.parser=parser;exports.Parser=parser.Parser;exports.parse=function(){return parser.parse.apply(parser,arguments)};exports.main=function commonjsMain(args){if(!args[1]){throw new Error("Usage: "+args[0]+" FILE")}var source,cwd;if(typeof process!=="undefined"){source=require("fs").readFileSync(require("path").resolve(args[1]),"utf8")}else{source=require("file").path(require("file").cwd()).join(args[1]).read({charset:"utf-8"})}return exports.parser.parse(source)};if(typeof module!=="undefined"&&require.main===module){exports.main(typeof process!=="undefined"?process.argv.slice(1):require("system").args)}};    
    
    var CSSParser = function() {
    }
    
    var cp = CSSParser.prototype;
    
    var u = new CSSParserUtility();
    
    cp._processBorderCommon = function(valStr, edges) {
        /*
        border-width
        border-style (required)
        border-color
         */
        var vals = valStr.split(' ');
        var l = vals.length;
        if ( l == 0 || l > 3) return null;
        var repos = {};
        var res = [];
        var legalTypes = [u.TYPE_COLOR, u.TYPE_WIDTH, u.TYPE_BORDERSTYLE];
        for (var i = 0; i < l; i++) {
            var val = vals[i];
            var type = u.valueType(val);
            //check duplication
            if (legalTypes.indexOf(type) < 0 || repos[type]) return null;
            repos[type] = 'XXX';
            //expand to result object
            for (var j = 0; j < edges.length; j++) {
                var name = edges[j] + '-';
                switch(type) {
                    case u.TYPE_COLOR:
                        name += 'color';
                        break;
                    case u.TYPE_WIDTH:
                        name += 'width';
                        break;
                    case u.TYPE_BORDERSTYLE:
                        name += 'style';
                        break;
                }   
                res.push({name: name, value: val});     
            }
        }
        if (!repos[u.TYPE_BORDERSTYLE]) return null;
        return res;
    }
    
    cp.processBorder = function(valStr) {
        var edges = ['border-top', 'border-right', 'border-bottom', 'border-left'];
        return this._processBorderCommon(valStr, edges);
    }
    
    cp.processBorderEdge = function(valStr, border) {
        return this._processBorderCommon(valStr, [border]);
    }
    
    cp._expandAttrTo4Edges = function(valStr, attrName, vFunc, range, edges) {
        var vals = valStr.split(' ');
        var l = vals.length;
        if (l == 0 || l > 4) return null;
        var res = [];
        for (var i = 0; i < 4; i++) {
            var name = edges[i].replace('*', attrName);
            var k = i;
            k < l || (k -= 2) < l || (k -= 3) < l;
            k >= 0 || (k = 0);
            var value = vals[k];
            if (valStr != 'inherit' && !vFunc.call(range, value)) return null;
            res.push({name: name, value: value});
        }
        return res;
    }
    
    cp._processBorderAttr = function(valStr, attrName) {
        var vFunc = null;
        switch (attrName) {
            case 'color':
                vFunc = u.isColor;
                break;
            case 'width':
                vFunc = u.isWidth;
                break;
            case 'style':
                vFunc = u.isBorderStyle;
                break;
            default:
                return null;
        }
        var edges = ['border-top-*', 'border-right-*', 'border-bottom-*', 'border-left-*'];
        return this._expandAttrTo4Edges(valStr, attrName, vFunc, u, edges);
    }
    
    cp.processBorderColor = function(valStr) {
        return this._processBorderAttr(valStr, 'color');
    }
    cp.processBorderWidth = function(valStr) {
        return this._processBorderAttr(valStr, 'width');
    }
    cp.processBorderStyle = function(valStr) {
        return this._processBorderAttr(valStr, 'style');
    }
    
    cp.processFont = function(valStr) {
        var vals = u.split(valStr, ' ');
        if (vals.length < 2) return null;
        var hasHeight = valStr.indexOf('/') >= 0;
        var res = [];
        res.push({name: 'font-family', value: vals.pop()});
        var size = vals.pop();
        if (hasHeight) {
            var eles = size.split('/');
            if (eles.length != 2 || eles[1] == '') return null;
            res.push({name: 'line-height', value: eles[1]});
            size = eles[0];
        }
        if (size == '') return null;
        if (!u.validateFontSize(size)) return null;
        res.push({name: 'font-size', value: size});
        var repos = {};
        var legalTypes = [u.TYPE_FONTSTYLE, u.TYPE_FONTVARIANT, u.TYPE_FONTWEIGHT];
        for (var i = 0, l = vals.length; i < l; i++) {
            var type = u.valueType(vals[i]);
            if (legalTypes.indexOf(type) < 0 || repos[type]) return null;
            repos[type] = 'XXX';
            var name = null;
            res.push({name: type, value: vals[i]});
        }
        return res;
    }
    
    cp.processMargin = function(str) {
        var edges = ['*-top', '*-right', '*-bottom', '*-left'];
        return this._expandAttrTo4Edges(str, 'padding', u.validateMargin, u, edges);
    }
    
    cp.processPadding = function(str) {
        var edges = ['*-top', '*-right', '*-bottom', '*-left'];
        return this._expandAttrTo4Edges(str, 'margin', u.validatePadding, u, edges);
    }
    
    cp.processParentAttrs = function(declarations) {
        /*
         * according to CSS 2.1:
         * 
         * parent attributes (need expanding to children attributes)
         * border, border-bottom, border-left, border-right, border-top, border-color, border-style, border-width, font, margin, outline(TODO), padding
         * 
         * abstract attributes (no expanding needed)
         * background, list-style
         * 
         */
        var res = [];
        for ( var i = 0, l = declarations.length; i < l; i++) {
            var attr = declarations[i];
            var attrName = attr.name.toLowerCase();
            var subAttrs = attr;
            switch (attrName) {
                case 'border':
                    subAttrs = this.processBorder(attr.value);
                    break;
                case 'border-top':
                case 'border-right':
                case 'border-bottom':
                case 'border-left':
                    subAttrs = this.processBorderEdge(attr.value, attrName);
                    break;
                case 'border-color':
                    subAttrs = this.processBorderColor(attr.value);
                    break;
                case 'border-style':
                    subAttrs = this.processBorderStyle(attr.value);
                    break;
                case 'border-width':
                    subAttrs = this.processBorderWidth(attr.value);
                    break;
                case 'font':
                    subAttrs = this.processFont(attr.value);
                    break;
                case 'margin':
                    subAttrs = this.processMargin(attr.value);
                    break;
                case 'padding':
                    subAttrs = this.processPadding(attr.value);
                    break;
                default:
                    break;
            }
            if (subAttrs === attr) {
                res.push(attr);
            } else {
                for (idx in subAttrs) {
                    subAttrs[idx].important = attr.important;
                    res.push(subAttrs[idx]);
                }
            }
        }
        return res;
    }
    /**
     * parse css string
     */
    cp.parse = function(cssText) {
        var sheet = null;
        try {
            sheet = parser.parse(cssText);
        } catch(ex) {
            alert('Parse error, please check your console output: \n' + ex);
            console.log( ex );
            console.log( ex.message );
            return null;
        }
        var records = [];
        var idx = 1;
        for (var i = 0, l = sheet.length; i < l; i++) {
            var rawRule = sheet[i];
            var des = this.processParentAttrs(rawRule.declaration);
            for (var j = 0, k = des.length; j < k; j++) {
                var record = {
                    idx: idx++,
                    selector: rawRule.selector,
                    property: des[j].name,
                    value: des[j].value,
                    important: des[j].important ? true : false
                }
                records.push(record);
            }
        }
        return records;
    }    
    
    return new CSSParser();	
});sap.riv.module(
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(typeUtils) {
	/**
	 * To utilize observable object, You have to extend your object from it, and
	 * set the 'events' property as Array of event name to the constructor 
	 * 
	 * @name sap.viz.base.Observable
	 * @constructor
	 */
	var ob = function(option) {
		this._events = {};
		var cclazz = this.constructor;
		while (cclazz) {
			var events = cclazz.prototype.events, len;
			if (events) {
				len = events.length;
				while (len--) {
					this.addEvents(events[len]);
				}
			}
			cclazz = cclazz.superclazz;
		}
		if (option) {
			if (option.listeners) {
				this.addListeners(option.listeners);
				delete option.listeners;
			}
		}
	};

	var obp = ob.prototype;

	/**
	 * Add events that could be monitored
	 * 
	 * @name sap.viz.base.Observable#addEvents
	 * @function
	 * @parameter {String|String|...} event1,event2,event3... variable length
	 *            arguments of String
	 */
	obp.addEvents = function(/* event1, event2,...,eventn */) {
		var es = this._events, a = arguments, len = arguments.length;
		while (len--) {
			if (typeof a[len] === 'string') {
				es[a[len]] = es[a[len]] || [];
			}
		}
	};
	/**
	 * Get the supported events
	 * 
	 * @name sap.viz.base.Observable#getSupportedEvents
	 * @function
	 * @return {Array} an array of event names
	 */
	obp.getSupportedEvents = function() {
		var ret = [];
		for ( var e in this._events) {
			ret.push(e);
		}
		return ret;
	};
	/**
	 * Add event listeners
	 * 
	 * @name sap.viz.base.Observable#addListeners
	 * @function
	 * @param {Object|[Object]}
	 *            o single event listener or array of event listener
	 * @param {String}
	 *            o.eventName the event to be monitored
	 * @param {Function}
	 *            o.listener the function to be called back when event is fired
	 * @param {Object}
	 *            [o.scope] the scope in which the listener will be executed
	 * @param {Object}
	 *            [o.optionalArgs] the additional arguments that will be passed
	 *            in the listener
	 */
	obp.addListeners = function(o) {
		var ls;
		if (typeUtils.isArray(o)) {
			ls = o;
		} else {
			ls = [ o ];
		}
		var len = ls.length, l, en;
		var es = this._events;
		while (len--) {
			l = ls[len];
			en = l.eventName;
			if (es.hasOwnProperty(en)) {
				var lList = es[en];
				if (!this.isListening(en, l.listener, l.scope)) {
					lList[lList.length] = {
						fn : l.listener,
						scp : l.scope,
						optArgs : l.optionalArgs
					};
				}
			}
		}
		return this;
	};

	/**
	 * Find the listener that registered before
	 * 
	 * @name sap.viz.base.Observable#findListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * 
	 * 
	 * @returns {-1|Integer} returning -1 means not found otherwise return the
	 *          position order in which the listener to be invoked
	 */
	obp.findListener = function(eventName, fn, scope) {
		var es = this._events;
		if (!es.hasOwnProperty(eventName)) {
			return -1;
		}
		var lList = es[eventName], len = lList.length, lis;
		while (len--) {
			lis = lList[len];
			if (scope) {
				if (lis.fn == fn && lis.scp == scope) {
					return len;
				}
			} else {
				if (lis.fn == fn) {
					return len;
				}
			}
		}
		return -1;
	};
	/**
	 * Check whether the listener is listening on the event
	 * 
	 * @name sap.viz.base.Observable#isListening
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * @returns {Boolean}
	 */
	obp.isListening = function(eventName, fn, scope) {
		return this.findListener(eventName, fn, scope) > -1;
	};

	/**
	 * Remove the previous registered listener listening on the given event
	 * 
	 * @name sap.viz.base.Observable#removeListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @param {Function}
	 *            fn the listener to find
	 * @param {Object}
	 *            [scope] the scope in which the listener will be executed, same
	 *            listener function could be registered under different scope
	 *            for the same event.
	 * @returns {this} return the observable object itself
	 */
	obp.removeListener = function(eventName, fn, scope) {
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			var lList = es[eventName];
			var len = lList.length, idx;
			while (len--) {
				idx = this.findListener(eventName, fn, scope);
				if (idx > -1) {
					lList.splice(idx, 1);
					len = lList.length;
				}
			}
		}
		return this;
	};

	/**
	 * Remove all the listeners currently watching the event
	 * 
	 * @name sap.viz.base.Observable#removeAllListeners
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {this} return the observable object itself
	 */
	obp.removeAllListeners = function(eventName) {
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			es[eventName] = [];
		}
		return this;
	};
	/**
	 * Check whether there is any listener watching the event
	 * 
	 * @name sap.viz.base.Observable#hasListener
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {Boolean}
	 */
	obp.hasListener = function(eventName) {
		return this._events[eventName] && this._events[eventName].length > 0;
	};

	/**
	 * Purge all listeners registered on the observable object
	 * 
	 * @name sap.viz.base.Observable#purgeListeners
	 * @function
	 * @param {String}
	 *            eventName the eventName to which the listener is monitoring
	 * @returns {Boolean}
	 */
	obp.purgeListeners = function() {
		var es = this._events;
		for ( var e in es) {
			es[e] = [];
		}
	};

	/**
	 * Fire a event, with optional details attached
	 * 
	 * @name sap.viz.base.Observable#fireEvent
	 * @function
	 * @param {String}
	 *            eventName name of the event to be fired
	 * @param {Object}
	 *            details variable length arguments,var1, var2..varn, the
	 *            details to be passed in each listener call.
	 */
	obp.fireEvent = function(eventName /* details */) {
		var details = Array.prototype.slice.call(arguments, 1);
		var es = this._events;
		if (es.hasOwnProperty(eventName)) {
			var lList = es[eventName], l;
			for ( var i = 0, len = lList.length; i < len; i++) {
				l = lList[i];
				if (l.optArgs) {
					details.push(l.optArgs);
				}
				l.fn.apply(l.scp || this || window, details);
			}
		}
	};

	/**
	 * Same as addListeners
	 * 
	 * @name sap.viz.base.Observable#on
	 * @function
	 * @see sap.viz.base.Observable#addListeners
	 */
	obp.on = obp.addListeners;
	/**
	 * Same as removeListener
	 * 
	 * @name sap.viz.base.Observable#un
	 * @function
	 * @see sap.viz.base.Observable#removeListener
	 */
	obp.un = obp.removeListener;
	return ob;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Observable',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.CSSParser',
  version : '4.0.0'
}
],
function Setup(ObjUtils, Observable, CSSParser) {
	//minified jscssp - CSSParser
	//var kCHARSET_RULE_MISSING_SEMICOLON="Missing semicolon at the end of @charset rule";var kCHARSET_RULE_CHARSET_IS_STRING="The charset in the @charset rule should be a string";var kCHARSET_RULE_MISSING_WS="Missing mandatory whitespace after @charset";var kIMPORT_RULE_MISSING_URL="Missing URL in @import rule";var kURL_EOF="Unexpected end of stylesheet";var kURL_WS_INSIDE="Multiple tokens inside a url() notation";var kVARIABLES_RULE_POSITION="@variables rule invalid at this position in the stylesheet";var kIMPORT_RULE_POSITION="@import rule invalid at this position in the stylesheet";var kNAMESPACE_RULE_POSITION="@namespace rule invalid at this position in the stylesheet";var kCHARSET_RULE_CHARSET_SOF="@charset rule invalid at this position in the stylesheet";var kUNKNOWN_AT_RULE="Unknow @-rule";var kENGINES=["webkit","presto","trident","generic"];var kCSS_VENDOR_VALUES={"-moz-box":{webkit:"-webkit-box",presto:"",trident:"",generic:"box"},"-moz-inline-box":{webkit:"-webkit-inline-box",presto:"",trident:"",generic:"inline-box"},"-moz-initial":{webkit:"",presto:"",trident:"",generic:"initial"},"-moz-linear-gradient":{webkit20110101:FilterLinearGradientForOutput,webkit:FilterLinearGradientForOutput,presto:"",trident:"",generic:FilterLinearGradientForOutput},"-moz-radial-gradient":{webkit20110101:FilterRadialGradientForOutput,webkit:FilterRadialGradientForOutput,presto:"",trident:"",generic:FilterRadialGradientForOutput},"-moz-repeating-linear-gradient":{webkit20110101:"",webkit:FilterRepeatingGradientForOutput,presto:"",trident:"",generic:FilterRepeatingGradientForOutput},"-moz-repeating-radial-gradient":{webkit20110101:"",webkit:FilterRepeatingGradientForOutput,presto:"",trident:"",generic:FilterRepeatingGradientForOutput}};var kCSS_VENDOR_PREFIXES={lastUpdate:1304175007,properties:[{gecko:"",webkit:"",presto:"",trident:"-ms-accelerator",status:"P"},{gecko:"",webkit:"",presto:"-wap-accesskey",trident:"",status:""},{gecko:"-moz-animation",webkit:"-webkit-animation",presto:"",trident:"",status:"WD"},{gecko:"-moz-animation-delay",webkit:"-webkit-animation-delay",presto:"",trident:"",status:"WD"},{gecko:"-moz-animation-direction",webkit:"-webkit-animation-direction",presto:"",trident:"",status:"WD"},{gecko:"-moz-animation-duration",webkit:"-webkit-animation-duration",presto:"",trident:"",status:"WD"},{gecko:"-moz-animation-fill-mode",webkit:"-webkit-animation-fill-mode",presto:"",trident:"",status:"ED"},{gecko:"-moz-animation-iteration-count",webkit:"-webkit-animation-iteration-count",presto:"",trident:"",status:"WD"},{gecko:"-moz-animation-name",webkit:"-webkit-animation-name",presto:"",trident:"",status:"WD"},{gecko:"-moz-animation-play-state",webkit:"-webkit-animation-play-state",presto:"",trident:"",status:"WD"},{gecko:"-moz-animation-timing-function",webkit:"-webkit-animation-timing-function",presto:"",trident:"",status:"WD"},{gecko:"-moz-appearance",webkit:"-webkit-appearance",presto:"",trident:"",status:"CR"},{gecko:"",webkit:"-webkit-backface-visibility",presto:"",trident:"",status:"WD"},{gecko:"background-clip",webkit:"-webkit-background-clip",presto:"background-clip",trident:"background-clip",status:"WD"},{gecko:"",webkit:"-webkit-background-composite",presto:"",trident:"",status:""},{gecko:"-moz-background-inline-policy",webkit:"",presto:"",trident:"",status:"P"},{gecko:"background-origin",webkit:"-webkit-background-origin",presto:"background-origin",trident:"background-origin",status:"WD"},{gecko:"",webkit:"background-position-x",presto:"",trident:"-ms-background-position-x",status:""},{gecko:"",webkit:"background-position-y",presto:"",trident:"-ms-background-position-y",status:""},{gecko:"background-size",webkit:"-webkit-background-size",presto:"background-size",trident:"background-size",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-behavior",status:""},{gecko:"-moz-binding",webkit:"",presto:"",trident:"",status:"P"},{gecko:"",webkit:"",presto:"",trident:"-ms-block-progression",status:""},{gecko:"",webkit:"-webkit-border-after",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-border-after-color",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-border-after-style",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-border-after-width",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-border-before",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-border-before-color",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-border-before-style",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-border-before-width",presto:"",trident:"",status:"ED"},{gecko:"-moz-border-bottom-colors",webkit:"",presto:"",trident:"",status:"P"},{gecko:"border-bottom-left-radius",webkit:"-webkit-border-bottom-left-radius",presto:"border-bottom-left-radius",trident:"border-bottom-left-radius",status:"WD"},{gecko:"",webkit:"-webkit-border-bottom-left-radius = border-bottom-left-radius",presto:"",trident:"",status:""},{gecko:"border-bottom-right-radius",webkit:"-webkit-border-bottom-right-radius",presto:"border-bottom-right-radius",trident:"border-bottom-right-radius",status:"WD"},{gecko:"",webkit:"-webkit-border-bottom-right-radius = border-bottom-right-radius",presto:"",trident:"",status:""},{gecko:"-moz-border-end",webkit:"-webkit-border-end",presto:"",trident:"",status:"ED"},{gecko:"-moz-border-end-color",webkit:"-webkit-border-end-color",presto:"",trident:"",status:"ED"},{gecko:"-moz-border-end-style",webkit:"-webkit-border-end-style",presto:"",trident:"",status:"ED"},{gecko:"-moz-border-end-width",webkit:"-webkit-border-end-width",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-border-fit",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-border-horizontal-spacing",presto:"",trident:"",status:""},{gecko:"-moz-border-image",webkit:"-webkit-border-image",presto:"-o-border-image",trident:"",status:"WD"},{gecko:"-moz-border-left-colors",webkit:"",presto:"",trident:"",status:"P"},{gecko:"border-radius",webkit:"-webkit-border-radius",presto:"border-radius",trident:"border-radius",status:"WD"},{gecko:"-moz-border-right-colors",webkit:"",presto:"",trident:"",status:"P"},{gecko:"-moz-border-start",webkit:"-webkit-border-start",presto:"",trident:"",status:"ED"},{gecko:"-moz-border-start-color",webkit:"-webkit-border-start-color",presto:"",trident:"",status:"ED"},{gecko:"-moz-border-start-style",webkit:"-webkit-border-start-style",presto:"",trident:"",status:"ED"},{gecko:"-moz-border-start-width",webkit:"-webkit-border-start-width",presto:"",trident:"",status:"ED"},{gecko:"-moz-border-top-colors",webkit:"",presto:"",trident:"",status:"P"},{gecko:"border-top-left-radius",webkit:"-webkit-border-top-left-radius",presto:"border-top-left-radius",trident:"border-top-left-radius",status:"WD"},{gecko:"",webkit:"-webkit-border-top-left-radius = border-top-left-radius",presto:"",trident:"",status:""},{gecko:"border-top-right-radius",webkit:"-webkit-border-top-right-radius",presto:"border-top-right-radius",trident:"border-top-right-radius",status:"WD"},{gecko:"",webkit:"-webkit-border-top-right-radius = border-top-right-radius",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-border-vertical-spacing",presto:"",trident:"",status:""},{gecko:"-moz-box-align",webkit:"-webkit-box-align",presto:"",trident:"-ms-box-align",status:"WD"},{gecko:"-moz-box-direction",webkit:"-webkit-box-direction",presto:"",trident:"-ms-box-direction",status:"WD"},{gecko:"-moz-box-flex",webkit:"-webkit-box-flex",presto:"",trident:"-ms-box-flex",status:"WD"},{gecko:"",webkit:"-webkit-box-flex-group",presto:"",trident:"",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-box-line-progression",status:""},{gecko:"",webkit:"-webkit-box-lines",presto:"",trident:"-ms-box-lines",status:"WD"},{gecko:"-moz-box-ordinal-group",webkit:"-webkit-box-ordinal-group",presto:"",trident:"-ms-box-ordinal-group",status:"WD"},{gecko:"-moz-box-orient",webkit:"-webkit-box-orient",presto:"",trident:"-ms-box-orient",status:"WD"},{gecko:"-moz-box-pack",webkit:"-webkit-box-pack",presto:"",trident:"-ms-box-pack",status:"WD"},{gecko:"",webkit:"-webkit-box-reflect",presto:"",trident:"",status:""},{gecko:"box-shadow",webkit:"-webkit-box-shadow",presto:"box-shadow",trident:"box-shadow",status:"WD"},{gecko:"-moz-box-sizing",webkit:"box-sizing",presto:"box-sizing",trident:"",status:"CR"},{gecko:"",webkit:"-webkit-box-sizing = box-sizing",presto:"",trident:"",status:""},{gecko:"",webkit:"-epub-caption-side = caption-side",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-color-correction",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-column-break-after",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-column-break-before",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-column-break-inside",presto:"",trident:"",status:""},{gecko:"-moz-column-count",webkit:"-webkit-column-count",presto:"column-count",trident:"column-count",status:"CR"},{gecko:"-moz-column-gap",webkit:"-webkit-column-gap",presto:"column-gap",trident:"column-gap",status:"CR"},{gecko:"-moz-column-rule",webkit:"-webkit-column-rule",presto:"column-rule",trident:"column-rule",status:"CR"},{gecko:"-moz-column-rule-color",webkit:"-webkit-column-rule-color",presto:"column-rule-color",trident:"column-rule-color",status:"CR"},{gecko:"-moz-column-rule-style",webkit:"-webkit-column-rule-style",presto:"column-rule-style",trident:"column-rule-style",status:"CR"},{gecko:"-moz-column-rule-width",webkit:"-webkit-column-rule-width",presto:"column-rule-width",trident:"column-rule-width",status:"CR"},{gecko:"",webkit:"-webkit-column-span",presto:"column-span",trident:"column-span",status:"CR"},{gecko:"-moz-column-width",webkit:"-webkit-column-width",presto:"column-width",trident:"column-width",status:"CR"},{gecko:"",webkit:"-webkit-columns",presto:"columns",trident:"columns",status:"CR"},{gecko:"",webkit:"-webkit-dashboard-region",presto:"-apple-dashboard-region",trident:"",status:""},{gecko:"filter",webkit:"",presto:"filter",trident:"-ms-filter",status:""},{gecko:"-moz-float-edge",webkit:"",presto:"",trident:"",status:"P"},{gecko:"",webkit:"",presto:"-o-focus-opacity",trident:"",status:""},{gecko:"-moz-font-feature-settings",webkit:"",presto:"",trident:"",status:""},{gecko:"-moz-font-language-override",webkit:"",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-font-size-delta",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-font-smoothing",presto:"",trident:"",status:""},{gecko:"-moz-force-broken-image-icon",webkit:"",presto:"",trident:"",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-column",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-column-align",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-column-span",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-columns",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-layer",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-row",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-row-align",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-row-span",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-grid-rows",status:"WD"},{gecko:"",webkit:"-webkit-highlight",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-hyphenate-character",presto:"",trident:"",status:"WD"},{gecko:"",webkit:"-webkit-hyphenate-limit-after",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-hyphenate-limit-before",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-hyphens",presto:"",trident:"",status:"WD"},{gecko:"",webkit:"-epub-hyphens = -webkit-hyphens",presto:"",trident:"",status:""},{gecko:"-moz-image-region",webkit:"",presto:"",trident:"",status:"P"},{gecko:"ime-mode",webkit:"",presto:"",trident:"-ms-ime-mode",status:""},{gecko:"",webkit:"",presto:"-wap-input-format",trident:"",status:""},{gecko:"",webkit:"",presto:"-wap-input-required",trident:"",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-interpolation-mode",status:""},{gecko:"",webkit:"",presto:"-xv-interpret-as",trident:"",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-layout-flow",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-layout-grid",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-layout-grid-char",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-layout-grid-line",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-layout-grid-mode",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-layout-grid-type",status:""},{gecko:"",webkit:"-webkit-line-box-contain",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-line-break",presto:"",trident:"-ms-line-break",status:""},{gecko:"",webkit:"-webkit-line-clamp",presto:"",trident:"",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-line-grid-mode",status:""},{gecko:"",webkit:"",presto:"-o-link",trident:"",status:""},{gecko:"",webkit:"",presto:"-o-link-source",trident:"",status:""},{gecko:"",webkit:"-webkit-locale",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-logical-height",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-logical-width",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-margin-after",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-margin-after-collapse",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-margin-before",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-margin-before-collapse",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-margin-bottom-collapse",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-margin-collapse",presto:"",trident:"",status:""},{gecko:"-moz-margin-end",webkit:"-webkit-margin-end",presto:"",trident:"",status:"ED"},{gecko:"-moz-margin-start",webkit:"-webkit-margin-start",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-margin-top-collapse",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-marquee",presto:"",trident:"",status:""},{gecko:"",webkit:"",presto:"-wap-marquee-dir",trident:"",status:""},{gecko:"",webkit:"-webkit-marquee-direction",presto:"",trident:"",status:"WD"},{gecko:"",webkit:"-webkit-marquee-increment",presto:"",trident:"",status:""},{gecko:"",webkit:"",presto:"-wap-marquee-loop",trident:"",status:"WD"},{gecko:"",webkit:"-webkit-marquee-repetition",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-marquee-speed",presto:"-wap-marquee-speed",trident:"",status:"WD"},{gecko:"",webkit:"-webkit-marquee-style",presto:"-wap-marquee-style",trident:"",status:"WD"},{gecko:"mask",webkit:"-webkit-mask",presto:"mask",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-attachment",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-box-image",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-clip",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-composite",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-image",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-origin",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-position",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-position-x",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-position-y",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-repeat",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-repeat-x",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-repeat-y",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-mask-size",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-match-nearest-mail-blockquote-color",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-max-logical-height",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-max-logical-width",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-min-logical-height",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-min-logical-width",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"",presto:"-o-mini-fold",trident:"",status:""},{gecko:"",webkit:"-webkit-nbsp-mode",presto:"",trident:"",status:"P"},{gecko:"",webkit:"",presto:"-o-object-fit",trident:"",status:"ED"},{gecko:"",webkit:"",presto:"-o-object-position",trident:"",status:"ED"},{gecko:"opacity",webkit:"-webkit-opacity",presto:"opacity",trident:"opacity",status:"WD"},{gecko:"",webkit:"-webkit-opacity = opacity",presto:"",trident:"",status:""},{gecko:"-moz-outline-radius",webkit:"",presto:"",trident:"",status:"P"},{gecko:"-moz-outline-radius-bottomleft",webkit:"",presto:"",trident:"",status:"P"},{gecko:"-moz-outline-radius-bottomright",webkit:"",presto:"",trident:"",status:"P"},{gecko:"-moz-outline-radius-topleft",webkit:"",presto:"",trident:"",status:"P"},{gecko:"-moz-outline-radius-topright",webkit:"",presto:"",trident:"",status:"P"},{gecko:"overflow-x",webkit:"overflow-x",presto:"overflow-x",trident:"-ms-overflow-x",status:"WD"},{gecko:"overflow-y",webkit:"overflow-y",presto:"overflow-y",trident:"-ms-overflow-y",status:"WD"},{gecko:"",webkit:"-webkit-padding-after",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-padding-before",presto:"",trident:"",status:"ED"},{gecko:"-moz-padding-end",webkit:"-webkit-padding-end",presto:"",trident:"",status:"ED"},{gecko:"-moz-padding-start",webkit:"-webkit-padding-start",presto:"",trident:"",status:"ED"},{gecko:"",webkit:"-webkit-perspective",presto:"",trident:"",status:"WD"},{gecko:"",webkit:"-webkit-perspective-origin",presto:"",trident:"",status:"WD"},{gecko:"",webkit:"-webkit-perspective-origin-x",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-perspective-origin-y",presto:"",trident:"",status:""},{gecko:"",webkit:"",presto:"-xv-phonemes",trident:"",status:""},{gecko:"",webkit:"-webkit-rtl-ordering",presto:"",trident:"",status:"P"},{gecko:"-moz-script-level",webkit:"",presto:"",trident:"",status:""},{gecko:"-moz-script-min-size",webkit:"",presto:"",trident:"",status:""},{gecko:"-moz-script-size-multiplier",webkit:"",presto:"",trident:"",status:""},{gecko:"",webkit:"",presto:"scrollbar-3dlight-color",trident:"-ms-scrollbar-3dlight-color",status:"P"},{gecko:"",webkit:"",presto:"scrollbar-arrow-color",trident:"-ms-scrollbar-arrow-color",status:"P"},{gecko:"",webkit:"",presto:"scrollbar-base-color",trident:"-ms-scrollbar-base-color",status:"P"},{gecko:"",webkit:"",presto:"scrollbar-darkshadow-color",trident:"-ms-scrollbar-darkshadow-color",status:"P"},{gecko:"",webkit:"",presto:"scrollbar-face-color",trident:"-ms-scrollbar-face-color",status:"P"},{gecko:"",webkit:"",presto:"scrollbar-highlight-color",trident:"-ms-scrollbar-highlight-color",status:"P"},{gecko:"",webkit:"",presto:"scrollbar-shadow-color",trident:"-ms-scrollbar-shadow-color",status:"P"},{gecko:"",webkit:"",presto:"scrollbar-track-color",trident:"-ms-scrollbar-track-color",status:"P"},{gecko:"-moz-stack-sizing",webkit:"",presto:"",trident:"",status:"P"},{gecko:"",webkit:"-webkit-svg-shadow",presto:"",trident:"",status:""},{gecko:"-moz-tab-size",webkit:"",presto:"-o-tab-size",trident:"",status:""},{gecko:"",webkit:"",presto:"-o-table-baseline",trident:"",status:""},{gecko:"",webkit:"-webkit-tap-highlight-color",presto:"",trident:"",status:"P"},{gecko:"",webkit:"",presto:"",trident:"-ms-text-align-last",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-text-autospace",status:"WD"},{gecko:"-moz-text-blink",webkit:"",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-text-combine",presto:"",trident:"",status:""},{gecko:"",webkit:"-epub-text-combine = -webkit-text-combine",presto:"",trident:"",status:""},{gecko:"-moz-text-decoration-color",webkit:"",presto:"",trident:"",status:""},{gecko:"-moz-text-decoration-line",webkit:"",presto:"",trident:"",status:""},{gecko:"-moz-text-decoration-style",webkit:"",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-text-decorations-in-effect",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-text-emphasis",presto:"",trident:"",status:""},{gecko:"",webkit:"-epub-text-emphasis = -webkit-text-emphasis",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-text-emphasis-color",presto:"",trident:"",status:""},{gecko:"",webkit:"-epub-text-emphasis-color = -webkit-text-emphasis-color",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-text-emphasis-position",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-text-emphasis-style",presto:"",trident:"",status:""},{gecko:"",webkit:"-epub-text-emphasis-style = -webkit-text-emphasis-style",presto:"",trident:"",status:""},{gecko:"",webkit:"-webkit-text-fill-color",presto:"",trident:"",status:"P"},{gecko:"",webkit:"",presto:"",trident:"-ms-text-justify",status:"WD"},{gecko:"",webkit:"",presto:"",trident:"-ms-text-kashida-space",status:"P"},{gecko:"",webkit:"-webkit-text-orientation",presto:"",trident:"",status:""},{gecko:"",webkit:"-epub-text-orientation = -webkit-text-orientation",presto:"",trident:"",status:""},{gecko:"",webkit:"text-overflow",presto:"text-overflow",trident:"-ms-text-overflow",status:"WD"},{gecko:"",webkit:"-webkit-text-security",presto:"",trident:"",status:"P"},{gecko:"",webkit:"-webkit-text-size-adjust",presto:"",trident:"-ms-text-size-adjust",status:""},{gecko:"",webkit:"-webkit-text-stroke",presto:"",trident:"",status:"P"},{gecko:"",webkit:"-webkit-text-stroke-color",presto:"",trident:"",status:"P"},{gecko:"",webkit:"-webkit-text-stroke-width",presto:"",trident:"",status:"P"},{gecko:"",webkit:"-epub-text-transform = text-transform",presto:"",trident:"",status:""},{gecko:"",webkit:"",presto:"",trident:"-ms-text-underline-position",status:"P"},{gecko:"",webkit:"-webkit-touch-callout",presto:"",trident:"",status:"P"},{gecko:"-moz-transform",webkit:"-webkit-transform",presto:"-o-transform",trident:"-ms-transform",status:"WD"},{gecko:"-moz-transform-origin",webkit:"-webkit-transform-origin",presto:"-o-transform-origin",trident:"-ms-transform-origin",status:"WD"},{gecko:"",webkit:"-webkit-transform-origin-x",presto:"",trident:"",status:"P"},{gecko:"",webkit:"-webkit-transform-origin-y",presto:"",trident:"",status:"P"},{gecko:"",webkit:"-webkit-transform-origin-z",presto:"",trident:"",status:"P"},{gecko:"",webkit:"-webkit-transform-style",presto:"",trident:"",status:"WD"},{gecko:"-moz-transition",webkit:"-webkit-transition",presto:"-o-transition",trident:"",status:"WD"},{gecko:"-moz-transition-delay",webkit:"-webkit-transition-delay",presto:"-o-transition-delay",trident:"",status:"WD"},{gecko:"-moz-transition-duration",webkit:"-webkit-transition-duration",presto:"-o-transition-duration",trident:"",status:"WD"},{gecko:"-moz-transition-property",webkit:"-webkit-transition-property",presto:"-o-transition-property",trident:"",status:"WD"},{gecko:"-moz-transition-timing-function",webkit:"-webkit-transition-timing-function",presto:"-o-transition-timing-function",trident:"",status:"WD"},{gecko:"",webkit:"-webkit-user-drag",presto:"",trident:"",status:"P"},{gecko:"-moz-user-focus",webkit:"",presto:"",trident:"",status:"P"},{gecko:"-moz-user-input",webkit:"",presto:"",trident:"",status:"P"},{gecko:"-moz-user-modify",webkit:"-webkit-user-modify",presto:"",trident:"",status:"P"},{gecko:"-moz-user-select",webkit:"-webkit-user-select",presto:"",trident:"",status:"P"},{gecko:"",webkit:"",presto:"-xv-voice-balance",trident:"",status:""},{gecko:"",webkit:"",presto:"-xv-voice-duration",trident:"",status:""},{gecko:"",webkit:"",presto:"-xv-voice-pitch",trident:"",status:""},{gecko:"",webkit:"",presto:"-xv-voice-pitch-range",trident:"",status:""},{gecko:"",webkit:"",presto:"-xv-voice-rate",trident:"",status:""},{gecko:"",webkit:"",presto:"-xv-voice-stress",trident:"",status:""},{gecko:"",webkit:"",presto:"-xv-voice-volume",trident:"",status:""},{gecko:"-moz-window-shadow",webkit:"",presto:"",trident:"",status:"P"},{gecko:"",webkit:"word-break",presto:"",trident:"-ms-word-break",status:"WD"},{gecko:"",webkit:"-epub-word-break = word-break",presto:"",trident:"",status:""},{gecko:"word-wrap",webkit:"word-wrap",presto:"word-wrap",trident:"-ms-word-wrap",status:"WD"},{gecko:"",webkit:"-webkit-writing-mode",presto:"writing-mode",trident:"-ms-writing-mode",status:"ED"},{gecko:"",webkit:"-epub-writing-mode = -webkit-writing-mode",presto:"",trident:"",status:""},{gecko:"",webkit:"zoom",presto:"",trident:"-ms-zoom",status:""}]};var kCSS_PREFIXED_VALUE=[{gecko:"-moz-box",webkit:"-moz-box",presto:"",trident:"",generic:"box"}];var CssInspector={mVENDOR_PREFIXES:null,kEXPORTS_FOR_GECKO:true,kEXPORTS_FOR_WEBKIT:true,kEXPORTS_FOR_PRESTO:true,kEXPORTS_FOR_TRIDENT:true,cleanPrefixes:function(){this.mVENDOR_PREFIXES=null},prefixesForProperty:function(aProperty){if(!this.mVENDOR_PREFIXES){this.mVENDOR_PREFIXES={};for(var i=0;i<kCSS_VENDOR_PREFIXES.properties.length;i++){var p=kCSS_VENDOR_PREFIXES.properties[i];if(p.gecko&&(p.webkit||p.presto||p.trident)){var o={};if(this.kEXPORTS_FOR_GECKO){o[p.gecko]=true}if(this.kEXPORTS_FOR_WEBKIT&&p.webkit){o[p.webkit]=true}if(this.kEXPORTS_FOR_PRESTO&&p.presto){o[p.presto]=true}if(this.kEXPORTS_FOR_TRIDENT&&p.trident){o[p.trident]=true}this.mVENDOR_PREFIXES[p.gecko]=[];for(var j in o){this.mVENDOR_PREFIXES[p.gecko].push(j)}}}}if(aProperty in this.mVENDOR_PREFIXES){return this.mVENDOR_PREFIXES[aProperty].sort()}return null},parseColorStop:function(parser,token){var color=parser.parseColor(token);var position="";if(!color){return null}token=parser.getToken(true,true);if(token.isPercentage()||token.isDimensionOfUnit("cm")||token.isDimensionOfUnit("mm")||token.isDimensionOfUnit("in")||token.isDimensionOfUnit("pc")||token.isDimensionOfUnit("px")||token.isDimensionOfUnit("em")||token.isDimensionOfUnit("ex")||token.isDimensionOfUnit("pt")){position=token.value;token=parser.getToken(true,true)}return{color:color,position:position}},parseGradient:function(parser,token){var isRadial=false;var gradient={isRepeating:false};if(token.isNotNull()){if(token.isFunction("-moz-linear-gradient(")||token.isFunction("-moz-radial-gradient(")||token.isFunction("-moz-repeating-linear-gradient(")||token.isFunction("-moz-repeating-radial-gradient(")){if(token.isFunction("-moz-radial-gradient(")||token.isFunction("-moz-repeating-radial-gradient(")){gradient.isRadial=true}if(token.isFunction("-moz-repeating-linear-gradient(")||token.isFunction("-moz-repeating-radial-gradient(")){gradient.isRepeating=true}token=parser.getToken(true,true);var haveGradientLine=false;var foundHorizPosition=false;var haveAngle=false;if(token.isAngle()){gradient.angle=token.value;haveGradientLine=true;haveAngle=true;token=parser.getToken(true,true)}if(token.isLength()||token.isIdent("top")||token.isIdent("center")||token.isIdent("bottom")||token.isIdent("left")||token.isIdent("right")){haveGradientLine=true;if(token.isLength()||token.isIdent("left")||token.isIdent("right")){foundHorizPosition=true}gradient.position=token.value;token=parser.getToken(true,true)}if(haveGradientLine){if(!haveAngle&&token.isAngle()){gradient.angle=token.value;haveAngle=true;token=parser.getToken(true,true)}else{if(token.isLength()||(foundHorizPosition&&(token.isIdent("top")||token.isIdent("center")||token.isIdent("bottom")))||(!foundHorizPosition&&(token.isLength()||token.isIdent("top")||token.isIdent("center")||token.isIdent("bottom")||token.isIdent("left")||token.isIdent("right")))){gradient.position=("position" in gradient)?gradient.position+" ":"";gradient.position+=token.value;token=parser.getToken(true,true)}}if(!haveAngle&&token.isAngle()){gradient.angle=token.value;haveAngle=true;token=parser.getToken(true,true)}if(!token.isSymbol(",")){return null}token=parser.getToken(true,true)}if(gradient.isRadial){if(token.isIdent("circle")||token.isIdent("ellipse")){gradient.shape=token.value;token=parser.getToken(true,true)}if(token.isIdent("closest-side")||token.isIdent("closest-corner")||token.isIdent("farthest-side")||token.isIdent("farthest-corner")||token.isIdent("contain")||token.isIdent("cover")){gradient.size=token.value;token=parser.getToken(true,true)}if(!("shape" in gradient)&&(token.isIdent("circle")||token.isIdent("ellipse"))){gradient.shape=token.value;token=parser.getToken(true,true)}if((("shape" in gradient)||("size" in gradient))&&!token.isSymbol(",")){return null}else{if(("shape" in gradient)||("size" in gradient)){token=parser.getToken(true,true)}}}var stop1=this.parseColorStop(parser,token);if(!stop1){return null}token=parser.currentToken();if(!token.isSymbol(",")){return null}token=parser.getToken(true,true);var stop2=this.parseColorStop(parser,token);if(!stop2){return null}token=parser.currentToken();if(token.isSymbol(",")){token=parser.getToken(true,true)}gradient.stops=[stop1,stop2];while(!token.isSymbol(")")){var colorstop=this.parseColorStop(parser,token);if(!colorstop){return null}token=parser.currentToken();if(!token.isSymbol(")")&&!token.isSymbol(",")){return null}if(token.isSymbol(",")){token=parser.getToken(true,true)}gradient.stops.push(colorstop)}return gradient}}return null},parseBoxShadows:function(aString){var parser=new CSSParser();parser._init();parser.mPreserveWS=false;parser.mPreserveComments=false;parser.mPreservedTokens=[];parser.mScanner.init(aString);var shadows=[];var token=parser.getToken(true,true);var color="",blurRadius="0px",offsetX="0px",offsetY="0px",spreadRadius="0px";var inset=false;while(token.isNotNull()){if(token.isIdent("none")){shadows.push({none:true});token=parser.getToken(true,true)}else{if(token.isIdent("inset")){inset=true;token=parser.getToken(true,true)}if(token.isPercentage()||token.isDimensionOfUnit("cm")||token.isDimensionOfUnit("mm")||token.isDimensionOfUnit("in")||token.isDimensionOfUnit("pc")||token.isDimensionOfUnit("px")||token.isDimensionOfUnit("em")||token.isDimensionOfUnit("ex")||token.isDimensionOfUnit("pt")){var offsetX=token.value;token=parser.getToken(true,true)}else{return[]}if(!inset&&token.isIdent("inset")){inset=true;token=parser.getToken(true,true)}if(token.isPercentage()||token.isDimensionOfUnit("cm")||token.isDimensionOfUnit("mm")||token.isDimensionOfUnit("in")||token.isDimensionOfUnit("pc")||token.isDimensionOfUnit("px")||token.isDimensionOfUnit("em")||token.isDimensionOfUnit("ex")||token.isDimensionOfUnit("pt")){var offsetX=token.value;token=parser.getToken(true,true)}else{return[]}if(!inset&&token.isIdent("inset")){inset=true;token=parser.getToken(true,true)}if(token.isPercentage()||token.isDimensionOfUnit("cm")||token.isDimensionOfUnit("mm")||token.isDimensionOfUnit("in")||token.isDimensionOfUnit("pc")||token.isDimensionOfUnit("px")||token.isDimensionOfUnit("em")||token.isDimensionOfUnit("ex")||token.isDimensionOfUnit("pt")){var blurRadius=token.value;token=parser.getToken(true,true)}if(!inset&&token.isIdent("inset")){inset=true;token=parser.getToken(true,true)}if(token.isPercentage()||token.isDimensionOfUnit("cm")||token.isDimensionOfUnit("mm")||token.isDimensionOfUnit("in")||token.isDimensionOfUnit("pc")||token.isDimensionOfUnit("px")||token.isDimensionOfUnit("em")||token.isDimensionOfUnit("ex")||token.isDimensionOfUnit("pt")){var spreadRadius=token.value;token=parser.getToken(true,true)}if(!inset&&token.isIdent("inset")){inset=true;token=parser.getToken(true,true)}if(token.isFunction("rgb(")||token.isFunction("rgba(")||token.isFunction("hsl(")||token.isFunction("hsla(")||token.isSymbol("#")||token.isIdent()){var color=parser.parseColor(token);token=parser.getToken(true,true)}if(!inset&&token.isIdent("inset")){inset=true;token=parser.getToken(true,true)}shadows.push({none:false,color:color,offsetX:offsetX,offsetY:offsetY,blurRadius:blurRadius,spreadRadius:spreadRadius});if(token.isSymbol(",")){inset=false;color="";blurRadius="0px";spreadRadius="0px";offsetX="0px";offsetY="0px";token=parser.getToken(true,true)}else{if(!token.isNotNull()){return shadows}else{return[]}}}}return shadows},parseTextShadows:function(aString){var parser=new CSSParser();parser._init();parser.mPreserveWS=false;parser.mPreserveComments=false;parser.mPreservedTokens=[];parser.mScanner.init(aString);var shadows=[];var token=parser.getToken(true,true);var color="",blurRadius="0px",offsetX="0px",offsetY="0px";while(token.isNotNull()){if(token.isIdent("none")){shadows.push({none:true});token=parser.getToken(true,true)}else{if(token.isFunction("rgb(")||token.isFunction("rgba(")||token.isFunction("hsl(")||token.isFunction("hsla(")||token.isSymbol("#")||token.isIdent()){var color=parser.parseColor(token);token=parser.getToken(true,true)}if(token.isPercentage()||token.isDimensionOfUnit("cm")||token.isDimensionOfUnit("mm")||token.isDimensionOfUnit("in")||token.isDimensionOfUnit("pc")||token.isDimensionOfUnit("px")||token.isDimensionOfUnit("em")||token.isDimensionOfUnit("ex")||token.isDimensionOfUnit("pt")){var offsetX=token.value;token=parser.getToken(true,true)}else{return[]}if(token.isPercentage()||token.isDimensionOfUnit("cm")||token.isDimensionOfUnit("mm")||token.isDimensionOfUnit("in")||token.isDimensionOfUnit("pc")||token.isDimensionOfUnit("px")||token.isDimensionOfUnit("em")||token.isDimensionOfUnit("ex")||token.isDimensionOfUnit("pt")){var offsetY=token.value;token=parser.getToken(true,true)}else{return[]}if(token.isPercentage()||token.isDimensionOfUnit("cm")||token.isDimensionOfUnit("mm")||token.isDimensionOfUnit("in")||token.isDimensionOfUnit("pc")||token.isDimensionOfUnit("px")||token.isDimensionOfUnit("em")||token.isDimensionOfUnit("ex")||token.isDimensionOfUnit("pt")){var blurRadius=token.value;token=parser.getToken(true,true)}if(!color&&(token.isFunction("rgb(")||token.isFunction("rgba(")||token.isFunction("hsl(")||token.isFunction("hsla(")||token.isSymbol("#")||token.isIdent())){var color=parser.parseColor(token);token=parser.getToken(true,true)}shadows.push({none:false,color:color,offsetX:offsetX,offsetY:offsetY,blurRadius:blurRadius});if(token.isSymbol(",")){color="";blurRadius="0px";offsetX="0px";offsetY="0px";token=parser.getToken(true,true)}else{if(!token.isNotNull()){return shadows}else{return[]}}}}return shadows},parseBackgroundImages:function(aString){var parser=new CSSParser();parser._init();parser.mPreserveWS=false;parser.mPreserveComments=false;parser.mPreservedTokens=[];parser.mScanner.init(aString);var backgrounds=[];var token=parser.getToken(true,true);while(token.isNotNull()){if(token.isFunction("url(")){token=parser.getToken(true,true);var urlContent=parser.parseURL(token);backgrounds.push({type:"image",value:"url("+urlContent});token=parser.getToken(true,true)}else{if(token.isFunction("-moz-linear-gradient(")||token.isFunction("-moz-radial-gradient(")||token.isFunction("-moz-repeating-linear-gradient(")||token.isFunction("-moz-repeating-radial-gradient(")){var gradient=this.parseGradient(parser,token);backgrounds.push({type:gradient.isRadial?"radial-gradient":"linear-gradient",value:gradient});token=parser.getToken(true,true)}else{return null}}if(token.isSymbol(",")){token=parser.getToken(true,true);if(!token.isNotNull()){return null}}}return backgrounds},serializeGradient:function(gradient){var s=gradient.isRadial?(gradient.isRepeating?"-moz-repeating-radial-gradient(":"-moz-radial-gradient("):(gradient.isRepeating?"-moz-repeating-linear-gradient(":"-moz-linear-gradient(");if(gradient.angle||gradient.position){s+=(gradient.angle?gradient.angle+" ":"")+(gradient.position?gradient.position:"")+", "}if(gradient.isRadial&&(gradient.shape||gradient.size)){s+=(gradient.shape?gradient.shape:"")+" "+(gradient.size?gradient.size:"")+", "}for(var i=0;i<gradient.stops.length;i++){var colorstop=gradient.stops[i];s+=colorstop.color+(colorstop.position?" "+colorstop.position:"");if(i!=gradient.stops.length-1){s+=", "}}s+=")";return s},parseBorderImage:function(aString){var parser=new CSSParser();parser._init();parser.mPreserveWS=false;parser.mPreserveComments=false;parser.mPreservedTokens=[];parser.mScanner.init(aString);var borderImage={url:"",offsets:[],widths:[],sizes:[]};var token=parser.getToken(true,true);if(token.isFunction("url(")){token=parser.getToken(true,true);var urlContent=parser.parseURL(token);if(urlContent){borderImage.url=urlContent.substr(0,urlContent.length-1).trim();if((borderImage.url[0]=='"'&&borderImage.url[borderImage.url.length-1]=='"')||(borderImage.url[0]=="'"&&borderImage.url[borderImage.url.length-1]=="'")){borderImage.url=borderImage.url.substr(1,borderImage.url.length-2)}}else{return null}}else{return null}token=parser.getToken(true,true);if(token.isNumber()||token.isPercentage()){borderImage.offsets.push(token.value)}else{return null}var i;for(i=0;i<3;i++){token=parser.getToken(true,true);if(token.isNumber()||token.isPercentage()){borderImage.offsets.push(token.value)}else{break}}if(i==3){token=parser.getToken(true,true)}if(token.isSymbol("/")){token=parser.getToken(true,true);if(token.isDimension()||token.isNumber("0")||(token.isIdent()&&token.value in parser.kBORDER_WIDTH_NAMES)){borderImage.widths.push(token.value)}else{return null}for(var i=0;i<3;i++){token=parser.getToken(true,true);if(token.isDimension()||token.isNumber("0")||(token.isIdent()&&token.value in parser.kBORDER_WIDTH_NAMES)){borderImage.widths.push(token.value)}else{break}}if(i==3){token=parser.getToken(true,true)}}for(var i=0;i<2;i++){if(token.isIdent("stretch")||token.isIdent("repeat")||token.isIdent("round")){borderImage.sizes.push(token.value)}else{if(!token.isNotNull()){return borderImage}else{return null}}token=parser.getToken(true,true)}if(!token.isNotNull()){return borderImage}return null},parseMediaQuery:function(aString){var kCONSTRAINTS={width:true,"min-width":true,"max-width":true,height:true,"min-height":true,"max-height":true,"device-width":true,"min-device-width":true,"max-device-width":true,"device-height":true,"min-device-height":true,"max-device-height":true,orientation:true,"aspect-ratio":true,"min-aspect-ratio":true,"max-aspect-ratio":true,"device-aspect-ratio":true,"min-device-aspect-ratio":true,"max-device-aspect-ratio":true,color:true,"min-color":true,"max-color":true,"color-index":true,"min-color-index":true,"max-color-index":true,monochrome:true,"min-monochrome":true,"max-monochrome":true,resolution:true,"min-resolution":true,"max-resolution":true,scan:true,grid:true};var parser=new CSSParser();parser._init();parser.mPreserveWS=false;parser.mPreserveComments=false;parser.mPreservedTokens=[];parser.mScanner.init(aString);var m={amplifier:"",medium:"",constraints:[]};var token=parser.getToken(true,true);if(token.isIdent("all")||token.isIdent("aural")||token.isIdent("braille")||token.isIdent("handheld")||token.isIdent("print")||token.isIdent("projection")||token.isIdent("screen")||token.isIdent("tty")||token.isIdent("tv")){m.medium=token.value;token=parser.getToken(true,true)}else{if(token.isIdent("not")||token.isIdent("only")){m.amplifier=token.value;token=parser.getToken(true,true);if(token.isIdent("all")||token.isIdent("aural")||token.isIdent("braille")||token.isIdent("handheld")||token.isIdent("print")||token.isIdent("projection")||token.isIdent("screen")||token.isIdent("tty")||token.isIdent("tv")){m.medium=token.value;token=parser.getToken(true,true)}else{return null}}}if(m.medium){if(!token.isNotNull()){return m}if(token.isIdent("and")){token=parser.getToken(true,true)}else{return null}}while(token.isSymbol("(")){token=parser.getToken(true,true);if(token.isIdent()&&(token.value in kCONSTRAINTS)){var constraint=token.value;token=parser.getToken(true,true);if(token.isSymbol(":")){token=parser.getToken(true,true);var values=[];while(!token.isSymbol(")")){values.push(token.value);token=parser.getToken(true,true)}if(token.isSymbol(")")){m.constraints.push({constraint:constraint,value:values});token=parser.getToken(true,true);if(token.isNotNull()){if(token.isIdent("and")){token=parser.getToken(true,true)}else{return null}}else{return m}}else{return null}}else{if(token.isSymbol(")")){m.constraints.push({constraint:constraint,value:null});token=parser.getToken(true,true);if(token.isNotNull()){if(token.isIdent("and")){token=parser.getToken(true,true)}else{return null}}else{return m}}else{return null}}}else{return null}}return m}};var CSS_ESCAPE="\\";var IS_HEX_DIGIT=1;var START_IDENT=2;var IS_IDENT=4;var IS_WHITESPACE=8;var W=IS_WHITESPACE;var I=IS_IDENT;var S=START_IDENT;var SI=IS_IDENT|START_IDENT;var XI=IS_IDENT|IS_HEX_DIGIT;var XSI=IS_IDENT|START_IDENT|IS_HEX_DIGIT;function CSSScanner(aString){this.init(aString)}CSSScanner.prototype={kLexTable:[0,0,0,0,0,0,0,0,0,W,W,0,W,W,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,W,0,0,0,0,0,0,0,0,0,0,0,0,I,0,0,XI,XI,XI,XI,XI,XI,XI,XI,XI,XI,0,0,0,0,0,0,0,XSI,XSI,XSI,XSI,XSI,XSI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,0,S,0,0,SI,0,XSI,XSI,XSI,XSI,XSI,XSI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI,SI],kHexValues:{"0":0,"1":1,"2":2,"3":3,"4":4,"5":5,"6":6,"7":7,"8":8,"9":9,a:10,b:11,c:12,d:13,e:14,f:15},mString:"",mPos:0,mPreservedPos:[],init:function(aString){this.mString=aString;this.mPos=0;this.mPreservedPos=[]},getCurrentPos:function(){return this.mPos},getAlreadyScanned:function(){return this.mString.substr(0,this.mPos)},preserveState:function(){this.mPreservedPos.push(this.mPos)},restoreState:function(){if(this.mPreservedPos.length){this.mPos=this.mPreservedPos.pop()}},forgetState:function(){if(this.mPreservedPos.length){this.mPreservedPos.pop()}},read:function(){if(this.mPos<this.mString.length){return this.mString.charAt(this.mPos++)}return -1},peek:function(){if(this.mPos<this.mString.length){return this.mString.charAt(this.mPos)}return -1},isHexDigit:function(c){var code=c.charCodeAt(0);return(code<256&&(this.kLexTable[code]&IS_HEX_DIGIT)!=0)},isIdentStart:function(c){var code=c.charCodeAt(0);return(code>=256||(this.kLexTable[code]&START_IDENT)!=0)},startsWithIdent:function(aFirstChar,aSecondChar){var code=aFirstChar.charCodeAt(0);return this.isIdentStart(aFirstChar)||(aFirstChar=="-"&&this.isIdentStart(aSecondChar))},isIdent:function(c){var code=c.charCodeAt(0);return(code>=256||(this.kLexTable[code]&IS_IDENT)!=0)},pushback:function(){this.mPos--},nextHexValue:function(){var c=this.read();if(c==-1||!this.isHexDigit(c)){return new jscsspToken(jscsspToken.NULL_TYPE,null)}var s=c;c=this.read();while(c!=-1&&this.isHexDigit(c)){s+=c;c=this.read()}if(c!=-1){this.pushback()}return new jscsspToken(jscsspToken.HEX_TYPE,s)},gatherEscape:function(){var c=this.peek();if(c==-1){return""}if(this.isHexDigit(c)){var code=0;for(var i=0;i<6;i++){c=this.read();if(this.isHexDigit(c)){code=code*16+this.kHexValues[c.toLowerCase()]}else{if(!this.isHexDigit(c)&&!this.isWhiteSpace(c)){this.pushback();break}else{break}}}if(i==6){c=this.peek();if(this.isWhiteSpace(c)){this.read()}}return String.fromCharCode(code)}c=this.read();if(c!="\n"){return c}return""},gatherIdent:function(c){var s="";if(c==CSS_ESCAPE){s+=this.gatherEscape()}else{s+=c}c=this.read();while(c!=-1&&(this.isIdent(c)||c==CSS_ESCAPE)){if(c==CSS_ESCAPE){s+=this.gatherEscape()}else{s+=c}c=this.read()}if(c!=-1){this.pushback()}return s},parseIdent:function(c){var value=this.gatherIdent(c);var nextChar=this.peek();if(nextChar=="("){value+=this.read();return new jscsspToken(jscsspToken.FUNCTION_TYPE,value)}return new jscsspToken(jscsspToken.IDENT_TYPE,value)},isDigit:function(c){return(c>="0")&&(c<="9")},parseComment:function(c){var s=c;while((c=this.read())!=-1){s+=c;if(c=="*"){c=this.read();if(c==-1){break}if(c=="/"){s+=c;break}this.pushback()}}return new jscsspToken(jscsspToken.COMMENT_TYPE,s)},parseNumber:function(c){var s=c;var foundDot=false;while((c=this.read())!=-1){if(c=="."){if(foundDot){break}else{s+=c;foundDot=true}}else{if(this.isDigit(c)){s+=c}else{break}}}if(c!=-1&&this.startsWithIdent(c,this.peek())){var unit=this.gatherIdent(c);s+=unit;return new jscsspToken(jscsspToken.DIMENSION_TYPE,s,unit)}else{if(c=="%"){s+="%";return new jscsspToken(jscsspToken.PERCENTAGE_TYPE,s)}else{if(c!=-1){this.pushback()}}}return new jscsspToken(jscsspToken.NUMBER_TYPE,s)},parseString:function(aStop){var s=aStop;var previousChar=aStop;var c;while((c=this.read())!=-1){if(c==aStop&&previousChar!=CSS_ESCAPE){s+=c;break}else{if(c==CSS_ESCAPE){c=this.peek();if(c==-1){break}else{if(c=="\n"||c=="\r"||c=="\f"){d=c;c=this.read();if(d=="\r"){c=this.peek();if(c=="\n"){c=this.read()}}}else{s+=this.gatherEscape();c=this.peek()}}}else{if(c=="\n"||c=="\r"||c=="\f"){break}else{s+=c}}}previousChar=c}return new jscsspToken(jscsspToken.STRING_TYPE,s)},isWhiteSpace:function(c){var code=c.charCodeAt(0);return code<256&&(this.kLexTable[code]&IS_WHITESPACE)!=0},eatWhiteSpace:function(c){var s=c;while((c=this.read())!=-1){if(!this.isWhiteSpace(c)){break}s+=c}if(c!=-1){this.pushback()}return s},parseAtKeyword:function(c){return new jscsspToken(jscsspToken.ATRULE_TYPE,this.gatherIdent(c))},nextToken:function(){var c=this.read();if(c==-1){return new jscsspToken(jscsspToken.NULL_TYPE,null)}if(this.startsWithIdent(c,this.peek())){return this.parseIdent(c)}if(c=="@"){var nextChar=this.read();if(nextChar!=-1){var followingChar=this.peek();this.pushback();if(this.startsWithIdent(nextChar,followingChar)){return this.parseAtKeyword(c)}}}if(c=="."||c=="+"||c=="-"){var nextChar=this.peek();if(this.isDigit(nextChar)){return this.parseNumber(c)}else{if(nextChar=="."&&c!="."){firstChar=this.read();var secondChar=this.peek();this.pushback();if(this.isDigit(secondChar)){return this.parseNumber(c)}}}}if(this.isDigit(c)){return this.parseNumber(c)}if(c=="'"||c=='"'){return this.parseString(c)}if(this.isWhiteSpace(c)){var s=this.eatWhiteSpace(c);return new jscsspToken(jscsspToken.WHITESPACE_TYPE,s)}if(c=="|"||c=="~"||c=="^"||c=="$"||c=="*"){var nextChar=this.read();if(nextChar=="="){switch(c){case"~":return new jscsspToken(jscsspToken.INCLUDES_TYPE,"~=");case"|":return new jscsspToken(jscsspToken.DASHMATCH_TYPE,"|=");case"^":return new jscsspToken(jscsspToken.BEGINSMATCH_TYPE,"^=");case"$":return new jscsspToken(jscsspToken.ENDSMATCH_TYPE,"$=");case"*":return new jscsspToken(jscsspToken.CONTAINSMATCH_TYPE,"*=");default:break}}else{if(nextChar!=-1){this.pushback()}}}if(c=="/"&&this.peek()=="*"){return this.parseComment(c)}return new jscsspToken(jscsspToken.SYMBOL_TYPE,c)}};function CSSParser(aString){this.mToken=null;this.mLookAhead=null;this.mScanner=new CSSScanner(aString);this.mPreserveWS=true;this.mPreserveComments=true;this.mPreservedTokens=[];this.mError=null}CSSParser.prototype={_init:function(){this.mToken=null;this.mLookAhead=null},kINHERIT:"inherit",kBORDER_WIDTH_NAMES:{thin:true,medium:true,thick:true},kBORDER_STYLE_NAMES:{none:true,hidden:true,dotted:true,dashed:true,solid:true,"double":true,groove:true,ridge:true,inset:true,outset:true},kCOLOR_NAMES:{transparent:true,black:true,silver:true,gray:true,white:true,maroon:true,red:true,purple:true,fuchsia:true,green:true,lime:true,olive:true,yellow:true,navy:true,blue:true,teal:true,aqua:true,aliceblue:true,antiquewhite:true,aqua:true,aquamarine:true,azure:true,beige:true,bisque:true,black:true,blanchedalmond:true,blue:true,blueviolet:true,brown:true,burlywood:true,cadetblue:true,chartreuse:true,chocolate:true,coral:true,cornflowerblue:true,cornsilk:true,crimson:true,cyan:true,darkblue:true,darkcyan:true,darkgoldenrod:true,darkgray:true,darkgreen:true,darkgrey:true,darkkhaki:true,darkmagenta:true,darkolivegreen:true,darkorange:true,darkorchid:true,darkred:true,darksalmon:true,darkseagreen:true,darkslateblue:true,darkslategray:true,darkslategrey:true,darkturquoise:true,darkviolet:true,deeppink:true,deepskyblue:true,dimgray:true,dimgrey:true,dodgerblue:true,firebrick:true,floralwhite:true,forestgreen:true,fuchsia:true,gainsboro:true,ghostwhite:true,gold:true,goldenrod:true,gray:true,green:true,greenyellow:true,grey:true,honeydew:true,hotpink:true,indianred:true,indigo:true,ivory:true,khaki:true,lavender:true,lavenderblush:true,lawngreen:true,lemonchiffon:true,lightblue:true,lightcoral:true,lightcyan:true,lightgoldenrodyellow:true,lightgray:true,lightgreen:true,lightgrey:true,lightpink:true,lightsalmon:true,lightseagreen:true,lightskyblue:true,lightslategray:true,lightslategrey:true,lightsteelblue:true,lightyellow:true,lime:true,limegreen:true,linen:true,magenta:true,maroon:true,mediumaquamarine:true,mediumblue:true,mediumorchid:true,mediumpurple:true,mediumseagreen:true,mediumslateblue:true,mediumspringgreen:true,mediumturquoise:true,mediumvioletred:true,midnightblue:true,mintcream:true,mistyrose:true,moccasin:true,navajowhite:true,navy:true,oldlace:true,olive:true,olivedrab:true,orange:true,orangered:true,orchid:true,palegoldenrod:true,palegreen:true,paleturquoise:true,palevioletred:true,papayawhip:true,peachpuff:true,peru:true,pink:true,plum:true,powderblue:true,purple:true,red:true,rosybrown:true,royalblue:true,saddlebrown:true,salmon:true,sandybrown:true,seagreen:true,seashell:true,sienna:true,silver:true,skyblue:true,slateblue:true,slategray:true,slategrey:true,snow:true,springgreen:true,steelblue:true,tan:true,teal:true,thistle:true,tomato:true,turquoise:true,violet:true,wheat:true,white:true,whitesmoke:true,yellow:true,yellowgreen:true,activeborder:true,activecaption:true,appworkspace:true,background:true,buttonface:true,buttonhighlight:true,buttonshadow:true,buttontext:true,captiontext:true,graytext:true,highlight:true,highlighttext:true,inactiveborder:true,inactivecaption:true,inactivecaptiontext:true,infobackground:true,infotext:true,menu:true,menutext:true,scrollbar:true,threeddarkshadow:true,threedface:true,threedhighlight:true,threedlightshadow:true,threedshadow:true,window:true,windowframe:true,windowtext:true},kLIST_STYLE_TYPE_NAMES:{decimal:true,"decimal-leading-zero":true,"lower-roman":true,"upper-roman":true,georgian:true,armenian:true,"lower-latin":true,"lower-alpha":true,"upper-latin":true,"upper-alpha":true,"lower-greek":true,disc:true,circle:true,square:true,none:true,box:true,check:true,diamond:true,hyphen:true,"lower-armenian":true,"cjk-ideographic":true,"ethiopic-numeric":true,hebrew:true,"japanese-formal":true,"japanese-informal":true,"simp-chinese-formal":true,"simp-chinese-informal":true,syriac:true,tamil:true,"trad-chinese-formal":true,"trad-chinese-informal":true,"upper-armenian":true,"arabic-indic":true,binary:true,bengali:true,cambodian:true,khmer:true,devanagari:true,gujarati:true,gurmukhi:true,kannada:true,"lower-hexadecimal":true,lao:true,malayalam:true,mongolian:true,myanmar:true,octal:true,oriya:true,persian:true,urdu:true,telugu:true,tibetan:true,"upper-hexadecimal":true,afar:true,"ethiopic-halehame-aa-et":true,"ethiopic-halehame-am-et":true,"amharic-abegede":true,"ehiopic-abegede-am-et":true,"cjk-earthly-branch":true,"cjk-heavenly-stem":true,ethiopic:true,"ethiopic-abegede":true,"ethiopic-abegede-gez":true,"hangul-consonant":true,hangul:true,"hiragana-iroha":true,hiragana:true,"katakana-iroha":true,katakana:true,"lower-norwegian":true,oromo:true,"ethiopic-halehame-om-et":true,sidama:true,"ethiopic-halehame-sid-et":true,somali:true,"ethiopic-halehame-so-et":true,tigre:true,"ethiopic-halehame-tig":true,"tigrinya-er-abegede":true,"ethiopic-abegede-ti-er":true,"tigrinya-et":true,"ethiopic-halehame-ti-et":true,"upper-greek":true,asterisks:true,footnotes:true,"circled-decimal":true,"circled-lower-latin":true,"circled-upper-latin":true,"dotted-decimal":true,"double-circled-decimal":true,"filled-circled-decimal":true,"parenthesised-decimal":true,"parenthesised-lower-latin":true},reportError:function(aMsg){this.mError=aMsg},consumeError:function(){var e=this.mError;this.mError=null;return e},currentToken:function(){return this.mToken},getHexValue:function(){this.mToken=this.mScanner.nextHexValue();return this.mToken},getToken:function(aSkipWS,aSkipComment){if(this.mLookAhead){this.mToken=this.mLookAhead;this.mLookAhead=null;return this.mToken}this.mToken=this.mScanner.nextToken();while(this.mToken&&((aSkipWS&&this.mToken.isWhiteSpace())||(aSkipComment&&this.mToken.isComment()))){this.mToken=this.mScanner.nextToken()}return this.mToken},lookAhead:function(aSkipWS,aSkipComment){var preservedToken=this.mToken;this.mScanner.preserveState();var token=this.getToken(aSkipWS,aSkipComment);this.mScanner.restoreState();this.mToken=preservedToken;return token},ungetToken:function(){this.mLookAhead=this.mToken},addUnknownAtRule:function(aSheet,aString){var currentLine=CountLF(this.mScanner.getAlreadyScanned());var blocks=[];var token=this.getToken(false,false);while(token.isNotNull()){aString+=token.value;if(token.isSymbol(";")&&!blocks.length){break}else{if(token.isSymbol("{")||token.isSymbol("(")||token.isSymbol("[")||token.type=="function"){blocks.push(token.isFunction()?"(":token.value)}else{if(token.isSymbol("}")||token.isSymbol(")")||token.isSymbol("]")){if(blocks.length){var ontop=blocks[blocks.length-1];if((token.isSymbol("}")&&ontop=="{")||(token.isSymbol(")")&&ontop=="(")||(token.isSymbol("]")&&ontop=="[")){blocks.pop();if(!blocks.length&&token.isSymbol("}")){break}}}}}}token=this.getToken(false,false)}this.addUnknownRule(aSheet,aString,currentLine)},addUnknownRule:function(aSheet,aString,aCurrentLine){var errorMsg=this.consumeError();var rule=new jscsspErrorRule(errorMsg);rule.currentLine=aCurrentLine;rule.parsedCssText=aString;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule)},addWhitespace:function(aSheet,aString){var rule=new jscsspWhitespace();rule.parsedCssText=aString;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule)},addComment:function(aSheet,aString){var rule=new jscsspComment();rule.parsedCssText=aString;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule)},parseCharsetRule:function(aToken,aSheet){var s=aToken.value;var token=this.getToken(false,false);s+=token.value;if(token.isWhiteSpace(" ")){token=this.getToken(false,false);s+=token.value;if(token.isString()){var encoding=token.value;token=this.getToken(false,false);s+=token.value;if(token.isSymbol(";")){var rule=new jscsspCharsetRule();rule.encoding=encoding;rule.parsedCssText=s;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule);return true}else{this.reportError(kCHARSET_RULE_MISSING_SEMICOLON)}}else{this.reportError(kCHARSET_RULE_CHARSET_IS_STRING)}}else{this.reportError(kCHARSET_RULE_MISSING_WS)}this.addUnknownAtRule(aSheet,s);return false},parseImportRule:function(aToken,aSheet){var currentLine=CountLF(this.mScanner.getAlreadyScanned());var s=aToken.value;this.preserveState();var token=this.getToken(true,true);var media=[];var href="";if(token.isString()){href=token.value;s+=" "+href}else{if(token.isFunction("url(")){token=this.getToken(true,true);var urlContent=this.parseURL(token);if(urlContent){href="url("+urlContent;s+=" "+href}}else{this.reportError(kIMPORT_RULE_MISSING_URL)}}if(href){token=this.getToken(true,true);while(token.isIdent()){s+=" "+token.value;media.push(token.value);token=this.getToken(true,true);if(!token){break}if(token.isSymbol(",")){s+=","}else{if(token.isSymbol(";")){break}else{break}}token=this.getToken(true,true)}if(!media.length){media.push("all")}if(token.isSymbol(";")){s+=";";this.forgetState();var rule=new jscsspImportRule();rule.currentLine=currentLine;rule.parsedCssText=s;rule.href=href;rule.media=media;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule);return true}}this.restoreState();this.addUnknownAtRule(aSheet,"@import");return false},parseVariablesRule:function(token,aSheet){var currentLine=CountLF(this.mScanner.getAlreadyScanned());var s=token.value;var declarations=[];var valid=false;this.preserveState();token=this.getToken(true,true);var media=[];var foundMedia=false;while(token.isNotNull()){if(token.isIdent()){foundMedia=true;s+=" "+token.value;media.push(token.value);token=this.getToken(true,true);if(token.isSymbol(",")){s+=","}else{if(token.isSymbol("{")){this.ungetToken()}else{token.type=jscsspToken.NULL_TYPE;break}}}else{if(token.isSymbol("{")){break}else{if(foundMedia){token.type=jscsspToken.NULL_TYPE;break}}}token=this.getToken(true,true)}if(token.isSymbol("{")){s+=" {";token=this.getToken(true,true);while(true){if(!token.isNotNull()){valid=true;break}if(token.isSymbol("}")){s+="}";valid=true;break}else{var d=this.parseDeclaration(token,declarations,true,false,aSheet);s+=((d&&declarations.length)?" ":"")+d}token=this.getToken(true,false)}}if(valid){this.forgetState();var rule=new jscsspVariablesRule();rule.currentLine=currentLine;rule.parsedCssText=s;rule.declarations=declarations;rule.media=media;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule);return true}this.restoreState();return false},parseNamespaceRule:function(aToken,aSheet){var currentLine=CountLF(this.mScanner.getAlreadyScanned());var s=aToken.value;var valid=false;this.preserveState();var token=this.getToken(true,true);if(token.isNotNull()){var prefix="";var url="";if(token.isIdent()){prefix=token.value;s+=" "+prefix;token=this.getToken(true,true)}if(token){var foundURL=false;if(token.isString()){foundURL=true;url=token.value;s+=" "+url}else{if(token.isFunction("url(")){token=this.getToken(true,true);var urlContent=this.parseURL(token);if(urlContent){url+="url("+urlContent;foundURL=true;s+=" "+urlContent}}}}if(foundURL){token=this.getToken(true,true);if(token.isSymbol(";")){s+=";";this.forgetState();var rule=new jscsspNamespaceRule();rule.currentLine=currentLine;rule.parsedCssText=s;rule.prefix=prefix;rule.url=url;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule);return true}}}this.restoreState();this.addUnknownAtRule(aSheet,"@namespace");return false},parseFontFaceRule:function(aToken,aSheet){var currentLine=CountLF(this.mScanner.getAlreadyScanned());var s=aToken.value;var valid=false;var descriptors=[];this.preserveState();var token=this.getToken(true,true);if(token.isNotNull()){if(token.isSymbol("{")){s+=" "+token.value;var token=this.getToken(true,false);while(true){if(token.isSymbol("}")){s+="}";valid=true;break}else{var d=this.parseDeclaration(token,descriptors,false,false,aSheet);s+=((d&&descriptors.length)?" ":"")+d}token=this.getToken(true,false)}}}if(valid){this.forgetState();var rule=new jscsspFontFaceRule();rule.currentLine=currentLine;rule.parsedCssText=s;rule.descriptors=descriptors;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule);return true}this.restoreState();return false},parsePageRule:function(aToken,aSheet){var currentLine=CountLF(this.mScanner.getAlreadyScanned());var s=aToken.value;var valid=false;var declarations=[];this.preserveState();var token=this.getToken(true,true);var pageSelector="";if(token.isSymbol(":")||token.isIdent()){if(token.isSymbol(":")){pageSelector=":";token=this.getToken(false,false)}if(token.isIdent()){pageSelector+=token.value;s+=" "+pageSelector;token=this.getToken(true,true)}}if(token.isNotNull()){if(token.isSymbol("{")){s+=" "+token.value;var token=this.getToken(true,false);while(true){if(token.isSymbol("}")){s+="}";valid=true;break}else{var d=this.parseDeclaration(token,declarations,true,true,aSheet);s+=((d&&declarations.length)?" ":"")+d}token=this.getToken(true,false)}}}if(valid){this.forgetState();var rule=new jscsspPageRule();rule.currentLine=currentLine;rule.parsedCssText=s;rule.pageSelector=pageSelector;rule.declarations=declarations;rule.parentStyleSheet=aSheet;aSheet.cssRules.push(rule);return true}this.restoreState();return false},parseDefaultPropertyValue:function(token,aDecl,aAcceptPriority,descriptor,aSheet){var valueText="";var blocks=[];var foundPriority=false;var values=[];while(token.isNotNull()){if((token.isSymbol(";")||token.isSymbol("}")||token.isSymbol("!"))&&!blocks.length){if(token.isSymbol("}")){this.ungetToken()}break}if(token.isIdent(this.kINHERIT)){if(values.length){return""}else{valueText=this.kINHERIT;var value=new jscsspVariable(kJscsspINHERIT_VALUE,aSheet);values.push(value);token=this.getToken(true,true);break}}else{if(token.isSymbol("{")||token.isSymbol("(")||token.isSymbol("[")){blocks.push(token.value)}else{if(token.isSymbol("}")||token.isSymbol("]")){if(blocks.length){var ontop=blocks[blocks.length-1];if((token.isSymbol("}")&&ontop=="{")||(token.isSymbol(")")&&ontop=="(")||(token.isSymbol("]")&&ontop=="[")){blocks.pop()}}}}}if(token.isFunction()){if(token.isFunction("var(")){token=this.getToken(true,true);if(token.isIdent()){var name=token.value;token=this.getToken(true,true);if(token.isSymbol(")")){var value=new jscsspVariable(kJscsspVARIABLE_VALUE,aSheet);valueText+="var("+name+")";value.name=name;values.push(value)}else{return""}}else{return""}}else{var fn=token.value;token=this.getToken(false,true);var arg=this.parseFunctionArgument(token);if(arg){valueText+=fn+arg;var value=new jscsspVariable(kJscsspPRIMITIVE_VALUE,aSheet);value.value=fn+arg;values.push(value)}else{return""}}}else{if(token.isSymbol("#")){var color=this.parseColor(token);if(color){valueText+=color;var value=new jscsspVariable(kJscsspPRIMITIVE_VALUE,aSheet);value.value=color;values.push(value)}else{return""}}else{if(!token.isWhiteSpace()&&!token.isSymbol(",")){var value=new jscsspVariable(kJscsspPRIMITIVE_VALUE,aSheet);value.value=token.value;values.push(value);valueText+=token.value}else{valueText+=token.value}}}token=this.getToken(false,true)}if(values.length&&valueText){this.forgetState();aDecl.push(this._createJscsspDeclarationFromValuesArray(descriptor,values,valueText));return valueText}return""},parseMarginOrPaddingShorthand:function(token,aDecl,aAcceptPriority,aProperty){var top=null;var bottom=null;var left=null;var right=null;var values=[];while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!values.length&&token.isIdent(this.kINHERIT)){values.push(token.value);token=this.getToken(true,true);break}else{if(token.isDimension()||token.isNumber("0")||token.isPercentage()||token.isIdent("auto")){values.push(token.value)}else{return""}}}token=this.getToken(true,true)}var count=values.length;switch(count){case 1:top=values[0];bottom=top;left=top;right=top;break;case 2:top=values[0];bottom=top;left=values[1];right=left;break;case 3:top=values[0];left=values[1];right=left;bottom=values[2];break;case 4:top=values[0];right=values[1];bottom=values[2];left=values[3];break;default:return""}this.forgetState();aDecl.push(this._createJscsspDeclarationFromValue(aProperty+"-top",top));aDecl.push(this._createJscsspDeclarationFromValue(aProperty+"-right",right));aDecl.push(this._createJscsspDeclarationFromValue(aProperty+"-bottom",bottom));aDecl.push(this._createJscsspDeclarationFromValue(aProperty+"-left",left));return top+" "+right+" "+bottom+" "+left},parseBorderColorShorthand:function(token,aDecl,aAcceptPriority){var top=null;var bottom=null;var left=null;var right=null;var values=[];while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!values.length&&token.isIdent(this.kINHERIT)){values.push(token.value);token=this.getToken(true,true);break}else{var color=this.parseColor(token);if(color){values.push(color)}else{return""}}}token=this.getToken(true,true)}var count=values.length;switch(count){case 1:top=values[0];bottom=top;left=top;right=top;break;case 2:top=values[0];bottom=top;left=values[1];right=left;break;case 3:top=values[0];left=values[1];right=left;bottom=values[2];break;case 4:top=values[0];right=values[1];bottom=values[2];left=values[3];break;default:return""}this.forgetState();aDecl.push(this._createJscsspDeclarationFromValue("border-top-color",top));aDecl.push(this._createJscsspDeclarationFromValue("border-right-color",right));aDecl.push(this._createJscsspDeclarationFromValue("border-bottom-color",bottom));aDecl.push(this._createJscsspDeclarationFromValue("border-left-color",left));return top+" "+right+" "+bottom+" "+left},parseCueShorthand:function(token,declarations,aAcceptPriority){var before="";var after="";var values=[];var values=[];while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!values.length&&token.isIdent(this.kINHERIT)){values.push(token.value)}else{if(token.isIdent("none")){values.push(token.value)}else{if(token.isFunction("url(")){var token=this.getToken(true,true);var urlContent=this.parseURL(token);if(urlContent){values.push("url("+urlContent)}else{return""}}else{return""}}}}token=this.getToken(true,true)}var count=values.length;switch(count){case 1:before=values[0];after=before;break;case 2:before=values[0];after=values[1];break;default:return""}this.forgetState();aDecl.push(this._createJscsspDeclarationFromValue("cue-before",before));aDecl.push(this._createJscsspDeclarationFromValue("cue-after",after));return before+" "+after},parsePauseShorthand:function(token,declarations,aAcceptPriority){var before="";var after="";var values=[];var values=[];while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!values.length&&token.isIdent(this.kINHERIT)){values.push(token.value)}else{if(token.isDimensionOfUnit("ms")||token.isDimensionOfUnit("s")||token.isPercentage()||token.isNumber("0")){values.push(token.value)}else{return""}}}token=this.getToken(true,true)}var count=values.length;switch(count){case 1:before=values[0];after=before;break;case 2:before=values[0];after=values[1];break;default:return""}this.forgetState();aDecl.push(this._createJscsspDeclarationFromValue("pause-before",before));aDecl.push(this._createJscsspDeclarationFromValue("pause-after",after));return before+" "+after},parseBorderWidthShorthand:function(token,aDecl,aAcceptPriority){var top=null;var bottom=null;var left=null;var right=null;var values=[];while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!values.length&&token.isIdent(this.kINHERIT)){values.push(token.value)}else{if(token.isDimension()||token.isNumber("0")||(token.isIdent()&&token.value in this.kBORDER_WIDTH_NAMES)){values.push(token.value)}else{return""}}}token=this.getToken(true,true)}var count=values.length;switch(count){case 1:top=values[0];bottom=top;left=top;right=top;break;case 2:top=values[0];bottom=top;left=values[1];right=left;break;case 3:top=values[0];left=values[1];right=left;bottom=values[2];break;case 4:top=values[0];right=values[1];bottom=values[2];left=values[3];break;default:return""}this.forgetState();aDecl.push(this._createJscsspDeclarationFromValue("border-top-width",top));aDecl.push(this._createJscsspDeclarationFromValue("border-right-width",right));aDecl.push(this._createJscsspDeclarationFromValue("border-bottom-width",bottom));aDecl.push(this._createJscsspDeclarationFromValue("border-left-width",left));return top+" "+right+" "+bottom+" "+left},parseBorderStyleShorthand:function(token,aDecl,aAcceptPriority){var top=null;var bottom=null;var left=null;var right=null;var values=[];while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!values.length&&token.isIdent(this.kINHERIT)){values.push(token.value)}else{if(token.isIdent()&&token.value in this.kBORDER_STYLE_NAMES){values.push(token.value)}else{return""}}}token=this.getToken(true,true)}var count=values.length;switch(count){case 1:top=values[0];bottom=top;left=top;right=top;break;case 2:top=values[0];bottom=top;left=values[1];right=left;break;case 3:top=values[0];left=values[1];right=left;bottom=values[2];break;case 4:top=values[0];right=values[1];bottom=values[2];left=values[3];break;default:return""}this.forgetState();aDecl.push(this._createJscsspDeclarationFromValue("border-top-style",top));aDecl.push(this._createJscsspDeclarationFromValue("border-right-style",right));aDecl.push(this._createJscsspDeclarationFromValue("border-bottom-style",bottom));aDecl.push(this._createJscsspDeclarationFromValue("border-left-style",left));return top+" "+right+" "+bottom+" "+left},parseBorderEdgeOrOutlineShorthand:function(token,aDecl,aAcceptPriority,aProperty){var bWidth=null;var bStyle=null;var bColor=null;while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!bWidth&&!bStyle&&!bColor&&token.isIdent(this.kINHERIT)){bWidth=this.kINHERIT;bStyle=this.kINHERIT;bColor=this.kINHERIT}else{if(!bWidth&&(token.isDimension()||(token.isIdent()&&token.value in this.kBORDER_WIDTH_NAMES)||token.isNumber("0"))){bWidth=token.value}else{if(!bStyle&&(token.isIdent()&&token.value in this.kBORDER_STYLE_NAMES)){bStyle=token.value}else{var color=(aProperty=="outline"&&token.isIdent("invert"))?"invert":this.parseColor(token);if(!bColor&&color){bColor=color}else{return""}}}}}token=this.getToken(true,true)}this.forgetState();bWidth=bWidth?bWidth:"medium";bStyle=bStyle?bStyle:"none";bColor=bColor?bColor:"-moz-initial";function addPropertyToDecl(aSelf,aDecl,property,w,s,c){aDecl.push(aSelf._createJscsspDeclarationFromValue(property+"-width",w));aDecl.push(aSelf._createJscsspDeclarationFromValue(property+"-style",s));aDecl.push(aSelf._createJscsspDeclarationFromValue(property+"-color",c))}if(aProperty=="border"){addPropertyToDecl(this,aDecl,"border-top",bWidth,bStyle,bColor);addPropertyToDecl(this,aDecl,"border-right",bWidth,bStyle,bColor);addPropertyToDecl(this,aDecl,"border-bottom",bWidth,bStyle,bColor);addPropertyToDecl(this,aDecl,"border-left",bWidth,bStyle,bColor)}else{addPropertyToDecl(this,aDecl,aProperty,bWidth,bStyle,bColor)}return bWidth+" "+bStyle+" "+bColor},parseBackgroundShorthand:function(token,aDecl,aAcceptPriority){var kHPos={left:true,right:true};var kVPos={top:true,bottom:true};var kPos={left:true,right:true,top:true,bottom:true,center:true};var bgColor=null;var bgRepeat=null;var bgAttachment=null;var bgImage=null;var bgPosition=null;while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!bgColor&&!bgRepeat&&!bgAttachment&&!bgImage&&!bgPosition&&token.isIdent(this.kINHERIT)){bgColor=this.kINHERIT;bgRepeat=this.kINHERIT;bgAttachment=this.kINHERIT;bgImage=this.kINHERIT;bgPosition=this.kINHERIT}else{if(!bgAttachment&&(token.isIdent("scroll")||token.isIdent("fixed"))){bgAttachment=token.value}else{if(!bgPosition&&((token.isIdent()&&token.value in kPos)||token.isDimension()||token.isNumber("0")||token.isPercentage())){bgPosition=token.value;token=this.getToken(true,true);if(token.isDimension()||token.isNumber("0")||token.isPercentage()){bgPosition+=" "+token.value}else{if(token.isIdent()&&token.value in kPos){if((bgPosition in kHPos&&token.value in kHPos)||(bgPosition in kVPos&&token.value in kVPos)){return""}bgPosition+=" "+token.value}else{this.ungetToken();bgPosition+=" center"}}}else{if(!bgRepeat&&(token.isIdent("repeat")||token.isIdent("repeat-x")||token.isIdent("repeat-y")||token.isIdent("no-repeat"))){bgRepeat=token.value}else{if(!bgImage&&(token.isFunction("url(")||token.isIdent("none"))){bgImage=token.value;if(token.isFunction("url(")){token=this.getToken(true,true);var url=this.parseURL(token);if(url){bgImage+=url}else{return""}}}else{if(!bgImage&&(token.isFunction("-moz-linear-gradient(")||token.isFunction("-moz-radial-gradient(")||token.isFunction("-moz-repeating-linear-gradient(")||token.isFunction("-moz-repeating-radial-gradient("))){var gradient=CssInspector.parseGradient(this,token);if(gradient){bgImage=CssInspector.serializeGradient(gradient)}else{return""}}else{var color=this.parseColor(token);if(!bgColor&&color){bgColor=color}else{return""}}}}}}}}token=this.getToken(true,true)}this.forgetState();bgColor=bgColor?bgColor:"transparent";bgImage=bgImage?bgImage:"none";bgRepeat=bgRepeat?bgRepeat:"repeat";bgAttachment=bgAttachment?bgAttachment:"scroll";bgPosition=bgPosition?bgPosition:"top left";aDecl.push(this._createJscsspDeclarationFromValue("background-color",bgColor));aDecl.push(this._createJscsspDeclarationFromValue("background-image",bgImage));aDecl.push(this._createJscsspDeclarationFromValue("background-repeat",bgRepeat));aDecl.push(this._createJscsspDeclarationFromValue("background-attachment",bgAttachment));aDecl.push(this._createJscsspDeclarationFromValue("background-position",bgPosition));return bgColor+" "+bgImage+" "+bgRepeat+" "+bgAttachment+" "+bgPosition},parseListStyleShorthand:function(token,aDecl,aAcceptPriority){var kPosition={inside:true,outside:true};var lType=null;var lPosition=null;var lImage=null;while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!lType&&!lPosition&&!lImage&&token.isIdent(this.kINHERIT)){lType=this.kINHERIT;lPosition=this.kINHERIT;lImage=this.kINHERIT}else{if(!lType&&(token.isIdent()&&token.value in this.kLIST_STYLE_TYPE_NAMES)){lType=token.value}else{if(!lPosition&&(token.isIdent()&&token.value in kPosition)){lPosition=token.value}else{if(!lImage&&token.isFunction("url")){token=this.getToken(true,true);var urlContent=this.parseURL(token);if(urlContent){lImage="url("+urlContent}else{return""}}else{if(!token.isIdent("none")){return""}}}}}}token=this.getToken(true,true)}this.forgetState();lType=lType?lType:"none";lImage=lImage?lImage:"none";lPosition=lPosition?lPosition:"outside";aDecl.push(this._createJscsspDeclarationFromValue("list-style-type",lType));aDecl.push(this._createJscsspDeclarationFromValue("list-style-position",lPosition));aDecl.push(this._createJscsspDeclarationFromValue("list-style-image",lImage));return lType+" "+lPosition+" "+lImage},parseFontShorthand:function(token,aDecl,aAcceptPriority){var kStyle={italic:true,oblique:true};var kVariant={"small-caps":true};var kWeight={bold:true,bolder:true,lighter:true,"100":true,"200":true,"300":true,"400":true,"500":true,"600":true,"700":true,"800":true,"900":true};var kSize={"xx-small":true,"x-small":true,small:true,medium:true,large:true,"x-large":true,"xx-large":true,larger:true,smaller:true};var kValues={caption:true,icon:true,menu:true,"message-box":true,"small-caption":true,"status-bar":true};var kFamily={serif:true,"sans-serif":true,cursive:true,fantasy:true,monospace:true};var fStyle=null;var fVariant=null;var fWeight=null;var fSize=null;var fLineHeight=null;var fFamily="";var fSystem=null;var fFamilyValues=[];var normalCount=0;while(true){if(!token.isNotNull()){break}if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}break}else{if(!fStyle&&!fVariant&&!fWeight&&!fSize&&!fLineHeight&&!fFamily&&!fSystem&&token.isIdent(this.kINHERIT)){fStyle=this.kINHERIT;fVariant=this.kINHERIT;fWeight=this.kINHERIT;fSize=this.kINHERIT;fLineHeight=this.kINHERIT;fFamily=this.kINHERIT;fSystem=this.kINHERIT}else{if(!fSystem&&(token.isIdent()&&token.value in kValues)){fSystem=token.value;break}else{if(!fStyle&&token.isIdent()&&(token.value in kStyle)){fStyle=token.value}else{if(!fVariant&&token.isIdent()&&(token.value in kVariant)){fVariant=token.value}else{if(!fWeight&&(token.isIdent()||token.isNumber())&&(token.value in kWeight)){fWeight=token.value}else{if(!fSize&&((token.isIdent()&&(token.value in kSize))||token.isDimension()||token.isPercentage())){fSize=token.value;var token=this.getToken(false,false);if(token.isSymbol("/")){token=this.getToken(false,false);if(!fLineHeight&&(token.isDimension()||token.isNumber()||token.isPercentage())){fLineHeight=token.value}else{return""}}else{this.ungetToken()}}else{if(token.isIdent("normal")){normalCount++;if(normalCount>3){return""}}else{if(!fFamily&&(token.isString()||token.isIdent())){var lastWasComma=false;while(true){if(!token.isNotNull()){break}else{if(token.isSymbol(";")||(aAcceptPriority&&token.isSymbol("!"))||token.isSymbol("}")){this.ungetToken();break}else{if(token.isIdent()&&token.value in kFamily){var value=new jscsspVariable(kJscsspPRIMITIVE_VALUE,null);value.value=token.value;fFamilyValues.push(value);fFamily+=token.value;break}else{if(token.isString()||token.isIdent()){var value=new jscsspVariable(kJscsspPRIMITIVE_VALUE,null);value.value=token.value;fFamilyValues.push(value);fFamily+=token.value;lastWasComma=false}else{if(!lastWasComma&&token.isSymbol(",")){fFamily+=", ";lastWasComma=true}else{return""}}}}}token=this.getToken(true,true)}}else{return""}}}}}}}}}token=this.getToken(true,true)}this.forgetState();if(fSystem){aDecl.push(this._createJscsspDeclarationFromValue("font",fSystem));return fSystem}fStyle=fStyle?fStyle:"normal";fVariant=fVariant?fVariant:"normal";fWeight=fWeight?fWeight:"normal";fSize=fSize?fSize:"medium";fLineHeight=fLineHeight?fLineHeight:"normal";fFamily=fFamily?fFamily:"-moz-initial";aDecl.push(this._createJscsspDeclarationFromValue("font-style",fStyle));aDecl.push(this._createJscsspDeclarationFromValue("font-variant",fVariant));aDecl.push(this._createJscsspDeclarationFromValue("font-weight",fWeight));aDecl.push(this._createJscsspDeclarationFromValue("font-size",fSize));aDecl.push(this._createJscsspDeclarationFromValue("line-height",fLineHeight));aDecl.push(this._createJscsspDeclarationFromValuesArray("font-family",fFamilyValues,fFamily));return fStyle+" "+fVariant+" "+fWeight+" "+fSize+"/"+fLineHeight+" "+fFamily},_createJscsspDeclaration:function(property,value){var decl=new jscsspDeclaration();decl.property=property;decl.value=this.trim11(value);decl.parsedCssText=property+": "+value+";";return decl},_createJscsspDeclarationFromValue:function(property,valueText){var decl=new jscsspDeclaration();decl.property=property;var value=new jscsspVariable(kJscsspPRIMITIVE_VALUE,null);value.value=valueText;decl.values=[value];decl.valueText=valueText;decl.parsedCssText=property+": "+valueText+";";return decl},_createJscsspDeclarationFromValuesArray:function(property,values,valueText){var decl=new jscsspDeclaration();decl.property=property;decl.values=values;decl.valueText=valueText;decl.parsedCssText=property+": "+valueText+";";return decl},parseURL:function(token){var value="";if(token.isString()){value+=token.value;token=this.getToken(true,true)}else{while(true){if(!token.isNotNull()){this.reportError(kURL_EOF);return""}if(token.isWhiteSpace()){nextToken=this.lookAhead(true,true);if(!nextToken.isSymbol(")")){this.reportError(kURL_WS_INSIDE);token=this.currentToken();break}}if(token.isSymbol(")")){break}value+=token.value;token=this.getToken(false,false)}}if(token.isSymbol(")")){return value+")"}return""},parseFunctionArgument:function(token){var value="";if(token.isString()){value+=token.value;token=this.getToken(true,true)}else{var parenthesis=1;while(true){if(!token.isNotNull()){return""}if(token.isFunction()||token.isSymbol("(")){parenthesis++}if(token.isSymbol(")")){parenthesis--;if(!parenthesis){break}}value+=token.value;token=this.getToken(false,false)}}if(token.isSymbol(")")){return value+")"}return""},parseColor:function(token){var color="";if(token.isFunction("rgb(")||token.isFunction("rgba(")){color=token.value;var isRgba=token.isFunction("rgba(");token=this.getToken(true,true);if(!token.isNumber()&&!token.isPercentage()){return""}color+=token.value;token=this.getToken(true,true);if(!token.isSymbol(",")){return""}color+=", ";token=this.getToken(true,true);if(!token.isNumber()&&!token.isPercentage()){return""}color+=token.value;token=this.getToken(true,true);if(!token.isSymbol(",")){return""}color+=", ";token=this.getToken(true,true);if(!token.isNumber()&&!token.isPercentage()){return""}color+=token.value;if(isRgba){token=this.getToken(true,true);if(!token.isSymbol(",")){return""}color+=", ";token=this.getToken(true,true);if(!token.isNumber()){return""}color+=token.value}token=this.getToken(true,true);if(!token.isSymbol(")")){return""}color+=token.value}else{if(token.isFunction("hsl(")||token.isFunction("hsla(")){color=token.value;var isHsla=token.isFunction("hsla(");token=this.getToken(true,true);if(!token.isNumber()){return""}color+=token.value;token=this.getToken(true,true);if(!token.isSymbol(",")){return""}color+=", ";token=this.getToken(true,true);if(!token.isPercentage()){return""}color+=token.value;token=this.getToken(true,true);if(!token.isSymbol(",")){return""}color+=", ";token=this.getToken(true,true);if(!token.isPercentage()){return""}color+=token.value;if(isHsla){token=this.getToken(true,true);if(!token.isSymbol(",")){return""}color+=", ";token=this.getToken(true,true);if(!token.isNumber()){return""}color+=token.value}token=this.getToken(true,true);if(!token.isSymbol(")")){return""}color+=token.value}else{if(token.isIdent()&&(token.value in this.kCOLOR_NAMES)){color=token.value}else{if(token.isSymbol("#")){token=this.getHexValue();if(!token.isHex()){return""}var length=token.value.length;if(length!=3&&length!=6){return""}if(token.value.match(/[a-fA-F0-9]/g).length!=length){return""}color="#"+token.value}}}}return color},parseDeclaration:function(aToken,aDecl,aAcceptPriority,aExpandShorthands,aSheet){this.preserveState();var blocks=[];if(aToken.isIdent()){var descriptor=aToken.value.toLowerCase();var token=this.getToken(true,true);if(token.isSymbol(":")){var token=this.getToken(true,true);var value="";var declarations=[];if(aExpandShorthands){switch(descriptor){case"background":value=this.parseBackgroundShorthand(token,declarations,aAcceptPriority);break;case"margin":case"padding":value=this.parseMarginOrPaddingShorthand(token,declarations,aAcceptPriority,descriptor);break;case"border-color":value=this.parseBorderColorShorthand(token,declarations,aAcceptPriority);break;case"border-style":value=this.parseBorderStyleShorthand(token,declarations,aAcceptPriority);break;case"border-width":value=this.parseBorderWidthShorthand(token,declarations,aAcceptPriority);break;case"border-top":case"border-right":case"border-bottom":case"border-left":case"border":case"outline":value=this.parseBorderEdgeOrOutlineShorthand(token,declarations,aAcceptPriority,descriptor);break;case"cue":value=this.parseCueShorthand(token,declarations,aAcceptPriority);break;case"pause":value=this.parsePauseShorthand(token,declarations,aAcceptPriority);break;case"font":value=this.parseFontShorthand(token,declarations,aAcceptPriority);break;case"list-style":value=this.parseListStyleShorthand(token,declarations,aAcceptPriority);break;default:value=this.parseDefaultPropertyValue(token,declarations,aAcceptPriority,descriptor,aSheet);break}}else{value=this.parseDefaultPropertyValue(token,declarations,aAcceptPriority,descriptor,aSheet)}token=this.currentToken();if(value){var priority=false;if(token.isSymbol("!")){token=this.getToken(true,true);if(token.isIdent("important")){priority=true;token=this.getToken(true,true);if(token.isSymbol(";")||token.isSymbol("}")){if(token.isSymbol("}")){this.ungetToken()}}else{return""}}else{return""}}else{if(token.isNotNull()&&!token.isSymbol(";")&&!token.isSymbol("}")){return""}}for(var i=0;i<declarations.length;i++){declarations[i].priority=priority;aDecl.push(declarations[i])}return descriptor+": "+value+";"}}}else{if(aToken.isComment()){if(this.mPreserveComments){this.forgetState();var comment=new jscsspComment();comment.parsedCssText=aToken.value;aDecl.push(comment)}return aToken.value}}this.restoreState();var s=aToken.value;blocks=[];var token=this.getToken(false,false);while(token.isNotNull()){s+=token.value;if((token.isSymbol(";")||token.isSymbol("}"))&&!blocks.length){if(token.isSymbol("}")){this.ungetToken()}break}else{if(token.isSymbol("{")||token.isSymbol("(")||token.isSymbol("[")||token.isFunction()){blocks.push(token.isFunction()?"(":token.value)}else{if(token.isSymbol("}")||token.isSymbol(")")||token.isSymbol("]")){if(blocks.length){var ontop=blocks[blocks.length-1];if((token.isSymbol("}")&&ontop=="{")||(token.isSymbol(")")&&ontop=="(")||(token.isSymbol("]")&&ontop=="[")){blocks.pop()}}}}}token=this.getToken(false,false)}return""},parseKeyframesRule:function(aToken,aSheet){var currentLine=CountLF(this.mScanner.getAlreadyScanned());var s=aToken.value;var valid=false;var keyframesRule=new jscsspKeyframesRule();keyframesRule.currentLine=currentLine;this.preserveState();var token=this.getToken(true,true);var foundName=false;while(token.isNotNull()){if(token.isIdent()){foundName=true;s+=" "+token.value;keyframesRule.name=token.value;token=this.getToken(true,true);if(token.isSymbol("{")){this.ungetToken()}else{token.type=jscsspToken.NULL_TYPE;break}}else{if(token.isSymbol("{")){if(!foundName){token.type=jscsspToken.NULL_TYPE}break}else{token.type=jscsspToken.NULL_TYPE;break}}token=this.getToken(true,true)}if(token.isSymbol("{")&&keyframesRule.name){s+=" { ";token=this.getToken(true,false);while(token.isNotNull()){if(token.isComment()&&this.mPreserveComments){s+=" "+token.value;var comment=new jscsspComment();comment.parsedCssText=token.value;keyframesRule.cssRules.push(comment)}else{if(token.isSymbol("}")){valid=true;break}else{var r=this.parseKeyframeRule(token,keyframesRule,true);if(r){s+=r}}}token=this.getToken(true,false)}}if(valid){this.forgetState();keyframesRule.currentLine=currentLine;keyframesRule.parsedCssText=s;aSheet.cssRules.push(keyframesRule);return true}this.restoreState();return false},parseKeyframeRule:function(aToken,aOwner){var currentLine=CountLF(this.mScanner.getAlreadyScanned());this.preserveState();var token=aToken;var key="";while(token.isNotNull()){if(token.isIdent()||token.isPercentage()){if(token.isIdent()&&!token.isIdent("from")&&!token.isIdent("to")){key="";break}key+=token.value;token=this.getToken(true,true);if(token.isSymbol("{")){this.ungetToken();break}else{if(token.isSymbol(",")){key+=", "}else{key="";break}}}else{key="";break}token=this.getToken(true,true)}var valid=false;var declarations=[];if(key){var s=key;token=this.getToken(true,true);if(token.isSymbol("{")){s+=" { ";token=this.getToken(true,false);while(true){if(!token.isNotNull()){valid=true;break}if(token.isSymbol("}")){s+="}";valid=true;break}else{var d=this.parseDeclaration(token,declarations,true,true,aOwner);s+=((d&&declarations.length)?" ":"")+d}token=this.getToken(true,false)}}}else{}if(valid){var rule=new jscsspKeyframeRule();rule.currentLine=currentLine;rule.parsedCssText=s;rule.declarations=declarations;rule.keyText=key;rule.parentRule=aOwner;aOwner.cssRules.push(rule);return s}this.restoreState();s=this.currentToken().value;this.addUnknownAtRule(aOwner,s);return""},parseMediaRule:function(aToken,aSheet){var currentLine=CountLF(this.mScanner.getAlreadyScanned());var s=aToken.value;var valid=false;var mediaRule=new jscsspMediaRule();mediaRule.currentLine=currentLine;this.preserveState();var token=this.getToken(true,true);var foundMedia=false;while(token.isNotNull()){if(token.isIdent()){foundMedia=true;s+=" "+token.value;mediaRule.media.push(token.value);token=this.getToken(true,true);if(token.isSymbol(",")){s+=","}else{if(token.isSymbol("{")){this.ungetToken()}else{token.type=jscsspToken.NULL_TYPE;break}}}else{if(token.isSymbol("{")){break}else{if(foundMedia){token.type=jscsspToken.NULL_TYPE;break}}}token=this.getToken(true,true)}if(token.isSymbol("{")&&mediaRule.media.length){s+=" { ";token=this.getToken(true,false);while(token.isNotNull()){if(token.isComment()&&this.mPreserveComments){s+=" "+token.value;var comment=new jscsspComment();comment.parsedCssText=token.value;mediaRule.cssRules.push(comment)}else{if(token.isSymbol("}")){valid=true;break}else{var r=this.parseStyleRule(token,mediaRule,true);if(r){s+=r}}}token=this.getToken(true,false)}}if(valid){this.forgetState();mediaRule.parsedCssText=s;aSheet.cssRules.push(mediaRule);return true}this.restoreState();return false},trim11:function(str){str=str.replace(/^\s+/,"");for(var i=str.length-1;i>=0;i--){if(/\S/.test(str.charAt(i))){str=str.substring(0,i+1);break}}return str},parseStyleRule:function(aToken,aOwner,aIsInsideMediaRule){var currentLine=CountLF(this.mScanner.getAlreadyScanned());this.preserveState();var selector=this.parseSelector(aToken,false);var valid=false;var declarations=[];if(selector){selector=this.trim11(selector.selector);var s=selector;var token=this.getToken(true,true);if(token.isSymbol("{")){s+=" { ";var token=this.getToken(true,false);while(true){if(!token.isNotNull()){valid=true;break}if(token.isSymbol("}")){s+="}";valid=true;break}else{var d=this.parseDeclaration(token,declarations,true,true,aOwner);s+=((d&&declarations.length)?" ":"")+d}token=this.getToken(true,false)}}}else{}if(valid){var rule=new jscsspStyleRule();rule.currentLine=currentLine;rule.parsedCssText=s;rule.declarations=declarations;rule.mSelectorText=selector;if(aIsInsideMediaRule){rule.parentRule=aOwner}else{rule.parentStyleSheet=aOwner}aOwner.cssRules.push(rule);return s}this.restoreState();s=this.currentToken().value;this.addUnknownAtRule(aOwner,s);return""},parseSelector:function(aToken,aParseSelectorOnly){var s="";var specificity={a:0,b:0,c:0,d:0};var isFirstInChain=true;var token=aToken;var valid=false;var combinatorFound=false;while(true){if(!token.isNotNull()){if(aParseSelectorOnly){return{selector:s,specificity:specificity}}return""}if(!aParseSelectorOnly&&token.isSymbol("{")){valid=!combinatorFound;if(valid){this.ungetToken()}break}if(token.isSymbol(",")){s+=token.value;isFirstInChain=true;combinatorFound=false;token=this.getToken(false,true);continue}else{if(!combinatorFound&&(token.isWhiteSpace()||token.isSymbol(">")||token.isSymbol("+")||token.isSymbol("~"))){if(token.isWhiteSpace()){s+=" ";var nextToken=this.lookAhead(true,true);if(!nextToken.isNotNull()){if(aParseSelectorOnly){return{selector:s,specificity:specificity}}return""}if(nextToken.isSymbol(">")||nextToken.isSymbol("+")||nextToken.isSymbol("~")){token=this.getToken(true,true);s+=token.value+" ";combinatorFound=true}}else{s+=token.value;combinatorFound=true}isFirstInChain=true;token=this.getToken(true,true);continue}else{var simpleSelector=this.parseSimpleSelector(token,isFirstInChain,true);if(!simpleSelector){break}s+=simpleSelector.selector;specificity.b+=simpleSelector.specificity.b;specificity.c+=simpleSelector.specificity.c;specificity.d+=simpleSelector.specificity.d;isFirstInChain=false;combinatorFound=false}}token=this.getToken(false,true)}if(valid){return{selector:s,specificity:specificity}}return""},isPseudoElement:function(aIdent){switch(aIdent){case"first-letter":case"first-line":case"before":case"after":case"marker":return true;break;default:return false;break}},parseSimpleSelector:function(token,isFirstInChain,canNegate){var s="";var specificity={a:0,b:0,c:0,d:0};if(isFirstInChain&&(token.isSymbol("*")||token.isSymbol("|")||token.isIdent())){if(token.isSymbol("*")||token.isIdent()){s+=token.value;var isIdent=token.isIdent();token=this.getToken(false,true);if(token.isSymbol("|")){s+=token.value;token=this.getToken(false,true);if(token.isIdent()||token.isSymbol("*")){s+=token.value;if(token.isIdent()){specificity.d++}}else{return null}}else{this.ungetToken();if(isIdent){specificity.d++}}}else{if(token.isSymbol("|")){s+=token.value;token=this.getToken(false,true);if(token.isIdent()||token.isSymbol("*")){s+=token.value;if(token.isIdent()){specificity.d++}}else{return null}}}}else{if(token.isSymbol(".")||token.isSymbol("#")){var isClass=token.isSymbol(".");s+=token.value;token=this.getToken(false,true);if(token.isIdent()){s+=token.value;if(isClass){specificity.c++}else{specificity.b++}}else{return null}}else{if(token.isSymbol(":")){s+=token.value;token=this.getToken(false,true);if(token.isSymbol(":")){s+=token.value;token=this.getToken(false,true)}if(token.isIdent()){s+=token.value;if(this.isPseudoElement(token.value)){specificity.d++}else{specificity.c++}}else{if(token.isFunction()){s+=token.value;if(token.isFunction(":not(")){if(!canNegate){return null}token=this.getToken(true,true);var simpleSelector=this.parseSimpleSelector(token,isFirstInChain,false);if(!simpleSelector){return null}else{s+=simpleSelector.selector;token=this.getToken(true,true);if(token.isSymbol(")")){s+=")"}else{return null}}specificity.c++}else{while(true){token=this.getToken(false,true);if(token.isSymbol(")")){s+=")";break}else{s+=token.value}}specificity.c++}}else{return null}}}else{if(token.isSymbol("[")){s+="[";token=this.getToken(true,true);if(token.isIdent()||token.isSymbol("*")){s+=token.value;var nextToken=this.getToken(true,true);if(token.isSymbol("|")){s+="|";token=this.getToken(true,true);if(token.isIdent()){s+=token.value}else{return null}}else{this.ungetToken()}}else{if(token.isSymbol("|")){s+="|";token=this.getToken(true,true);if(token.isIdent()){s+=token.value}else{return null}}else{return null}}token=this.getToken(true,true);if(token.isIncludes()||token.isDashmatch()||token.isBeginsmatch()||token.isEndsmatch()||token.isContainsmatch()||token.isSymbol("=")){s+=token.value;token=this.getToken(true,true);if(token.isString()||token.isIdent()){s+=token.value;token=this.getToken(true,true)}else{return null}if(token.isSymbol("]")){s+=token.value;specificity.c++}else{return null}}else{if(token.isSymbol("]")){s+=token.value;specificity.c++}else{return null}}}else{if(token.isWhiteSpace()){var t=this.lookAhead(true,true);if(t.isSymbol("{")){return""}}}}}}if(s){return{selector:s,specificity:specificity}}return null},preserveState:function(){this.mPreservedTokens.push(this.currentToken());this.mScanner.preserveState()},restoreState:function(){if(this.mPreservedTokens.length){this.mScanner.restoreState();this.mToken=this.mPreservedTokens.pop()}},forgetState:function(){if(this.mPreservedTokens.length){this.mScanner.forgetState();this.mPreservedTokens.pop()}},parse:function(aString,aTryToPreserveWhitespaces,aTryToPreserveComments){if(!aString){return null}this.mPreserveWS=aTryToPreserveWhitespaces;this.mPreserveComments=aTryToPreserveComments;this.mPreservedTokens=[];this.mScanner.init(aString);var sheet=new jscsspStylesheet();var token=this.getToken(false,false);if(!token.isNotNull()){return}if(token.isAtRule("@charset")){this.parseCharsetRule(token,sheet);token=this.getToken(false,false)}var foundStyleRules=false;var foundImportRules=false;var foundNameSpaceRules=false;while(true){if(!token.isNotNull()){break}if(token.isWhiteSpace()){if(aTryToPreserveWhitespaces){this.addWhitespace(sheet,token.value)}}else{if(token.isComment()){if(this.mPreserveComments){this.addComment(sheet,token.value)}}else{if(token.isAtRule()){if(token.isAtRule("@variables")){if(!foundImportRules&&!foundStyleRules){this.parseVariablesRule(token,sheet)}else{this.reportError(kVARIABLES_RULE_POSITION);this.addUnknownAtRule(sheet,token.value)}}else{if(token.isAtRule("@import")){if(!foundStyleRules&&!foundNameSpaceRules){foundImportRules=this.parseImportRule(token,sheet)}else{this.reportError(kIMPORT_RULE_POSITION);this.addUnknownAtRule(sheet,token.value)}}else{if(token.isAtRule("@namespace")){if(!foundStyleRules){foundNameSpaceRules=this.parseNamespaceRule(token,sheet)}else{this.reportError(kNAMESPACE_RULE_POSITION);this.addUnknownAtRule(sheet,token.value)}}else{if(token.isAtRule("@font-face")){if(this.parseFontFaceRule(token,sheet)){foundStyleRules=true}else{this.addUnknownAtRule(sheet,token.value)}}else{if(token.isAtRule("@page")){if(this.parsePageRule(token,sheet)){foundStyleRules=true}else{this.addUnknownAtRule(sheet,token.value)}}else{if(token.isAtRule("@media")){if(this.parseMediaRule(token,sheet)){foundStyleRules=true}else{this.addUnknownAtRule(sheet,token.value)}}else{if(token.isAtRule("@keyframes")){if(!this.parseKeyframesRule(token,sheet)){this.addUnknownAtRule(sheet,token.value)}}else{if(token.isAtRule("@charset")){this.reportError(kCHARSET_RULE_CHARSET_SOF);this.addUnknownAtRule(sheet,token.value)}else{this.reportError(kUNKNOWN_AT_RULE);this.addUnknownAtRule(sheet,token.value)}}}}}}}}}else{var ruleText=this.parseStyleRule(token,sheet,false);if(ruleText){foundStyleRules=true}}}}token=this.getToken(false)}return sheet}};function jscsspToken(aType,aValue,aUnit){this.type=aType;this.value=aValue;this.unit=aUnit}jscsspToken.NULL_TYPE=0;jscsspToken.WHITESPACE_TYPE=1;jscsspToken.STRING_TYPE=2;jscsspToken.COMMENT_TYPE=3;jscsspToken.NUMBER_TYPE=4;jscsspToken.IDENT_TYPE=5;jscsspToken.FUNCTION_TYPE=6;jscsspToken.ATRULE_TYPE=7;jscsspToken.INCLUDES_TYPE=8;jscsspToken.DASHMATCH_TYPE=9;jscsspToken.BEGINSMATCH_TYPE=10;jscsspToken.ENDSMATCH_TYPE=11;jscsspToken.CONTAINSMATCH_TYPE=12;jscsspToken.SYMBOL_TYPE=13;jscsspToken.DIMENSION_TYPE=14;jscsspToken.PERCENTAGE_TYPE=15;jscsspToken.HEX_TYPE=16;jscsspToken.prototype={isNotNull:function(){return this.type},_isOfType:function(aType,aValue){return(this.type==aType&&(!aValue||this.value.toLowerCase()==aValue))},isWhiteSpace:function(w){return this._isOfType(jscsspToken.WHITESPACE_TYPE,w)},isString:function(){return this._isOfType(jscsspToken.STRING_TYPE)},isComment:function(){return this._isOfType(jscsspToken.COMMENT_TYPE)},isNumber:function(n){return this._isOfType(jscsspToken.NUMBER_TYPE,n)},isSymbol:function(c){return this._isOfType(jscsspToken.SYMBOL_TYPE,c)},isIdent:function(i){return this._isOfType(jscsspToken.IDENT_TYPE,i)},isFunction:function(f){return this._isOfType(jscsspToken.FUNCTION_TYPE,f)},isAtRule:function(a){return this._isOfType(jscsspToken.ATRULE_TYPE,a)},isIncludes:function(){return this._isOfType(jscsspToken.INCLUDES_TYPE)},isDashmatch:function(){return this._isOfType(jscsspToken.DASHMATCH_TYPE)},isBeginsmatch:function(){return this._isOfType(jscsspToken.BEGINSMATCH_TYPE)},isEndsmatch:function(){return this._isOfType(jscsspToken.ENDSMATCH_TYPE)},isContainsmatch:function(){return this._isOfType(jscsspToken.CONTAINSMATCH_TYPE)},isSymbol:function(c){return this._isOfType(jscsspToken.SYMBOL_TYPE,c)},isDimension:function(){return this._isOfType(jscsspToken.DIMENSION_TYPE)},isPercentage:function(){return this._isOfType(jscsspToken.PERCENTAGE_TYPE)},isHex:function(){return this._isOfType(jscsspToken.HEX_TYPE)},isDimensionOfUnit:function(aUnit){return(this.isDimension()&&this.unit==aUnit)},isLength:function(){return(this.isPercentage()||this.isDimensionOfUnit("cm")||this.isDimensionOfUnit("mm")||this.isDimensionOfUnit("in")||this.isDimensionOfUnit("pc")||this.isDimensionOfUnit("px")||this.isDimensionOfUnit("em")||this.isDimensionOfUnit("ex")||this.isDimensionOfUnit("pt"))},isAngle:function(){return(this.isDimensionOfUnit("deg")||this.isDimensionOfUnit("rad")||this.isDimensionOfUnit("grad"))}};var kJscsspUNKNOWN_RULE=0;var kJscsspSTYLE_RULE=1;var kJscsspCHARSET_RULE=2;var kJscsspIMPORT_RULE=3;var kJscsspMEDIA_RULE=4;var kJscsspFONT_FACE_RULE=5;var kJscsspPAGE_RULE=6;var kJscsspKEYFRAMES_RULE=7;var kJscsspKEYFRAME_RULE=8;var kJscsspNAMESPACE_RULE=100;var kJscsspCOMMENT=101;var kJscsspWHITE_SPACE=102;var kJscsspVARIABLES_RULE=200;var kJscsspSTYLE_DECLARATION=1000;var gTABS="";function jscsspStylesheet(){this.cssRules=[];this.variables={}}jscsspStylesheet.prototype={insertRule:function(aRule,aIndex){try{this.cssRules.splice(aIndex,1,aRule)}catch(e){}},deleteRule:function(aIndex){try{this.cssRules.splice(aIndex)}catch(e){}},cssText:function(){var rv="";for(var i=0;i<this.cssRules.length;i++){rv+=this.cssRules[i].cssText()+"\n"}return rv},resolveVariables:function(aMedium){function ItemFoundInArray(aArray,aItem){for(var i=0;i<aArray.length;i++){if(aItem==aArray[i]){return true}}return false}for(var i=0;i<this.cssRules.length;i++){var rule=this.cssRules[i];if(rule.type==kJscsspSTYLE_RULE||rule.type==kJscsspIMPORT_RULE){break}else{if(rule.type==kJscsspVARIABLES_RULE&&(!rule.media.length||ItemFoundInArray(rule.media,aMedium))){for(var j=0;j<rule.declarations.length;j++){var valueText="";for(var k=0;k<rule.declarations[j].values.length;k++){valueText+=(k?" ":"")+rule.declarations[j].values[k].value}this.variables[rule.declarations[j].property]=valueText}}}}}};function jscsspCharsetRule(){this.type=kJscsspCHARSET_RULE;this.encoding=null;this.parsedCssText=null;this.parentStyleSheet=null;this.parentRule=null}jscsspCharsetRule.prototype={cssText:function(){return"@charset "+this.encoding+";"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(false,false);if(token.isAtRule("@charset")){if(parser.parseCharsetRule(token,sheet)){var newRule=sheet.cssRules[0];this.encoding=newRule.encoding;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};function jscsspErrorRule(aErrorMsg){this.error=aErrorMsg?aErrorMsg:"INVALID";this.type=kJscsspUNKNOWN_RULE;this.parsedCssText=null;this.parentStyleSheet=null;this.parentRule=null}jscsspErrorRule.prototype={cssText:function(){return this.parsedCssText}};function jscsspComment(){this.type=kJscsspCOMMENT;this.parsedCssText=null;this.parentStyleSheet=null;this.parentRule=null}jscsspComment.prototype={cssText:function(){return this.parsedCssText},setCssText:function(val){var parser=new CSSParser(val);var token=parser.getToken(true,false);if(token.isComment()){this.parsedCssText=token.value}else{throw DOMException.SYNTAX_ERR}}};function jscsspWhitespace(){this.type=kJscsspWHITE_SPACE;this.parsedCssText=null;this.parentStyleSheet=null;this.parentRule=null}jscsspWhitespace.prototype={cssText:function(){return this.parsedCssText}};function jscsspImportRule(){this.type=kJscsspIMPORT_RULE;this.parsedCssText=null;this.href=null;this.media=[];this.parentStyleSheet=null;this.parentRule=null}jscsspImportRule.prototype={cssText:function(){var mediaString=this.media.join(", ");return"@import "+this.href+((mediaString&&mediaString!="all")?mediaString+" ":"")+";"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(token.isAtRule("@import")){if(parser.parseImportRule(token,sheet)){var newRule=sheet.cssRules[0];this.href=newRule.href;this.media=newRule.media;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};function jscsspNamespaceRule(){this.type=kJscsspNAMESPACE_RULE;this.parsedCssText=null;this.prefix=null;this.url=null;this.parentStyleSheet=null;this.parentRule=null}jscsspNamespaceRule.prototype={cssText:function(){return"@namespace "+(this.prefix?this.prefix+" ":"")+this.url+";"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(token.isAtRule("@namespace")){if(parser.parseNamespaceRule(token,sheet)){var newRule=sheet.cssRules[0];this.url=newRule.url;this.prefix=newRule.prefix;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};function jscsspDeclaration(){this.type=kJscsspSTYLE_DECLARATION;this.property=null;this.values=[];this.valueText=null;this.priority=null;this.parsedCssText=null;this.parentStyleSheet=null;this.parentRule=null}jscsspDeclaration.prototype={kCOMMA_SEPARATED:{cursor:true,"font-family":true,"voice-family":true,"background-image":true},kUNMODIFIED_COMMA_SEPARATED_PROPERTIES:{"text-shadow":true,"box-shadow":true,"-moz-transition":true,"-moz-transition-property":true,"-moz-transition-duration":true,"-moz-transition-timing-function":true,"-moz-transition-delay":true},cssText:function(){var prefixes=CssInspector.prefixesForProperty(this.property);if(this.property in this.kUNMODIFIED_COMMA_SEPARATED_PROPERTIES){if(prefixes){var rv="";for(var propertyIndex=0;propertyIndex<prefixes.length;propertyIndex++){var property=prefixes[propertyIndex];rv+=(propertyIndex?gTABS:"")+property+": ";rv+=this.valueText+(this.priority?" !important":"")+";";rv+=((prefixes.length>1&&propertyIndex!=prefixes.length-1)?"\n":"")}return rv}return this.property+": "+this.valueText+(this.priority?" !important":"")+";"}if(prefixes){var rv="";for(var propertyIndex=0;propertyIndex<prefixes.length;propertyIndex++){var property=prefixes[propertyIndex];rv+=(propertyIndex?gTABS:"")+property+": ";var separator=(property in this.kCOMMA_SEPARATED)?", ":" ";for(var i=0;i<this.values.length;i++){if(this.values[i].cssText()!=null){rv+=(i?separator:"")+this.values[i].cssText()}else{return null}}rv+=(this.priority?" !important":"")+";"+((prefixes.length>1&&propertyIndex!=prefixes.length-1)?"\n":"")}return rv}var rv=this.property+": ";var separator=(this.property in this.kCOMMA_SEPARATED)?", ":" ";var extras={webkit:false,presto:false,trident:false,generic:false};for(var i=0;i<this.values.length;i++){var v=this.values[i].cssText();if(v!=null){var paren=v.indexOf("(");var kwd=v;if(paren!=-1){kwd=v.substr(0,paren)}if(kwd in kCSS_VENDOR_VALUES){for(var j in kCSS_VENDOR_VALUES[kwd]){extras[j]=extras[j]||(kCSS_VENDOR_VALUES[kwd][j]!="")}}rv+=(i?separator:"")+v}else{return null}}rv+=(this.priority?" !important":"")+";";for(var j in extras){if(extras[j]){var str="\n"+gTABS+this.property+": ";for(var i=0;i<this.values.length;i++){var v=this.values[i].cssText();if(v!=null){var paren=v.indexOf("(");var kwd=v;if(paren!=-1){kwd=v.substr(0,paren)}if(kwd in kCSS_VENDOR_VALUES){functor=kCSS_VENDOR_VALUES[kwd][j];if(functor){v=(typeof functor=="string")?functor:functor(v,j);if(!v){str=null;break}}}str+=(i?separator:"")+v}else{return null}}if(str){rv+=str+";"}else{rv+="\n"+gTABS+"/* Impossible to translate property "+this.property+" for "+j+" */"}}}return rv},setCssText:function(val){var declarations=[];var parser=new CSSParser(val);var token=parser.getToken(true,true);if(parser.parseDeclaration(token,declarations,true,true,null)&&declarations.length&&declarations[0].type==kJscsspSTYLE_DECLARATION){var newDecl=declarations.cssRules[0];this.property=newDecl.property;this.value=newDecl.value;this.priority=newDecl.priority;this.parsedCssText=newRule.parsedCssText;return}throw DOMException.SYNTAX_ERR}};function jscsspFontFaceRule(){this.type=kJscsspFONT_FACE_RULE;this.parsedCssText=null;this.descriptors=[];this.parentStyleSheet=null;this.parentRule=null}jscsspFontFaceRule.prototype={cssText:function(){var rv=gTABS+"@font-face {\n";var preservedGTABS=gTABS;gTABS+="  ";for(var i=0;i<this.descriptors.length;i++){rv+=gTABS+this.descriptors[i].cssText()+"\n"}gTABS=preservedGTABS;return rv+gTABS+"}"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(token.isAtRule("@font-face")){if(parser.parseFontFaceRule(token,sheet)){var newRule=sheet.cssRules[0];this.descriptors=newRule.descriptors;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};function jscsspKeyframesRule(){this.type=kJscsspKEYFRAMES_RULE;this.parsedCssText=null;this.cssRules=[];this.name=null;this.parentStyleSheet=null;this.parentRule=null}jscsspKeyframesRule.prototype={cssText:function(){var rv=gTABS+"@keyframes "+this.name+" {\n";var preservedGTABS=gTABS;gTABS+="  ";for(var i=0;i<this.cssRules.length;i++){rv+=gTABS+this.cssRules[i].cssText()+"\n"}gTABS=preservedGTABS;rv+=gTABS+"}\n";return rv},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(token.isAtRule("@keyframes")){if(parser.parseKeyframesRule(token,sheet)){var newRule=sheet.cssRules[0];this.cssRules=newRule.cssRules;this.name=newRule.name;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};function jscsspKeyframeRule(){this.type=kJscsspKEYFRAME_RULE;this.parsedCssText=null;this.declarations=[];this.keyText=null;this.parentStyleSheet=null;this.parentRule=null}jscsspKeyframeRule.prototype={cssText:function(){var rv=this.keyText+" {\n";var preservedGTABS=gTABS;gTABS+="  ";for(var i=0;i<this.declarations.length;i++){var declText=this.declarations[i].cssText();if(declText){rv+=gTABS+this.declarations[i].cssText()+"\n"}}gTABS=preservedGTABS;return rv+gTABS+"}"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(!token.isNotNull()){if(parser.parseKeyframeRule(token,sheet,false)){var newRule=sheet.cssRules[0];this.keyText=newRule.keyText;this.declarations=newRule.declarations;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};function jscsspMediaRule(){this.type=kJscsspMEDIA_RULE;this.parsedCssText=null;this.cssRules=[];this.media=[];this.parentStyleSheet=null;this.parentRule=null}jscsspMediaRule.prototype={cssText:function(){var rv=gTABS+"@media "+this.media.join(", ")+" {\n";var preservedGTABS=gTABS;gTABS+="  ";for(var i=0;i<this.cssRules.length;i++){rv+=gTABS+this.cssRules[i].cssText()+"\n"}gTABS=preservedGTABS;return rv+gTABS+"}"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(token.isAtRule("@media")){if(parser.parseMediaRule(token,sheet)){var newRule=sheet.cssRules[0];this.cssRules=newRule.cssRules;this.media=newRule.media;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};function jscsspStyleRule(){this.type=kJscsspSTYLE_RULE;this.parsedCssText=null;this.declarations=[];this.mSelectorText=null;this.parentStyleSheet=null;this.parentRule=null}jscsspStyleRule.prototype={cssText:function(){var rv=this.mSelectorText+" {\n";var preservedGTABS=gTABS;gTABS+="  ";for(var i=0;i<this.declarations.length;i++){var declText=this.declarations[i].cssText();if(declText){rv+=gTABS+this.declarations[i].cssText()+"\n"}}gTABS=preservedGTABS;return rv+gTABS+"}"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(!token.isNotNull()){if(parser.parseStyleRule(token,sheet,false)){var newRule=sheet.cssRules[0];this.mSelectorText=newRule.mSelectorText;this.declarations=newRule.declarations;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR},selectorText:function(){return this.mSelectorText},setSelectorText:function(val){var parser=new CSSParser(val);var token=parser.getToken(true,true);if(!token.isNotNull()){var s=parser.parseSelector(token,true);if(s){this.mSelectorText=s.selector;return}}throw DOMException.SYNTAX_ERR}};function jscsspPageRule(){this.type=kJscsspPAGE_RULE;this.parsedCssText=null;this.pageSelector=null;this.declarations=[];this.parentStyleSheet=null;this.parentRule=null}jscsspPageRule.prototype={cssText:function(){var rv=gTABS+"@page "+(this.pageSelector?this.pageSelector+" ":"")+"{\n";var preservedGTABS=gTABS;gTABS+="  ";for(var i=0;i<this.declarations.length;i++){rv+=gTABS+this.declarations[i].cssText()+"\n"}gTABS=preservedGTABS;return rv+gTABS+"}"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(token.isAtRule("@page")){if(parser.parsePageRule(token,sheet)){var newRule=sheet.cssRules[0];this.pageSelector=newRule.pageSelector;this.declarations=newRule.declarations;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};function jscsspVariablesRule(){this.type=kJscsspVARIABLES_RULE;this.parsedCssText=null;this.declarations=[];this.parentStyleSheet=null;this.parentRule=null;this.media=null}jscsspVariablesRule.prototype={cssText:function(){var rv=gTABS+"@variables "+(this.media.length?this.media.join(", ")+" ":"")+"{\n";var preservedGTABS=gTABS;gTABS+="  ";for(var i=0;i<this.declarations.length;i++){rv+=gTABS+this.declarations[i].cssText()+"\n"}gTABS=preservedGTABS;return rv+gTABS+"}"},setCssText:function(val){var sheet={cssRules:[]};var parser=new CSSParser(val);var token=parser.getToken(true,true);if(token.isAtRule("@variables")){if(parser.parseVariablesRule(token,sheet)){var newRule=sheet.cssRules[0];this.declarations=newRule.declarations;this.parsedCssText=newRule.parsedCssText;return}}throw DOMException.SYNTAX_ERR}};var kJscsspINHERIT_VALUE=0;var kJscsspPRIMITIVE_VALUE=1;var kJscsspVARIABLE_VALUE=4;function jscsspVariable(aType,aSheet){this.value="";this.type=aType;this.name=null;this.parentRule=null;this.parentStyleSheet=aSheet}jscsspVariable.prototype={cssText:function(){if(this.type==kJscsspVARIABLE_VALUE){return this.resolveVariable(this.name,this.parentRule,this.parentStyleSheet)}else{return this.value}},setCssText:function(val){if(this.type==kJscsspVARIABLE_VALUE){throw DOMException.SYNTAX_ERR}else{this.value=val}},resolveVariable:function(aName,aRule,aSheet){if(aName.toLowerCase() in aSheet.variables){return aSheet.variables[aName.toLowerCase()]}return null}};function ParseURL(buffer){var result={};result.protocol="";result.user="";result.password="";result.host="";result.port="";result.path="";result.query="";var section="PROTOCOL";var start=0;var wasSlash=false;while(start<buffer.length){if(section=="PROTOCOL"){if(buffer.charAt(start)==":"){section="AFTER_PROTOCOL";start++}else{if(buffer.charAt(start)=="/"&&result.protocol.length()==0){section=PATH}else{result.protocol+=buffer.charAt(start++)}}}else{if(section=="AFTER_PROTOCOL"){if(buffer.charAt(start)=="/"){if(!wasSlash){wasSlash=true}else{wasSlash=false;section="USER"}start++}else{throw new ParseException("Protocol shell be separated with 2 slashes")}}else{if(section=="USER"){if(buffer.charAt(start)=="/"){result.host=result.user;result.user="";section="PATH"}else{if(buffer.charAt(start)=="?"){result.host=result.user;result.user="";section="QUERY";start++}else{if(buffer.charAt(start)==":"){section="PASSWORD";start++}else{if(buffer.charAt(start)=="@"){section="HOST";start++}else{result.user+=buffer.charAt(start++)}}}}}else{if(section=="PASSWORD"){if(buffer.charAt(start)=="/"){result.host=result.user;result.port=result.password;result.user="";result.password="";section="PATH"}else{if(buffer.charAt(start)=="?"){result.host=result.user;result.port=result.password;result.user="";result.password="";section="QUERY";start++}else{if(buffer.charAt(start)=="@"){section="HOST";start++}else{result.password+=buffer.charAt(start++)}}}}else{if(section=="HOST"){if(buffer.charAt(start)=="/"){section="PATH"}else{if(buffer.charAt(start)==":"){section="PORT";start++}else{if(buffer.charAt(start)=="?"){section="QUERY";start++}else{result.host+=buffer.charAt(start++)}}}}else{if(section=="PORT"){if(buffer.charAt(start)=="/"){section="PATH"}else{if(buffer.charAt(start)=="?"){section="QUERY";start++}else{result.port+=buffer.charAt(start++)}}}else{if(section=="PATH"){if(buffer.charAt(start)=="?"){section="QUERY";start++}else{result.path+=buffer.charAt(start++)}}else{if(section=="QUERY"){result.query+=buffer.charAt(start++)}}}}}}}}}if(section=="PROTOCOL"){result.host=result.protocol;result.protocol="http"}else{if(section=="AFTER_PROTOCOL"){throw new ParseException("Invalid url")}else{if(section=="USER"){result.host=result.user;result.user=""}else{if(section=="PASSWORD"){result.host=result.user;result.port=result.password;result.user="";result.password=""}}}}return result}function ParseException(description){this.description=description}function CountLF(s){var nCR=s.match(/\n/g);return nCR?nCR.length+1:1}function FilterLinearGradientForOutput(aValue,aEngine){if(aEngine=="generic"){return aValue.substr(5)}if(aEngine=="webkit"){return aValue.replace(/\-moz\-/g,"-webkit-")}if(aEngine!="webkit20110101"){return""}var g=CssInspector.parseBackgroundImages(aValue)[0];var cancelled=false;var str="-webkit-gradient(linear, ";var position=("position" in g.value)?g.value.position.toLowerCase():"";var angle=("angle" in g.value)?g.value.angle.toLowerCase():"";if(angle){var match=angle.match(/^([0-9\-\.\\+]+)([a-z]*)/);var angle=parseFloat(match[1]);var unit=match[2];switch(unit){case"grad":angle=angle*90/100;break;case"rad":angle=angle*180/Math.PI;break;default:break}while(angle<0){angle+=360}while(angle>=360){angle-=360}}var startpoint=[];var endpoint=[];if(position!=""){if(position=="center"){position="center center"}startpoint=position.split(" ");if(angle==""&&angle!=0){switch(startpoint[0]){case"left":endpoint.push("right");break;case"center":endpoint.push("center");break;case"right":endpoint.push("left");break;default:var match=startpoint[0].match(/^([0-9\-\.\\+]+)([a-z]*)/);var v=parseFloat(match[0]);var unit=match[1];if(unit=="%"){endpoint.push((100-v)+"%")}else{cancelled=true}break}if(!cancelled){switch(startpoint[1]){case"top":endpoint.push("bottom");break;case"center":endpoint.push("center");break;case"bottom":endpoint.push("top");break;default:var match=startpoint[1].match(/^([0-9\-\.\\+]+)([a-z]*)/);var v=parseFloat(match[0]);var unit=match[1];if(unit=="%"){endpoint.push((100-v)+"%")}else{cancelled=true}break}}}else{switch(angle){case 0:endpoint.push("right");endpoint.push(startpoint[1]);break;case 90:endpoint.push(startpoint[0]);endpoint.push("top");break;case 180:endpoint.push("left");endpoint.push(startpoint[1]);break;case 270:endpoint.push(startpoint[0]);endpoint.push("bottom");break;default:cancelled=true;break}}}else{if(angle==""){angle=270}switch(angle){case 0:startpoint=["left","center"];endpoint=["right","center"];break;case 90:startpoint=["center","bottom"];endpoint=["center","top"];break;case 180:startpoint=["right","center"];endpoint=["left","center"];break;case 270:startpoint=["center","top"];endpoint=["center","bottom"];break;default:cancelled=true;break}}if(cancelled){return""}str+=startpoint.join(" ")+", "+endpoint.join(" ");if(!g.value.stops[0].position){g.value.stops[0].position="0%"}if(!g.value.stops[g.value.stops.length-1].position){g.value.stops[g.value.stops.length-1].position="100%"}var current=0;for(var i=0;i<g.value.stops.length&&!cancelled;i++){var s=g.value.stops[i];if(s.position){if(s.position.indexOf("%")==-1){cancelled=true;break}}else{var j=i+1;while(j<g.value.stops.length&&!g.value.stops[j].position){j++}var inc=parseFloat(g.value.stops[j].position)-current;for(var k=i;k<j;k++){g.value.stops[k].position=(current+inc*(k-i+1)/(j-i+1))+"%"}}current=parseFloat(s.position);str+=", color-stop("+(parseFloat(current)/100)+", "+s.color+")"}if(cancelled){return""}return str+")"}function FilterRadialGradientForOutput(aValue,aEngine){if(aEngine=="generic"){return aValue.substr(5)}else{if(aEngine=="webkit"){return aValue.replace(/\-moz\-/g,"-webkit-")}else{if(aEngine!="webkit20110101"){return""}}}var g=CssInspector.parseBackgroundImages(aValue)[0];var shape=("shape" in g.value)?g.value.shape:"";var size=("size" in g.value)?g.value.size:"";if(shape!="circle"||(size!="farthest-corner"&&size!="cover")){return""}if(g.value.stops.length<2||!("position" in g.value.stops[0])||!g.value.stops[g.value.stops.length-1].position||!("position" in g.value.stops[0])||!g.value.stops[g.value.stops.length-1].position){return""}for(var i=0;i<g.value.stops.length;i++){var s=g.value.stops[i];if(("position" in s)&&s.position&&s.position.indexOf("px")==-1){return""}}var str="-webkit-gradient(radial, ";var position=("position" in g.value)?g.value.position:"center center";str+=position+", "+parseFloat(g.value.stops[0].position)+", ";str+=position+", "+parseFloat(g.value.stops[g.value.stops.length-1].position);var current=parseFloat(g.value.stops[0].position);for(var i=0;i<g.value.stops.length;i++){var s=g.value.stops[i];if(!("position" in s)||!s.position){var j=i+1;while(j<g.value.stops.length&&!g.value.stops[j].position){j++}var inc=parseFloat(g.value.stops[j].position)-current;for(var k=i;k<j;k++){g.value.stops[k].position=(current+inc*(k-i+1)/(j-i+1))+"px"}}current=parseFloat(s.position);var c=(current-parseFloat(g.value.stops[0].position))/(parseFloat(g.value.stops[g.value.stops.length-1].position)-parseFloat(g.value.stops[0].position));str+=", color-stop("+c+", "+s.color+")"}str+=")";return str}function FilterRepeatingGradientForOutput(aValue,aEngine){if(aEngine=="generic"){return aValue.substr(5)}else{if(aEngine=="webkit"){return aValue.replace(/\-moz\-/g,"-webkit-")}}return""};
	/**
	 * A theme object
	 * @ignore
	 * @name sap.viz.mvc.Theme
	 * @class
	 */
	function Theme(themeName, themeDef) {
	    var records = themeDef === '' ? [] : CSSParser.parse(themeDef);
		// data structure
		// idx, selector(array of selectors), property, value, important    
		this._classes = records;
		this.name = themeName;
	};
	var tp = Theme.prototype;
	/**
	 * query class defintion
	 * @ignore
	 * @name sap.viz.mvc.Theme#query
	 * @function
	 * @param {String} className single class 'classname', or multiclass 'class1name class2name...'
	 * @returns {String} the definition of the class(es)
	 */
	tp.query = function(i_className) {
		if (/\./.test(i_className)) throw '. is not allowed';
		var cls = i_className.split(' ');
		var className = '';
		for (var i = 0, l = cls.length; i < l; i++) {
			if (cls[i] != '') className += '.' + cls[i];
		}
		if (className == '') return null;
		className += '.'; //make query easier
		//filter
		var classes = [];
		for (var i = 0, l = this._classes.length; i < l; i++) {
			var cRaw = this._classes[i];
			for (var i2 = 0, l2 = this._classes[i].selector.length; i2 < l2; i2++) {
				var clazz =  {idx:cRaw.idx, selector:this._classes[i].selector[i2], property:cRaw.property, value:cRaw.value, important:cRaw.important, weight:0};
				if (className.indexOf(clazz.selector + '.') >= 0) {
					var idx = -1;
					while (true) {
						idx = clazz.selector.indexOf('.', idx + 1);
						if (idx >= 0) clazz.weight++;
						else break;
					}
					classes.push(clazz);
				}
			}
		}
		//sort
		classes.sort(function(ca, cb) {
			if (ca.important != cb.important) return cb.important ? -1 : 1; 
			if (ca.weight != cb.weight) return ca.weight < cb.weight ? -1 : 1;
			return ca.idx < cb.idx ? -1 : 1;
		})
		//construct result
		var classObj = {};
		for (var i = 0, l = classes.length; i < l; i++) {
			var clazz = classes[i];
			classObj[clazz.property] = clazz.value + (clazz.important ? ' !important' : '');
		}
		classObj.toString = function() {
			var def = '';
			for (var p in this) {
				if (this.hasOwnProperty(p) && typeof this[p] === 'string') def += ';\n ' + p + ': ' + this[p]; 
			}
			if (def != '') return def.slice(2);
			return null;
		}
		return classObj;
	}	
	/**
	 * A global theme manager
	 * 
	 * @class sap.viz.mvc.ThemeManager
	 */	
	var ThemeManager = new (ObjUtils.derive(Observable,

	{
		events : [], // [ 'themechanged' ],
		_currentTheme: undefined,
		constructor : function(options) {
			this._themeReg = {};
		},
		/**
		 * Install a theme to theme manager
		 * @name sap.viz.mvc.ThemeManager#installTheme
		 * @function
		 * @param {String} themeName theme name
		 * @param {String} themeDef the definition of theme
		 */
		installTheme: function(themeName, themeDef) {
			var theme = new Theme(themeName, themeDef);
			if (!theme) {
				console.log(themeDef);
				throw new Error('Failed to parse theme "' + themeName + '", check console for detail info.')
			}
			this._themeReg[themeName] = theme;
		},
		/**
		 * Get definition of a theme class.
		 * 
		 * @name sap.viz.mvc.ThemeManager#getClassDef
		 * @function
		 * @param {String}
		 *            className the name of the theme class, it could be either single class 'classname', or multiclass 'class1name class2name...'
		 * @return {String} the definition of the theme class
		 */
		getClassDef : function(className) {
			return this._currentTheme ? this._currentTheme.query(className) : null;
		},
		/**
		 * switch to another theme
		 * 
		 * @name sap.viz.mvc.ThemeManager#changeTheme
		 * @function
		 * @param {String}
		 *            themeName the name of the theme.
		 * @param {Object}
		 *            [themeObject] theme definition.
		 */
		changeTheme : function(themeName, force) {
			var me = this;
			if (!force && me._currentTheme && me._currentTheme.name == themeName) return;
			if (this._themeReg[themeName]) {
				me._changeTheme(themeName);
			} else {
				me._loadTheme(themeName, function() {
					me._changeTheme(themeName);
				});
			}
		},
		_changeTheme: function(themeName) {
			this._currentTheme = this._themeReg[themeName];
			//this.fireEvent('themechanged');
		},
		_loadTheme: function(themeName, callback) {
			var me = this;
			//load theme
			var url = 'themes/' + themeName + '.js';
			var head = document.getElementsByTagName("head")[0] || document.documentElement;
			var script = document.createElement("script");
			script.type = 'text/javascript';
			script.src = url;
			// Handle Script loading
			var done = false;
			// Attach handlers for all browsers
			script.onload = script.onreadystatechange = function() {
				if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
					done = true;
					// Handle memory leak in IE
					script.onload = script.onreadystatechange = null;
					if (head && script.parentNode) {
						head.removeChild(script);
					}
					callback.call(me);
				}
			};
			if (script.addEventListener) {
				script.addEventListener('error', function() {
					throw new Error('Loading ' + url + ' failed.')
				}, true);
			}
			// Use insertBefore instead of appendChild to circumvent an IE6 bug.
			// This arises when a base node is used (#2709 and #4378).
			head.insertBefore(script, head.firstChild);
		}
	}))();
	return ThemeManager;
});sap.riv.module(
{
  qname : 'sap.viz.TemplateManager',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
}
],
function Setup(manifest, ThemeManager, FunctionUtils, TypeUtils, ObjectUtils) {

  function loadResource(url, cb, onError) {
    var head = document.getElementsByTagName("head")[0] || document.documentElement;
    var script = document.createElement("script");
    script.type = 'text/javascript';
    script.src = url;

    var done = false;
    script.onload = script.onreadystatechange = function() {
      if (!done && (!this.readyState || this.readyState === "loaded" || this.readyState === "complete")) {
        done = true;
        cleanScript(script);
        cb();
      }
    };
    if (script.addEventListener) {
      script.addEventListener('error', function() {
        cleanScript(script);
        onError();
      }, true);
    }

    head.insertBefore(script, head.firstChild);
  }

  function loadTemplate(loadPaths, index, templateId, cb, onError) {
    if (index < loadPaths.length) {
      var url = loadPaths[index] + templateId + '/template.js';
      var done = function() {
        loadTemplate(loadPaths, index + 1, templateId, cb, onError);
      };
      loadResource(url, done, done);
    } else {
      var template = get(templateId);
      if (template){
        cb(template);
      }
      else{
        onError();
      }
    }
  }

  function load(templateId, cb) {
    loadTemplate(manager.loadPath, 0, templateId, cb, function() {
      FunctionUtils.error('Loading template {0} failed.', templateId);
    });
  }

  function cleanScript(script) {
    script.onload = script.onreadystatechange = null;
    script.parentNode.removeChild(script);
  }

  var templateCategory = manifest.registerCategory("template", function(obj) {
    var cssText;
    Object.defineProperties(obj, {
      props : {
        value : function(vizId) {
          var properties = obj.properties;
          if (properties){
            return properties[vizId];
          }
        }
      },
      cssText : {
        value : function() {
          if (cssText === undefined) {
            cssText = "";
            var css = current.css;
            for ( var i in css) {
              if(css.hasOwnProperty(i)){
                cssText += i + "{";
                var style = css[i];
                for ( var j in style) {
                  if(style.hasOwnProperty(j)){
                    cssText += j + ":" + style[j] + ";";
                  }
                }
                cssText += "}";
              }
            }
          }
          return cssText;
        }
      }
    });
    return obj;
  });

  var current;

  var listeners = [];

  function get(id) {
    return templateCategory.get(id);
  }

  function applyStyles() {
    var themeName = current.id + "-theme";
    var themeDef = current.cssText();
    ThemeManager.installTheme(themeName, themeDef);
    ThemeManager.changeTheme(themeName);
  }

  function onTemplateChanged(template, cb, thisObj) {
    current = template;
    applyStyles();
    listeners.forEach(function(listener) {
      listener.fn.call(listener.scope, current);
    });
    if (cb){
      cb.call(thisObj, current);
    }
  }

  var defaultTemplateId = "default", defaultTemplate = {
    id : defaultTemplateId,
    name : "Default"
  };
  var manager =
  /** @lends sap.viz.TemplateManager */
  {
    /**
     * @constructs
     */
    constructor : function() {
      return;
    },
    /**
     * The file paths of templates folder. {@link sap.viz.TemplateManager} will
     * discover available templates in this folder.
     * 
     * @default ["../../../resources/templates/"]
     */
    loadPath : [ "../../../resources/templates/" ],
    /**
     * Return current applied template.
     * 
     * @returns {Object} the manifest of template
     */
    current : function() {
      return current;
    },
    /**
     * Apply(switch) a template.
     * 
     * @param {String}
     *          id the template id
     * @param {Function}
     *          [cb] the call back function. It will be executed after template
     *          is applied successfully with current template as parameter. *
     * @param {Object}
     *          [thisObj] "this" object during calling call beck function.
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    apply : function(id, cb, thisObj) {
      var template = get(id);
      if (!template) {
        load(id, function(template) {
          onTemplateChanged(template, cb, thisObj);
        });
      } else {
        onTemplateChanged(template, cb, thisObj);
      }

      return manager;
    },
    /**
     * Add a listener which will be executed when current template is changed.
     * 
     * @param {Object}
     *          listener
     * @param {Function}
     *          listener.fn the listener function
     * @param {Object}
     *          listener.scope the "this" object in the listener function
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    addListener : function(listener) {
      listeners.push(listener);
      return manager;
    },
    /**
     * Remove the listener.
     * 
     * @param {Object}
     *          listener the listener reference
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    removeListener : function(listener) {
      var index = listeners.indexOf(listener);
      if (index !== -1){
        listeners.splice(index, 1);
      }
      return manager;
    },
    /**
     * Register new templates.
     * 
     * @param {Object...}
     *          templates the template descriptors(may be multiple).
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    register : function() {
      templateCategory.register.apply(templateCategory, arguments);
      return manager;
    },
    /**
     * Extend/modify an existing template.
     * 
     * @param {String}
     *          id the template id
     * @param {Object}
     *          obj the extended part.
     * 
     * @returns {Object} {@link sap.viz.TemplateManager}
     */
    extend : function(id, obj) {
      var template = templateCategory.get(id, true);
      ObjectUtils.extend(true, template, obj);
      return manager;
    }
  };

  delete manager.constructor;

  var apiProp = {
    writable : false,
    configurable : false
  };
  Object.defineProperties(manager, {
    loadPath : {
      configurable : false
    },
    current : apiProp,
    apply : apiProp,
    addListener : apiProp,
    removeListener : apiProp,
    register : apiProp
  });

  manager.register(defaultTemplate);
  current = get(defaultTemplateId);
  return manager;
});sap.riv.module(
{
  qname : 'sap.viz.util.EffectManager',
  version : '4.0.0'},
[

],
function Setup(){

  /**
   * 
   * @param svgdef d3 svg defs to store all gradient effect
   * @return TODO: add desc
   */
  function EffectManager(svgdef, enableGhostEffect){
    this._defs  = svgdef;
    this._enableGhostEffect = enableGhostEffect;
  }

  function color2hex(color) {
    var hex;
    if(color!=null && typeof(color) == 'object') {
      if (color.rgb) 
        hex = color.rgb().toString();
      else
        hex = color.toString();
    } else if (typeof(color) == 'string') {
      hex = d3.rgb(color.toLowerCase()).toString();
    }
    return hex;
  }
  
  function rgb2gray (hex) {
    var r = parseInt(hex.substr(1, 2), 16);
    var g = parseInt(hex.substr(3, 2), 16);
    var b = parseInt(hex.substr(5, 2), 16);

    var gstr;
    if ((r == g) && (g == b)) {
      gstr = ((0 | (1 << 8) + r + (256 - r)*0.6).toString(16)).substr(1);
    } else {
      var gray = (r*299 + g*587 + b*114 + 500) / 1000;
      gstr = ((0 | (1 << 8) + gray).toString(16)).substr(1);
    }
    return '#' + gstr + gstr + gstr;
  }

  function increaseBrightness(hex, percent) {
    var r = parseInt(hex.substr(1, 2), 16);
    var g = parseInt(hex.substr(3, 2), 16);
    var b = parseInt(hex.substr(5, 2), 16);

    if (percent >= 0) {
      return '#'
      + ((0 | (1 << 8) + r + (256 - r) * percent / 100).toString(16)).substr(1)
      + ((0 | (1 << 8) + g + (256 - g) * percent / 100).toString(16)).substr(1)
      + ((0 | (1 << 8) + b + (256 - b) * percent / 100).toString(16)).substr(1);
    } else {
      return '#'
      + ((0 | (1 << 8) + r * (100 + percent) / 100).toString(16)).substr(1)
      + ((0 | (1 << 8) + g * (100 + percent) / 100).toString(16)).substr(1)
      + ((0 | (1 << 8) + b * (100 + percent) / 100).toString(16)).substr(1);  
    }
  }
  
  function drawGlossySector(d3defs, id, fillColor, radius) {
    var c0 = fillColor;
    var c2 = increaseBrightness(c0, 50);
    var c3 = increaseBrightness(fillColor, -30);

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', 0);
    rg.setAttribute('cy', 0);
    rg.setAttribute('r', radius);
    rg.setAttribute('fx', 0);
    rg.setAttribute('fy', 0);
    rg.setAttribute('gradientUnits',"userSpaceOnUse");
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 1).attr("stop-color", c3);
  }
   
  function drawGlossyCircle(d3defs, id, fillColor) {
    var c0 = fillColor;
    var c1 = increaseBrightness(c0, 10);
    var c2 = increaseBrightness(c0, 80);

    var d3rg = d3defs.append('radialGradient');
    var rg = d3rg[0][0];
    rg.setAttribute('id', id);
    rg.setAttribute('cx', '50%');
    rg.setAttribute('cy', '50%');
    rg.setAttribute('r', '50%');
    rg.setAttribute('fx', '50%');
    rg.setAttribute('fy', '20%');
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0).attr("stop-color", c2);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0.7).attr("stop-color", c1);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 0.9).attr("stop-color", c0);
    d3rg.append("stop").attr('stop-opacity' , 1).attr("offset", 1).attr("stop-color", c0);
  }

  function drawGlossyRectangle(d3defs, id, fillColor, direction) {
     var c1 = increaseBrightness(fillColor, 30);
     var c2 = increaseBrightness(fillColor, 50);
     var c3 = increaseBrightness(fillColor, -10);
     var c4 = increaseBrightness(fillColor, 10);
     var gradient = d3defs.append("svg:linearGradient").attr("id", id).attr("x1", "0%").attr("y1", "0%");
     if(direction == 'horizontal') {
       gradient.attr("y2", "0%").attr("x2", "100%");
     } else {
       gradient.attr("y2", "100%").attr("x2", "0%");
     }
     
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 0).attr("stop-color", c1);
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 0.2).attr("stop-color", c2);
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 0.8).attr("stop-color", c3);
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 1).attr("stop-color", c4);
  }

  function drawGlossyBackground(d3defs, id, fillColor, direction) {
     var gradient = d3defs.append("svg:linearGradient").attr("id", id);
     if(direction == 'horizontal') {
       gradient.attr("x1", "100%").attr("y1", "0%").attr("x2", "0%").attr("y2", "0%");
     } else {
       gradient.attr("x1", "0%").attr("y1", "0%").attr("x2", "0%").attr("y2", "100%");
     }
     
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 0).attr("stop-color", '#ffffff');
     gradient.append("stop").attr('stop-opacity' , 1).attr("offset", 1).attr("stop-color", fillColor);
  }

  
  function getFillElementId(parameters, color)
  {
    var id;
    if(parameters.drawingEffect == "glossy")
    {
      switch(parameters.graphType)
      {
      case 'sector':
        id = parameters.drawingEffect + parameters.graphType + color.slice(1) + Math.round(parameters.radius);
        break;
      case 'circle':
        id = parameters.drawingEffect + parameters.graphType + color.slice(1);
        break;
      case 'triangle-up' :
      case 'triangle-down' :
        id = parameters.drawingEffect + 'triangle' + color.slice(1) + 'vertical';
        break;
      case 'triangle-left' :
      case 'triangle-right' :
        id =  parameters.drawingEffect + 'triangle' + color.slice(1) + 'horizontal';
        break;
      case 'rectangle' :
      case 'diamond' :
      case 'cross' :
      case 'star' :
      case 'intersection' :
      case 'background' :  
      default :      
        id =  parameters.drawingEffect + 'rectangle' + color.slice(1) + parameters.direction;
        break;
      case 'line' :
        id = null;
        break;
      }
    }

    return id;

  }
  /**
   * 
   * @param parameters
   * {
   *   graphType: 'circle','square','diamond'.....
   *   drawingEffect,
   *   fillColor,
   *   direction,  "horizontal" means left to right. "vertical" means top to bottom
   * }
   * @return id to use in "fill"
   */

  EffectManager.prototype.register = function(parameters)
  {
    var color = parameters.fillColor;
    color = color2hex(color);

    if (this._enableGhostEffect) {
      color = rgb2gray(color);
    }
    var id = getFillElementId(parameters, color);
    if(!id) return color;
    var element = this._defs.select("#" + id);
    if(element.empty())
    {
      if(parameters.drawingEffect == "glossy")
      {    
        switch (parameters.graphType)
        {
        case 'background' : 
          drawGlossyBackground(this._defs, id, color, parameters.direction);
          break;
         case 'sector' :
          drawGlossySector(this._defs, id, color, parameters.radius);
          break;
         case 'circle' :
          drawGlossyCircle(this._defs, id, color, parameters.direction);
          break;
         case 'triangle-up' :
         case 'triangle-down' :
          drawGlossyRectangle(this._defs, id, color, 'vertical');
          break;
         case 'triangle-left' :
         case 'triangle-right' :
          drawGlossyRectangle(this._defs, id, color, 'horizontal');
          break;
         case 'rectangle' :
         case 'diamond' :
         case 'cross' :
         case 'star' :
         case 'intersection' :
         default :
          drawGlossyRectangle(this._defs, id, color, parameters.direction);
          break;
         }
       }
       else
            return color;
     }
     return "url(#" + id + ")";
     
   };
   
   EffectManager.prototype.setContainer = function(container){
    this._defs = container;
  };

  EffectManager.prototype.ghostEffect = function(_){
    if(!arguments.length)
      return this._enableGhostEffect;

    this._enableGhostEffect = _;
  };
  return EffectManager;
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.BaseDataHandler',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
 function Setup(FunctionUtils, TypeUtils){
 
   
   /**
    * determine which feed should be appended with MeasureNamesDimension 
    * @param feeds feeds Array
    * @returns feedId  to auto feed mnd
    */
   function determineMNDFeed(feeds){
     
     var dimensionFeed = [];
     var allFeeded = true;
     //first to see if MND is manually feeded
     var i = 0;
     for(; i < feeds.length; i++){
       var feed = feeds[i];
       if(feed.type() == "Dimension" && feed.acceptMND() >= 0){
         if(feed.hasMNDFeeded())
          return feed.feedId();
         else if(feed.getDataCount() < feed.max()){
           dimensionFeed[feed.acceptMND()] = feed;
           if(allFeeded)
              allFeeded = feed.hasFeeded();
         }
           
       } 
     }
     
     if( dimensionFeed.length == 0)
       return "";
     
     //Second, see which feed should be auto feeded MND
     //case 1: all feeds has been feeded, decide by mndPriority
     
     if(allFeeded)
      return dimensionFeed[dimensionFeed.length - 1].feedId();
      
     //case 2: not all feeds has been feeded, feed MND to non-feeded feed with highest priority
     for(i = dimensionFeed.length - 1; i >= 0; i--){
       if(dimensionFeed[i] && !dimensionFeed[i].hasFeeded())
        return dimensionFeed[i].feedId();
     }
     
     return "";
   }
   
   /**
    * return a validate value according to val passed by user
    * 1 if val is string, just return
    * 2 if val is number, convert to string , return
    * 3 if val is other type, return null
    * 
    */
   function validateStringValue(val){
     if(TypeUtils.isString(val))
      return val;
     else if(TypeUtils.isNumber(val))
      return val.toString();
     else
      return null;
   }
   
   /**
    * return a validate value according to val passed by user
    * 1 if val is number, just return
    * 2 if val is string, convert to number , return
    * 3 if val is other type, return null
    * 
    */
   function validateNumberValue(val){
     if(TypeUtils.isNumber(val))
      return parseFloat(val);
     else
      return null;
   }
   
   function initDataPointUpperLimit(rawData, upperLimit){
       var limit = [ Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY];
       
       var rawDataCount = rawData.getDataPointCount();
       if(upperLimit == Number.POSITIVE_INFINITY || !TypeUtils.isNumber(upperLimit) || upperLimit >= rawDataCount)
        return limit;
       
       //get total measure values count
       var mvCount = 0;
       var mvgCount = rawData.getMeasureValuesGroupCount();
       for(var i = 0; i < mvgCount; i++){
         mvCount += rawData.getMeasureValuesGroupByIdx(i).getMeasureValues().length;
       }
       
       //limit of one measure value
       var mvLimit = Math.floor(upperLimit / mvCount);
       
       var aaCount = rawData.getAnalysisAxisCount();
       if(aaCount == 0 || aaCount == 1){
         limit[0] = mvLimit; 
       }else if(aaCount == 2){
         var mv = rawData.getMeasureValuesGroupByIdx(0).getMeasureValues()[0];
         //var aa2Point = mv.getValues().length;
         var aa1Point = mv.getValues()[0].length;
         if(mvLimit/aa1Point < 1){
           limit[0] = mvLimit;
             limit[1] = 1;
         }else{
           limit[1] = Math.floor(mvLimit/aa1Point);
         }
       }
       
       
       return limit;
   }
   
   function BaseDataHandler(feeder, rawData, upperLimit){
          this._feeder  = feeder;
          this._feeds   = feeder.getFeeds();
          this._mndFeed = determineMNDFeed(this._feeds);
          this._limit = initDataPointUpperLimit(rawData, upperLimit);
   }
   
   
   BaseDataHandler.prototype.getFeedValues = function(feedId){
      var feed = this._feeder.findFeed(feedId);
      if(!feed)
        FunctionUtils.error('could not find feed definition of ' + feedId );
      
      
      if(feed.type() == "Dimension")
         return this.getDimensionFeedValues(feed);
        else if(feed.type() == "Measure")
         return this.getMeasureFeedValues(feed);
     
   };
   
   
   BaseDataHandler.prototype.getDimensionFeedValues = function(feed){
     
      var feedValues = [];
      var hasManualMND = false;
      
      var datas = feed.data();
      
      if(datas.length > 0){
        
        for(var i = 0; i < datas.length; i++ ){
          var data = datas[i];
          var obj = {};
          
          if(data){
            if(data.getType() == "measureNamesDimension"){  
                //col
                obj['col'] = {'val': 'MND'};
                obj['type'] = 'MND';
                
                obj['rows'] = this.getMeasureNamesValues(); 
                feedValues.push(obj);
                hasManualMND = true;
                
            }else if(data.getType() == "analysisAxis"){
              
              var dimensionLabels = data.getDimensionLabels();
              var aaIndex = this._feeder.getAnalysisAxisIndex(feed);
              
              for(var j = 0 ; j < dimensionLabels.length; j++){
                var obj = {};
                  
                  //col
                  obj['col'] = {'val': validateStringValue(dimensionLabels[j].getId())};
                  //rows
                  var rows = [];
                  var values =  dimensionLabels[j].getValues();
                  var infos =  dimensionLabels[j].infos();
                  var limit = values.length;
                  if(this._limit[aaIndex] != Number.POSITIVE_INFINITY){
                   limit = this._limit[aaIndex];
                  }
                  
                  for(var k = 0; k < limit; k++){
                        var value = { 'val':validateStringValue(values[k]), 
                                  'ctx': {
                                                          'type' : 'Dimension',
                                                          'path': {
                                                                     'aa': aaIndex,
                                                                     'di':  j,
                                                                     'dii': k  }
                                                         }
                                                };
                        
                        if(infos != null)
                         value.info = infos[k];
                        
                      rows.push(value);
                      
                      
                  }
                  
                    obj['rows'] = rows;
                    
                        feedValues.push(obj);
                     }                
            }else{
              FunctionUtils.error('wrong type when getting data');
            } 
          }
          
        }
      }
     
      
      if(feed.feedId() == this._mndFeed && hasManualMND == false){
        var obj = {};
          //col
          obj['col'] = {'val': 'MND'};
          obj['type'] = 'MND';
          
          obj['rows'] = this.getMeasureNamesValues();
          
          feedValues.unshift(obj);
      }
      
      return feedValues.length > 0 ? feedValues : null;
   };
   
     BaseDataHandler.prototype.getMeasureFeedValues = function(feed){
       var feedValues = [];
       var measureValues = feed.getMeasureValues();
         var mgIndex = this._feeder.getMeasureValuesGroupIndex(feed);
         for(var i = 0; i < measureValues.length; i++){
                 var obj = {};
                 
                 //col
                 obj['col'] =  validateStringValue(measureValues[i].getId());
                 
                 //rows
                  var rows = [];
                 var values =  measureValues[i].getValues(); //values is an aa2 * aa1 array;
                 //aa2
                 var aa2Limit = values.length;
                 if(this._limit[1] != Number.POSITIVE_INFINITY)
                  aa2Limit = this._limit[1];
                 
                 for(var j = 0; j < aa2Limit; j++){
                   var value = values[j];
                   var row = [];
                   //aa1
                   var aa1Limit = value.length;
                   if(this._limit[0] != Number.POSITIVE_INFINITY)
                    aa1Limit = this._limit[0];
                   
                   for(var k = 0; k < aa1Limit; k++){
                    
                     row.push({'val': validateNumberValue(value[k]), 'ctx': {
                                                    'type' : 'Measure',
                                                    'path': {
                                                      'mg'     :  mgIndex,
                                                      'mi'     :  i,
                                                      'dii_a1' :  k, 
                                                      'dii_a2' :  j
                                                    }
                                                       }
                               });
                   }
                   
                   rows.push(row);
                 }
                 
                 obj['rows'] = rows;
                 
                 feedValues.push(obj);
         }
         
          return feedValues.length > 0 ? feedValues : null;
   };
   
   
     BaseDataHandler.prototype.getMeasureNamesValues = function(){
       var values = [];
     var mgFeeds = this._feeder.getMeasureValuesGroupFeeds();
     for(var i = 0; i < mgFeeds.length; i++){
       if(mgFeeds[i].hasFeeded()){   
           var mvs = mgFeeds[i].getMeasureValues();
           for(var j = 0; j < mvs.length; j++){
             values.push({'val':validateStringValue(mvs[j].getId()),'ctx': { 'path' : {'mg': i, 'mi': j}}});
           }   
         }    
       }  
     
     return values;
   };
   
   return BaseDataHandler;
 });sap.riv.module(
{
  qname : 'sap.viz.data.handler.SingleChartDataHandler',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.0'
}
],
 function Setup(FunctionUtils, MultiAxesDataAdapter, MeasureDataHandler){
   
   
   function initMeasureValueAxisIndex(bindingInfo){
     
      //axis 1 has been feeded with crosstable
      if(bindingInfo[0] == true){
       if(bindingInfo[1] == true)
        return [1 ,2];
       else if(bindingInfo[2] == true)
        // pass crosstable data to module if module accpet more than 2 axis feed
        return [1, 2];
       else if(bindingInfo[3] == true)// Multi Radar, aa 4 could not be feeded
        FunctionUtils.error("Not Supported");
       else
        return [1];
      }else if(bindingInfo[1] == true){
       if(bindingInfo[2] == true)
          //pass crosstable data to module if module accpet more than 2 axis feed
          return [1,2];
       else if(bindingInfo[3] == true)
        FunctionUtils.error("Not Supported");
       else{
         //pass crosstable data to module if module accpet more than 2 axis feed
         if(bindingInfo.length > 2)
            return [1];
         else
            return [2];
       }
      }else if(bindingInfo[2] == true){
        if(bindingInfo[3] == true)
         FunctionUtils.error("Not Supported");
        else
         //pass crosstable data to module if module accpet more than 2 axis feed
         return [1];
      }else{
        for(var i = 0; i< bindingInfo.length;i++){
          if(bindingInfo[i] == true)
            FunctionUtils.error("could not determin measure value axis index");
        }
        //all false
        return [1];
      }
       
      FunctionUtils.error("could not determin measure value axis index");
     
    } 
   
   function SinngleChartDataHandler(dataAdapter){
        this._dataAdapter =  dataAdapter;
   }
   
   SinngleChartDataHandler.prototype.getDataAdapter = function(){
      if(this._dataAdapter.getBindingInfo() == null || this._dataAdapter.getBindingInfo() == undefined )
       return this._dataAdapter;
      else{
       return this.getChartDataAdapter();
      }
   };
   
   SinngleChartDataHandler.prototype.getChartDataAdapter = function(){
      var measureAxisIndex = initMeasureValueAxisIndex(this._dataAdapter.getBindingInfo());
      var aa = this._dataAdapter.getAnalysisAxisDataByIdx();
      var mg = this._dataAdapter.getMeasureValuesGroupDataByIdx();
      var dataAdapter = new MultiAxesDataAdapter();
      for(var i = 0; i < aa.length; i++){
        var axis = aa[i];
        dataAdapter.addAnalysisAxis({index: axis.index, values: axis.values});
      }
      
      for(i = 0; i < mg.length; i++){
        var mvg = mg[i];
        dataAdapter.addMeasureValuesGroup({index:mvg.index, values: MeasureDataHandler.makeMeasureValues(null, mvg, measureAxisIndex, 2, false)});
      }
      
      return dataAdapter;
   };
   
   return SinngleChartDataHandler;
 });sap.riv.module(
{
  qname : 'sap.viz.util.Objects',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils) {

  var objects = {
    // copy from sap.viz.base.utils.ObjectUtils.extend
    // in this version, when target is array, just use src replace target
    extend : function() {
      var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

      // Handle a deep copy situation
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        // skip the boolean and the target
        i = 2;
      }

      // Handle case when target is a string or something (possible in
      // deep
      // copy)
      if (typeof target !== "object" && !TypeUtils.isFunction(target)) {
        target = {};
      }

      // extend jQuery itself if only one argument is passed
      if (length === i) {
        target = this;
        --i;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
          // Extend the base object
          for (name in options) {
            src = target[name];
            copy = options[name];

            // Prevent never-ending loop
            if (target === copy) {
              continue;
            }

            // Recurse if we're merging plain objects or arrays
            // in this version, when target is array, just src replace target
            if (deep && copy && (TypeUtils.isPlainObject(copy))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && TypeUtils.isArray(src) ? src : [];

              } else {
                clone = src && TypeUtils.isPlainObject(src) ? src : {};
              }
              // Never move original objects, clone them
              target[name] = objects.extend(deep, clone, copy);
              // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      }
      // Return the modified object
      return target;
    },    
  };
  return objects;
});sap.riv.module(
{
  qname : 'sap.viz.modules.xycontainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.SingleChartDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
}
],
function Setup ( TypeUtils, Objects, Functions, layout, Manifest, SingleChartDataHandler, dispatch) {
    
    function load(moduleId) {
        return Manifest.module.get(moduleId).execute();
    }
    
  return function () {
      var width = 0, 
          height = 0, 
          properties = {}, 
          data = {},
          config = {},
          modules = {},
          selections = {},
          spaceWithoutPlot,
          parent = null, // a d3 selection   
          effectManager = null;
      var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), initializedModules = 0;;
      
      ///////////////////////can be moved to base container/////////////////////
      var resolveProperties = function(nodeConfig, isContainer){
        var props = {}, // Empty properties basket
            propsCat,   // Property category node
            usrProps,   // User set properties
            sysProps;   // Predefined properties in configure node
        if(isContainer){
          //Jimmy/8/15/2012 pay attention to the property structure, for container we will pass
          //all properties instead of properties under propsCat only.
          if ( nodeConfig ) {
            propsCat = nodeConfig.propertyCategory;
            usrProps = properties;
            sysProps = {};
            sysProps[propsCat] = nodeConfig.properties;
            Objects.extend( true, props, sysProps, usrProps ); 
          }else{
            props = properties;
          }
        }else{
          if ( nodeConfig ) {
            propsCat = nodeConfig.propertyCategory;
            usrProps = properties[ propsCat ];
            sysProps = nodeConfig.properties;
            // User properties will override predefined properties 
            Objects.extend( true, props, sysProps, usrProps );
          }
        }
        return props;
    };
    
    var updateProperties = function (id, isContainer){
      var moduleManifest = config.modules; // Module configurations
      var props, nodeConfig;
      if ( moduleManifest[id] && modules[id] ) {
        nodeConfig = moduleManifest[id].configure;
        props = resolveProperties (nodeConfig, isContainer);
        modules[id].properties(props);
      }
    };
    ///////////////////////can be moved to base container/////////////////////
    
    function initialize() {
      if ( TypeUtils.isEmptyObject(config) ) Functions.error('Container configuration missing');
      
      initializedModules = 0;
      
      initAxis('xAxis');
      initAxis('yAxis');
      initAxis('xAxis2');
      initAxis('yAxis2');
      initAxis('background');
      
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) return;
      var plot = modules.plot = load(plotConfig.id);
      var dataHandler = new SingleChartDataHandler(data); 
      plot.data(dataHandler.getDataAdapter());
      if (typeof plot.effectManager == 'function')
        plot.effectManager(effectManager);
      
      var props;
      if ( plotConfig.configure ) {
        props = resolveProperties(plotConfig.configure);
        plot.properties(props);
      }
      
      if(plot.dispatch){
        var dis =  plot.dispatch();
        if(dis.initialized) { initializedModules++; dis.on('initialized.xycontainer', initialized);};
        if(dis.showTooltip) dis.on('showTooltip.xycontainer', showTooltip);
        if(dis.hideTooltip) dis.on('hideTooltip.xycontainer', hideTooltip);
      }
      
      if ( modules.xAxis && !selections.xAxis )
        selections.xAxis = parent.append('g').attr('class', 'xAxis');
      if ( modules.xAxis2 && !selections.xAxis2 )
        selections.xAxis2 = parent.append('g').attr('class', 'xAxis2');
      if ( modules.yAxis && !selections.yAxis ) 
        selections.yAxis = parent.append('g').attr('class', 'yAxis');
      if ( modules.yAxis2 && !selections.yAxis2 ) 
        selections.yAxis2 = parent.append('g').attr('class', 'yAxis2');
      if ( modules.plot && !selections.plot ) 
        selections.plot = parent.append('g').attr('class', 'plot');
      if ( modules.background && !selections.background ) 
        selections.background = parent.insert('g', ':first-child').attr('class', 'background');        
    }
    
    function updateAxisData ( id ) {
      if(modules[id]){
        var axisConfig = config.modules[id];
        var axisDataConfig = axisConfig.data;
        if (axisDataConfig) {
          modules[id].data(data.createDataAdapterForModule(axisDataConfig));
        } 
      }  
    };
    
    function initAxis( id ) {
      if ( !config.modules[id] ) return;
      
      var axisConfig = config.modules[id],
          axis = modules[id] = load(axisConfig.id); // Saves references to axis function.
      
      updateAxisData(id);

      var props = resolveProperties(axisConfig.configure);
      axis.properties(props);
      
      axis.effectManager(effectManager);
      
      if(axis.dispatch && axis.dispatch()['initialized']){
        initializedModules++;
        axis.dispatch().on('initialized.xycontainer', initialized);
      }
    }
    
    function relayout() {
      if ( TypeUtils.isEmptyObject(modules) || !width || !height) return;
      
      width = width < 0 ? 0 : width;
      height = height < 0 ? 0 : height;
      var prefs = {};
      if ( modules.xAxis ) {
          modules.xAxis.drawable(true);
          prefs.south = { size : modules.xAxis.getPreferredSize() };
      }
      if ( modules.yAxis ) {
          modules.yAxis.drawable(true);
          prefs.west = { size : modules.yAxis.getPreferredSize() };
      }
      if ( modules.xAxis2 ) {
          modules.xAxis2.drawable(true);
          prefs.north = { size : modules.xAxis2.getPreferredSize() };
      }
      if ( modules.yAxis2 ) {
          modules.yAxis2.drawable(true);
          prefs.east = { size : modules.yAxis2.getPreferredSize() };
      }
      if ( modules.plot ) prefs.center = {};
      
      var solution = layout({
        type : 'border',
        bias : 'none',
        size : { width : width, height : height },
        prefs : prefs
      });

      //we have to layout top and bottom axes firstly, because if you change the size of top or bottom axes, the 
      //height of the axis may be changed (vertical label). Left and right axes have no vertical labels.
      if ( solution.east ) {
        // Modifies yAxis height and coordinate to handle vertical offset
        // to ensure joints with xAxis.
        var yAxis2Height = 0, yAxis2Y = 0;
        if ( solution.south ) {
          yAxis2Height = solution.east.bounds.height - solution.south.bounds.height;
          yAxis2Y = solution.east.bounds.y;
        }
        if ( solution.north ) {
          yAxis2Height = solution.east.bounds.height - solution.north.bounds.height;
          yAxis2Y = solution.west.bounds.y;
        }
        
        selections.yAxis2.attr('transform', 
          'translate(' + solution.east.bounds.x + ',' + yAxis2Y + ')');
        
        modules.yAxis2
          .width(solution.east.bounds.width)
          .height(yAxis2Height);
          
        modules.yAxis2.gridlineLength(solution.center.bounds.width); 
      } else if(modules.yAxis2) {
          modules.yAxis2.drawable(false);
      }

      if ( solution.north ) {
        
        var xAxis2Width = 0, xAxis2X = 0;
        if ( solution.west ) {
          xAxis2X = solution.north.bounds.x + solution.west.bounds.width;
        }

        selections.xAxis2.attr('transform', 
          'translate(' + xAxis2X + 
          ',' + solution.north.bounds.y + ')');

        modules.xAxis2
          .width(xAxis2X)
          .height(solution.north.bounds.height);
          
        modules.xAxis2.gridlineLength(solution.center.bounds.height);    
      } else if (modules.xAxis2) {
          modules.xAxis2.drawable(false);
      }
            
      if ( solution.west ) {
        // Modifies yAxis height and coordinate to handle vertical offset
        // to ensure joints with xAxis.
        var yAxisHeight = 0, yAxisY = 0;
        if ( solution.south ) {
          yAxisHeight = solution.west.bounds.height - solution.south.bounds.height;
          yAxisY = solution.west.bounds.y;
        }
        if ( solution.north ) {
          yAxisHeight = solution.west.bounds.height - solution.north.bounds.height;
          yAxisY = solution.west.bounds.y;
        }
        
        selections.yAxis.attr('transform', 
          'translate(' + solution.west.bounds.x + ',' + yAxisY + ')');
        
        modules.yAxis
          .width(solution.west.bounds.width)
          .height(yAxisHeight);
          
        modules.yAxis.gridlineLength(solution.center.bounds.width);  
      } else if(modules.yAxis) {
          modules.yAxis.drawable(false);
      }

      if ( solution.south ) {

        var xAxisWidth = 0, xAxisX = 0;
        if ( solution.west ) {
            xAxisX = solution.south.bounds.x + solution.west.bounds.width;
        }

        selections.xAxis.attr('transform', 
          'translate(' + xAxisX + 
          ',' + solution.south.bounds.y + ')');
          
        modules.xAxis
          .width(solution.south.bounds.width)
          .height(solution.south.bounds.height);
          
        modules.xAxis.gridlineLength(solution.center.bounds.height);
      }else if (modules.xAxis) {
          modules.xAxis.drawable(false);
      }

      //we should adjust the axes start and end padding
      //todo: add more padding
      var rightPadding = 0, rightPaddingxAxis = rightPaddingxAxis2 = 0;
      if(!solution.east)
      {
          if(modules.xAxis)
          {
            rightPaddingxAxis = modules.xAxis.endPadding();
          }
          if(modules.xAxis2)
          {
            rightPaddingxAxis2 = modules.xAxis2.endPadding();
          }
          rightPadding = rightPaddingxAxis > rightPaddingxAxis2 ? rightPaddingxAxis : rightPaddingxAxis2;
      }
      
      // if (!solution.south && modules.xAxis) {
          // modules.xAxis.drawable(false);
      // }
      // if (!solution.north && modules.xAxis2) {
          // modules.xAxis2.drawable(false);
      // }
            
      if ( solution.center ) {
        selections.plot.attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ',' + solution.center.bounds.y + ')');
        var plotWidth = solution.center.bounds.width - rightPadding;
        modules.plot
          .width(plotWidth > 0 ? plotWidth : 0)
          .height(solution.center.bounds.height > 0 ? solution.center.bounds.height : 0);
        
        spaceWithoutPlot = width - plotWidth;

        if (selections.background) {
            selections.background.attr('transform', 
              'translate(' + solution.center.bounds.x + 
              ',' + solution.center.bounds.y + ')');
            modules.background
              .width(plotWidth > 0 ? plotWidth : 0)
              .height(solution.center.bounds.height > 0 ? solution.center.bounds.height : 0);
        }          
      }
      if ( solution.west )
      {
        modules.yAxis.gridlineLength(solution.center.bounds.width - rightPadding); 
      }
      
    }
    
    function container( selection ) {
      selection.each(function ( data ) {
        parent = selection;
        if ( TypeUtils.isEmptyObject(modules) ) initialize();
        render();
      });
      return container;
    }
    
    container.width = function (_) {
      if ( !arguments.length ) return width;
      width = _;
      //Jimmy,8/20/2012, as a container, you don't know whether your
      //sub elements need relayout even if the container size remains
      //the same. so here we just give a chance to sub elements to relayout
      relayout();
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) return height;
      height = _;
      //see @width
      relayout();
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) return {
        'width' : width,
        'height' : height
      };
      height = _.height;
      width = _.width;
      //see @width
      relayout();
      return container;
    };
    
    container.data = function (_) {
      if ( !arguments.length ) return data;
      data = _;
      if(!TypeUtils.isEmptyObject(modules)){
        //plot exists, we need update its data
        var dataHandler = new SingleChartDataHandler(data); 
        modules.plot.data(dataHandler.getDataAdapter());
        updateAxisData('xAxis');
        updateAxisData('yAxis');
        updateAxisData('xAxis2');
        updateAxisData('yAxis2');
      }
      
      return container;
    };
    
    container.properties = function (_) {
      if ( !arguments.length ) return properties;
      properties = _;
      if(!TypeUtils.isEmptyObject(modules)){
        updateProperties('xAxis');
        updateProperties('xAxis2');
        updateProperties('yAxis');
        updateProperties('yAxis2');
        updateProperties('plot');
        updateProperties('background');
      }
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) return config;
      config = _;
      return container;
    };
    
    container.modules = function (_) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) {
          initialize();
        } 
        return modules;
      }
      modules = _;
      return container;
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) return parent;
      parent = _;
      return container;
    };
    
    container.effectManager = function (_) {
        if ( !arguments.length ) return effectManager;
        effectManager = _;
        return container;
      };
      
    container.dispatch = function(_){
        if ( !arguments.length) return eDispatch;
        eDispatch = _;
        return container;
    };
    
    container.infoForSizeLegend = function(){
            return {
              space : spaceWithoutPlot,
              number : 1,
              plotHeight : modules.plot.height()
            };
    };
    
    function render() {
      for ( var sel in selections ) {
        if ( selections.hasOwnProperty(sel) ) {
          selections[sel].datum(modules[sel].data()).call(modules[sel]);
        }
      }
    }
    
    var initializedCount = 0;
    function initialized(){
      if(initializedModules == ++initializedCount){
        initializedCount = 0;
        eDispatch.initialized();
      }
    };
    
    function showTooltip(evt){
        eDispatch.showTooltip(evt);
    };
    
    function hideTooltip(evt){
        eDispatch.hideTooltip(evt);
    };
    
    return container;
  };
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.tooltip',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
}
],
function Setup(Dispatch) {
    return function(manifest) {
    var _display = {
      singleMeasure : {
        label : {
          font : 'bold 11px sans-serif',
          color : '#333333'
        },
        value : {
          font : 'bold 14px sans-serif',
          color : '#333333'
        },
        padding : {
          vertical : 9,
          horizontal : 10
        }
      },
      multipleMeasure : {
        label : {
          font :  "12px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        value : {
          font : "12px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        padding : {
          vertical : 8,
          horizontal : 10,
          inline : 6,
          symbolGap : 7,
          defaultSpace : 8
        }
      },
      title : {
        color : '#333333',
        font : "bold 13px 'Open Sans', Arial, Helvetica, sans-serif",
        formatString : ''
      },
      footer : {
        label : {
          font :  "bold 10.5px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        value : {
          font : "10.5px 'Open Sans', Arial, Helvetica, sans-serif",
          color : '#333333'
        },
        padding : {
          inline : 6
        }
      },
      valueFormat : [],
      labelFormat : [],
      maxDimensionLabelWidth : 150,
      maxMeasureLabelWidth : 80
    };

    var _finalWidth = {
      dimension : undefined,
      measure : undefined,
      value : undefined
    };

    var _shapeLayout = {
      padding : 5,
      radius : 4,
      markerWidth : 12,
      markerHeight : 8,
      borderWidth : 2
    };

    var _shapes = {
      tooltip : null,
      tooltipRB : null,
      dimensionLabel : null,
      separateLine : null,
      measureLabels : [],
      measureMarks : [],
      valueLabels : []
    };

    var _currentValue = {
      offset : undefined
    };

    var _defaultToolTipColors = {
      backgroundColor : '#ffffff',
      borderColor : '#000000',
      separateLineColor : [ '#ffffff', '#8a8a8a', '#ffffff' ],
      separateLineSingleColor : '#AAAAAA',
      guideLineColor : '#AAAAAA'
    };

    var _svgPathCommand = {
      arcA : 'A',
      lineToA : 'L',
      moveToA : 'M',
      closePath: 'z'
    };
    
    var _symbol = {
      symbolSize : 8,
      hasSymbol : false
    };
    
    var _symbolClassName = 'tooltipsymbol', _paragraphTitleClassName = 'tooltipparagraphtitle', _paragraphLabelTextClassName = 'tooltipparagraphlabel', _paragraphValueTextClassName = 'tooltipparagraphvalue', _footerLabelClassName = 'tooltipfooterlabel', _footerValueClassName = 'tooltipfootervalue';
    
    var vis = null, gWrapper = null;
    var tooltipWidth = 0, tooltipHeight = 0, textMaxWidth = 0, effectManager = null,
    zone = {
        width : 200,
        height : 100
    },
    
    plotArea = {
        width: 160,
          height: 70,
          x: 0,
          y: 0
    },
    
    _properties = {},
    
    //tooltip border marker orientation
    _orientation = null;

    //variables are for tooltip content truncation case
    _truncationParameter = {
      isTruncated : false,
      currentFooterIndex : -1,
      currentBodyIndex : -1,
      defaultValue : '...',
      font : 'bold 20px Arial',
      color : '#000000'
    };
    
    function clearTruncationParameter() {
      _truncationParameter.isTruncated = false;
      _truncationParameter.currentFooterIndex = -1;
      _truncationParameter.currentBodyIndex = -1;
    }
    
    function tooltip(selection) {
      vis = d3.select(selection).append('svg').style('position', 'absolute').attr('pointer-events', 'none').attr('width', '0').attr('height', 0).attr('class','tooltip');
      
      return tooltip;
    };

        function getTooltipHeightV2(vis, data) {
          var bodyInline = _display.multipleMeasure.padding.inline, 
            multipleVertical = _display.multipleMeasure.padding.vertical,
            multipleLabelFont = _display.multipleMeasure.label.font,
            multipleValueFont = _display.multipleMeasure.value.font,
            footerInline = _display.footer.padding.inline,
            footerLabelFont = _display.footer.label.font,
            titleFont = _display.title.font;
            var tooltipHeight = 0, bodyLineNum = 0, footerLineNum = 0, bodyTitleNum = 0, tooltipBody = data.body, tooltipFooter = data.footer;
           
            
            //First rule, make sure the content contains the first paragraph title and footer if the tooltip height is beyond zone height.
            if (tooltipBody && tooltipBody.length > 0) {
                tooltipHeight = multipleVertical;
              
                if (tooltipFooter && tooltipFooter.length > 0) {
                  var firstPlaceHolderHeight = 0;
                  if (tooltipBody[0].name != null) {
                    firstPlaceHolderHeight =  getTextBox(vis, tooltipBody[0].name,  titleFont).height + bodyInline + getTextBox(vis, _truncationParameter.defaultValue,  _truncationParameter.font).height;
                  }
                  
                  if (tooltipFooter[0].label != null) {
                    var footerlabelBox = getTextBox(vis, tooltipFooter[0].label, footerLabelFont);
                    
                    tooltipHeight += multipleVertical * 3;
                    
                    tooltipHeight += (tooltipFooter.length * footerlabelBox.height + footerInline * (tooltipFooter.length - 1));
                
                    tooltipHeight += firstPlaceHolderHeight;
                    if (tooltipHeight > zone.height) {
                      _truncationParameter.isTruncated = true;
                      _truncationParameter.currentBodyIndex = 0;
                      
                      var num = 0;
                      while (tooltipHeight > zone.height) {
                        tooltipHeight -= footerlabelBox.height;
                        tooltipHeight -= footerInline;
                        num++;
                      }
                      _truncationParameter.currentFooterIndex = tooltipFooter.length - num - 1;
                      
                      return tooltipHeight;
                    }
                    
                    tooltipHeight -= firstPlaceHolderHeight;
                  }
                } else {
                  tooltipHeight += multipleVertical;
                }
                
                var paragraphTitleNum = 0, paragraphLineNum = 0;
              for (var i = 0; i < tooltipBody.length; i++) {
                paragraphTitleNum++;
                paragraphLineNum += tooltipBody[i].val.length;
              }
              
              if (tooltipBody[0].name != null) {
                tooltipHeight += (paragraphTitleNum * getTextBox(vis, tooltipBody[0].name,  titleFont).height);
              }
              
            var maxValue = 0;
              if (tooltipBody[0].val.length > 0) {
                if (tooltipBody[0].val[0].label != null) {
                  maxValue = getTextBox(vis, tooltipBody[0].val[0].label,  multipleLabelFont).height;
                }
                
                if (tooltipBody[0].val[0].value != null) {
                  var valueHeight = getTextBox(vis, tooltipBody[0].val[0].value,  multipleValueFont).height;
                  if (valueHeight > maxValue)
                    maxValue = valueHeight;
                }
                
                tooltipHeight += (paragraphLineNum * maxValue);
              }
                
              tooltipHeight += (bodyInline * (paragraphTitleNum + paragraphLineNum - 1));
              
                if (tooltipHeight > zone.height) {
                  _truncationParameter.isTruncated = true;
                  
                  var num = 0;
                  while (tooltipHeight > zone.height) {
                    tooltipHeight -= maxValue;
                    tooltipHeight -= bodyInline;
                    num++;
                  }
                  
                  _truncationParameter.currentBodyIndex = paragraphTitleNum + paragraphLineNum - num - 2;
                  var defaultValueBox = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                  
                  return tooltipHeight + (defaultValueBox.height - maxValue);
                }
            } else  if (tooltipFooter && tooltipFooter.length > 0) {
              if (tooltipFooter[0].label != null) {
                var footerlabelBox = getTextBox(vis, tooltipFooter[0].label, footerLabelFont);
                
                tooltipHeight += multipleVertical;
                
                tooltipHeight += (tooltipFooter.length * footerlabelBox.height + footerInline * (tooltipFooter.length - 1));
            
                  if (tooltipHeight > zone.height) {
                    _truncationParameter.isTruncated = true;
                    var num = 0;
                    while (tooltipHeight > zone.height) {
                      tooltipHeight -= footerlabelBox.height;
                      tooltipHeight -= footerInline;
                      num++;
                    }
                    
                    _truncationParameter.currentFooterIndex = tooltipFooter.length - num - 1;
                    var defaultValueBox = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                    
                    return tooltipHeight + (defaultValueBox.height - footerlabelBox.height);
                  }
              }
            }    
            
            return tooltipHeight;
        }
        
        function getTooltipWidthV2(vis, data) {
            var tooltipWidth = 0, multipleHorizontal = _display.multipleMeasure.padding.horizontal, symbolGap = _display.multipleMeasure.padding.symbolGap, defaultSpace = _display.multipleMeasure.padding.defaultSpace, symbolSize = _symbol.symbolSize;
            
            tooltipWidth = textMaxWidth + (multipleHorizontal * 2) + defaultSpace;
            if (_symbol.hasSymbol) {
              tooltipWidth += symbolSize + symbolGap;
            }
            return tooltipWidth;
        }
        
        function getTextMaxWidthV2(vis, data) {
            var maxValue = 0, tmpWidth = 0, tooltipBody = data.body, tooltipFooter = data.footer;
            
            if (tooltipBody) {
              for (var i = 0; i < tooltipBody.length; i++) {
                if (tooltipBody[i].name != null) {
                tmpWidth = getTextBox(vis, tooltipBody[i].name, _display.title.font).width;
              if (tmpWidth > maxValue) {
                maxValue = tmpWidth;
              }
                }
            
            var paragraphValue = tooltipBody[i].val;
            if (paragraphValue) {
              if (paragraphValue.length == 1 && (paragraphValue[0].value != null)) {
                var valueBox = getTextBox(vis, paragraphValue[0].value, _display.multipleMeasure.value.font);
                
                    _symbol.symbolSize = valueBox.height * 0.8;
                    _symbol.hasSymbol = true;
                    
                  if (valueBox.width > maxValue) {
                    maxValue = valueBox.width;
                  }
              } else if (paragraphValue.length > 1) {
                if (paragraphValue[0].label != null) {
                  if (paragraphValue[0].shape != null && paragraphValue[0].color != null) {
                        _symbol.symbolSize = getTextBox(vis, paragraphValue[0].label, _display.multipleMeasure.label.font).height * 0.8;
                        _symbol.hasSymbol = true;
                  }
                }
                
                if (paragraphValue[0].value != null) {
                  if (paragraphValue[0].shape != null && paragraphValue[0].color != null) {
                        _symbol.symbolSize = getTextBox(vis, paragraphValue[0].value, _display.multipleMeasure.value.font).height * 0.8;
                        _symbol.hasSymbol = true;
                  }               
                }
                
                for (var j = 0; j < paragraphValue.length; j++) {
                  if ((paragraphValue[j].label != null) && (paragraphValue[j].value != null)) {
                    tmpWidth = getTextBox(vis, paragraphValue[j].label, _display.multipleMeasure.label.font).width + getTextBox(vis, paragraphValue[j].value, _display.multipleMeasure.value.font).width;
                        if (tmpWidth > maxValue) {
                          maxValue = tmpWidth;
                        }
                  } else if (paragraphValue[j].label != null) {
                    tmpWidth = getTextBox(vis, paragraphValue[j].label, _display.multipleMeasure.label.font).width;
                        if (tmpWidth > maxValue) {
                          maxValue = tmpWidth;
                        }                    
                  } else if (paragraphValue[j].value != null) {
                    tmpWidth = getTextBox(vis, paragraphValue[j].value, _display.multipleMeasure.value.font).width;
                        if (tmpWidth > maxValue) {
                          maxValue = tmpWidth;
                        }                    
                  }
                }
              }
            }
              }
            }
            
            if (tooltipFooter) {
              for (var m = 0; m < tooltipFooter.length; m++) {
                var item = tooltipFooter[m];
                
                if (item.label && item.value) {
                  tmpWidth = getTextBox(vis, item.label, _display.footer.label.font).width + getTextBox(vis, item.value, _display.footer.value.font).width;
              if (tmpWidth > maxValue) {
                maxValue = tmpWidth;
              }
                }
              }
            }
          
            return maxValue;
        }
 
        function getSymbolPath(type, size){
        var symbolPath = '', r; 
        switch(type){
      case 'circle' :
        r = size / 2;
        symbolPath = "M0," + r + "A" + r + "," + r + " 0 1,1 0," + (-r) + "A" + r + "," + r + " 0 1,1 0," + r + "Z";
        break;
      case "cross" :
                var rx = size / 6, ry = size / 6;
                symbolPath = "M" + -3 * rx + "," + -ry + "H" + -rx + "V" + -3 * ry + "H" + rx + "V" + -ry + "H" + 3 * rx + "V" + ry + "H" + rx + "V" + 3 * ry + "H" + -rx + "V" + ry + "H" + -3 * rx + "Z";
                break;
      case "triangle-down" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M0," + ry + "L" + rx + "," + -ry + " " + -rx + "," + -ry + "Z";
                break;
            case "triangle-up" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M0," + -ry + "L" + rx + "," + ry + " " + -rx + "," + ry + "Z";
                break;
            case "diamond" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M0," + -ry + "L" + rx + ",0" + " 0," + ry + " " + -rx + ",0" + "Z";
                break;
            case 'squareWithRadius' : 
              r = size / 2;
              var radius = r - 3;
        symbolPath = "M0," +  -r + "L" + -radius + ","+ -r + "Q" + -r +"," + -r + " " + -r + "," + -radius + "L" + -r +"," + radius + "Q" + -r + "," + r + " " + -radius + "," + r
          + "L" + radius + "," + r +"Q" + r + "," + r + " " + r + "," +radius + "L" + r +"," + -radius + "Q" + r + "," + -r + " "+ radius + "," + -r +"Z";
        break;
            case 'square' :
              default : 
        r = size / 2;
        symbolPath = "M" + -r + "," + -r + "L" + r + "," + -r + " " + r + "," + r + " " + -r + "," + r + "Z";
        break;
          case "triangle-left" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M" + -rx + ",0L" + rx + "," + ry + " " + rx + "," + -ry + "Z";
                break;
            case "triangle-right" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M" + rx + ",0L" + -rx + "," + ry + " " + -rx + "," + -ry + "Z";
                break;
            case "intersection" :
                var rx = size / 2, ry = size / 2;
                symbolPath = "M" + rx + ',' + ry + ' ' +  rx/3 + ',0 ' + rx + ',' + -ry + ' ' + rx / 2 + ',' + -ry + ' 0,' + -ry/3 + ' ' + -rx / 2 + ',' + -ry + ' ' + -rx + ',' + -ry + ' ' + -rx/3 + ',0 ' + -rx + ',' + ry + ' ' + -rx/2 + ',' + ry + ' 0,' + ry/3 + ' ' + rx/2 + ',' + ry;
                break;
        }
        return symbolPath;
      }
      
        function drawSymbolV2(vis, pos, symbolType, color, symbolSize, className) {
            var parameter = {
            drawingEffect: _properties.drawingEffect,
            fillColor : color,
            graphType : symbolType,
            direction : 'vertical'
        };
            
            var fillId =  effectManager.register(parameter);
            vis.append('path').attr('d', getSymbolPath(symbolType, symbolSize)).attr('transform', 'translate(' + pos.x + ',' + pos.y + ')').attr('fill', fillId).attr('class', className);
        } 
        
        function drawContentV2(vis, pos, data, markerPos) {
          //Because yStart starts at a offset radius in function drawShape, to substract radius here.
          var xStart = pos.x, yStart = pos.y - _shapeLayout.radius / 2;
          //var markerPos = properties.orientation;
          var markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
          
          if (markerPos == 'left') {
        xStart += markerHeight;
      }
      if (markerPos == 'top') {
        yStart += markerHeight;
      }
      
          var multipleHorizontal = _display.multipleMeasure.padding.horizontal, multipleVertical = _display.multipleMeasure.padding.vertical, 
            multipleInline = _display.multipleMeasure.padding.inline, symbolGap = _display.multipleMeasure.padding.symbolGap, 
            defaultSpace = _display.multipleMeasure.padding.defaultSpace;
          var symbolSize = _symbol.symbolSize, hasSymbol = _symbol.hasSymbol;
            var titleColor = _display.title.color, titleFont = _display.title.font;
            var multipleLabelFont = _display.multipleMeasure.label.font, multipleLabelColor = _display.multipleMeasure.label.color, 
              singleLabelFont = _display.singleMeasure.label.font, singleLabelColor = _display.singleMeasure.label.color;
            var multipleValueFont = _display.multipleMeasure.value.font, multipleValueColor = _display.multipleMeasure.value.color, 
              singleValueFont = _display.singleMeasure.value.font, singleValueColor = _display.singleMeasure.value.color;
            var footerInline = _display.footer.padding.inline, footerLabelFont = _display.footer.label.font, 
              footerValueFont = _display.footer.value.font, footerLabelColor = _display.footer.label.color, 
              footerValueColor = _display.footer.value.color;
            var tooltipBody = data.body, tooltipFooter = data.footer;
            var currentBodyIndex = -1, currentFooterIndex = -1;
            var rowPos = {
                    x : 0,
                    y : 0
                };
            
            var isBreak = false;
            
            if (tooltipBody) {

              for (var i = 0; i < tooltipBody.length; i++) {
                
                if (isBreak)
                  break;
                
                var paragraph = tooltipBody[i];
                if (paragraph.name) {
                        var titleBox = getTextBox(vis, paragraph.name, titleFont);
                        var titleHeight = titleBox.height;    
                        
                        rowPos.x = xStart + multipleHorizontal;
                        if (i == 0)
                          rowPos.y = yStart + titleHeight + multipleVertical;
                        else
                          rowPos.y += (yStart + titleHeight + multipleInline);
                        
                        drawTextV2(vis, rowPos, paragraph.name, titleColor, titleFont, _paragraphTitleClassName);
                        currentBodyIndex++;
                        if (_truncationParameter.isTruncated && currentBodyIndex == _truncationParameter.currentBodyIndex) {
                    var valueBox = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                    rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                    rowPos.y += (multipleInline + valueBox.height);
                    drawTextV2(vis, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);    
                          break;
                        }
                }
                
                if (paragraph.val.length > 0) {
                  
                  if (paragraph.val.length > 1) {
                    for (var j = 0; j < paragraph.val.length; j++) {
                      
                      if ((paragraph.val[j].shape != null) && (paragraph.val[j].color != null) && (paragraph.val[j].label != null) && (paragraph.val[j].value != null)) {                     
                        var labelBox = getTextBox(vis, paragraph.val[j].label, multipleLabelFont), valueBox = getTextBox(vis, paragraph.val[j].value, multipleValueFont);
                        var offset = (labelBox.height >= valueBox.height) ? labelBox.height: valueBox.heigth;
                        
                        rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                        rowPos.y += (multipleInline + offset);
                        //drawSymbol
                        drawSymbolV2(vis, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape,  paragraph.val[j].color, symbolSize, _symbolClassName);
                        
                        rowPos.x = xStart + multipleHorizontal + symbolSize + symbolGap;
                        drawTextV2(vis, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
                        
                        rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                        drawTextV2(vis, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);                          
                      } else if ((paragraph.val[j].shape != null) && (paragraph.val[j].color != null) && (paragraph.val[j].label != null)) {
                        var labelBox = getTextBox(vis, paragraph.val[j].label, multipleLabelFont);
                        rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                        rowPos.y += (multipleInline + labelBox.height);
                        //drawSymbol
                        drawSymbolV2(vis, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape, paragraph.val[j].color, symbolSize, _symbolClassName);
                        
                        rowPos.x = xStart + multipleHorizontal + symbolSize + symbolGap;
                        drawTextV2(vis, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
    
                      } else if ((paragraph.val[j].shape != null) && (paragraph.val[j].color != null) && (paragraph.val[j].value != null)) {
                        var valueBox = getTextBox(vis, paragraph.val[j].value, multipleValueFont);
                        rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                        rowPos.y += (multipleInline + valueBox.height);
                        //drawSymbol
                        drawSymbolV2(vis, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[j].shape, paragraph.val[j].color, symbolSize, _symbolClassName);
                        
                        rowPos.x = xStart + tooltipWidth - valueBox.width - multipleHorizontal;
                        drawTextV2(vis, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                      
                      } else if ((paragraph.val[j].label != null) && (paragraph.val[j].value != null)) {
                        var labelBox = getTextBox(vis, paragraph.val[j].label, multipleLabelFont), valueBox = getTextBox(vis, paragraph.val[j].value, multipleValueFont);
                           var offset = (labelBox.height >= valueBox.height) ? labelBox.height: valueBox.heigth;
         
                        rowPos.x = xStart + multipleHorizontal;
                        rowPos.y += (multipleInline + offset);
                        drawTextV2(vis, rowPos, paragraph.val[j].label, multipleLabelColor, multipleLabelFont, _paragraphLabelTextClassName);
                        
                        rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                        drawTextV2(vis, rowPos, paragraph.val[j].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                      }
                      
                      currentBodyIndex++;
                              if (_truncationParameter.isTruncated && currentBodyIndex == _truncationParameter.currentBodyIndex) {
                          var defaultValueBox = getTextBox(vis, _truncationParameter.defaultValue, _truncationParameter.font);
                          rowPos.x = xStart + (tooltipWidth - defaultValueBox.width - multipleHorizontal);
                          rowPos.y += (multipleInline + defaultValueBox.height);
                          drawTextV2(vis, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);
                          isBreak = true;
                                break;
                              }  
                    }
                    
                  } else if (paragraph.val.length == 1) {
                    if (paragraph.val[0].value != null) {
                         var valueBox = getTextBox(vis, paragraph.val[0].value, multipleValueFont);
                      rowPos.y += (multipleInline + valueBox.height);
                      
                      if (_properties.chartType == 'heatmap' || _properties.chartType == 'tagcloud' || _properties.chartType == 'geo') {
                        rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);

                      } else if (paragraph.val[0].shape != null && paragraph.val[0].color != null) {
                        rowPos.x = xStart + multipleHorizontal + symbolSize / 2;
                        drawSymbolV2(vis, {x: rowPos.x, y: (rowPos.y - symbolSize/2)}, paragraph.val[0].shape, paragraph.val[0].color, symbolSize, _symbolClassName);
                        rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                        
                      }
                      drawTextV2(vis, rowPos, paragraph.val[0].value, multipleValueColor, multipleValueFont, _paragraphValueTextClassName);
                      
                      currentBodyIndex++;
                              if (_truncationParameter.isTruncated && currentBodyIndex == _truncationParameter.currentBodyIndex) {
                          var valueBox = getTextBox(vis, _truncationParameter.defaultValue, multipleValueFont);
                          rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
                          rowPos.y += (multipleInline + valueBox.height);
                          drawTextV2(vis, rowPos, _truncationParameter.defaultValue, _truncationParameter.color, _truncationParameter.font, _paragraphValueTextClassName);    
                                break;
                              }
                    }
                  }
                }
              }
            }
            
            if (tooltipFooter && tooltipFooter.length > 0) {
              //draw seperated line
                var separateLineStart = {
                      x: xStart,
                      y: rowPos.y + multipleVertical
                    };
 
                var separateLineEnd = {
                      x: xStart + tooltipWidth,
                      y: rowPos.y + multipleVertical
                    };
                
                vis.append('line').attr('x1', separateLineStart.x + 1).attr('y1', separateLineStart.y).attr('x2', separateLineEnd.x - 1).attr('y2', separateLineEnd.y).style('stroke',  _defaultToolTipColors.separateLineSingleColor).style('stroke-width', 1).style('shape-rendering', 'crispEdges');
                
            rowPos.y += (multipleVertical * 2);
            
                //draw footer
                for (var k = 0; k < tooltipFooter.length; k++) {
                  if (tooltipFooter[k].label && tooltipFooter[k].value) {
                    var labelBox = getTextBox(vis, tooltipFooter[k].label, footerLabelFont), valueBox = getTextBox(vis, tooltipFooter[k].value, footerValueFont);
                    rowPos.x = xStart + multipleHorizontal;
                    if (k > 0)
                      rowPos.y += footerInline;
                      
                    rowPos.y += (labelBox.height);
                    
                    //draw label
              drawTextV2(vis, rowPos, tooltipFooter[k].label, footerLabelColor, footerLabelFont, _footerLabelClassName);
              
              rowPos.x = xStart + (tooltipWidth - valueBox.width - multipleHorizontal);
              //draw value
              drawTextV2(vis,rowPos, tooltipFooter[k].value, footerValueColor, footerValueFont, _footerValueClassName);
              
                currentFooterIndex++;
                        if (_truncationParameter.isTruncated && currentFooterIndex == _truncationParameter.currentFooterIndex) {
                          break;
                        }
                  }
                }
            }           
            
        }
        
    tooltip.showTooltip = function (eventData) {
      var data = eventData.data;
      if(gWrapper != null){
        gWrapper.remove();
      }
      
      if (_properties.visible) {
        if (data.plotArea) {
            tooltip.plotArea(data.plotArea);
        }
        
        _orientation = _properties.orientation;
        gWrapper = vis.append('svg:g');
        updateTooltipStyle();
      
        textMaxWidth = getTextMaxWidthV2(vis, data);
        tooltipWidth = getTooltipWidthV2(gWrapper, data);
        tooltipHeight = getTooltipHeightV2(gWrapper, data);
          
        var tmpWidth = tooltipWidth, tmpHeight = tooltipHeight;
        if (_orientation == 'top' || _orientation == 'bottom') {
          tmpHeight += _shapeLayout.markerHeight;
        }
        
        if (_orientation == 'left' || _orientation == 'right') {
          tmpWidth += _shapeLayout.markerHeight
        }
        vis.attr('width', tmpWidth + _shapeLayout.padding).attr('height', tmpHeight + _shapeLayout.padding);
        
        //appendLinearGradient(gWrapper);
  
        var tooltipPos = calculatePos(data.point, plotArea, zone, tooltipWidth, tooltipHeight);
        drawShape(gWrapper, {x:0,y:0, absoluteMarkerOffset : tooltipPos.absoluteMarkerOffset}, tooltipWidth, tooltipHeight, _orientation);
        drawContentV2(gWrapper, {x:0,y:0}, data, _orientation);
        vis.style('left', tooltipPos.x + 'px').style('top', tooltipPos.y + 'px');
        clearTruncationParameter();
      }
    };  
    
    tooltip.hideTooltip = function () {
      if (gWrapper != null) {
        gWrapper.remove();
        vis.attr('width', 0).attr('height', 0);
        gWrapper = null;
        }
    };
    
    function calculateSymbolSize(data) {
      if (data.labels) {
        _symbol.symbolSize = getTextBox(vis, data.labels[0].label, _display.multipleMeasure.label.font).height;
      }
    }
    
    function calculatePos(point, plotArea, zone, tooltipWidth, tooltipHeight) {
      var tooltipPos = {
          x: 0,
          y: 0,
          absoluteMarkerOffset: 0
      };
      
      var chartType = _properties.chartType;
      var markerHeight = _shapeLayout.markerHeight, markerWidth = _shapeLayout.markerWidth;

//      if (tooltipWidth > zone.width || tooltipHeight > zone.height) {
//        return tooltipPos;
//      } 
      
      if (_properties.chartType === undefined) {
        tooltipPos.x = point.x;
        tooltipPos.y = point.y;
      } else if (chartType == 'heatmap' || chartType == 'tagcloud') {
        
        if (_orientation == 'bottom') {
          var upBorder = zone.height - point.y + tooltipHeight + markerHeight;
          if (upBorder > zone.height) {
            _orientation = 'top';
            tooltipPos.y = point.y;
          } else {
            tooltipPos.y = point.y - tooltipHeight - markerHeight;
          }
        }
        
        var tooltipPosX = calculateTooltipPosX(point, plotArea, zone, tooltipWidth);
        tooltipPos.x = tooltipPosX.x;
        tooltipPos.absoluteMarkerOffset = tooltipPosX.absoluteMarkerOffset;
        
      } else if (chartType == 'line' || chartType == 'verticalboxplot' || chartType == 'verticalbar') {
        if (_orientation == 'left') {
          var rightBorder = point.x + tooltipWidth + markerHeight;
          if (rightBorder > zone.width) {
            _orientation = 'right';
            tooltipPos.x = point.x - tooltipWidth - markerHeight;
          } else {
            tooltipPos.x = point.x + markerHeight;
          }
        }
        if (tooltipHeight / 2 < plotArea.y) {
          //tooltip marker is over chart top border.
          tooltipPos.y = plotArea.y - (tooltipHeight - markerWidth) / 2;
        } else
          tooltipPos.y = 0;
        
      } else if (chartType == 'radar') {
        var rightOffset = 0,  leftOffset = 0, topOffset = 0, bottomOffset = 0, x = 0, y = 0;
        
        _orientation = point.orientation;
        tooltipPos.x = point.x;
        tooltipPos.y = point.y - tooltipHeight / 2;
        
        if (point.orientation == 'right') {
          tooltipPos.x -= (tooltipWidth + markerHeight);
        }
        
        if (point.orientation == 'left') {
          rightOffset = point.x + tooltipWidth + markerHeight - zone.width;

        }
        
        if (point.orientation == 'right') {
          leftOffset = point.x - tooltipWidth - markerHeight;
        }
        
        topOffset = point.y - tooltipHeight / 2;
        bottomOffset = point.y + tooltipHeight / 2 - zone.height;
        
        if (rightOffset <= 0 && leftOffset >= 0 && topOffset >= 0 && bottomOffset <= 0) {
          return tooltipPos;
        }
        
        if (rightOffset > 0 &&  rightOffset > point.range.x) {
          return tooltipPos;
        }
        
        if (leftOffset < 0 && Math.abs(leftOffset) > point.range.x) {
          return tooltipPos;
        }
        
        if (topOffset < 0 && Math.abs(topOffset) > point.range.y) {
          return tooltipPos;
        }
        
        if (bottomOffset > 0 && bottomOffset > point.range.y) {
          return tooltipPos;
        }
        
        var angle = point.angle * 180 / Math.PI, radian = point.angle;
        
        if (angle >= 0) {

          if (angle == 0 && rightOffset > 0) {
            tooltipPos.x -= rightOffset;
          } else if (angle == 90 && topOffset < 0) {
            tooltipPos.y -= topOffset;
          } else if (angle == 180 && leftOffset < 0) {
            tooltipPos.x -= leftOffset;
          } else if (angle > 0 && angle < 90) {
            if (topOffset < 0 && rightOffset > 0) {
              //both tooltip top and right border cross chart top and right border
              var  topOffsetAbs = Math.abs(topOffset);
              if (topOffsetAbs >= rightOffset) {
                y = topOffsetAbs;
                x = y / Math.tan(radian);
              } else  {
                x = rightOffset;
                y = x * Math.tan(radian);
                
              }
            } else if (topOffset < 0 && rightOffset <= 0) {
              //only tooltip top border cross chart top border
              y = Math.abs(topOffset);
              x = y / Math.tan(radian);
            } else if (topOffset >= 0 && rightOffset > 0) {
              //only tooltip right border cross chart right border
              x = rightOffset;
              y = x * Math.tan(radian);
            }
            
            tooltipPos.x -=x;
            tooltipPos.y += y;
            
          } else if (angle > 90 && angle < 180) {
            if (topOffset < 0 && leftOffset < 0) {
              //both tooltip top and left border cross chart top and left border
              var topOffsetAbs = Math.abs(topOffset), leftOffsetAbs = Math.abs(leftOffset);
              if (topOffsetAbs >= leftOffsetAbs) {
                y = topOffsetAbs;
                x = y / Math.tan(Math.PI - radian);
              } else {
                x = leftOffsetAbs;
                y = x * Math.tan(Math.PI - radian);
              }
              
            } else if (topOffset < 0 && leftOffset >= 0) {
              //only tooltip top border cross chart top border
              y = Math.abs(topOffset);
              x = y / Math.tan(Math.PI - radian);
              
            } else if (topOffset >= 0 && leftOffset < 0) {
              //only tooltip left border cross chart left border
              x = Math.abs(leftOffset);
              y = x * Math.tan(Math.PI -radian);
            }
            
            tooltipPos.x +=x;
            tooltipPos.y += y;
          }
          
        } else {
          
          var angleAbs = Math.abs(angle);
          if (angleAbs == 0 && rightOffset > 0) {
            tooltipPos.x -= rightOffset;
          } else if (angleAbs == 90 && bottomOffset > 0) {
            tooltipPos.y -= bottomOffset;
          } else if (angleAbs == 180 && leftOffset < 0) {
            tooltipPos.x -= leftOffset;
          } else if (angleAbs > 0 && angleAbs < 90) {
            if (bottomOffset > 0 && rightOffset > 0) {
              //both tooltip bottom and right border cross chart top and right border
              if (bottomOffset >= rightOffset) {
                y = bottomOffset;
                x = y / Math.tan(Math.abs(radian));
              } else  {
                x = rightOffset;
                y = x * Math.tan(Math.abs(radian));
                
              }
            } else if (bottomOffset > 0 && rightOffset <= 0) {
              //only tooltip bottom border cross chart bottom border
              y = bottomOffset;
              x = y / Math.tan(Math.abs(radian));
            } else if (bottomOffset <= 0 && rightOffset > 0) {
              //only tooltip right border cross chart right border
              x = rightOffset;
              y = x * Math.tan(Math.abs(radian));
            }
            
            tooltipPos.x -=x;
            tooltipPos.y -= y;            
          } else if (angleAbs > 90 && angleAbs < 180) {
            if (bottomOffset > 0 && leftOffset < 0) {
              var leftOffsetAbs = Math.abs(leftOffset);
              //both tooltip bottomOffset and left border cross chart top and left border
              if (bottomOffset >= leftOffsetAbs) {
                y = bottomOffset;
                x = y / Math.tan(Math.PI - Math.abs(radian));
              } else {
                x = leftOffsetAbs;
                y = x * Math.tan(Math.PI - Math.abs(radian));
              }
              
            } else if (bottomOffset > 0 && leftOffset >= 0) {
              //only tooltip bottom border cross chart bottom border
              y = bottomOffset;
              x = y / Math.tan(Math.PI - Math.abs(radian));
              
            } else if (bottomOffset <= 0 && leftOffset < 0) {
              //only tooltip left border cross chart left border
              x = Math.abs(leftOffset);
              y = x * Math.tan(Math.PI -Math.abs(radian));
            }
            
            tooltipPos.x +=x;
            tooltipPos.y -= y;            
          }      
        }
        
      } else if (chartType == 'geo' && _orientation == 'left'){
        // In this style, tooltip will always point to the plot origin horizontally.
        var topOffset = point.y - tooltipHeight / 2, 
            bottomOffset = point.y + tooltipHeight / 2 - zone.height;
        
        tooltipPos.y = topOffset;
        
        if (plotArea.x + plotArea.width + tooltipWidth - markerHeight > zone.width) {
          tooltipPos.x = plotArea.x - plotArea.width - tooltipWidth;
          _orientation = 'right';
        } else {
          tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
        }

        if (topOffset < 0) {
          tooltipPos.y = 0;
          tooltipPos.absoluteMarkerOffset = topOffset;
        }
        
        if (bottomOffset > 0) {
          tooltipPos.y = zone.height - tooltipHeight;
          tooltipPos.absoluteMarkerOffset = bottomOffset;
        }
      } else {
        
        if (_properties.orientation == 'left') {
        
          var rightOffset = 0, leftOffset = 0, topOffset = 0, bottomOffset = 0;
          
          rightOffset = plotArea.x + plotArea.width + tooltipWidth + markerHeight - zone.width;
          topOffset = point.y - tooltipHeight / 2;
          bottomOffset = point.y + tooltipHeight / 2 - zone.height;
          
          tooltipPos.y = point.y - tooltipHeight / 2;
          
          if (rightOffset > 0) {
            tooltipPos.x = zone.width - markerHeight - tooltipWidth;
          } else {
            tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
          }
          
          if (topOffset < 0) {
            tooltipPos.y = 0;
            tooltipPos.absoluteMarkerOffset = topOffset;
          }
          
          if (bottomOffset > 0) {
            tooltipPos.y = zone.height - tooltipHeight;
            tooltipPos.absoluteMarkerOffset = bottomOffset;
          }
          
//          var rightBorder = plotArea.x + plotArea.width + markerHeight + tooltipWidth;
//          if (rightBorder <= zone.width) {
//              tooltipPos.x = plotArea.x + plotArea.width - markerHeight;
//          } else {
//            tooltipPos.x = zone.width - markerHeight - tooltipWidth;
//          }
//          
//          var tooltipPosY = calculateTooltipPosY(point, plotArea, zone, tooltipHeight);
//          tooltipPos.y = tooltipPosY.y;
//          tooltipPos.absoluteMarkerOffset = tooltipPosY.absoluteMarkerOffset;

        } else if (_properties.orientation == 'bottom') {      
  
          var top = plotArea.y - tooltipHeight;
          if (top < 0) {
            tooltipPos.y = 0;
          } else {
            tooltipPos.y = plotArea.y - tooltipHeight;
          }
          
          var tooltipPosX = calculateTooltipPosX(point, plotArea, zone, tooltipWidth);
          tooltipPos.x = tooltipPosX.x;
          tooltipPos.absoluteMarkerOffset = tooltipPosX.absoluteMarkerOffset;
        }
        
      }

      return tooltipPos;
    }
    
    function calculateTooltipPosX(point, plotArea, zone, tooltipWidth) {
      var tooltipPosX = {
          x: 0,
          absoluteMarkerOffset: 0
      };
      
      var leftBorder = tooltipWidth / 2 - (point.x - plotArea.x) + plotArea.width;
      var rightBorder = point.x - plotArea.x + tooltipWidth / 2;
      if (leftBorder > zone.width) {
        tooltipPosX.x = plotArea.x;
        tooltipPos.absoluteMarkerOffset = point.x - plotArea.x - tooltipWidth / 2;
      } else if (rightBorder > zone.width) {
        tooltipPosX.x = plotArea.x + (plotArea.width - tooltipWidth);
        tooltipPosX.absoluteMarkerOffset = plotArea.width - (point.x - plotArea.x) - tooltipWidth / 2;
      } else {
        tooltipPosX.x = point.x - tooltipWidth / 2;
        tooltipPosX.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosX;
    }
    
    function calculateTooltipPosY(point, plotArea, zone, tooltipHeight) {
      var tooltipPosY = {
          y: 0,
          absoluteMarkerOffset: 0
      };
      
      var upBorder = plotArea.height + (tooltipHeight / 2 - (point.y - plotArea.y));
      var downBorder = point.y - plotArea.y + tooltipHeight / 2;
      if (upBorder > zone.height) {
        tooltipPosY.y = plotArea.y;
        tooltipPosY.absoluteMarkerOffset = point.y - plotArea.y - tooltipHeight / 2;
      } else if (downBorder > zone.height) {
        tooltipPosY.y = plotArea.y + plotArea.height - tooltipHeight;
        tooltipPosY.absoluteMarkerOffset = point.y - (plotArea.height - tooltipHeight) - plotArea.y - tooltipHeight / 2;
      } else {
        tooltipPosY.y = point.y - tooltipHeight / 2;
        tooltipPosY.absoluteMarkerOffset = 0;
      }
      
      return tooltipPosY;
    }
    
    function drawShape(vis, pos, width, height, markerPos) {
      
      var xStart = pos.x, yStart = pos.y, offset = pos.absoluteMarkerOffset, radius = _shapeLayout.radius, markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
      var space = ' ';
      var lineTo = _svgPathCommand.lineToA, moveTo = _svgPathCommand.moveToA, arc = _svgPathCommand.arcA, closePath = _svgPathCommand.closePath;
      //var markerPos = properties.orientation;
      
      if (markerPos == 'left') {
        xStart += markerHeight;
      }
      if (markerPos == 'top') {
        yStart += markerHeight;
      }

            var path = moveTo + space + xStart + space + (yStart + radius) + space;

            if (markerPos == 'left') {
                path += lineTo + space + xStart + space + (yStart + height / 2 + offset - markerWidth / 2 ) + space;
                path += lineTo + space + (xStart - markerHeight) + space + (yStart + height / 2 + offset ) + space;
                path += lineTo + space + xStart + space + (yStart + height / 2 + offset + markerWidth / 2 ) + space;
            }

            path += lineTo + xStart + space + (yStart + height - radius) + space;

            path += arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + radius) + space + (yStart + height) + space;

            if (markerPos == 'bottom') {
                path += lineTo + space + (xStart + width / 2 + offset - markerWidth / 2) + space + (yStart + height) + space;
                path += lineTo + space + (xStart + width / 2 + offset) + space + (yStart + height + markerHeight) + space;
                path += lineTo + space + (xStart + width / 2 + offset + markerWidth / 2) + space + (yStart + height) + space;
            }

            path += lineTo + space + (xStart + width - radius) + space + (yStart + height) + space;

            path += space + arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + width) + space + (yStart + height - radius) + space;

            if (markerPos == 'right') {
                path += lineTo + space + (xStart + width) + space + (yStart + height / 2 + offset + markerWidth / 2) + space;
                path += lineTo + space + (xStart + width + markerHeight) + space + (yStart + height / 2 - offset) + space;
                path += lineTo + space + (xStart + width) + space + (yStart + height / 2 + offset - markerWidth / 2) + space;
            }

            path += lineTo + space + (xStart + width) + space + (yStart + radius) + space;

            path += space + arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + (xStart + width - radius) + space + yStart + space;

            if (markerPos == 'top') {
                path += lineTo + space + (xStart + width / 2 + offset + markerWidth / 2) + space + yStart + space;
                path += lineTo + space + (xStart + width / 2 + offset) + space + (yStart - markerHeight) + space;
                path += lineTo + space + (xStart + width / 2 + offset - markerWidth / 2) + space + yStart + space;
            }

            path += lineTo + space + (xStart + radius) + space + yStart + space;

            path += arc + space + radius + space + radius + space + '0' + space + '0' + space + '0' + space + xStart + space + (yStart + radius) + space;

            path += closePath;
            
            vis.append('path').attr('d', path).attr('fill', _defaultToolTipColors.backgroundColor).attr('stroke', _defaultToolTipColors.borderColor).style('stroke-width', 1).style('-webkit-svg-shadow', '3px 3px 8px rgba(0, 0, 0, 0.3)');

    };

        function getTextBox(vis, text, style) {
            var text = vis.append('svg:text').attr('x', 0).attr('y', 0).attr('visibility', 'hidden').style('font', style).text(text);
            var bbox = text.node().getBBox();
            text.remove();
            return bbox;
        }

        function getTextMaxWidth(vis, data) {
            var maxValue = 0;
            if (data.title != null) {
                if (data.labels.length > 0) {
                    var bBox = getTextBox(vis, data.title, _display.title.font);
                    var currentMax = bBox.width;

                    for (var i = 0, len = data.labels.length; i < len; i++) {
                        var textWidth = getTextBox(vis, data.labels[i].label, _display.multipleMeasure.label.font).width + getTextBox(vis, data.labels[i].value, _display.multipleMeasure.value.font).width;
                        if (textWidth > currentMax) {
                            currentMax = textWidth;
                        }
                    }
                    maxValue = currentMax;
                }
            } else {
                maxValue = getTextBox(vis, data.labels[0].label, _display.singleMeasure.label.font).width;
                var textWidth = getTextBox(svg, data.labels[0].value, _display.singleMeasure.value.font).width;

                if (textWidth > maxValue) {
                    maxValue = textWidth;
                }
            }
            return maxValue;
        }

        
        function getTooltipWidth(vis, data) {
            var tooltipWidth = 0, symbolSize = _symbol.symbolSize;
            var singleHorizontal = _display.singleMeasure.padding.horizontal, multipleHorizontal = _display.multipleMeasure.padding.horizontal, symbolGap = _display.multipleMeasure.padding.symbolGap, defaultSpace = _display.multipleMeasure.padding.defaultSpace;
            if (data.title != null) {
                tooltipWidth = textMaxWidth + (multipleHorizontal * 2) + defaultSpace; //+ radius * 2;
        if (data.shapes && data.colors) {
          tooltipWidth +=  symbolSize + symbolGap;
        }
            } else {
                tooltipWidth = textMaxWidth + (singleHorizontal * 2); 
            }
            return tooltipWidth;
        }

        function getTooltipHeight(vis, data) {
          var inline = _display.multipleMeasure.padding.inline, multipleVertical = _display.multipleMeasure.padding.vertical, singleVertical = _display.singleMeasure.padding.vertical;
          var multipleValueFont = _display.multipleMeasure.value.font, singleValueFont = _display.singleMeasure.value.font;
      var titleFont = _display.title.font;
            var tooltipHeight = 0;
            if (data.title != null) {
                tooltipHeight = (multipleVertical * 3) + (inline * (data.labels.length - 1)) + getTextBox(vis, data.title, titleFont).height + getTextBox(vis, data.labels[0].value, multipleValueFont).height * data.labels.length;

            } else {
                tooltipHeight = (singleVertical * 3 ) + getTextBox(vis, data.labels[0].value, singleValueFont).height;
            }
            return tooltipHeight;
        }
        
        function appendLinearGradient(vis) {
            var gradient = vis.append('svg:defs').append('svg:linearGradient').attr('id', 'tooltipGradient1').attr('x1', '0%').attr('y1', '0%').attr('x2', '80%').attr('y2', '0%').attr('x3', '100%').attr('y3', '0%');
            
            gradient.append('svg:stop').attr('offset', '30%').attr('style', 'stop-color:' + _defaultToolTipColors.separateLineColor[0]);
            gradient.append('svg:stop').attr('offset', '60%').attr('style', 'stop-color:' + _defaultToolTipColors.separateLineColor[1]);
            gradient.append('svg:stop').attr('offset', '100%').attr('style', 'stop-color:' + _defaultToolTipColors.separateLineColor[2]);          
        }
  
        function drawSymbol(vis, pos, symbolSize, symbolType, color) {
            var symbolPath = d3.svg.symbol().type(symbolType).size(symbolSize * symbolSize);
            var parameter = {
                drawingEffect: _properties.drawingEffect,
                fillColor : color,
              graphType : symbolType,
                direction : 'vertical'
            };
            var fillId =  effectManager.register(parameter);
            vis.append('path').attr('d', symbolPath).attr('transform', 'translate(' + pos.x + ',' + pos.y + ')').attr('fill', fillId);
        } 
        
        function drawText(vis, pos, text, color, style) {
            vis.append('text').attr('x', pos.x).attr('y', pos.y).attr('fill', color).style('font', style).text(text);
        }
        
        function drawTextV2(vis, pos, text, color, style, className) {
            vis.append('text').attr('x', pos.x).attr('y', pos.y).attr('fill', color).style('font', style).text(text).attr('class', className);
        }
        
        function drawContent(vis, pos, data) {
          //Because yStart starts at a offset radius in function drawShape, to substract radius here.
          var xStart = pos.x, yStart = pos.y - _shapeLayout.radius;
          var markerPos = _properties.orientation;
          var markerWidth = _shapeLayout.markerWidth, markerHeight = _shapeLayout.markerHeight;
          
          if (markerPos == 'left') {
        xStart += markerHeight;
      }
      if (markerPos == 'top') {
        yStart += markerHeight;
      }
      
          var radius = _shapeLayout.radius;
          var multipleHorizontal = _display.multipleMeasure.padding.horizontal, multipleVertical = _display.multipleMeasure.padding.vertical, 
            multipleInline = _display.multipleMeasure.padding.inline, symbolGap = _display.multipleMeasure.padding.symbolGap, 
            defaultSpace = _display.multipleMeasure.padding.defaultSpace;
          var singleHorizontal = _display.singleMeasure.padding.horizontal, singleVertical = _display.singleMeasure.padding.vertical;
          var symbolSize = _symbol.symbolSize;
            var titleColor = _display.title.color, titleFont = _display.title.font;
            var multipleLabelFont = _display.multipleMeasure.label.font, multipleLabelColor = _display.multipleMeasure.label.color, 
              singleLabelFont = _display.singleMeasure.label.font, singleLabelColor = _display.singleMeasure.label.color;
            var multipleValueFont = _display.multipleMeasure.value.font, multipleValueColor = _display.multipleMeasure.value.color, 
              singleValueFont = _display.singleMeasure.value.font, singleValueColor = _display.singleMeasure.value.color;

            if (data.title != null) {
                var titleBox = getTextBox(vis, data.title, titleFont);
                var titleWidth = titleBox.width;
                var titleHeight = titleBox.height;

          
                var titlePos = {
                    x : xStart + multipleHorizontal,
                    y : yStart + titleHeight + multipleVertical
                };

                drawText(vis, titlePos, data.title, titleColor, titleFont);
                
                var separateLineStart = {
                      x: xStart,
                      y: yStart + titleHeight + multipleVertical * 2
                    };
 
                var separateLineEnd = {
                      x: xStart + tooltipWidth,
                      y: yStart + titleHeight + multipleVertical * 2
                    };
                
                 //vis.append('rect').attr('x', separateLineStart.x + 2).attr('y', separateLineStart.x + 2).attr('width', tooltipWidth - 4).attr('height', 1).attr('style', 'fill:none; stroke:url(#tooltipGradient1); stroke-width:none; shape-rendering:crispEdges'); 
                 //vis.append('line').attr('x1', separateLineStart.x + 5).attr('y1', separateLineStart.y).attr('x2', separateLineEnd.x - 5).attr('y2', separateLineEnd.y).style('stroke',  _defaultToolTipColors.separateLineSingleColor).style('stroke-width', 1).style('shape-rendering', 'crispEdges');
                    
                    for (var i = 0, len = data.labels.length; i < len; i++) {
                      
                    var labelBox = getTextBox(vis, data.labels[i].label, multipleLabelFont);
                    var valueBox = getTextBox(vis, data.labels[i].value, multipleValueFont);
                        
                        var markerPos = {
                                x : xStart + multipleHorizontal + symbolSize / 2,
                                y : yStart + multipleVertical * 2 + titleHeight + multipleInline * i + valueBox.height * (i + 1) - symbolSize / 2
                            };                 
  
            var cloneSymbolSize = 0, cloneSymbolGap = 0;
            if (data.shapes && data.colors) {
              cloneSymbolSize = symbolSize;
              cloneSymbolGap = symbolGap;
            }
            
                      var labelPos = {
                                x : xStart + multipleHorizontal + cloneSymbolSize + cloneSymbolGap,
                                y : yStart + multipleVertical * 2 + titleHeight + multipleInline * i + valueBox.height * (i + 1) 
                      };
                      
                      var valuePos = {
                                x : xStart + multipleHorizontal + cloneSymbolSize + cloneSymbolGap + textMaxWidth - valueBox.width + defaultSpace,
                                y : yStart + multipleVertical * 2 + titleHeight + multipleInline * i + valueBox.height * (i + 1) 
                      };
                      
                      if(data.shapes && data.colors) {
                          drawSymbol(vis, markerPos, symbolSize, data.shapes[i], data.colors[i]);
                      }
                      drawText(vis, labelPos, data.labels[i].label, multipleLabelColor, multipleLabelFont);
                      drawText(vis, valuePos, data.labels[i].value, multipleValueColor, multipleValueFont);
                    }
        
            } else {

                var labelBox = getTextBox(vis, data.labels[0].label, singleLabelFont);
                var valueBox = getTextBox(vis, data.labels[0].value, singleValueFont);
                
              var labelPos = {
                        x : xStart + singleHorizontal,
                        y : yStart + singleVertical + labelBox.height
              };
              
              var valuePos = {
                        x : xStart + singleHorizontal,
                        y : yStart + singleVertical + labelBox.height + valueBox.height
              };
              
              drawText(vis, labelPos, data.labels[i].label, singleLabelColor, singleLabelFont);
              drawText(vis, valuePos, data.labels[i].value, singleValueColor, singleValueFont);             
            }

        }
        
        tooltip.zone = function(_){
          if(!arguments.length){
            return zone;
          }
          zone = _;
          return this;
        };
  
         tooltip.plotArea = function(_){
          if(!arguments.length){
            return plotArea;
          }
          plotArea = _;
          return this;
        };
        
        tooltip.properties = function (_) {
      if (!arguments.length){
          return _properties;
       }
      _properties = manifest.props(_);

          return this;
        };
        
        tooltip.effectManager = function(_){
          if(!arguments.length){
            return effectManager;
          }
          effectManager = _;
          return this;
        };
    
    function updateTooltipStyle() {
      var cssDef;
      if (cssDef = manifest.style('viz-tooltip-background')) {
      if ((cssDef['fill']) && (_defaultToolTipColors.backgroundColor != cssDef['fill'])) 
        _defaultToolTipColors.backgroundColor = cssDef['fill'];
      }
      
      if (cssDef = manifest.style('viz-tooltip-title')) {
        if ((cssDef['fill']) && (_display.title.color != cssDef['fill'])) 
          _display.title.color = cssDef['fill'];
      }

      if (cssDef = manifest.style('viz-tooltip-label')) {
        if (cssDef['fill']) {
          _display.singleMeasure.label.color  = cssDef['fill'];
          _display.multipleMeasure.label.color = cssDef['fill'];
        }            
      }

      if (cssDef = manifest.style('viz-tooltip-value')) {
        if (cssDef['fill']) {
          _display.singleMeasure.value.color  = cssDef['fill'];
          _display.multipleMeasure.value.color = cssDef['fill'];
        } 
      }
    }
    tooltip.properties(null);
    return tooltip;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(constants) {
  var moduleConstants = {
    Type : {
      Chart : 'CHART',
      Container : 'CONTAINER',
      Supplementary : 'SUPPLEMENTARY',
      Controller : 'CONTROLLER',
      ThirdParty : 'THIRDPARTY'
    },
    CSS : {
      CLASS : {
        DATAPOINT : "datapoint"
      }
    },
    Event : {
      SelectData : {
        name: 'selectData',
        desc : 'Event fired when certain data point(s) is(are) selected, data context of selected item(s) would be passed in accordance with the following format.'
          + '<code>{name: "selectData",'
          + 'data:[{\n//selected element\'s detail\n'
          + 'target:"Dom Element",//an object pointed to corresponding dom element\n'
          + 'data:[{val: "...",//value of this element\n'
          + 'ctx:{type:"Dimension"||"Measure"||"MND",\n'
          + '//for Dimension\n'
          + 'path:{aa:"...",di:"...",dii:"..."},\n'
          + '//for Measure\n'
          + 'path:{mg:"...",mi:"...",dii_a1:"...",dii_a2:"..."},\n'
          + '//for MND\n'
          + 'path:{mg:"...",mi:"..."}\n'
          + '//path: analysis path\n'
          + '//aa: analysis axis index // 0 for analysis axis 1,  1 for analysis 2\n'
          + '//di: dimension index //zero based\n'
          + '//dii: dimension item index //zero based\n'
          + '//mg: measure group index // 0 for measure group 1,1 for measure group 2\n'
          + '//mi: measure index // measure index in measure group zero based\n'
          + '//dii_a1: each dii of di in analysis axis 1 index\n'
          + '//dii_a2: each dii of di in analysis axis 2 index\n'
          + '}},{\n//for bubble, tagcloud and scatter, there will be more than one values in one selected element.\n'
          + 'var:"...",ctx:"..."}]},{\n//if under multi selection, there will be more than one selected elements\n'
          + 'target:"...",data:["..."]}]}'
      },
      DeSelectData : {
        name: 'deselectData',
        desc : 'Event fired when certain data point(s) is(are) deselected, data context of deselected item(s) would be passed in accordance with the following format.'
          + '<code>{name: "deselectData",'
          + 'data:["---the same as selectedData---"]}'
      },
      TooltipShow : {
        name: 'showTooltip',
        desc : 'Event fired when the mouse hover onto the specific part of chart, data context of tooltip would be passed in accordance with the following format.'
          + '<code>{name:"showTooltip",data:{body:[{\n//data of one group\n'
          + 'name:"...",val:[{\n//data of one row\n'
          + 'color:"...",label:"...",shape:"...",value:"..."},"..."]},"..."],footer:[{label:"...",value:"..."},"..."],'
          + 'plotArea:{\n//this object specifies the plot area of the chart\n'
          + 'height:"...",width:"...",x:"...",y:"..."},point:{\n//this object specifies a point which affects the position of tooltip\n'
          + 'x:"...",y:"..."}}}'
      },
      TooltipHide : {
        name: 'hideTooltip',
        desc : 'Event fired when the mouse hover out of the specific part of chart, no data is passed.'
      },
      initialized : {
        desc : 'Event fired when the loading ends, which contains event name only.'
      },
      highlightedByLegend : {
        desc : "Event fired when legend item is clicked, which contains its data context."
      }   
    }
  };

  constants.Module = moduleConstants;

  return moduleConstants;
});sap.riv.module(
{
  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(constants) {
  var feed = {
    Type : {
      Dimension : "Dimension",
      Measure : "Measure"
    },
    Constraints : {
      INF : Number.POSITIVE_INFINITY
    }
  };
  constants.Feed = feed;
  return feed;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.0'
}
],
function Setup(manifest, FunctionUtils, ThemeManager, ObjectUtils, Objects) {
  function loadModule(modules, moduleConfig) {
    var moduleId = moduleConfig.id;
    if (moduleId == null)
      FunctionUtils.error("Cannot find module id in sub module config \"{0}\"",
          JSON.stringify(moduleConfig));

    var module = manifest.module.get(moduleConfig.id, true);
    modules.push({
      module : module,
      config : moduleConfig,
      subModules : module.subModules(moduleConfig)
    });
  }

  function exactDefaultProperties(props) {
    var defaultProps = {}, n;
    for (n in props) {
      var prop = props[n];
      if (prop)
        defaultProps[n] = prop.supportedValueType == 'Object' ? exactDefaultProperties(prop.supportedValues)
            : prop.defaultValue;
    }
    return defaultProps;
  }
  /**
   * This is a instantce , which already have been registered into {@link sap.viz.manifest.module}.</br>
   * </br>
   * Now, once an item is loaded from {@link sap.viz.manifest.module}, it will automatically provide some APIs .</br>
   * </br>
   * @example
   * var legend = manifest.module.get(legendID);
   * @see sap.viz.manifest.module#get
   * @class Built-in_Manifest_Objects.moduleManifest
   */
  manifest.registerCategory("module", function(obj) {
    var defaultProperties;

    Object.defineProperties(obj, {
      subModules : {
        value : function(moduleConfig) {
          var subModules;
          var subModuleKeys = obj.submodulekeys;
          if (subModuleKeys && moduleConfig) {
            var subModuleConfigs = moduleConfig.modules;
            if (subModuleConfigs) {
              subModules = new Array();
              subModuleKeys.forEach(function(key) {
                var subModuleConfig = subModuleConfigs[key.key];
                if (subModuleConfig) {
                  loadModule(subModules, subModuleConfig);
                }
              });
            }
          }
          return subModules;
        }
      },
      /**
       * return an object containing all CSS of a module which have been registered in module's manifest
       * @method Built-in_Manifest_Objects.moduleManifest#style
       * @param {Object} className a classname of the CSS
       * @return {Object} 
       */
      style : {
        value : function(className) {
          var css = obj.css;
          var result = ObjectUtils.extend(null,
              css ? css["." + className].value : null, ThemeManager
                  .getClassDef(className));
          Object.defineProperty(result, "toString", {
            value : function() {
              var str = "", i;

              for (i in this) {
                str += i + ":" + this[i] + ";";
              }

              return str;
            },
            enumerable : false
          });
          return result;
        }
      },
      /**
           * get the cssText of a module in "module" category.</br>
           * This API will firstly search in ThemeManager by className. If find nothing, it will get the default value from module's manifest.
           * </br>
           * @method Built-in_Manifest_Objects.moduleManifest#cssText
           * @param {Object} className a className of the css
           * @return {String} the cssText decided by className
           * @example
           * 
           * var moduleManifest = manifest.module.get(id);//get the item from module's manifest by id
           * var cssOfModule = moduleManifest.cssText(moduleConfig)//return the cssText
           * @ignore
           */
      cssText : {
        value : function(className) {
          return this.style(className).toString();
        }
      },
      /**
       * merge the props object with defaultProperties object into a new object and return it 
       * @method Built-in_Manifest_Objects.moduleManifest#props
       * @param {Object} props an object which contains some properties
       * @return {Object} the result of merge props with defaultProperties
       */
      props : {
        value : function(props) {
          if (!defaultProperties)
            defaultProperties = exactDefaultProperties(obj.properties);
          return Objects.extend(true, null, defaultProperties, props);
        }
      },
      /**
           * execute the fn(function) defined in selected module. The default argument of fn is the module self.</br>
           * @method Built-in_Manifest_Objects.moduleManifest#execute          
           * @return {Object} the result of executing fn
           * @example
           * 
           * var moduleManifest = manifest.module.get(id);//get the item from module's manifest by id
           * var result = moduleManifest.execute();//execute the fn defined in the item
           * 
           */
      execute : {
        value : function() {
          return obj.fn(obj);
        }
      }
    });
    return obj;
  });

  manifest.module.loadModule = loadModule;

  return manifest.module;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tooltip',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.tooltip',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'tooltip',
    'description': 'Settings for the tooltip that appears when the user hovers over a series or point.',
    'properties' : {
      'visible' : {
        'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : true,
          'description' : 'Set visibility of tooltip.'
      },
     'drawingEffect':{
       'name' : 'drawingEffect',
       'supportedValueType' : 'List',
       'supportedValues' : [ 'normal', 'glossy' ],
           'defaultValue' : 'normal',
           'description' : 'Set drawing effect of Tooltip.',
           'isExported' : true
    }
      },
    'css' : {
      '.viz-tooltip-background' : {
        'description' : 'Define style for the tooltip background.',
        'value' : {
          'fill' : '#ffffff'
        }
      },
      '.viz-tooltip-title' : {
        'description' : 'Define style for the tooltip title.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.viz-tooltip-label' : {
        'description' : 'Define style for the tooltip label.',
        'value' : {
          'fill' : '#333333'
        }
      },
      '.viz-tooltip-value' : {
        'description' : 'Define style for the tooltip value.',
        'value' : {
          'fill' : '#333333'
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.background',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var visibleObj = {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of background.'
      };
  var module = {
    'id' : 'sap.viz.modules.background',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'background',
    'description': 'Settings for the background for the outer chart area.',
    'properties' : {
      'visible' : visibleObj,
    'border' : {
        'name' : 'border',
      'description' : 'Settings for border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : { 
      'left' : {
        'name' : 'left',
        'description' : 'Set left border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'right' : {
        'name' : 'right',
        'description' : 'Set right border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'top' : {
        'name' : 'top',
        'description' : 'Set top border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          }, 
      'bottom' : {
        'name' : 'bottom',
        'description' : 'Set bottom border property.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : visibleObj,
        },
          },
          },
    },
        'drawingEffect':{
          'name' : 'drawingEffect',
            'description' : 'Set drawing effect of background.',
          'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'isExported' : true,
        },
        'direction':{
          'name' : 'direction',
            'description' : 'Set gradient direction of background.',
          'supportedValueType' : 'List',
            'supportedValues' : [ 'horizontal', 'vertical' ],
            'defaultValue' : 'vertical',
        }
    },
    'css' : {
      '.viz-plot-background' : {
        'description' : 'Define style for the plot background.',
        'value' : {
          'fill' : '#ffffff',
        }
      },
      '.viz-plot-background-border' : {
        'description' : 'Define style for the plot background border.',
        'value' : {
          'stroke' : '#d8d8d8',
      'stroke-width' : 1,
      'shape-rendering' : 'crispEdges',
        }
      },
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis.categoryAxisCore',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
}
],
function Setup(TextUtils, NumberUtils, Objects, langManager, TypeUtils) {

    return function() {
            
        var m_position;
        var m_axScale;

        var m_textOffset = 6;
        var m_tickSize = 5;
        
        var m_styleLineSrokeWidth = 1;
        var m_styleGridLineColor = "#d8d8d8";

        var m_disableSpaceLimit = false;
        
        var m_style = null; //used to hold style passed from axis
        var m_props = 
        { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": false, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true,"format": "", },
            "position": "left",
            "color": "#333333"
        }; 

        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;

            if(!m_disableSpaceLimit)
            {
                m_spaceLimit = _spaceLimit;
            }

            return axis;
        }

        var adjustScale = function()
        {
            //we have to adjust the scale because we may not draw all the levels.
            var scaleToDraw = [];
            
            if(m_axScale && m_axScale.length >= 1)
            {
                scaleToDraw.push(m_axScale[0]);
            }
            
            for(var iScale = 1; iScale < m_axScale.length; iScale++)
            {
                var axDomain = m_axScale[iScale].domain;//["a", "b"]
                var axRange = m_axScale[iScale].range;//[[0, 100], [100. 200], ...]

                //count the max text size
                var re = maxLabelTextHeight(axDomain, axRange);
                var isVertical = re.isVertical;

                if(m_position == "left" || m_position == "right")
                {
                    m_axScale[iScale].labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange);
                }
                else
                {
                    m_axScale[iScale].labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical);
                }

                if(m_axScale[iScale].labelsToDraw.length == m_axScale[iScale].domain.length)
                {
                    scaleToDraw.push(m_axScale[iScale]);
                }
            }
            return scaleToDraw;
        }
        
        var drawGridLine = function(selection, x1, y1, x2, y2){
          var gridline = selection.append("line")
                          .attr("y1", y1)
                          .attr("y2", y2)
                          .attr("x1", x1)
                          .attr("x2", x2)
                          .attr("stroke", m_props.color)
                          .attr("stroke-width", m_props.size)
                          .attr("shape-rendering", "crispEdges");
          if(m_props.gridline.type == "dotted")
          {
               gridline.attr("stroke-dasharray", "3, 2");
          }                        
        };

        function axis(selection)
        {
            //we have to adjust the scale
            var scaleToDraw = adjustScale();

            //---we should dicide show or hide somethings because of the spaceLimit
            if(m_spaceLimit >= 0)
            {
                var scaleToAdjust = [];
                var spacings = axis.getPreferredSize().spacings;
                var spaceLeft = m_spaceLimit;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        scaleToAdjust.push(scaleToDraw[i]);
                        spaceLeft -= spacings[i];
                    }
                    else
                    {
                        break;
                    }
                }

                if(scaleToAdjust.length == 0 && scaleToDraw.length > 0)
                {
                    //scaleToAdjust.push(scaleToDraw[0]);//always draw one
                    var lastDomain = [];
                    for (var i = 0; i < scaleToDraw[0].domain.length; i++) {
                        lastDomain.push('');
                    }
                    scaleToAdjust.push({
                            domain : lastDomain, 
                            range : scaleToDraw[0].range
                        });
                }

                scaleToDraw = scaleToAdjust;
            }
            //------------------------------------------------------

            if(m_position == "left")
            {
                var iDraw = 0;
                var lastLevelWidth = 0;

                for(var iScale = 0; iScale < scaleToDraw.length; iScale++, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    var labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange);


                    //count the max text size
                    var re = maxLabelTextWidth(axDomain, axRange);
                    var maxTextWidth = re.maxLabelTextWidth;
                    //var isVertical = re.isVertical;

                    if(!m_props.label.visible)
                    {
                        maxTextWidth = 0;
                    }
                    
                    
                      
                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                  axRange[axRange.length-1][1], 
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                  axRange[axRange.length-1][1]);
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                  axRange[0][0], 
                                  lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                  axRange[0][0]);
                        }
                    }

                    ///////////////drawing the most inner vertical line////////////////
                    if( scaleToDraw.length == 1 ) {
                        ////////////////in single case, also include the first and last tick////////
                        //<path d="M150 0 L75 200 L225 200 Z" />
                        var x1 = lastLevelWidth + (maxTextWidth + 2*m_textOffset);
                        var x2 = lastLevelWidth + (maxTextWidth + 2*m_textOffset);
                        var y1 = axRange[0][0];
                        var y2 = axRange[axRange.length-1][1];

                        var dPath  = "M" + (x1-m_tickSize) + " " + y1
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2-m_tickSize) + " " + y2;

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");

                    }else if(scaleToDraw.length >= 2 && (iScale == scaleToDraw.length -1)) {
                        var axLine = selection.append("line")
                                    .attr("x1", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                                    .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                                    .attr("y1", axRange[0][0])
                                    .attr("y2", axRange[axRange.length-1][1])
                                    .attr("class", "domain")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }
                    /////////////// end of drawing the most inner vertical line////////////////


                    ///////////////drawing vertical line for each level, based on lastLevelWidth///// 
                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", lastLevelWidth)
                        .attr("x2", lastLevelWidth)
                        .attr("y1", axRange[0][0])
                        .attr("y2", axRange[axRange.length-1][1])
                        .attr("class", "domain")
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", "crispEdges");
                    }
                    ///////////////end of drawing vertical line for each level, based on lastLevelWidth/////

                    //draw gridline in the last scaleToDraw///////////////////////
                    //FIXME Jimmy/9/22/2012 currently the grid line only used for
                    //multi charts. we have a bug for the last gridline here, if for example
                    //we draw gridline for yaxis on [i][1], then the last gridline
                    //will override xaxis. so we have to seperate last gridline
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][0]);
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][1], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][1]);
                        }
                      }
                      //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
                      drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length,
                                axRange[0][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length,
                                axRange[i - 1][1]
                                );
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////


                    for(var i = 0; i < axDomain.length; i++)
                    {
                        /////////////////////////////draw tick for single case, horizontal line for multi case////////
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                          //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][0] will not be equal with axRange[i-1][1]?
                          if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                          {
                              var axTick1 = selection.append("line")
                                          .attr("x1", (maxTextWidth + 2*m_textOffset) - m_tickSize)
                                          .attr("x2", (maxTextWidth + 2*m_textOffset))
                                          .attr("y1", axRange[i][0])
                                          .attr("y2", axRange[i][0])
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", "crispEdges");

                          }
                          
                          ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                          if(i != (axDomain.length - 1)){
                            var axTick2 = selection.append("line")
                                        .attr("x1", (maxTextWidth + 2*m_textOffset) - m_tickSize)
                                        .attr("x2", (maxTextWidth + 2*m_textOffset))
                                        .attr("y1", axRange[i][1])
                                        .attr("y2", axRange[i][1])
                                        .attr("stroke", m_props.color)
                                        .attr("stroke-width", m_props.lineSize)
                                        .attr("shape-rendering", "crispEdges");
                          }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", lastLevelWidth)
                            .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                            .attr("y1", axRange[i][0])
                            .attr("y2", axRange[i][0])
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", "crispEdges");
                            
                            //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", lastLevelWidth)
                              .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                              .attr("y1", axRange[i][1])
                              .attr("y2", axRange[i][1])
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", "crispEdges"); 
                            }
                        }
                        /////////////////////////////draw tick for single case, horizontal line for multi case////////
                    }

                    
                    for(var i = 0; i < labelsToDraw.length; i++)
                    {
                      var m_label = labelsToDraw[i].text? labelsToDraw[i].text:'';
                        if(m_props.label.visible)
                        {
                            //selection.append("circle").attr("cx", lastLevelWidth + maxTextWidth - m_textOffset).attr("cy", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2). attr("r", 3);
                            var axLabels = selection.append("text")
                                          .attr("x", lastLevelWidth + maxTextWidth + m_textOffset)
                                          .attr("y", labelsToDraw[i].y)
                                          .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                          .attr("text-anchor", "end") // text-align
                                          .text(m_label)
                                          .attr("fill", m_style.label.fill)
                                          .attr("font-size", m_style.label['font-size'])
                                          .attr("font-weight", m_style.label['font-weight'])
                                          .attr("font-family", m_style.label['font-family']); 

                            adjustLabelForIE(axLabels);
                        }

                        
                    }

                    lastLevelWidth += (maxTextWidth + 2*m_textOffset);
                }
            }
            else if(m_position == "right")
            {
                var iDraw = 0;
                var lastLevelWidth = 0;
                
                for(var iScale = (scaleToDraw.length-1); iScale >= 0; iScale--, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextWidth(axDomain, axRange);
                    var maxTextWidth = re.maxLabelTextWidth;
                    //var isVertical = re.isVertical;

                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth, 
                                  axRange[axRange.length-1][1], 
                                  lastLevelWidth-m_props.gridline.length, 
                                  axRange[axRange.length-1][1]);
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  lastLevelWidth, 
                                  axRange[0][0], 
                                  lastLevelWidth-m_props.gridline.length, 
                                  axRange[0][0]);
                        }
                    }

                    if((scaleToDraw.length == 1) )
                    {
                        //<path d="M150 0 L75 200 L225 200 Z" />
                        var x1 = lastLevelWidth;
                        var x2 = lastLevelWidth;
                        var y1 = axRange[0][0];
                        var y2 = axRange[axRange.length-1][1];

                        var dPath  = "M" + (x1+m_tickSize) + " " + y1
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x1+m_tickSize) + " " + y2;

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }
                    else if(scaleToDraw.length >= 2 && (iScale == (scaleToDraw.length-1)) ) 
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", lastLevelWidth)
                                    .attr("x2", lastLevelWidth)
                                    .attr("y1", axRange[0][0])
                                    .attr("y2", axRange[axRange.length-1][1])
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                        .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                        .attr("y1", axRange[0][0])
                        .attr("y2", axRange[axRange.length-1][1])
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", "crispEdges");
                    }
                    
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][0], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][0]);
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset), 
                                axRange[i][1], 
                                lastLevelWidth + (maxTextWidth + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i][1]);
                        }
                      }

                    }

                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", 0)
                                            .attr("x2", m_tickSize)
                                            .attr("y1", axRange[i][0])
                                            .attr("y2", axRange[i][0])
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", "crispEdges");
                            }
                            if(i != (axDomain.length - 1)){
                              var axTick2 = selection.append("line")
                                          .attr("x1", 0)
                                          .attr("x2", m_tickSize)
                                          .attr("y1", axRange[i][1])
                                          .attr("y2", axRange[i][1])
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", "crispEdges");
                            }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", lastLevelWidth)
                            .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                            .attr("y1", axRange[i][0])
                            .attr("y2", axRange[i][0])
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", 1)
                            .attr("shape-rendering", "crispEdges");
                            
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", lastLevelWidth)
                              .attr("x2", lastLevelWidth + (maxTextWidth + 2*m_textOffset))
                              .attr("y1", axRange[i][1])
                              .attr("y2", axRange[i][1])
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", "crispEdges");
                            }
                        }
                    }

                    var labelsToDraw = buildLeftRightToDrawLabels(axDomain, axRange);
                    for(var i = 0; i < labelsToDraw.length; i++)
                    {
                      var m_label = labelsToDraw[i].text? labelsToDraw[i].text:'';
                        if(m_props.label.visible)
                        {
                            //selection.append("circle").attr("cx", lastLevelWidth + 100000).attr("cy", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2). attr("r", 3);
                            var axLabels = selection.append("text")
                                          .attr("x", lastLevelWidth + m_textOffset)
                                          .attr("y", labelsToDraw[i].y)
                                          .attr("text-anchor", "start") // text-align
                                          .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                          .text(m_label)
                                          .attr("fill", m_style.label.fill)
                                          .attr("font-size", m_style.label['font-size'])
                                          .attr("font-weight", m_style.label['font-weight'])
                                          .attr("font-family", m_style.label['font-family']); 

                            adjustLabelForIE(axLabels);
                        }
                    }

                    lastLevelWidth += (maxTextWidth + 2*m_textOffset);
                }
            }
            else if(m_position == "bottom")
            {
                var iDraw = 0;
                var lastLevelHeight = 0;
                
                for(var iScale = (scaleToDraw.length - 1); iScale >= 0; iScale--, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextHeight(axDomain, axRange);
                    var maxTextHeight = re.maxLabelTextHeight;
                    var isVertical = re.isVertical;

                    if(iScale == (scaleToDraw.length - 1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  axRange[0][0],  
                                  lastLevelHeight, 
                                  axRange[0][0],
                                  lastLevelHeight-m_props.gridline.length
                                  );
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  axRange[axRange.length-1][0],  
                                  lastLevelHeight, 
                                  axRange[axRange.length-1][0],
                                  lastLevelHeight-m_props.gridline.length
                                  );
                        }
                    }

                    if(scaleToDraw.length == 1)
                    {
                        var x1 = axRange[0][0];
                        var x2 = axRange[axRange.length-1][1];
                        var y1 = lastLevelHeight;
                        var y2 = lastLevelHeight;

                        var dPath  = "M" + x1 + " " + (y1+m_tickSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2+m_tickSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }
                    else if( scaleToDraw.length >= 2 && (iScale == scaleToDraw.length-1) )
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", axRange[0][0])
                                    .attr("x2", axRange[axRange.length-1][1])
                                    .attr("y1", lastLevelHeight)
                                    .attr("y2", lastLevelHeight)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", axRange[0][0])
                        .attr("x2", axRange[axRange.length-1][1])
                        .attr("y1", lastLevelHeight + maxTextHeight + 2*m_textOffset)
                        .attr("y2", lastLevelHeight + maxTextHeight + 2*m_textOffset)
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", "crispEdges");
                    }
                    
                    //draw gridline in the last scaleToDraw///////////////////////
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset),
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset), 
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        }
                      }
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////


                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", axRange[i][0])
                                            .attr("x2", axRange[i][0])
                                            .attr("y1", 0)
                                            .attr("y2", m_tickSize)
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", "crispEdges");
                            }
                            if(i != (axDomain.length - 1)){
                              var axTick2 = selection.append("line")
                                          .attr("x1", axRange[i][1])
                                          .attr("x2", axRange[i][1])
                                          .attr("y1", 0)
                                          .attr("y2", m_tickSize)
                                          .attr("stroke", m_props.color)
                                          .attr("stroke-width", m_props.lineSize)
                                          .attr("shape-rendering", "crispEdges");
                            }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", axRange[i][0])
                            .attr("x2", axRange[i][0])
                            .attr("y1", lastLevelHeight)
                            .attr("y2", lastLevelHeight + 2*m_textOffset + maxTextHeight)
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", "crispEdges");
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", axRange[i][1])
                              .attr("x2", axRange[i][1])
                              .attr("y1", lastLevelHeight)
                              .attr("y2", lastLevelHeight + 2*m_textOffset + maxTextHeight)
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", "crispEdges");
                            }
                        }
                    }

                    var labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical);
                    drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length != 1);

                    lastLevelHeight += (maxTextHeight + 2*m_textOffset);
                }
            }
            else if(m_position == "top")
            {
                var iDraw = 0;
                var lastLevelHeight = 0;
                
                for(var iScale = 0; iScale < scaleToDraw.length; iScale++, iDraw++)
                {
                    if(!m_props.label.visible && iScale != (scaleToDraw.length-1))
                    {
                        continue;
                    }

                    var axDomain = scaleToDraw[iScale].domain;//["a", "b"]
                    var axRange = scaleToDraw[iScale].range;//[[0, 100], [100. 200], ...]

                    //count the max text size
                    var re = maxLabelTextHeight(axDomain, axRange);
                    var maxTextHeight = re.maxLabelTextHeight;
                    var isVertical = re.isVertical;

                    if(!m_props.label.visible)
                    {
                        maxTextHeight = 0;
                    }

                    if(iScale == (scaleToDraw.length-1))
                    {
                        if(m_props.gridline.showFirstLine)
                        {
                            drawGridLine(selection,
                                  axRange[0][0],  
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight, 
                                  axRange[0][0],
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight+m_props.gridline.length
                                  );
                        }

                        if(m_props.gridline.showLastLine)
                        {
                            drawGridLine(selection,
                                  axRange[axRange.length-1][1],  
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight, 
                                  axRange[axRange.length-1][1],
                                  maxTextHeight + 2*m_textOffset + lastLevelHeight+m_props.gridline.length
                                  );
                        }
                    }

                    if( (scaleToDraw.length == 1) )
                    {
                        var x1 = axRange[0][0];
                        var x2 = axRange[axRange.length-1][1];
                        var y1 = maxTextHeight + 2*m_textOffset + lastLevelHeight;
                        var y2 = maxTextHeight + 2*m_textOffset + lastLevelHeight;

                        var dPath  = "M" + x1 + " " + (y1-m_tickSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2-m_tickSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }
                    else if( scaleToDraw.length >= 2 && (iScale == scaleToDraw.length-1) )
                    {
                        var axLine = selection.append("line")
                                    .attr("x1", axRange[0][0])
                                    .attr("x2", axRange[axRange.length-1][1])
                                    .attr("y1", maxTextHeight + 2*m_textOffset + lastLevelHeight)
                                    .attr("y2", maxTextHeight + 2*m_textOffset + lastLevelHeight)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }

                    if(scaleToDraw.length >= 2 && m_props.label.visible)
                    {
                         selection.append("line")
                        .attr("x1", axRange[0][0])
                        .attr("x2", axRange[axRange.length-1][1])
                        .attr("y1", lastLevelHeight)
                        .attr("y2", lastLevelHeight)
                        .attr("stroke", m_props.color)
                        .attr("stroke-width", m_props.lineSize)
                        .attr("shape-rendering", "crispEdges");
                    }
                    
                    //draw gridline in the last scaleToDraw///////////////////////
                    if(m_props.gridline.visible && iScale == (scaleToDraw.length-1)){
                      for(var i = 0; i < axDomain.length; i++)
                      {
                        drawGridLine(selection,
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset),
                                axRange[i][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                          drawGridLine(selection,
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset), 
                                axRange[i][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                        }
                      }
                      //we need an extra line to close the gridline area, otherwise, if we have only one axis, the gridline area will be kept open
                      drawGridLine(selection,
                                axRange[0][0],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length, 
                                axRange[i - 1][1],
                                lastLevelHeight + (maxTextHeight + 2*m_textOffset) + m_props.gridline.length 
                                );
                    }
                    //end draw gridline in the last scaleToDraw///////////////////////

                    for(var i = 0; i < axDomain.length; i++)
                    {
                        if(scaleToDraw.length == 1 || (scaleToDraw.length != 1 && !m_props.label.visible))//draw ticks
                        {
                            if(i > 0 && (axRange[i][0] != axRange[i-1][1]))
                            {
                                var axTick1 = selection.append("line")
                                            .attr("x1", axRange[i][0])
                                            .attr("x2", axRange[i][0])
                                            .attr("y1", (maxTextHeight + 2*m_textOffset))
                                            .attr("y2", (maxTextHeight + 2*m_textOffset)-m_tickSize)
                                            .attr("stroke", m_props.color)
                                            .attr("stroke-width", m_props.lineSize)
                                            .attr("shape-rendering", "crispEdges");
                            }
                            
                            ////////////////in single case, first and last tick is already drawn in path, ignore them here////////
                          if(i != (axDomain.length - 1)){
                            var axTick2 = selection.append("line")
                                        .attr("x1", axRange[i][1])
                                        .attr("x2", axRange[i][1])
                                        .attr("y1", (maxTextHeight + 2*m_textOffset))
                                        .attr("y2", (maxTextHeight + 2*m_textOffset)-m_tickSize)
                                        .attr("stroke", m_props.color)
                                        .attr("stroke-width", m_props.lineSize)
                                        .attr("shape-rendering", "crispEdges");
                          }
                        }
                                      
                        if(scaleToDraw.length >= 2 && m_props.label.visible)
                        {
                             selection.append("line")
                            .attr("x1", axRange[i][0])
                            .attr("x2", axRange[i][0])
                            .attr("y1", lastLevelHeight)
                            .attr("y2", lastLevelHeight + (maxTextHeight + 2*m_textOffset))
                            .attr("stroke", m_props.color)
                            .attr("stroke-width", m_props.lineSize)
                            .attr("shape-rendering", "crispEdges");
                            //Jimmy/9/22/2012 to @Catkin, in which scenario axRange[i][1] will not be equal with axRange[i+1][0]?
                            if((i == (axDomain.length - 1)) || (axRange[i][1] != axRange[i+1][0])){
                               selection.append("line")
                              .attr("x1", axRange[i][1])
                              .attr("x2", axRange[i][1])
                              .attr("y1", lastLevelHeight)
                              .attr("y2", lastLevelHeight + (maxTextHeight + 2*m_textOffset))
                              .attr("stroke", m_props.color)
                              .attr("stroke-width", m_props.lineSize)
                              .attr("shape-rendering", "crispEdges");
                            }
                        }
                    }

                    var labelsToDraw = buildTopBottomToDrawLabels(axDomain, axRange, isVertical);
                    drawTopBottomLabels(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, scaleToDraw.length != 1);
                    lastLevelHeight += (maxTextHeight + 2*m_textOffset);
                }
            }

        };

        var adjustLabelForIE = function(text)
        {
            if(jQuery.browser.msie)
            {
                //dominant-baseline does not work
                var textHeight = m_style.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        var buildLeftRightToDrawLabels = function(allLabels, allLabelsLocation)
        {
            //we always draw the bottom label for yAxis.

            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < allLabels.length; i++)
            {
                var item = {};
                item.text = isInvalidString(allLabels[i])?langManager.get('IDS_ISNOVALUE'): allLabels[i];

                //count y1 and y2
                var itemHeight = fastMeasure (item.text, m_style.label).height;
                var centerY = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0])/2;

                item.y = centerY;
                item.y1 = centerY - itemHeight/2;
                item.y2 = centerY + itemHeight/2;

                allTicksLabels.push(item);
            }

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];
            for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
            {
                var isDrawable = true;
                for(var i = (allTicksLabels.length - 1); i >= 0 ; i-=(iBeyond+1))
                {   
                    var item = allTicksLabels[i];
                    if(i != (allTicksLabels.length - 1))
                    {
                        var previousIndex = i + (iBeyond+1);

                            if(allTicksLabels[i].y2 >= allTicksLabels[previousIndex].y1)
                            {
                                isDrawable = false;
                                break;
                            }
                    }
                    ticksLabelsToDraw.push(item);
                }
                if(isDrawable) //iBeyond = (allTicksLabels.length - 1) is always drawable
                {
                    break;
                }
                else
                {
                    ticksLabelsToDraw = [];
                }
            }

            return ticksLabelsToDraw;
        }

        var buildTopBottomToDrawLabels = function(allLabels, allLabelsLocation, isVertical)
        {
            //we always draw the first label for xAxis.

            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < allLabels.length; i++)
            {
                var item = {};
                item.text =  isInvalidString(allLabels[i])?langManager.get('IDS_ISNOVALUE'): allLabels[i];

                //count x1 and x2
                var itemWidth;
                if(isVertical)
                {
                    itemWidth = fastMeasure (item.text, m_style.label).height;
                }
                else
                {
                    itemWidth = fastMeasure (item.text, m_style.label).width;
                }

                var centerX = allLabelsLocation[i][0] + (allLabelsLocation[i][1] - allLabelsLocation[i][0])/2;

                item.x = centerX;
                item.x1 = centerX - itemWidth/2;
                item.x2 = centerX + itemWidth/2;

                allTicksLabels.push(item);
            }

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];
            for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
            {
                var isDrawable = true;
                for(var i = 0; i < allTicksLabels.length; i+=(iBeyond+1))
                {   
                    var item = allTicksLabels[i];
                    if(i != 0)
                    {
                        var previousIndex = i - (iBeyond+1);

                        if(allTicksLabels[i].x1 <= allTicksLabels[previousIndex].x2)
                        {
                            isDrawable = false;
                            break;
                        }
                    }
                    ticksLabelsToDraw.push(item);
                }
                if(isDrawable) //iBeyond = (allTicksLabels.length - 1) is always drawable
                {
                    break;
                }
                else
                {
                    ticksLabelsToDraw = [];
                }
            }
            //console.log(ticksLabelsToDraw);

            return ticksLabelsToDraw;
        }

        var drawTopBottomLabels = function(selection, labelsToDraw, lastLevelHeight, maxTextHeight, axDomain, isVertical, isHierarchical)
        {
            for(var i = 0; i < labelsToDraw.length; i++)
            {
              var label = labelsToDraw[i].text? labelsToDraw[i].text:'';
                if(m_props.label.visible)
                {
                    //selection.append("circle").attr("cx", axRange[i][0] + (axRange[i][1] - axRange[i][0])/2).attr("cy", lastLevelHeight + maxTextHeight/2 + m_textOffset). attr("r", 5);                               
                    var axLabels = selection.append("text")
                                  .attr("x", labelsToDraw[i].x)
                                  .attr("y", lastLevelHeight + maxTextHeight/2 + m_textOffset)
                                  .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                                  .attr("text-anchor", "middle") // text-align
                                  .text(label)
                                  .attr("fill", m_style.label.fill)
                                  .attr("font-size", m_style.label['font-size'])
                                  .attr("font-weight", m_style.label['font-weight'])
                                  .attr("font-family", m_style.label['font-family']); 

                    if(isVertical)
                    {
                        if(!isHierarchical){
                          if(m_position == 'top'){
                            axLabels.attr('text-anchor', 'start')
                            .attr("y", lastLevelHeight + maxTextHeight + m_textOffset);
                          }else if(m_position == 'bottom'){
                            axLabels.attr("y", lastLevelHeight + m_textOffset).attr('text-anchor', 'end');
                          }
                        }
                        
                        var ac = "-90";
                        axLabels.attr("transform","rotate( " + ac + " " + axLabels.attr("x") + " "  + axLabels.attr("y") + " )");
                       
                    }
                    adjustLabelForIE(axLabels);
                }
            }
        }


        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = Objects.extend(true, m_props, _properties);
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.getPreferredSize = function() {

            var scaleToDraw = adjustScale();

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            for(var i = 0; i < scaleToDraw.length; i++)
            {
                if(!m_props.label.visible && i != (scaleToDraw.length-1))
                {
                    continue;
                }

                var axDomain = scaleToDraw[i].domain;//["a", "b"]
                var axRange = scaleToDraw[i].range;//[[0, 100], [100. 200], ...]

                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = Math.abs(axRange[axRange.length-1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
                    
                    var offsetHeight = 0;
                    if(m_props.label.visible)
                    {
                        offsetHeight += maxLabelTextHeight(axDomain, axRange).maxLabelTextHeight;
                    }

                    offsetHeight += 2*m_textOffset;
                    axisHeight += offsetHeight;

                    axisSpacings.push(offsetHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    var offsetWidth = 0;

                    if(m_props.label.visible)
                    {
                        offsetWidth += maxLabelTextWidth(axDomain, axRange).maxLabelTextWidth;
                    }
                    offsetWidth += 2*m_textOffset;

                    axisWidth += offsetWidth;
                    axisSpacings.push(offsetWidth);

                    axisHeight = Math.abs(axRange[axRange.length-1][1] - axRange[0][0]) + m_styleLineSrokeWidth;
                }
            }

            //--------------
            if(m_spaceLimit >= 0)
            {
                var spacings = axisSpacings;
                var spaceLeft = m_spaceLimit;

                var spacingToDraw = 0;


                for(var i = 0; i < spacings.length; i++)
                {
                    if(spaceLeft >= spacings[i])
                    {
                        spacingToDraw += spacings[i];
                        spaceLeft -= spacings[i];
                    }
                    else
                    {
                        break;
                    }
                }

                if(spacingToDraw == 0 && spacings.length > 0)
                {
                    spacingToDraw += spacings[0];
                }


                if(m_position == "bottom" || m_position == "top")
                {
                    axisHeight = spacingToDraw;
                }
                else if(m_position == "left" || m_position == "right")
                {
                    axisWidth = spacingToDraw;
                }
            }

            //------------------------------------

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,
            };
        };


        var maxLabelTextHeight = function (textArray, rangeArray)
        {
            var re = {"maxLabelTextHeight": 0, "isVertical": false};
            var maxTextHeight = 0;
            var isVerticalFont = false;

            var heightArray = [];
            var widthArray = [];

            for(var i = 0; i < textArray.length; i++)
            {
                var tSize = fastMeasure(textArray[i], m_style.label);

                var tHeight = tSize.height;
                var tWidth = tSize.width;

                if((tHeight < tWidth) && tWidth > (rangeArray[i][1]-rangeArray[i][0]) )
                {
                    if(m_position == "top" || m_position == "bottom")
                    {
                        isVerticalFont = true;
                        //console.log(isVerticalFont);
                    }
                }

                heightArray.push(tHeight);
                widthArray.push(tWidth);
            }

            for(var i = 0; i < textArray.length; i++)
            {
                if(isVerticalFont)
                {
                    if(maxTextHeight < widthArray[i])
                    {
                        maxTextHeight = widthArray[i];
                    }
                }
                else
                {
                    if(maxTextHeight < heightArray[i])
                    {
                        maxTextHeight = heightArray[i];
                    }
                }
            }

            re.maxLabelTextHeight = maxTextHeight;
            re.isVertical = isVerticalFont;
            
            return re;
        }

        var maxLabelTextWidth = function (textArray, rangeArray)
        {
            var re = {"maxLabelTextWidth": 0, "isVertical": false};
            var maxTextWidth = 0;
            var isVerticalFont = false;

            var heightArray = [];
            var widthArray = [];

            for(var i = 0; i < textArray.length; i++)
            {
                var tSize = fastMeasure( isInvalidString(textArray[i])?langManager.get('IDS_ISNOVALUE'):textArray[i] , m_style.label);

                var tHeight = tSize.height;
                var tWidth = tSize.width;

                if((tHeight < tWidth) && tWidth > (rangeArray[i][1]-rangeArray[i][0]) )
                {
                    if(m_position == "top" || m_position == "bottom")
                    {
                        isVerticalFont = true;
                    }
                }

                heightArray.push(tHeight);
                widthArray.push(tWidth);
            }

            for(var i = 0; i < textArray.length; i++)
            {
                if(isVerticalFont)
                {
                    if(maxTextWidth < heightArray[i])
                    {
                        maxTextWidth = heightArray[i];
                    }
                }
                else
                {
                    if(maxTextWidth < widthArray[i])
                    {
                        maxTextWidth = widthArray[i];
                    }
                }
            }

            re.maxLabelTextWidth = maxTextWidth;
            re.isVertical = isVerticalFont;

            return re;
        }
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        };
        
        var isInvalidString = function(str){
           if( typeof (str) != "string" && NumberUtils.isNoValue(str))
             {
                   return true;
             }
           return false;
        }

        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis.valueAxisCore',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
}
],
function Setup(TextUtils, NumberUtils, Objects) {

    return function() {
   
        var m_position;
        var m_axScale = null;

        var m_tickSize = 5;
        var m_textOffset = 4;

        var m_axDefaultTickNum = 7;

        var m_styleLineSrokeWidth = 1;
        var m_styleAxisColor = "#6c6c6c";
        var m_styleGridLineColor = "#d8d8d8";
        var m_styleGridIncisedLineColor = "#ffffff";
        var m_styleAxisLabelColor = "#333333";
        
        var m_style = null;
        var m_props = { 
            "title": {"visible": false, "text": undefined,},
            "gridline": {"visible": true, "color": m_styleGridLineColor, "showFirstLine": false, "length": 0, "showLastLine": false, "type":"line"},
            "type" : "value",
            "visible" : true,
            "label": {"visible": true,"numberFormat": "", },
            "position": "left",
            "color": m_styleAxisColor,
            "axisline" : {"visible": true},
        };

        var m_spaceLimit = -1;
        axis.spaceLimit = function(_spaceLimit)
        {
            if (!arguments.length) 
                return m_spaceLimit;
            m_spaceLimit = _spaceLimit;
            return axis;
        }

        function axis(selection) {
                
                var axRange = m_axScale.range();//[0, 500]
                var axDomain = m_axScale.domain();//[-100, 2000]

                if(axRange[0] == 0 && axRange[1] == 0)
                {
                    return;//do not draw value axis
                }

                var axTicksLabels = getTicksLabel();

                if(m_position == "bottom")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if  ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", 0)
                                    .attr("y2", m_tickSize + 1)//line contains the first but not the last point
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");


                        var drawLine = function()
                        {
                             var line = selection.append("line")
                            .attr("x1", m_axScale(axTicksLabels[i].value))
                            .attr("x2", m_axScale(axTicksLabels[i].value))
                            .attr("y1", -m_props.gridline.length)
                            .attr("y2", 0)
                            .attr("stroke", m_props.gridline.color)
                            .attr("stroke-width", m_props.gridline.size)
                            .attr("shape-rendering", "crispEdges");

                            if(m_props.gridline.type == "dotted")
                            {
                                 line.attr("stroke-dasharray", "3, 2");
                            }
                            
                            if(m_props.gridline.type == "incised")
                            {
                                var line = selection.append("line")
                                .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                .attr("y1", -m_props.gridline.length)
                                .attr("y2", 0)
                                .attr("stroke", m_styleGridIncisedLineColor)
                                .attr("stroke-width", m_props.gridline.size)
                                .attr("shape-rendering", "crispEdges");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "Bottom", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = 0;
                        var y2 = 0;

                        var endSize = 0;//m_tickSize

                        var dPath  = "M" + x1 + " " + (y1 + endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 + endSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }
                }
                else if(m_position == "top")
                {
                    var maxTextHeight = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextHeight = maxLabelTextHeight(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextHeight + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }
                    
                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", m_axScale(axTicksLabels[i].value))
                                    .attr("x2", m_axScale(axTicksLabels[i].value))
                                    .attr("y1", maxTextHeight + nOffset*m_textOffset)
                                    .attr("y2", maxTextHeight + nOffset*m_textOffset + m_tickSize)
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("x1", m_axScale(axTicksLabels[i].value))
                                        .attr("x2", m_axScale(axTicksLabels[i].value))
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering", "crispEdges");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("x1", m_axScale(axTicksLabels[i].value)-1)
                                        .attr("x2", m_axScale(axTicksLabels[i].value)-1)
                                        .attr("y1", maxTextHeight + m_tickSize + nOffset*m_textOffset)
                                        .attr("y2", maxTextHeight + m_tickSize + nOffset*m_textOffset + m_props.gridline.length)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering", "crispEdges");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                    }

                    if(m_props.label.visible)
                    {
                        drawTopBottomLabels(selection, "Top", axTicksLabels, maxTextHeight);
                    }

                    if (m_props.axisline.visible) {
                        var x1 = axRange[0];
                        var x2 = axRange[1];
                        var y1 = maxTextHeight + m_tickSize + nOffset*m_textOffset;
                        var y2 = maxTextHeight + m_tickSize + nOffset*m_textOffset;

                        var endSize = 0;//m_tickSize
                        var dPath  = "M" + x1 + " " + (y1 - endSize);
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + x2 + " " + (y2 - endSize);

                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }

                }
                else if(m_position == "left")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels);

                    //count the max text width
                    var maxTextWidth = 0;
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    var nOffset = 1;
                    if(m_props.label.visible)
                    {
                        nOffset = 2;
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", maxTextWidth + nOffset*m_textOffset)
                                    .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering", "crispEdges");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }

                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("x1", maxTextWidth + nOffset*m_textOffset + m_tickSize)
                                        .attr("x2", maxTextWidth + nOffset*m_textOffset + m_tickSize + m_props.gridline.length)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering", "crispEdges");
                            }
                            
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }
                        
                        //selection.append("circle").attr("cx", maxTextWidth).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection.append("text")
                           .attr("x", maxTextWidth + m_textOffset)
                           .attr("y", m_axScale(axTicksLabels[i].value))
                           .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                           .attr("text-anchor", "end") // text-align
                           .text(axTicksLabels[i].text)
                           .attr("fill", m_style.label.fill)
                           .attr("font-size", m_style.label['font-size'])
                           .attr("font-weight", m_style.label['font-weight'])
                           .attr("font-family", m_style.label['font-family']);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var x2 = maxTextWidth + nOffset*m_textOffset + m_tickSize;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 - endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 - endSize) + " " + y2;
                        
                        var axLine = selection.append("path")
                                    .attr("d", dPath)
                                    .attr("fill", "none")
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");
                    }
                }
                else if(m_position == "right")
                {
                    //we must change axTicksLabels, remove some lable array items for label management
                    //console.log(axTicksLabels);
                    axTicksLabels = buildToDrawLabels(axTicksLabels);
                    if(m_props.label.visible) {
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        maxTextWidth = maxLabelTextWidth(textArray);
                    }
                    if ((m_spaceLimit != -1) && (maxTextWidth + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2 > m_spaceLimit)) {
                        axTicksLabels = [];
                    }

                    for(var i = 0; i < axTicksLabels.length; i++)
                    {
                        var axTick = selection.append("line")
                                    .attr("x1", 0)
                                    .attr("x2", m_tickSize)
                                    .attr("y1", m_axScale(axTicksLabels[i].value))
                                    .attr("y2", m_axScale(axTicksLabels[i].value))
                                    .attr("stroke", m_props.color)
                                    .attr("stroke-width", m_props.lineSize)
                                    .attr("shape-rendering", "crispEdges");

                        var drawLine = function()
                        {
                            var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value))
                                        .attr("y2", m_axScale(axTicksLabels[i].value))
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_props.gridline.color)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering", "crispEdges");

                            if(m_props.gridline.type == "dotted")
                            {
                                 gridline.attr("stroke-dasharray", "3, 2");
                            }
                            if(m_props.gridline.type == "incised")
                            {
                                var gridline = selection.append("line")
                                        .attr("y1", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("y2", m_axScale(axTicksLabels[i].value)+1)
                                        .attr("x1", -m_props.gridline.length)
                                        .attr("x2", 0)
                                        .attr("stroke", m_styleGridIncisedLineColor)
                                        .attr("stroke-width", m_props.gridline.size)
                                        .attr("shape-rendering", "crispEdges");
                            }
                        };

                        if( i == 0 && m_props.gridline.showFirstLine)
                        {
                             drawLine();
                        }
                        else if ( i == (axTicksLabels.length - 1) && m_props.gridline.showLastLine)
                        {
                             drawLine();
                        }
                        else if ( (i != (axTicksLabels.length - 1))
                               && (i != 0)
                               && m_props.gridline.visible )
                        {
                             drawLine();
                        }

                        //selection.append("circle").attr("cx", m_tickSize + m_textOffset).attr("cy", m_axScale(axTicksLabels.value[i])). attr("r", 3);
                        if(m_props.label.visible)
                        {
                            var text = selection.append("text")
                            .attr("x", m_tickSize + m_textOffset)
                            .attr("y", m_axScale(axTicksLabels[i].value))
                            .attr("dominant-baseline", "middle")//"auto")//"hanging")//"central")
                            .attr("text-anchor", "start") // text-align
                            .text(axTicksLabels[i].text)
                            .attr("fill", m_style.label.fill)
                            .attr("font-size", m_style.label['font-size'])
                            .attr("font-weight", m_style.label['font-weight'])
                            .attr("font-family", m_style.label['font-family']);

                            adjustLabelForIE(text);
                        }
                    }

                    if (m_props.axisline.visible) {
                        var x1 = 0;
                        var x2 = 0;
                        var y1 = axRange[0];
                        var y2 = axRange[1];

                        var endSize = 0;//m_tickSizes
                        var dPath  = "M" + (x1 + endSize) + " " + y1;
                            dPath += "L" + x1 + " " + y1;
                            dPath += "L" + x2 + " " + y2;
                            dPath += "L" + (x2 + endSize) + " " + y2;

                        var axLine = selection.append("path")
                                .attr("d", dPath)
                                .attr("fill", "none")
                                .attr("stroke", m_props.color)
                                .attr("stroke-width", m_props.lineSize)
                                .attr("shape-rendering", "crispEdges");
                    }
                }
            };

        var adjustLabelForIE = function(text)
        {
            if(jQuery.browser.msie)
            {
                //dominant-baseline does not work
                var textHeight = m_style.label['font-size'].toString();
                var indexPX = textHeight.indexOf("px");
                if(indexPX >= 0)
                {
                    textHeight = textHeight.substr(0, indexPX);
                }

                //textHeight = fastMeasure(text, m_style.label).height;
                var y = text.attr("y");
                text.attr("y", Number(y) + textHeight/2);
                text.attr("dominant-baseline", "auto");
            }
        }

        axis.position = function(_position) {
            if (!arguments.length) 
                return m_position;
            m_position = _position;
            return axis;
        };
        
        axis.style = function(_style) {
          if(arguments.length == 0)
            return m_style;
          m_style = Objects.extend(true, m_style, _style);
          return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = extendObj(m_props, _properties);
            return axis;
        };

        axis.axScale = function(_axScale) {
            if (!arguments.length) 
                return m_axScale;
            m_axScale = _axScale;
            return axis;
        };

        axis.startPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = getTicksLabel();
                
                var labelSize = 0;
                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[0].text, m_style.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.endPadding = function() {
            if(m_axScale)
            {
                var axTicksLabels = getTicksLabel();

                var labelSize = 0;

                if(axTicksLabels.length > 0)
                {
                    labelSize = fastMeasure(axTicksLabels[axTicksLabels.length-1].text, m_style.label);
                }
                if(labelSize == 0){
                  return 0;
                }
                if(m_position == "top" || m_position == "bottom")
                {
                    return labelSize.width/2;
                }
                else
                {
                    return labelSize.height/2;
                }
            }
            else
            {
                return 0;
            }
        };

        axis.getPreferredSize = function() {

            var axDomain = m_axScale.domain();//[0, 100]
            var axRange = m_axScale.range();//[0, 200]

            var axisWidth = 0;
            var axisHeight = 0;

            var axisSpacings = [];

            if( !(axRange[0] == 0 && axRange[1] == 0) )
            {
                if(m_position == "bottom" || m_position == "top")
                {
                    axisWidth = Math.abs(axRange[1] - axRange[0]) + m_styleLineSrokeWidth;
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = getTicksLabel();
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisHeight = maxLabelTextHeight(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisHeight = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisHeight);
                }
                else if(m_position == "left" || m_position == "right")
                {
                    if(m_props.label.visible)
                    {
                        var axTicksLabels = getTicksLabel();
                        var textArray = [];
                        for(var i = 0; i < axTicksLabels.length; i++)
                        {
                            textArray.push(axTicksLabels[i].text);
                        }
                        axisWidth = maxLabelTextWidth(textArray) + m_tickSize + 2*m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    else
                    {
                        axisWidth = m_tickSize + m_textOffset + m_styleLineSrokeWidth/2;
                    }
                    axisSpacings.push(axisWidth);

                    axisHeight = Math.abs(axRange[1] - axRange[0]) + m_styleLineSrokeWidth;
                }
            }

            return {
                width : axisWidth,
                height : axisHeight,
                spacings : axisSpacings,

            };
        };

        var buildToDrawLabels = function(axTicksLabels)
        {
            var isReversed = false;
            if(axTicksLabels.length > 0)
            {
                if(m_axScale (axTicksLabels[0].value) > m_axScale (axTicksLabels[axTicksLabels.length-1].value))
                {
                    isReversed = true;
                }
            }
            //build the "todraw" array
            //count all the labels y1 and y2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {   
              if(!NumberUtils.isNoValue(axTicksLabels[i].value)){
                var item = {};
                item.value = axTicksLabels[i].value;
                item.text = axTicksLabels[i].text;

                //count y1 and y2
                var itemHeight = fastMeasure (item.text, m_style.label).height;
                var centerY = m_axScale (item.value);

                item.y1 = centerY - itemHeight/2;
                item.y2 = centerY + itemHeight/2;

                allTicksLabels.push(item);
              }
            }
            //console.log(allTicksLabels);

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels, isReversed, true);

            //console.log(ticksLabelsToDraw);
            return ticksLabelsToDraw;
        };

        var drawTopBottomLabels = function(selection, type, ticksLabels, maxTextHeight)
        {
            if(ticksLabels.length == 0)
            {
                return;
            }

            var isReversed = false;
            if(ticksLabels.length > 0)
            {
                if(m_axScale (ticksLabels[0].value) > m_axScale (ticksLabels[ticksLabels.length-1].value))
                {
                    isReversed = true;
                }
            }
            //build the "todraw" array
            //count all the labels x1 and x2, and save them.
            var allTicksLabels = [];
            for(var i = 0; i < ticksLabels.length; i++)
            {   
                var item = {};
                item.value = ticksLabels[i].value;
                item.text = ticksLabels[i].text;

                //count x1 and x2
                var itemWidth = fastMeasure (item.text, m_style.label).width;
                var centerX = m_axScale (item.value);

                item.x1 = centerX - itemWidth/2;
                item.x2 = centerX + itemWidth/2;

                allTicksLabels.push(item);
            }

            var ticksLabelsToDraw = [];
            ticksLabelsToDraw = calculateLabelsToDraw(allTicksLabels, isReversed, false);

            //console.log(ticksLabelsToDraw);
            for(var i = 0; i < ticksLabelsToDraw.length; i++)
            {
                //selection.append("circle").attr("cx", m_axScale(axTicksLabels.value[i])).attr("cy", m_textOffset + m_tickSize). attr("r", 3);
                var item = selection.append("text")
                 .attr("x", m_axScale(ticksLabelsToDraw[i].value))
                 .attr("y", m_textOffset + m_tickSize)
                 .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")
                 .attr("text-anchor", "middle") // text-align
                 .text(ticksLabelsToDraw[i].text)
                 .attr("fill", m_style.label.fill)
                 .attr("font-size", m_style.label['font-size'])
                 .attr("font-weight", m_style.label['font-weight'])
                 .attr("font-family", m_style.label['font-family']);

                //IE does not support dominant-baseline
                item.attr("dominant-baseline", "auto");
                item.attr("y", maxTextHeight + m_textOffset);
            }
        };

        var calculateLabelsToDraw = function(allTicksLabels, isReversed, isVertical)
        {
            var labelsToDraw = [];
            
            if(allTicksLabels.length > 0)
            {
                //split allTicksLabels if it is required.
                if( !(allTicksLabels[0].value >= 0 && allTicksLabels[allTicksLabels.length - 1].value >= 0) 
                  &&!(allTicksLabels[0].value <= 0 && allTicksLabels[allTicksLabels.length - 1].value <= 0)
                  )
                {
                    var negativeArray = [];
                    var positiveArray = [];
                    for(var i = 0; i < allTicksLabels.length; i++)
                    {
                        if(allTicksLabels[i].value <= 0)
                        {
                            negativeArray.push(allTicksLabels[i]);
                        }

                        if(allTicksLabels[i].value >= 0)
                        {
                            positiveArray.push(allTicksLabels[i]);
                        }
                    }
                    negativeArray = calculateLabelsToDrawHelper(negativeArray, isReversed, isVertical);
                    positiveArray = calculateLabelsToDrawHelper(positiveArray, isReversed, isVertical);

                    var compareValue = function (firstObj, secondObj)
                    {
                        return firstObj.value - secondObj.value;
                    }
                    negativeArray.sort(compareValue);
                    positiveArray.sort(compareValue);

                    if( negativeArray[negativeArray.length -1].value == 0
                        && positiveArray[0].value == 0)
                    {
                        negativeArray.pop();
                    }

                    //console.log(negativeArray);
                    labelsToDraw = negativeArray.concat(positiveArray);
                }
                else
                {
                    labelsToDraw = calculateLabelsToDrawHelper(allTicksLabels, isReversed, isVertical);
                }
            }

            //BITVIZA-454 [label management] When the height/width of 
            //vertical/horizontal axis is small that can only hold one axis label, the label 
            //should be hidden.
            if(labelsToDraw.length <= 1)
            {
                labelsToDraw = [];
            }

            return labelsToDraw;
        }

        var calculateLabelsToDrawHelper = function(allTicksLabels, isReversed, isVertical)
        {
            var isFromBeginToEnd = true;
            if( Math.abs(allTicksLabels[0].value) > Math.abs(allTicksLabels[allTicksLabels.length -1].value) )
            {
                isFromBeginToEnd = false;
            }

            //allTicksLabels:
            //[0, X]
            //[-X, 0]
            //[X1, X2] (X1>0, X2>0)
            //[X1, X2] (X1<0, X2<0)

            //now we should decide which label to draw.
            //iBeyond = 0:0,1,2,3,4,5,6,...
            //iBeyond = 1:0, ,2, ,4, ,6,...
            //iBeyond = 2:0, , ,3, , ,6,...
            //...
            //iBeyond = (allTicksLabels.length - 1):0
            var ticksLabelsToDraw = [];

            if(!isReversed)
            {
                for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
                {
                    var isDrawable = true;

                    if(isFromBeginToEnd)
                    {
                        for(var i = 0; i < allTicksLabels.length; i+=(iBeyond+1))
                        {
                            var item = allTicksLabels[i];
                            if(i != 0)
                            {
                                var previousIndex = i - (iBeyond+1);

                                if(!isVertical)
                                {
                                    if(allTicksLabels[i].x1 <= allTicksLabels[previousIndex].x2)
                                    {
                                        isDrawable = false;
                                        break;
                                    }
                                }
                                else
                                {
                                    if(allTicksLabels[i].y1 <= allTicksLabels[previousIndex].y2)
                                    {
                                        isDrawable = false;
                                        break;
                                    }
                                }
                            }
                            ticksLabelsToDraw.push(item);
                        }
                    }
                    else
                    {
                        for(var i = (allTicksLabels.length - 1); i >= 0; i-=(iBeyond+1))
                        {
                            var item = allTicksLabels[i];
                            if(i != (allTicksLabels.length - 1))
                            {
                                var previousIndex = i + (iBeyond+1);

                                if(!isVertical)
                                {
                                    if(allTicksLabels[i].x2 >= allTicksLabels[previousIndex].x1)
                                    {
                                        isDrawable = false;
                                        break;
                                    }
                                }
                                else
                                {
                                    if(allTicksLabels[i].y2 >= allTicksLabels[previousIndex].y1)
                                    {
                                        isDrawable = false;
                                        break;
                                    }
                                }
                            }
                            ticksLabelsToDraw.push(item);
                        }
                    }

                    if(isDrawable)//find the labels
                    {
                        break;
                    }
                    else
                    {
                        ticksLabelsToDraw = [];
                    }
                }
            }
            else
            {
                for(var iBeyond = 0; iBeyond <= (allTicksLabels.length - 1); iBeyond++)
                {
                    var isDrawable = true;

                    if(isFromBeginToEnd)
                    {
                        for(var i = 0; i < allTicksLabels.length; i+=(iBeyond+1))
                        {   
                            var item = allTicksLabels[i];
                            if(i != 0)
                            {
                                var previousIndex = i - (iBeyond+1);

                                if(!isVertical)
                                {
                                    if(allTicksLabels[previousIndex].x1 <= allTicksLabels[i].x2)
                                    {
                                        isDrawable = false;
                                        break;
                                    }
                                }
                                else
                                {
                                    if(allTicksLabels[previousIndex].y1 <= allTicksLabels[i].y2)
                                    {
                                        isDrawable = false;
                                        break;
                                    }
                                }
                            }
                            ticksLabelsToDraw.push(item);
                        }
                    }
                    else
                    {
                        for(var i = (allTicksLabels.length - 1); i >= 0; i-=(iBeyond+1))
                        {   
                            var item = allTicksLabels[i];
                            if(i != (allTicksLabels.length - 1))
                            {
                                var previousIndex = i + (iBeyond+1);

                                if(!isVertical)
                                {
                                    if(allTicksLabels[previousIndex].x2 >= allTicksLabels[i].x1)
                                    {
                                        isDrawable = false;
                                        break;
                                    }
                                }
                                else
                                {
                                    if(allTicksLabels[previousIndex].y2 >= allTicksLabels[i].y1)
                                    {
                                        isDrawable = false;
                                        break;
                                    }
                                }
                            }
                            ticksLabelsToDraw.push(item);
                        }
                    }

                    if(isDrawable)//find the labels
                    {
                        break;
                    }
                    else
                    {
                        ticksLabelsToDraw = [];
                    }
                }
            }

            return ticksLabelsToDraw;
        }

        var getTicksLabel = function ()
        {
            var axDomain = m_axScale.domain();//[-100, 2000]

            var tickNum = m_axDefaultTickNum;
            if(m_axScale.tickHint)//after perfect
            {
                tickNum = m_axScale.tickHint;
            }

            var axTicksLabels = m_axScale.ticks(tickNum);//[0, 2000, 4000, ...]
            // [21-Sep-2012 Nick ] FIXME Comment out this part to fix bug BITVIZA-383, any particular reason to filter ticks?
            // if it is yes, what kind of criteria should be taken?
//            if(axTicksLabels.length > 20)
//            {
//                //too many ticks. filter some ticks
//                var tempTicks = [];
//                for(var i = 0; i < axTicksLabels.length; i++)
//                {
//                    if(axTicksLabels[i].toString().substr(0,1) == "1"
//                      || axTicksLabels[i].toString().substr(0,1) == "2"
//                      || axTicksLabels[i].toString().substr(0,1) == "5")
//                    {
//                        tempTicks.push(axTicksLabels[i]);
//                    }
//                }
//                axTicksLabels = tempTicks;
//            }

            var beginLabel;
            var endLabel;
            if(axDomain[0] <= axDomain[axDomain.length -1])
            {
                beginLabel = axDomain[0];
                endLabel = axDomain[axDomain.length -1];
            }
            else
            {
                beginLabel = axDomain[axDomain.length -1];
                endLabel = axDomain[0];
            }

            if(axTicksLabels.length > 0)
            {
                if(axTicksLabels[0] != beginLabel) {
                    //the first label is not the first doamin. Add it.
                    axTicksLabels.unshift(beginLabel);
                }
                
                if(axTicksLabels[axTicksLabels.length -1] != endLabel) {
                    //the last label is not the end. Add it.
                    axTicksLabels.push(endLabel);
                }
            }

            var ticks = [];
            for(var i = 0; i < axTicksLabels.length; i++)
            {
                var tickItem = {};
                tickItem.value = axTicksLabels[i];
                tickItem.text = axTicksLabels[i].toString();
                ticks.push(tickItem);
            }

            //format value label
            if(m_props.label && m_props.label.numberFormat)
            {
                for(var i = 0; i < axTicksLabels.length; i++)
                {
                    var formatFun = d3.format(m_props.label.numberFormat);
                    ticks[i].text = (formatFun(axTicksLabels[i]));
                }
            }

            //console.log(ticks);
            return ticks;
        }

        var maxLabelTextHeight = function (textArray)
        {
            var maxTextHeight = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = fastMeasure(textArray[i], m_style.label).height;
                if(maxTextHeight < tLen)
                {
                    maxTextHeight = tLen;
                }
            }
            return maxTextHeight;
        }

        var maxLabelTextWidth = function (textArray)
        {
            var maxTextWidth = 0;
            for(var i = 0; i <  textArray.length; i++)
            {
                var tLen = fastMeasure(textArray[i], m_style.label).width;
                if(maxTextWidth < tLen)
                {
                    maxTextWidth = tLen;
                }
            }
            return maxTextWidth;
        }
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }        

        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        
        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.axis',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.axis.valueAxisCore',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.axis.categoryAxisCore',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
}
],
function Setup(TextUtils, Objects, valueAxisCore, categoryAxisCore, langManager, NumberUtils, dispatch) {

    return function(manifest) {
        //we should build the axis Data Module, and then draw the axis.
        var m_AxisDM = null;

        var parent = null;
        var m_width = 0;
        var m_height = 0;

        var m_isDrawBody = true;

        var m_spaceLimit = -1;

        var m_axClassName = "viz-axis";
        var m_axBodyClassName = "viz-axis-body";
        var m_axTitleClassName = "viz-axis-title";
        var m_axLabelClassName = "viz-axis-label";

        var m_titleOffset = 11;

        var m_data = { };
        var m_dataAxis = { };
        
        var m_isTitleVisible = true;
        
        var m_props = {
            "drawable": true,
        };
        var eDispatch = new dispatch('initialized');
        
        m_props = Objects.extend(true, m_props, manifest.props(null));

        var m_defaultProps = { };
        m_defaultProps = Objects.extend(true, m_defaultProps, manifest.props(null));

        var m_scale = null;

        var m_effectManager = null;
        
        var m_title = null;
        
        var m_style = {};
        
        function getThemeStyleDef() {
            m_style.title = manifest.style(m_axTitleClassName);
            m_style.label = manifest.style(m_axLabelClassName);
        };

        var drawAll = function()
        {
            if(!m_props.drawable)
            {
                //do not draw bacause of smart layout
                return false;
            }
            else
            {
                if(!drawBody() && !drawTitle())
                {
                    return false;
                }
            }

            return true;
        }

        var drawTitle = function() 
        {
            return m_props.title.visible;
        }

        var drawBody = function() 
        {
            if(!m_isDrawBody)
            {
                return false;
            }

            var rangeArray = m_scale.range();
            var domainArray = m_scale.domain();
            var rangeBand = null;
            if(m_props.type == "category")
            {
                rangeBand = m_scale.rangeBand();
            }

            var hasData = false;
            if(!m_props.isIndependentMode)
            {
                if(m_dataAxis)
                {
                    hasData = true;
                }
            }
            else
            {
                if(m_data)
                {
                    hasData = true;
                }
            }

            return !(!m_props.visible 
            || (rangeArray[0] == 0 && rangeArray[rangeArray.length-1] == 0 && rangeArray.length >=2 )
                || (rangeArray.length == 1 && rangeArray[0] == 0 
                    && domainArray.length == 1 && domainArray[0] == 0 && m_props.type == "value")
                || ((!rangeBand || !hasData) && rangeArray.length == 1 && rangeArray[0] == 0 
                    && domainArray.length == 1 && domainArray[0] == 0 && m_props.type == "category")    
                );
        }

        var axis = function (selection) {
            
                parent = selection;
                //in axis, we cannot use data driven way like
                //        var e = selectDIV.selectAll("p")
                //.data(pdata,function(d){return d;});
             
                //e.enter().append("p")
                //.text(function(d){return d;});

                //e.exit().remove();
                //to control the redraw, because axis is not based on data, but based on scale

                //there should be only one axis Class
                var axisClass = selection.select("." + m_axClassName);

                var rangeArray = m_scale.range();
                var domainArray = m_scale.domain();
                if(!drawAll())
                {
                    //remove all the axis 
                    //to improve the performance, we should remove as less elements as possible.
                    axisClass.remove();
                }
                else
                {
                    //---we should dicide show or hide somethings because of the spaceLimit
                    var spacings = axis.getPreferredSize().spacings;

                    var titleSpace = spacings[0];
                    var bodySpace = 0;
                    for(var i = 1; i < spacings.length; i++)
                    {
                        bodySpace += spacings[i];
                    }

                    if(m_spaceLimit >= 0 && m_spaceLimit < (titleSpace + bodySpace))
                    {
                        m_isTitleVisible = false;
                    }
                    //------------------------------------------------------
                    //TODO: if user could customize CSS style, do need getThemeStyleDef() here
                    //getThemeStyleDef();

                    prepareProperties();

                    var core;
                    var coreScale;
                    var re = getCoreAndScale();
                    core = re.core;
                    coreScale = re.coreScale;

                    //the axis body
                    var axisCore = core()
                                  .properties(m_props)
                                  .style(m_style)
                                  .position(m_props.position)
                                  .axScale(coreScale)
                                  .spaceLimit(m_spaceLimit);

                    var axisBody;
                    if(axisClass.empty())
                    {
                        axisClass = selection.append("g")
                                 .attr("class", m_axClassName);

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName);
                    }
                    else
                    {
                        //redraw axis body
                        var e=axisClass.select("." + m_axBodyClassName).remove();

                        axisBody = axisClass.append("g")
                                  .attr("class", m_axBodyClassName);

                        axisBody = axisClass.select("." + m_axBodyClassName);
                    }

                    if(drawBody())
                    {
                        axisBody.call(axisCore);
                    }

                    //build axis title Text
                    var title = "";
                    if(!(m_props.title.text === undefined))
                    {
                        title = m_props.title.text;
                    }
                    else
                    {
                        if(m_props.type == "value")
                        {
                            if(m_title) title = m_title;
                            else title = "Value";
                        }
                        else //let us build the title!
                        {
                            var dataset = [];
                            if(m_props.isIndependentMode)
                            {
                                if(m_data)
                                {
                                    for(dataObj in m_data)
                                    {
                                        dataset = m_data[dataObj].values;
                                        break;
                                    }
                                }
                            }
                            else
                            {
                                if(m_dataAxis)
                                {
                                    dataset = m_dataAxis.values;
                                }
                            }

                            for(var i = 0 ; i < dataset.length; i++)
                            {
                                if(dataset[i].type)
                                {
                                    if(dataset[i].type == "MND" && i == 0)
                                    {
                                        title += langManager.get('IDS_DEFAULTMND') + ((dataset.length == 1)? "" : " - ");
                                    }
                                    else if(dataset[i].type == "MND" && i == (dataset.length-1))
                                    {
                                        title += " - " + langManager.get('IDS_DEFAULTMND');
                                    }
                                }
                                else
                                {
                                    title += dataset[i].col.val;
                                    if(!(i == (dataset.length-1)) && !dataset[i+1].type)
                                    {
                                        title += " / ";
                                    }
                                }
                            }
                        }
                    }
                    

                    //redraw axis title
                    var titleOffset = m_titleOffset;
                    axisClass.select("." + m_axTitleClassName).remove();

                    if(drawTitle())
                    {
                        if(m_props.title.visible && m_isTitleVisible)
                        {  
                            var pSize = axisCore.getPreferredSize();
                            var axTitle = axisClass.append("g")
                                  .attr("class", m_axTitleClassName)
                                  .append("text")
                                  .attr("text-anchor", "middle")
                                  .attr("fill", m_style.title.fill)
                                  .attr("font-size", m_style.title['font-size'])
                                  .attr("font-weight", m_style.title['font-weight'])
                                  .attr("font-family", m_style.title['font-family']); // text-align
                                  
                            if(m_props.position == "bottom")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }
                                  axTitle.attr("x", pSize.width/2)
                                         .attr("y", pSize.height + titleOffset)
                                         .attr("dominant-baseline", "hanging");//"auto")//"hanging")//"central");
                                    
                                  if(jQuery.browser.msie)
                                  {
                                      //dominant-baseline does not work
                                      var textHeight = m_style.title['font-size'].toString();
                                      var indexPX = textHeight.indexOf("px");
                                      if(indexPX >= 0)
                                      {
                                          textHeight = textHeight.substr(0, indexPX);
                                      }
                                      axTitle.attr("y", Number(axTitle.attr("y")) + textHeight/2);
                                      axTitle.attr("dominant-baseline", "auto");
                                  }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.title.toString());
                            }
                            else if(m_props.position == "top")
                            {
                                if(!drawBody())
                                {
                                    pSize.height = 0;
                                }

                                titleHieght = fastMeasure(title, m_style.title).height;

                                axisBody.attr("transform", "translate(0, " + (titleHieght + titleOffset) + ")");

                                axTitle.attr("x", pSize.width/2)
                                  .attr("y", titleHieght)
                                  .attr("dx", "0") // padding-right
                                  .attr("dy", "0") // vertical-align: middle?
                                  .attr("dominant-baseline", "auto");//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.width, m_style.title.toString());
                            }
                            else if(m_props.position == "left")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.title).height;

                                axisBody.attr("transform", "translate(" + (titleWidth + titleOffset) + ", " + 0 + ")");

                                var centerX = titleWidth;
                                var centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY)
                                  .attr("dominant-baseline", "auto")//"auto")//"hanging")//"central")
                                
                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.title.toString());
                            }
                            else// if(m_props.position == "right")
                            {
                                if(!drawBody())
                                {
                                    pSize.width = 0;
                                }

                                //title is vertical
                                titleWidth = fastMeasure(title, m_style.title).height;
                                
                                var centerX = pSize.width + titleWidth/2 + titleOffset;
                                var centerY = pSize.height/2;
                                var ac = "-90";

                                //axisClass.append("circle").attr("cx", centerX).attr("cy", centerY). attr("r", 5);
                                axTitle.attr("transform","rotate( " + ac + " " + centerX + " "  + centerY + " )")
                                  .attr("x", centerX)
                                  .attr("y", centerY - titleWidth/2)
                                  .attr("dominant-baseline", "hanging")//"auto")//"hanging")//"central")

                                if(jQuery.browser.msie)
                                {
                                    //dominant-baseline does not work
                                    var textHeight = m_style.title['font-size'].toString();
                                    var indexPX = textHeight.indexOf("px");
                                    if(indexPX >= 0)
                                    {
                                        textHeight = textHeight.substr(0, indexPX);
                                    }

                                    centerY = Number(pSize.height/2) + textHeight/2;
                                    axTitle.attr("y", centerY);
                                    axTitle.attr("dominant-baseline", "auto");
                                }

                                TextUtils.ellipsis(title, axTitle.node(), pSize.height, m_style.title.toString());
                            }
                        }
                    }
                    m_isTitleVisible = true;
                }
                
            eDispatch.initialized();
            
            return axis;
        }

        axis.parent = function (_) {
          if ( !arguments.length ) return parent;
          parent = _;
          return axis;
        };

        axis.width = function(_width) {
            if (arguments.length == 0) {
                return m_width;
            }
            else {
                m_width = _width;

                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(m_height)
                    {
                        m_spaceLimit = m_height;

                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(m_width)
                    {
                        m_spaceLimit = m_width;
                    }
                }

                return axis;
            }
        };

        axis.height = function(_height) {
            if (arguments.length == 0)
                return m_height;
            
            m_height = _height;
            if(m_props.position == "bottom" || m_props.position == "top")
            {
                if(m_height)
                {
                    m_spaceLimit = m_height;

                }
            }
            else if(m_props.position == "left" || m_props.position == "right")
            {
                if(m_width)
                {
                    m_spaceLimit = m_width;
                }
            }

            
            return axis;
        };

        axis.gridlineLength = function(_gridlineLength) {
            if (arguments.length == 0)
                return m_props.gridline.length;
            m_props.gridline.length = _gridlineLength;
            return axis;
        };

        axis.startPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .startPadding();
            }
            return padding;
        };

        axis.endPadding = function() {
            var padding = 0;
            if(m_props.type == "value")
            {
                padding = valueAxisCore()
                         .properties(m_props)
                         .style(m_style)
                         .position(m_props.position)
                         .axScale(m_scale)
                         .endPadding();
            }
            return padding;
        };

        axis.size = function(_size) {
            if (arguments.length == 0)
                return {
                           "width" : m_width,
                           "height": m_height,
                       };
            m_width = _size.width;
            m_height = _size.height;
            return axis;
        };
        
        /*
         * Jimmy/9/22/2012 if axis works under independentMode(boxplot for now)
         * it doesn't rely on the data passed through this API from container, instead, boxplot
         * will pass calculated data through dependency 
         */
        axis.independentData = function(_data) {
          if(m_props.isIndependentMode) {
            if (arguments.length == 0)
                return m_data;
            m_data = _data;
          }
        },

        axis.data = function(_data) {
            if (arguments.length == 0)
                return m_data;
            
            if(!m_props.isIndependentMode)
            {
              m_data = _data;
              if(_data.getAnalysisAxisDataByIdx)
              {
                m_dataAxis = m_data.getAnalysisAxisDataByIdx(0);
              }
            }
            return axis;
        };

        axis.title = function(_title) {
            if (arguments.length == 0)
                return m_title;
            m_title = _title;
            return axis;
        };

        axis.properties = function(_properties) {
            if (arguments.length == 0)
                return m_props;

            m_props = Objects.extend(true, m_props, manifest.props(_properties));
            getThemeStyleDef();

            if(m_props.customizedColor)
            {
                m_props.color = m_props.customizedColor;
            }

            return axis;
        };

        axis.scale = function(_scale) {
            if (arguments.length == 0)
                return m_scale;

            m_scale = _scale;
            return axis;
        };

        axis.isDrawBody = function(_isDrawBody) {
            if (arguments.length == 0)
                return m_isDrawBody;

            m_isDrawBody = _isDrawBody;
            return axis;
        };

        axis.color = function(_color) {
            if (arguments.length == 0)
                return m_props.color;

            if(!_color)
            {
                _color = m_defaultProps.color;
            }

            m_props = Objects.extend(true, m_props, {"customizedColor":_color});
            m_props = Objects.extend(true, m_props, {"color":_color});

      if (m_props.title.applyAxislineColor && _color) {
        m_style.title.fill = _color;
      }

            return axis;
        };

        axis.drawable = function(_drawable) {
            //drawable or not because of smart layout
            if (arguments.length == 0)
                return m_props.drawable;

            m_props = Objects.extend(true, m_props, {"drawable":_drawable});

            return axis;
        };

        axis.getPreferredSize = function() {
            //getThemeStyleDef();
            var rangeArray = [0];
            var domainArray = [0];
            if(m_scale)
            {
                rangeArray = m_scale.range();
                domainArray = m_scale.domain();
            }

            if(!m_scale || (!drawAll()) )            
            {
                return {
                    width : 0,
                    height : 0,
                };
            }
            else {
                //body size && title size
                var reCS = getCoreAndScale();
                var axisCore = (reCS.core)()
                              .properties(m_props)
                              .style(m_style)
                              .position(m_props.position)
                              .axScale(reCS.coreScale)
                              .spaceLimit(m_spaceLimit);
                
                var title;
                if(m_props.title.visible)
                {
                    var title;
                    //console.log(m_props.title.text);
                    if(!(m_props.title.text === undefined))
                    {
                        title = m_props.title.text;
                    }
                    else
                    {
                        title = "Value";
                    }
                }
                
                var titleHieght = 0;
                var titleWidth = 0;
                var titleOffset = 0;
                var axisSpacings = [];

                var sizeCore = axisCore.getPreferredSize();

                
                if(m_props.position == "bottom" || m_props.position == "top")
                {
                    if(!drawBody())
                    {
                        sizeCore.height = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible)
                    {
                        titleHieght = fastMeasure(title, m_style.title).height; 
                        titleOffset = m_titleOffset;
                    }

                    var titleSpace = titleHieght + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullHeight = titleSpace + bodySpace;
                    var realHeight = fullHeight;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullHeight)
                    {
                        realHeight = sizeCore.height;//no title
                    }

                    return {
                        maxSizeConstant : 0.5,
                        width: sizeCore.width,
                        height: fullHeight,
                        realHeight: realHeight,
                        spacings: axisSpacings,
                    }
                }
                else if(m_props.position == "left" || m_props.position == "right")
                {
                    if(!drawBody())
                    {
                        sizeCore.width = 0;
                        sizeCore.spacings = [];
                    }

                    if(m_props.title.visible)
                    {
                        //title is vertical
                        titleWidth = fastMeasure(title, m_style.title).height; 
                        titleOffset = m_titleOffset;
                    }

                    var titleSpace = titleWidth + titleOffset;
                    axisSpacings = axisSpacings.concat([titleSpace]);
                    axisSpacings = axisSpacings.concat(sizeCore.spacings);

                    var bodySpace = 0;
                    for(var i = 1; i < axisSpacings.length; i++)
                    {
                        bodySpace += axisSpacings[i];
                    }

                    var fullWidth = bodySpace + titleSpace;
                    var realWidth = fullWidth;
                    
                    if(m_spaceLimit >= 0 && m_spaceLimit < fullWidth)
                    {
                        realWidth = sizeCore.width;//no title
                    }
                    

                    return {
                        maxSizeConstant : 0.5,
                        width: fullWidth,
                        realWidth: realWidth,
                        height: sizeCore.height,
                        spacings: axisSpacings,
                    }
                }
            }
        };

        axis.effectManager = function(_effectManager) {
            if (arguments.length == 0)
                return m_effectManager;

            m_effectManager = _effectManager;

            return axis;
        };

        axis.dispatch = function(_){
          if(!arguments.length)
            return eDispatch;
          eDispatch = _;return axis;
        };
        
        var fastMeasure = function(_text, _style)
        {
            return TextUtils.fastMeasure(_text, _style['font-size'],
                                                _style['font-weight'],
                                                _style['font-family']);
        }

        var getCoreAndScale = function()
        {
            var re = { };
            var coreScale;
            if(m_props.type == "category") //a new scale is required
            {
                //reverse domain or not
                var isReverse = false;
                var oRange = m_scale.range();
                if(oRange[0] > oRange[1])
                {
                    isReverse = true;
                }

                coreScale = [];
               
                //build labels (domain)
                var dataset = [];
                if(m_props.isIndependentMode)
                {
                    for(dataObj in m_data)
                    {
                        dataset = m_data[dataObj].values;
                    }
                }
                else
                {
                    if(m_dataAxis)
                    {
                        dataset = m_dataAxis.values;
                    }
                }

                var MNDIndex = -1;
                var MNDMultiNum = 1;
                //check has MND or not. Get MND number
                for(var i = 0 ; i < dataset.length; i++)
                {
                    if(dataset[i].type)
                    {
                        if(dataset[i].type == "MND")
                        {
                            MNDIndex = i;
                            MNDMultiNum = dataset[i].rows.length;
                        }
                    }
                }

                if(MNDIndex == 0)
                {
                    MNDMultiNum = 1;
                }

                var orRange = m_scale.range();
                var orRangeBand = m_scale.rangeBand();
                
                for(var i = 0 ; i < dataset.length; i++)
                {
                    var isMNDValue = false;
                    if(dataset[i].type)
                    {
                        if(dataset[i].type == "MND")
                        {
                            isMNDValue = true;
                        }
                    }

                    if(!isMNDValue)
                    {
                        var dataRows = dataset[i].rows;
                        //replace null to "No Value"
//                        for(var j = 0; j < dataRows.length; j++)
//                        {
//                            if( typeof (dataRows[j].val) != "string")
//                            {
//                                if(NumberUtils.isNoValue(dataRows[j].val))
//                                {
//                                    dataRows[j].val = langManager.get('IDS_ISNOVALUE');
//                                }
//                            }
//                        }

                        var cgDomain = [];
                        var cgRange = [];

                        var lastRangeName = null;
                        var lastRangeEnd = 0;
                        var lastNRangeEnd = 1;

                        for(var j = 0 ; j < dataRows.length; j++)
                        {
                            if((j == dataRows.length-1) || (dataRows[j].val != dataRows[j+1].val)
                                    || ( (MNDIndex !=0) && (i == (dataset.length -1) )) )
                            {
                                cgDomain.push(dataRows[j].val);
                                lastRangeName = dataRows[j].val;

                                cgRange.push([lastRangeEnd, lastRangeEnd + lastNRangeEnd * orRangeBand * MNDMultiNum]);
                                lastRangeEnd = lastRangeEnd + lastNRangeEnd * orRangeBand * MNDMultiNum;
                                lastNRangeEnd = 1;
                            } else if( (j == dataRows.length-1) && dataRows[j].val == dataRows[j+1].val){
                              if(dataset[i -1] && dataset[i -1].rows[j] && dataset[i -1].rows[j+1] && dataset[i -1].rows[j].val !=  dataset[i -1].rows[j+1].val){
                                cgDomain.push(dataRows[j].val);
                                    lastRangeName = dataRows[j].val;

                                    cgRange.push([lastRangeEnd, lastRangeEnd + lastNRangeEnd * orRangeBand * MNDMultiNum]);
                                    lastRangeEnd = lastRangeEnd + lastNRangeEnd * orRangeBand * MNDMultiNum;
                                    lastNRangeEnd = 1;
                              }
                            }else
                            {
                                lastNRangeEnd++; 
                            }
                        }
                        
                        if(dataRows.length == 0){
                            cgRange.push([lastRangeEnd, orRangeBand * 2]);
                            lastRangeEnd = orRangeBand * 2;
                        }

                        if(isReverse)
                        {
                            cgDomain = cgDomain.reverse();
                        }

                        coreScaleItem = { 
                                       "domain": cgDomain, 
                                       "range":  cgRange,
                                    };
                        coreScale.push(coreScaleItem);
                    }
                }
                //now MND. MND is the inner one or the outer one
                if(MNDIndex == 0) //outer one. Should be added as the first
                {
                    var cgDomain = [];
                    var cgRange = [];

                    var dataRow = dataset[MNDIndex].rows;

                    var coreScaleItem;
                    if(!coreScale[0])
                    {
                        //only MND
                        var rg = oRange;
                        var rangS;
                        
                        // [24-Sep-2012 Nick] if the range only has 0, it means the domain only has 1 value.
                        // in this case, the range of the scale is from smallest value to largest value.
                        rangS = m_scale.rangeExtent()[1] / dataRow.length;
//                        
//                        if(rg[1] > rg[0])
//                        {
//                            rangS = rg[1] - rg[0];
//                        }
//                        else
//                        {
//                            rangS = rg[0] - rg[1];
//                        }
                        
                        for(var i = 0; i < dataRow.length; i++)
                        {
                            cgDomain.push(dataRow[i].val);
                            cgRange.push([rangS * i, rangS * (i+1)]);
                        }

                        if(isReverse)
                        {
                            cgDomain = cgDomain.reverse();
                        }
                        
                        coreScaleItem = { 
                                       "domain": cgDomain, 
                                       "range":  cgRange,
                                    };
                    }
                    else
                    {
                        var rg = coreScale[0].range;
                        var lastItem = rg.length - 1;

                        var rangS = rg[lastItem][1] - rg[0][0];
                        for(var i = 0; i < dataRow.length; i++)
                        {
                            cgDomain.push(dataRow[i].val);
                            cgRange.push([rangS * i, rangS * (i+1)]);
                        }

                        if(isReverse)
                        {
                            cgDomain = cgDomain.reverse();
                        }
                        
                        coreScaleItem = { 
                                       "domain": cgDomain, 
                                       "range":  cgRange,
                                    };

                        //we need to "multiply" the existing scales for MND
                        for(var i = 0; i < coreScale.length; i++)
                        {
                            var dm = coreScale[i].domain;
                            for(var j = 1; j < dataRow.length; j++)
                            {
                                coreScale[i].domain = coreScale[i].domain.concat(dm);
                            }

                            var rg = [];//clone of coreScale[i].range
                            for(var k = 0; k < coreScale[i].range.length; k++)
                            {
                                rg.push( [coreScale[i].range[k][0], coreScale[i].range[k][1]] );
                            }                            
                            
                            var rgOffset = rg[rg.length -1][1] - rg[0][0]; 
                            
                            for(var j = 1; j < dataRow.length; j++)
                            {       
                                var orArray = [];//clone coreScale[i].range array
                                for(var k = 0; k < coreScale[i].range.length; k++)
                                {
                                    orArray.push( [coreScale[i].range[k][0], coreScale[i].range[k][1]] );
                                }
                               
                                //adjust rg
                                for(var k = 0; k < rg.length; k++)
                                {
                                    rg[k][0] += rgOffset;
                                    rg[k][1] += rgOffset;
                                }
                                

                                var reArray = orArray.concat(rg);
                                var orArray = [];//clone coreScale[i].range array
                                for(var k = 0; k < reArray.length; k++)
                                {
                                    orArray.push( [reArray[k][0], reArray[k][1]] );
                                }
                                coreScale[i].range = orArray;
                            }
                        }
                    }
                    
                    coreScale.unshift(coreScaleItem);//add to the first
                }
                else if(MNDIndex > 0) //inner one. Should be added as the latest
                {
                    var ranges = coreScale[coreScale.length -1].range;
                    //console.log(ranges);

                    var cgDomain = [];
                    var cgRange = [];

                    var dataRow = dataset[MNDIndex].rows;
                    var rg = coreScale[0].range;
                    var lastItem = rg.length - 1;

                    var rangS = rg[lastItem][1] - rg[0][0];

                    
                    for(var i = 0; i < (MNDMultiNum * ranges.length); i++)
                    {
                        cgDomain.push(dataRow[i%MNDMultiNum].val);

                        var rBegin = ranges[parseInt(i/MNDMultiNum)][0];
                        var rEnd = ranges[parseInt(i/MNDMultiNum)][1];

                        var iOffset = parseInt(i%MNDMultiNum);
                        var iRange = (rEnd - rBegin)/MNDMultiNum;

                        cgRange.push( [rBegin + iOffset * iRange,rBegin + iOffset * iRange + iRange] );
                    }

                    if(isReverse)
                    {
                        cgDomain = cgDomain.reverse();
                    }
                    var coreScaleItem = { 
                                   "domain": cgDomain, 
                                   "range":  cgRange,
                                };
                    
                    coreScale.push(coreScaleItem);//add to the latest
                }
                core = categoryAxisCore;
            }
            else //value axis
            {   
                core = valueAxisCore;
                coreScale = m_scale;
            }
            re.core = core;
            re.coreScale = coreScale;
            return re;
        }
        
        function prepareProperties()
        {
            if (!m_effectManager) return;

            var parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_props.color,
            };
            m_props.color = m_effectManager.register(parameter);
            if(m_props.customizedColor)
            {
                m_props.color = m_props.customizedColor;
            }

            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.label.fill,
            };
            m_style.label.fill = m_effectManager.register(parameter);

            parameter = {
                    drawingEffect : 'normal',
                    fillColor : m_style.title.fill,
            };
            m_style.title.fill = m_effectManager.register(parameter);
        }

        return axis;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.axis',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.axis',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'axis',
    'properties' : {
      'isIndependentMode' : {
        'name' : 'isIndependentMode',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set whether axis works on independent mode, currently it is used specially for boxplot chart.',
        'isExported' : false
      },
    'lineSize' : {
        'name' : 'lineSize',
        'supportedValueType' : 'String',
        'defaultValue' : '1',
        'description' : 'Set line size of axis.',
        'isExported' : true,
      },
      'title' : {
        'name' : 'title',
      'description' : 'Settings for axis title.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set visibility of axis title.'
        }, 
        'text' : {
        'name' : 'text',
        'supportedValueType' : 'String',
        'description' : 'Set text of axis title.'
        },
        'applyAxislineColor' : {
        'name' : 'applyAxislineColor',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set title color same with axisline color.',
        'isExported' : false,
        },
      },
      },
      'gridline' : {
        'name' : 'gridline',
      'description' : 'Settings for axis gridline.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible': {
          'name' : 'visible',
          'supportedValueType' : 'Boolean',
          'defaultValue' : true,
          'description' : 'Set visibility of axis gridline.'
        },
        showFirstLine : {
              'name' : 'showFirstLine',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled the first line of gridlines.',
              'isExported' : false,
        },
        showLastLine : {
              'name' : 'showLastLine',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled the last line of gridlines.',
              'isExported' : false,
        },
        'type' : {
          'name' : 'type',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'line', 'dotted', 'incised'],
          'defaultValue' : 'line',
          'description' : 'Set type of gridline.',
          'isExported' : true,
        },
        'color' : {
          'name' : 'color',
          'supportedValueType' : 'String',
          'defaultValue' : '#d8d8d8',
          'description' : 'Set color of gridline.',
          'isExported' : true,
        },
        'size' : {
          'name' : 'size',
          'supportedValueType' : 'String',
          'defaultValue' : '1',
          'description' : 'Set line size of gridline.',
          'isExported' : true,
        },        
          },
      }, 
    'color' : {
        'name' : 'color',
        'supportedValueType' : 'String',
        'defaultValue' : '#6c6c6c',
        'description' : 'Set color of axisline.',
          'isExported' : true,
      },
      'axisline' : {
        'name' : 'axisline',
      'description' : 'Settings for axisline.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axisline.'
        },
      },
      },    
      'type' : {
        'name' : 'type',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'value', 'category', ],
        'defaultValue' : 'value',
        'description' : 'Set type of axis.',
          'isExported' : false,
      },
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axis.',
      },
      'label' : {
        'name' : 'label',
      'description' : 'Settings for axis label.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of axis label.'
        }, 
        'numberFormat' : {
        'name' : 'numberFormat',
        'supportedValueType' : 'String',
        'description' : 'Set number format of value axis.'
        },
      },
      },
      'position' : {
        'name' : 'position',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'left', 'right', 'top', 'bottom' ],
        'defaultValue' : 'bottom',
        'description' : 'Set position of axis.',
          'isExported' : false,
      },
    },
    'css' : {
      '.viz-axis-title' : {
        'description' : 'Define style for the axis title.',
        'value' : {
          'fill' : 'black',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'bold'
        }
      },
      '.viz-axis-label' : {
        'description' : 'Define style for the axis label.',
        'value' : {
          'fill' : '#333333',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.MeasureDataHandler',
  version : '4.0.0'
}
],
 function Setup(FunctionUtils, MultiAxesDataAdapter, MeasureDataHandler){
    
   function initSubChartAxes(axes){
     
       var sub = axes.slice(0);
       sub.sort(function(a,b){return a.index -b.index;});
     sub.shift();  
       
     return sub;
   }
   
   function initMeasureValueAxisIndexForMeasure(bindingInfo){
     if(bindingInfo[0] == true){
      if(bindingInfo[1] == true)
         return [1,2];
      else
         return [1];
     }else if(bindingInfo[1] == true){
       return [2];
     }else{
       return [1]; 
     }
     
   }
   
   function initMeasureValueAxisIndex(bindingInfo){
     
      //axis 1 has been feeded with crosstable
      if(bindingInfo[0] == true){
       if(bindingInfo[1] == true)
        return [1];
       else if(bindingInfo[2] == true){
        if(bindingInfo.length > 3)
           return [1]; //Multi Radar,pass crosstable to radar as single chart handler
        else
           return [2];
       }
       else if(bindingInfo[3] == true)// Multi Radar, aa 4 could not be feeded
        FunctionUtils.error("Not Supported");
       else
        return [1];
      }else if(bindingInfo[1] == true){
       if(bindingInfo[2] == true)
          return [1, 2];
       else if(bindingInfo[3] == true)
        FunctionUtils.error("Not Supported");
       else
        return [1];
      }else if(bindingInfo[2] == true){
        if(bindingInfo[3] == true)
         FunctionUtils.error("Not Supported");
        else{
          if(bindingInfo.length > 3)
             return [1]; //Multi Radar,pass crosstable to radar as single chart handler
          else
             return [2];
        }
      }else{
        for(var i = 0; i< bindingInfo.length;i++){
          if(bindingInfo[i] == true)
           FunctionUtils.error("could not determin measure value axis index");
        }
        //all false
        return [1];
      }
      
      FunctionUtils.error("could not determin measure value axis index");
     
     } 
   
   function MultiChartDataHandler(dataAdapter, type){
        this._dataAdapter =  dataAdapter;
        this._aa = this._dataAdapter.getAnalysisAxisDataByIdx();
        this._mg = this._dataAdapter.getMeasureValuesGroupDataByIdx();
        this._subAxes = initSubChartAxes(this._aa);
        this._type = type;
        
        if(this._type == undefined){
          this._measureValueAxisIndex = initMeasureValueAxisIndex(this._dataAdapter.getBindingInfo());
          this._maxMeasureAxis = 2;
      }else if(this._type == "measures"){
        this._measureValueAxisIndex = initMeasureValueAxisIndexForMeasure(this._dataAdapter.getBindingInfo());
        this._maxMeasureAxis = this._dataAdapter.getBindingInfo().length ;
      }
      
      
   }
   
   MultiChartDataHandler.prototype.getSubDataAdapter = function(ctx){
       if(this._type == undefined){
         return this.getSubDataAdapterByContext(ctx);
       }else if(this._type == "measures"){
           return this.getSubDataAdapterByMeasures(ctx);
       }
       
       return null;
     
   };
   
   MultiChartDataHandler.prototype.getSubDataAdapterByContext = function(ctx){
     if(ctx){
        //Multiplier with MND
        if(ctx.path.mg != undefined && ctx.path.mi != undefined){
          if(ctx.path.di != undefined && ctx.path.dii != undefined){ // Mulitplier with Dimension and MND
            var dataAdapter = new MultiAxesDataAdapter();
            
            for(var i = 0; i < this._subAxes.length; i++){
              var subAxis = this._subAxes[i];
              dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
            }
            
            var mvg = this._mg[ctx.path.mg];
              dataAdapter.addMeasureValuesGroup({index: 0, values: MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxMeasureAxis, true)});
            
            
            return dataAdapter;

          }else{//Multiplier with MND only
           var dataAdapter = new MultiAxesDataAdapter();
           
           for(var i = 0; i < this._subAxes.length; i++){
             var subAxis = this._subAxes[i];
             dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
           }
           
           var mvg = this._mg[ctx.path.mg];
           //MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxAxisCount
           dataAdapter.addMeasureValuesGroup({index: 0, values:MeasureDataHandler.makeMeasureValues(null, {"values":[mvg.values[ctx.path.mi]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
           
           return dataAdapter;
          }
          
        }else{ //Multiplier without MND
          var dataAdapter = new MultiAxesDataAdapter();
        
          for(var i = 0; i < this._subAxes.length; i++){
            var subAxis = this._subAxes[i];
            dataAdapter.addAnalysisAxis({index: subAxis.index - 1, values: subAxis.values});
          }
          
          for(i = 0; i < this._mg.length; i++){
            var mvg = this._mg[i];
            dataAdapter.addMeasureValuesGroup({index: mvg.index, values:  MeasureDataHandler.makeMeasureValues(ctx, mvg, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
          }
          
          return dataAdapter;
          }
       }
     
     return null;
   };
   
   MultiChartDataHandler.prototype.getSubDataAdapterByMeasures = function(ctx){
     var dataAdapter = new MultiAxesDataAdapter();
      
     for(var i = 0; i < this._aa.length; i++){
        dataAdapter.addAnalysisAxis(this._aa[i]);
     }
      
     var mg = this._mg[0];
     
     dataAdapter.addMeasureValuesGroup({index : 0, values : MeasureDataHandler.makeMeasureValues(null, {"values":[mg.values[ctx.row]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
     dataAdapter.addMeasureValuesGroup({index : 1, values : MeasureDataHandler.makeMeasureValues(null, {"values":[mg.values[ctx.col]]}, this._measureValueAxisIndex, this._maxMeasureAxis, false)});
     
     return dataAdapter;
   };
   
   
   return MultiChartDataHandler;
   
 });sap.riv.module(
{
  qname : 'sap.viz.modules.util.DimensionalInfoHandler',
  version : '4.0.0'},
[

],
function Setup() {
  //fake dataset
  return function(props, multiplier) {
    var data_ = multiplier;
    var props_ = props;;
    var dimInCol_;
    var dimInRow_;
    var rowDimension_ = {
      'values' : []
    };

    var colDimension_ = {
      'values' : []  
    };
    var ctx_ = [];
    var rowCount_;
    var colCount_;

    var my = function() {

    };


    my.setData = function(data)
    {
      data_ = data;
      return my;
    };

    my.setProperties = function(props)
    {
      props_ = props;
      return my;
    };

    my.getColumnDimensionData = function()
    {
      return  colDimension_;
    };

    my.getRowDimensionData = function()
    {
      return rowDimension_;
    };

    my.getContexts = function()
    {
      return ctx_;
    };

    function buildIndexMeasuresOnly()
    {
      if(dimInCol_ > 0)
      {
        rowCount_ = 1;
        colCount_ = data_.values[0].rows.length;
        ctx_.push([]);
        var colDimVals = colDimension_.values;
        colDimVals[0] = { 
            'col':{
          'val': "MND"
        },
        'rows':[]
        };

        for(var i = 0; i < data_.values[0].rows.length; ++i)
        {
          colDimVals[0].rows.push({ 'val': data_.values[0].rows[i].val});
          ctx_[0].push(data_.values[0].rows[i].ctx);
        }
      }
      else
      {
        rowCount_ = data_.values[0].rows.length;
        colCount_ = 1;
        var rowDimVals = rowDimension_.values;
        rowDimVals[0] = { 
            'col':{
          'val': "MND"
        },
        'rows':[]
        };
        for(var i = 0; i < data_.values[0].rows.length; ++i)
        {
          rowDimVals[0].rows.push({ 'val': data_.values[0].rows[i].val});
          ctx_.push([data_.values[0].rows[i].ctx]);
        }
      }
    };

    function initilize()
    {
      rowDimension_.values = [];
      colDimension_.values = [];
      rowCount_ = 0;
      colCount_ = 0;
      ctx_ = [];
    };
    // compare tow title is the same
    function compare(index, preIndex, startDim, dimNum)
    {
      for(var i = startDim; i < startDim + dimNum; ++i)
      {
        if(data_.values[i].rows[index].val != data_.values[i].rows[preIndex].val)
          return false;
      }
      return true;
    };

    //  
    function buildUniqueIndexes(uniqueIndex, index, startDim, dimNum)
    {
      var start = 0;
      var end = uniqueIndex.length;
      var isFound = true;
      for ( var level = 0; isFound && level < dimNum; ++level) {
        var nextStart = end;
        var nextEnd = start;
        isFound = false;
        for ( var pos = start; pos < end; ++pos) {
          if (data_.values[startDim + level].rows[uniqueIndex[pos]].val 
              === data_.values[startDim + level].rows[index].val) {
            isFound = true;
            if (pos < nextStart)
              nextStart = pos;
            if (pos >= nextEnd)
              nextEnd = pos + 1;
          }
        }

        if (isFound) {
          start = nextStart;
          end = nextEnd;
        }
      }

      if (!isFound)
      {
        if (end < uniqueIndex.length)
          uniqueIndex.splice(end, 0, index);
        else
          uniqueIndex.push(index);
      }       
    };

    // use one array to stroe one column header title
    function buildOneHeader(index, startDim, dimNum)
    {
      var result = [];
      for(var i = startDim; i < startDim + dimNum; ++i)
      {
        result.push(data_.values[i].rows[index].val);
      }
      return result;
    };

    // generate hashmap map from name to col index
    function generateIndexMap(allUniqueColIndex, startDim, dimNum)
    {
      var map = {};
      for(var i = 0; i < allUniqueColIndex.length; ++i)
      {
        map[buildOneHeader(allUniqueColIndex[i], startDim, dimNum)] = i;
      }
      return map;
    };

    function processColHeader(startDim, dimNum)
    {
      var colIndex = [];
      var allUniqueColIndex = [];
      allUniqueColIndex.push(0);
      for(var i = 1; i < data_.values[startDim].rows.length; ++i)
      {
        buildUniqueIndexes(allUniqueColIndex, i, startDim, dimNum);
      }

      //build column dimension data set
      var colDimVals = colDimension_.values;
      for(var i = 0; i < dimNum; ++i)
      {
        var element = {};
        element.col = data_.values[startDim + i].col;
        element.rows = [];
        element.rows[0] = {'val':data_.values[startDim + i].rows[0].val};
        colDimVals.push(element);
      }
      for(var i = 0; i < allUniqueColIndex.length; ++i)
      {
        for(var j = 0; j < dimNum; j++)
        {
          colDimVals[j].rows[i] = {'val': data_.values[startDim + j].rows[allUniqueColIndex[i]].val};
        }

      }
      // to solve performance issue
      var hashMap = generateIndexMap(allUniqueColIndex, startDim, dimNum);
      for(var i = 0; i < data_.values[startDim].rows.length; ++i)
      {
        var element = buildOneHeader(i, startDim, dimNum);
        colIndex[i] = hashMap[element];
      }
      colCount_ = allUniqueColIndex.length;
      return colIndex;
    };
    
    
    function cloneOneContext(ctx)
    {
      if(!ctx) return null;
      return {
        'type': ctx.type,
        'path':{
          'aa': ctx.path.aa,
          'di': ctx.path.di,
          'dii': ctx.path.dii
        }
      };
    };
    
    function cloneOneRowContext(row)
    {
      var clones = [];
      for(var i = 0; i < row.length; ++i)
      {
        clones.push(cloneOneContext(row[i]));
      }
      return clones;
    };

    function addMeasureContext(row, ctx)
    {
      
      for(var i = 0; i < row.length; ++i)
      {
        if(!row[i]) row[i] = {path:{}};
        row[i].path.mg = ctx.path.mg;
        row[i].path.mi = ctx.path.mi;
      }
    };

    function expendContexts(num)
    {
      var totalRow = ctx_.length;
      for(var i = 0; i < num; ++i)
      {
        for(var j = 0; j < totalRow; ++j)
        {
          ctx_.push(cloneOneRowContext(ctx_[j]));
        }
      }
    };

    function addMND(bMNDInner, bMNDInRow, dimInRow, dimInCol)
    {
      var indexMND = bMNDInner ? data_.values.length - 1 : 0;
      var measures = data_.values[indexMND].rows;
      //new dimension to add row or column
      var row = {};
         row.col = data_.values[indexMND].col;
         row.rows = []; 
      var dimVals = bMNDInRow ? rowDimension_.values :colDimension_.values;
      var dimNums = bMNDInRow ? dimInRow : dimInCol;
      
      //1 MND in row and no dimension in row
      if(bMNDInRow && dimInRow == 0)
      {
        dimVals[0] = { 
            'col':{
            'val': "MND"
          },
          'rows':[]
        };
        addMeasureContext(ctx_[0], measures[0].ctx);
        dimVals[0].rows.push({ 'val': measures[0].val});
        for(var i = 1; i < measures.length; ++i)
        {
          dimVals[0].rows.push({ 'val': measures[i].val});
          ctx_.push(cloneOneRowContext(ctx_[0]));
          addMeasureContext(ctx_[i], measures[i].ctx);
        }
        rowCount_ = measures.length;
        return;
      }
      
      //2 MND in column and no dimension in column
      if(!bMNDInRow && dimInCol == 0)
      {
        //create column dimension and set value
        dimVals[0] = { 
            'col':{
            'val': "MND"
            },
            'rows':[]
        };
        for(var i = 0; i < measures.length; ++i)
        {
          dimVals[0].rows.push({'val' : measures[i].val});
        }
        
        // expand context  
        for(var i = 0; i < ctx_.length; ++i)
        {
          ctx_[i][0].path.mg = measures[0].ctx.path.mg;
          ctx_[i][0].path.mi = measures[0].ctx.path.mi;
          for(var j = 1; j < measures.length; ++j)
          {
            ctx_[i].push(cloneOneContext(ctx_[i][0]));
            ctx_[i][j].path.mg = measures[j].ctx.path.mg;
            ctx_[i][j].path.mi = measures[j].ctx.path.mi;
          }
        }
        return;
      }
      var count = bMNDInRow ? rowCount_ : colCount_;
      // 3 have dimensions in column and have dimensions in row
      if( bMNDInner)
      {
        // add measure data
        for(var i = 0; i < count; ++i)
        {
          for(var j = 0; j < dimVals.length; ++j)
          {
            for(var k = 1; k < measures.length; ++k)
            {
              var element =  {'val':dimVals[j].rows[i * measures.length + k - 1].val};
              dimVals[j].rows.splice(i * measures.length + k, 0, element);
            }
          }
        }

        //add MND dimension to row/column
        for(var i = 0; i < count; ++i)
        {
          for(var j = 0; j < measures.length; ++j)
          {
            var element =  {'val': measures[j].val};
            row.rows.push(element);
          }
        }
        dimVals.push(row);

        if(bMNDInRow)
        {
          rowCount_ *= measures.length;
          for(var i = 0; i < rowCount_; i += measures.length)
          {
            addMeasureContext(ctx_[i], measures[0].ctx);
            for(var j = 1; j < measures.length; ++j)
            {
              var oneRow = cloneOneRowContext(ctx_[i]);
              ctx_.splice(i + j, 0, oneRow);
              addMeasureContext(ctx_[i + j],  measures[j].ctx);
            }
          }

        }else{      
          colCount_ *= measures.length;
          for(var i = 0; i < ctx_.length; ++i)
          {
            for( var j = 0; j < colCount_; j+= measures.length)
            {
              ctx_[i][j].path.mg = measures[0].ctx.path.mg;
              ctx_[i][j].path.mi = measures[0].ctx.path.mi;    
              for(var k = 1; k < measures.length; ++k)
              {
                ctx_[i].splice(j + k, 0, cloneOneContext(ctx_[i][j]));
                ctx_[i][j + k].path.mg = measures[k].ctx.path.mg;
                ctx_[i][j + k].path.mi = measures[k].ctx.path.mi;
              }
            }
          }
        }
        return;
      }
      else {

        //expand value first; 
        for(var i = 1; i < measures.length; ++i)
        {
          for(var j = 0; j < dimNums; ++j)
          {
            for(var k = 0; k < count; ++k)
            {
              var element = {'val': dimVals[j].rows[k].val};
              dimVals[j].rows.push(element);
            }
          }
        }

        //add 
        for(var j = 0; j < measures.length; ++j)
        {
          for(var i = 0; i < count; ++i)
          {
            var element =  {'val': measures[j].val};
            row.rows.push(element);
          }
        }
        dimVals.splice(0, 0, row);
        if(bMNDInRow)
        {
          rowCount_ *= measures.length;
          expendContexts(measures.length - 1);
          for(var i = 0; i < rowCount_; ++i)
          {
            addMeasureContext(ctx_[i], measures[rowCount_ % measures.length].ctx);
          }
        }else{
          colCount_ *= measures.length;

          for(var i = 0; i < ctx_.length; ++i)
          {
            var rows = [];
            addMeasureContext(ctx_[i], measures[0].ctx);
            for(var j = 1; j < measures.length; ++j)
            {
              var addedRow = cloneOneRowContext(i);
              addMeasureContext(addedRow, measures[0].ctx);
              rows = rows.concat(cloneOneRowContext(i));
            }
            ctx_[i] = ctx_[i].concat(rows);
          }
        }
      }
    };
    
    function buildRowDimension(dimInRow, startIndex, rowIndexs){

      var rowDimVals = rowDimension_.values;
      for(var i = 0; i < dimInRow; ++i)
      {
        var element = {};
        element.col = data_.values[startIndex + i].col;
        element.rows = [];
        element.rows[0] = {'val':data_.values[startIndex + i].rows[0].val};
        rowDimVals.push(element);
      }
      for (var i = 1; i < data_.values[startIndex].rows.length; ++i)
      {
        if (compare(i, i - 1, startIndex, dimInRow))
          rowIndexs[i] = rowCount_;
        else {  
          ++rowCount_;
          for(var j = 0; j < dimInRow; j++)
          {
            rowDimVals[j].rows[rowCount_] = {'val': data_.values[startIndex + j].rows[i].val};
          }
          rowIndexs[i] = rowCount_;
        }
      }
      ++rowCount_;
    };
    
    // Mix MND and dimension case
    function processDimsWithMeasure()
    {
      var startIndex = 0,
        endIndex = data_.values.length;
      var dimInRow = dimInRow_,
        dimInCol = dimInCol_;
      var bMNDInner = false,
        bMNDInRow = true;
      if(data_.values[0].type == "MND")
      {
        ++startIndex;
        if(dimInRow > 0) 
          --dimInRow;
        else {
          --dimInCol;
          bMNDInRow = false;
        }
      }

      if(data_.values[endIndex - 1].type == "MND")
      {
        bMNDInner = true;
        --endIndex;
        if(dimInCol > 0)
        {
          --dimInCol;
          bMNDInRow = false;
        }else{
          bMNDInRow = true;
          --dimInRow;
        }
      }

      //process no MND cases first
      if(startIndex < endIndex)
      {
        //some dimension in row and some in column 
        var rowIndexs = [];
        if(dimInCol > 0 || dimInRow > 0)
        {
          //process row dimension first
          rowIndexs[0] = 0;
          rowCount_ = 0;
          if(dimInRow > 0)
          {
            buildRowDimension(dimInRow, startIndex, rowIndexs);
          }else{
            rowCount_ = 1;
            for(var i = 1; i < data_.values[startIndex].rows.length; ++i)
              rowIndexs[i] = 0;
          }
          
          //build column dimensions and indexes
          var colIndexs = [];
          if(dimInCol > 0)
          {
            colIndexs = processColHeader(startIndex + dimInRow, dimInCol);
          }else{
            colCount_ = 1;
            for(var i = 0; i < data_.values[startIndex].rows.length; ++i)
              colIndexs[i] = 0;
          }
          
          //generate data context for each sub chart
          ctx_ = new Array(rowCount_);
          for(var i = 0; i < rowCount_; ++i)
          {
            ctx_[i] = [];
            for(var j = 0; j < colCount_; ++j)
              ctx_[i][j] = null;
          }

          for(var i = 0 ; i < data_.values[startIndex].rows.length; ++i)
          {
            ctx_[rowIndexs[i]][colIndexs[i]] = data_.values[startIndex + dimInRow + dimInCol - 1].rows[i].ctx;
          }
        }
        
        //process measure names at last
        if(dimInRow < dimInRow_ || dimInCol < dimInCol_)
        {
          addMND(bMNDInner, bMNDInRow, dimInRow, dimInCol);
        }
      }
    };

    my.process = function()
    {
      initilize();
      if(!data_ || !data_.values || data_.values.length == 0) return;
      dimInCol_ =  props_ && props_["numberOfDimensionsInColumn"] != undefined ?  props_["numberOfDimensionsInColumn"] : 1;
      if(!dimInCol_ || dimInCol_ < 0) dimInCol_ = 0;
      if(dimInCol_ > data_.values.length) dimInCol_ = data_.values.length;
      dimInRow_ = data_.values.length - dimInCol_;
      if(dimInRow_ < 0) dimInRow_ = 0;

      if(data_.values.length == 1 && data_.values[0].type == "MND")
      {
        buildIndexMeasuresOnly();
      }else{
        processDimsWithMeasure();
      }
    };

    return my;

  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.tablecontainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.DimensionalInfoHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
}
],
function Setup ( TypeUtils, Objects, Functions, layout, DIHandler, MCHandler, Manifest, MultiAxesDataAdapter,dispatch) {
  
  return function (manifest) {
    var width = 0, 
        height = 0,
        centerWidth = 0, //size for the real table area without table headers
        centerHeight = 0, 
        properties = {},
        effectManager = null,
        //for containers we use properties to hold any properties we have to pass to sub
        //then we use this internalProps to hold properties for container itself
        internalProps = manifest.props(null),
        internalRange = {}, //used for data range merge
        multiData = {
          
        },//used to save raw data process result
        subModuleNames = [], //used to update sub modules while data updating
        subControllerNames = [], //used to update controllers while data updating  
        data = null,
        config = {},
        modules = {},
        selections = {},
        parent = null, // a d3 selection
        rows = 3,
        columns = 2,
        xCategoryScale = d3.scale.ordinal(),
        yCategoryScale = d3.scale.ordinal(),
        eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0, avaModulesCount = 0;
    
    //for container, we won't extract properties exactly for it. so we have to
    //get property by ourselves. the property category should be consistent with
    //module definition
    var PROPERTYCATEGORY = 'multiLayout';
    
    function load(moduleId) {
      return Manifest.module.get(moduleId).execute();
    }
    
    function initialize() {
      if ( TypeUtils.isEmptyObject(config) ) Functions.error('Container configuration missing');
      
      processRawData();
      avaPlotCount = 0, avaModulesCount = 0;
      //Jimmy/9/13/2012 we only support yAxis and xAxis2 for now, the other two won't be initialized
      initAxis(config, 'xAxis', multiData.columnData);
      initAxis(config, 'yAxis', multiData.rowData);
      initAxis(config, 'xAxis2', multiData.columnData);
      initAxis(config, 'yAxis2', multiData.rowData);
      
      initializePlots();
      updatePlotProperties();
      updatePlotData();
      initializePlotElements();
      
      avaModulesCount = avaModulesCount + avaPlotCount;
    }
    
    function processRawData() {
      delete multiData.contexts;
      delete multiData.columnData;
      delete multiData.rowData;
      delete multiData.dataHandler;
      //get dimensional info
      //FIXME jimmy/8/8/2012, we assume to use dimensional layout by default
      //we may need support other layouts
      //FIXME jimmy/8/8/2012, how to know which feed is for multiplier?
      var dih = DIHandler({
        'numberOfDimensionsInColumn' : internalProps.numberOfDimensionsInColumn
      }, data.getAnalysisAxisDataByIdx(0));//data['sap.viz.multiplier']);
      
      dih.process();
      
      var rowD = dih.getRowDimensionData();
      var columnD = dih.getColumnDimensionData();
      var contexts = dih.getContexts();
      rows = contexts.length;
      columns = rows > 0 ? contexts[0].length : columns;
      
      var columnData = new MultiAxesDataAdapter();
      columnData.addAnalysisAxis({key:columnData.key, index : 0, values: columnD.values});
      var rowData = new MultiAxesDataAdapter();
      rowData.addAnalysisAxis({key:rowD.key, index : 0, values: rowD.values});
      
      multiData.contexts = contexts;
      multiData.columnData = columnData;
      multiData.rowData = rowData;
      multiData.dataHandler = new MCHandler(data);
    }
    
    function initAxis( config, id , axisData) {
      if ( !config.modules[id] ) return;
      
      var axisConfig = config.modules[id],
          axis = modules[id] = load(axisConfig.id); // Saves references to axis function.
      
      updateAxisData(id, axisData);
          
      var props = {}, usrProps, sysProps;
      if ( axisConfig.configure ) {
        usrProps = properties[axisConfig.configure.propertyCategory] || {};
        sysProps = axisConfig.configure.properties || {};
        Objects.extend( true, props, sysProps, usrProps );
        axis.properties(props);
      }
      axis.effectManager(effectManager);
      
      if(axis.dispatch && axis.dispatch()['initialized']){
        avaModulesCount++;
        axis.dispatch().on('initialized.tablecontainer', initialized);
      }
      
      selections[id] = parent.append('g').attr('class', id);
    }
    
    function updateAxisData (id, axisData) {
      if(modules[id]){
        modules[id].data(axisData);
      }
    }
    
    function initializePlots() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) return;
      
      cleanSubControllers();
      cleanSubModules();

      //we will create multi plot here
      var contexts = multiData.contexts;
      var plots = modules.plot = [];
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          //contexts returned from dimensionalInfoHandler is rows*column
          var ctxI = contexts[rowI][colI];
          //[Jimmy/8/28/2012]we won't create sub plots when ctxI is undefined. but do we need
          //filter them out of the array? currently we will still have the full-size array with
          //some of them undefined. other parts who need read them should pay attention to (like
          //dependency resolving, and controller etc.)
          if(ctxI){
            
            var i = colI * rows + rowI;
            var plotI = plots[i] = load(plotConfig.id);
            plotI.config(plotConfig);
            plotI.effectManager(effectManager);

            if(plotI.dispatch){
              avaPlotCount++;
              var dis =  plotI.dispatch();
                 if(dis.initialized) dis.on('initialized.tablecontainer', initialized);
                 if(dis.showTooltip) dis.on('showTooltip.tablecontainer', showTooltip);
                 if(dis.hideTooltip) dis.on('hideTooltip.tablecontainer', hideTooltip);
            }
          }
        }
      }
    }
    
    function updatePlotProperties() {
      var plots = modules.plot;
      if(plots){
        var plotConfig = config.modules.plot;
        if ( !plotConfig ) return;
        //Jimmy/8/23/2012 pay attention to the property structure, for container we will pass
        //all properties instead of properties under propsCat only.
        //FIXME currently it's hard coded here we assume the plot is container, actually we should
        //check the plot type
        var props = null, usrProps, sysProps;
        var nodeConfig = plotConfig.configure;
        if ( nodeConfig ) {
          sysProps = {};
          if ( nodeConfig.propertyCategory ) {
            sysProps[nodeConfig.propertyCategory]  = nodeConfig.properties;
          }
          usrProps = properties;
          props = {};
          Objects.extend( true, props, sysProps, usrProps ); 
        }else{
          props = properties;
        }
        
        for(var i = 0, len = plots.length; i < len; i++){
          if(props && plots[i]){
            plots[i].properties(props);
          }
        }
      }
    }
    
    function updatePlotData() {
      var dataHandler = multiData.dataHandler;
      var contexts = multiData.contexts;
      var plots = modules.plot;
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          //contexts returned from dimensionalInfoHandler is rows*column
          var ctxI = contexts[rowI][colI];
          if(ctxI){
            var i = colI * rows + rowI;
            var dataI = dataHandler.getSubDataAdapter(ctxI);
            if(plots[i]){
              plots[i].data(dataI);
            }  
          }
        }
      }
    }
    
    function initializePlotElements() {
      var plotConfig = config.modules.plot;
      if ( !plotConfig ) return;
           
      var plots = modules.plot;
      var splots = selections.plot = [];
      if(selections.plotRoot){
        selections.plotRoot.remove();
      }
      var plotRoot = selections.plotRoot = parent.append('g').attr('class', 'plot');
      
      for(var colI = 0; colI < columns; colI++){
        for(var rowI = 0; rowI < rows; rowI++){
          var i = colI * rows + rowI;
          if(plots[i]){
            var plotI = plots[i];
            
            //create svg elements
            splots[i] = plotRoot.append('g').attr('class', 'plot' + i);
            plotI.parent(splots[i]);
            
            if(plotI.modules){
              var subModules = plotI.modules();
              var sname;
              for ( var m in subModules ){
                if ( subModules.hasOwnProperty(m) ){
                  sname = 'plot[' + i + ']' + '.' + m;
                  subModuleNames.push(sname);
                  modules['plot[' + i + ']' + '.' + m] = subModules[m];
                }
              }  
            }
            
             //Jimmy/8/22/2012 we introduce controller module which can be configured to any module (except controller module of course)
            //as for now, we only add the support to container. TODO
           
            var nodeController = plotConfig.controllers;
            if(nodeController){
              for(var nc in nodeController){
                if(nodeController.hasOwnProperty(nc)){
                  var controllerConfig = nodeController[nc];
                  var controller = load(controllerConfig.id);
                  controller().module(plotI);
                  props = {};
                  propsCat = controllerConfig.propertyCategory;
                  usrProps = properties[ propsCat ];
                  sysProps = controllerConfig.properties;
                  Objects.extend( true, props, sysProps, usrProps );
                  controller.properties(props);
                  subControllerNames.push('plot[' + i + ']' + '.' + nc);
                  modules['plot[' + i + ']' + '.' + nc] = controller;
                }
              }
            }
          }
        }
      }
    }
    
    function cleanSubControllers() {
      //clean all current submodules
      for(var i = 0, len = subControllerNames.length; i < len; i++){
        delete modules[subControllerNames[i]];
      }
      subControllerNames = [];
    }
    
    function cleanSubModules () {
      //clean all current submodules
      for(var i = 0, len = subModuleNames.length; i < len; i++){
        delete modules[subModuleNames[i]];
      }
      subModuleNames = [];
    }

    function relayout() {
      if ( TypeUtils.isEmptyObject(modules) || !width || !height ) return;
      
      var prefs = {};
      if ( modules.xAxis ) {
          modules.xAxis.drawable(true);
          prefs.south = { size : modules.xAxis.getPreferredSize() };
      }
      if ( modules.yAxis ) {
          modules.yAxis.drawable(true);
          prefs.west = { size : modules.yAxis.getPreferredSize() };
      }
      if ( modules.xAxis2 ) {
          modules.xAxis2.drawable(true);
          prefs.north = { size : modules.xAxis2.getPreferredSize() };
      }
      if ( modules.yAxis2 ) {
          modules.yAxis2.drawable(true);
          prefs.east = { size : modules.yAxis2.getPreferredSize() };
      }
      if ( modules.plot ) prefs.center = {};
      
      var solution = layout({
        type : 'border',
        bias : 'none',
        size : { width : width, height : height },
        prefs : prefs
      });
      
      centerWidth = solution.center.bounds.width;
      centerHeight = solution.center.bounds.height;
      
      //JIMMY/8/8/2012, WHY WE NEED DO THIS HERE?
      //the first time layout, we haven't set scale to axis (as dependency resolve happens after
       // the first layout), so the preferred size we get from axis is 0. then during dependency
       //resolving, we return scale to axis based on this inaccurate preferred size.
       
       //then during rendering, we will do layout again, this time we get a new preferred size from
       //axis as axis has scale now. but with this new preferred size, the scale has also to be updated,
       //but we won't do dependency resolving anymore. so we have to update the scale here. as axis
       //has the same reference of the scale, it can also get the new scale value.
       
       //so the preferred size returned by axis is actually based on the old scale and thus inaccurate. why
       //it doesn't affect the rendering result? for horizontal axis, the scale only matters the width of the axis
       //which we don't care, we only care height for horizontal axis. for vertical axis, the scale only matters
       //the height of the axis while we only care the width of it during layout.
       
       //so that's why we need layout again before rendering? we want to get the preferredsize from axis
       //even with a wrong scale. if axis can return preferredsize without scale (it's only possible for one
       //direction which is exactly we care during layout), we don't need do this.  
      xCategoryScale.rangeBands([0, centerWidth]);
      yCategoryScale.rangeBands([0, centerHeight]);
      
      if ( solution.north ) {
        // Modifies xAxis width and coordinate to handle horizontal offset
        // to ensure joints with yAxis.
        var xAxis2Width = 0, xAxis2X = 0;
        if ( solution.west ) {
          xAxis2Width = solution.north.bounds.width - solution.west.bounds.width;
          xAxis2X = solution.north.bounds.x + solution.west.bounds.width;
        }
        if ( solution.east ) {
          xAxis2Width = solution.north.bounds.width - solution.east.bounds.width;
        }
        
        selections.xAxis2.attr('transform', 
          'translate(' + xAxis2X + ',' + solution.north.bounds.y + ')');
        
        modules.xAxis2
          .width(xAxis2Width)
          .height(solution.north.bounds.height);
      
        modules.xAxis2.gridlineLength(solution.center.bounds.height);  
      } else if (modules.xAxis2) {
          modules.xAxis2.drawable(false);
      }
      
      if ( solution.east ) {
        selections.yAxis2.attr('transform', 
          'translate(' + solution.east.bounds.x + 
          ',' + solution.east.bounds.y + ')');
        modules.yAxis2
          .width(solution.east.bounds.width)
          .height(solution.east.bounds.height);
          
        modules.yAxis2.gridlineLength(solution.center.bounds.width);    
      } else if (modules.yAxis2) {
          modules.yAxis2.drawable(false);
      }
      
      if ( solution.south ) {
        // Modifies xAxis width and coordinate to handle horizontal offset
        // to ensure joints with yAxis.
        var xAxisWidth = 0, xAxisX = 0;
        if ( solution.west ) {
          xAxisWidth = solution.south.bounds.width - solution.west.bounds.width;
          xAxisX = solution.south.bounds.x + solution.west.bounds.width;
        }
        if ( solution.east )
          xAxisWidth = solution.south.bounds.width - solution.east.bounds.width;
        
        selections.xAxis.attr('transform', 
          'translate(' + xAxisX + ',' + solution.south.bounds.y + ')');
        
        modules.xAxis
          .width(xAxisWidth)
          .height(solution.south.bounds.height);

        modules.xAxis.gridlineLength(solution.center.bounds.height);
      } else if (modules.xAxis) {
          modules.xAxis.drawable(false);
      }
      
      if ( solution.west ) {
        selections.yAxis.attr('transform', 
          'translate(' + solution.west.bounds.x + 
          ',' + solution.west.bounds.y + ')');
        modules.yAxis
          .width(solution.west.bounds.width)
          .height(solution.west.bounds.height);
      
        modules.yAxis.gridlineLength(solution.center.bounds.width);       
      } else if (modules.yAxis) {
          modules.yAxis.drawable(false);
      }
      
      if ( solution.center ) {
        selections.plotRoot.attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ',' + solution.center.bounds.y + ')');
          
        var centersolution = layout({
          type : 'table',
          bias : 'none',
          size : { width : solution.center.bounds.width, height : solution.center.bounds.height },
          columns : columns,
          rows : rows,
          cellpadding : internalProps.cellPadding,
          paddingThreshold : internalProps.paddingThreshold
        });
        
        for(var colI = 0; colI < columns; colI++){
          for(var rowI = 0; rowI < rows; rowI++){
            var plotI = modules.plot[colI * rows + rowI];
            if(plotI){
              var csi = centersolution[colI][rowI];
              var splotI = selections.plot[colI * rows + rowI];
              plotI.width(csi.bounds.width).height(csi.bounds.height);
              splotI.attr('transform', 
                  'translate(' + csi.bounds.x + 
                  ',' + csi.bounds.y + ')');
            }
          }
        }
      }
    }
    
    
    function dataRange(type) {
        return function(range) {
            if (!arguments.length) {
                return internalRange[type];
            } else {
                if (!internalRange[type]) {
                    internalRange[type] = range;
                } else {
                    var currentRange = internalRange[type];
                    if (range.distinctValuesObj) {
                        for (var i in range.distinctValuesObj) {
                            currentRange.distinctValuesObj[i] = range.distinctValuesObj[i];
                        }
                    }
                    
                    if (range.min < currentRange.min) {
                        currentRange.min = range.min;
                    }
                    if (range.max > currentRange.max) {
                        currentRange.max = range.max;
                    }
                    
                    if (range.hasNoValue) {
                      currentRange.hasNoValue = true;
                    }

                }
            }
        };
    }

    
    function resolveMergeDataRange (types){
      //for each type we will generate a function to set/get data range
      for(var i = 0, len = types.length; i < len; i++){
        container[types[i] + 'DataRange'] = dataRange(types[i]);
      }
    }
    
    function parseProperties (props){
      properties = props;
      if(props[PROPERTYCATEGORY]){
        if(props[PROPERTYCATEGORY].mergeDataRange){
          internalProps.mergeDataRange = props[PROPERTYCATEGORY].mergeDataRange;
          resolveMergeDataRange(internalProps.mergeDataRange);
        }
        Objects.extend(true, internalProps, props[PROPERTYCATEGORY]);
      }
    }
    
    function container( selection ) {
      selection.each(function ( data ) {
        parent = selection;
        if ( TypeUtils.isEmptyObject(modules) ) initialize();
        render();
      });
      return container;
    }
    
    container.width = function (_) {
      if ( !arguments.length ) return width;
      width = _;
      //Jimmy,8/20/2012, as a container, you don't know whether your
      //sub elements need relayout even if the container size remains
      //the same. so here we just give a chance to sub elements to relayout
      relayout();
      return container;
    };
    
    container.height = function (_) {
      if ( !arguments.length ) return height;
      height = _;
      //see @width
      relayout();
      return container;
    };
    
    container.size = function(_) {
      if ( !arguments.length ) return {
        'width' : width,
        'height' : height
      };
      height = _.height;
      width = _.width;
      //see @width
      relayout();
      return container;
    };
    
    container.data = function (_) {
      if ( !arguments.length ) return data;
      data = _;
      
      //clean internal data range
      for(var i in internalRange){
        if(internalRange.hasOwnProperty(i)){
          delete internalRange[i];
        }
      }
      
      if(!TypeUtils.isEmptyObject(modules)){
        processRawData();

        avaModulesCount = avaModulesCount - avaPlotCount;
       
        updateAxisData('xAxis', multiData.columnData);
        updateAxisData('yAxis', multiData.rowData);
        updateAxisData('xAxis2', multiData.columnData);
        updateAxisData('yAxis2', multiData.rowData);
        
        avaPlotCount = 0;
        //Jimmy/9/13/2012 we may have chance to split data update and data
        //schema update in the future
        initializePlots();
        updatePlotProperties();
        updatePlotData();
        initializePlotElements();
        
        avaModulesCount = avaModulesCount + avaPlotCount;
      }
      return container;
    };
    
    container.properties = function (_) {
      if ( !arguments.length ) return properties;
      //FIXME JIMMY/8/8/2012, columns/rows may be different with different properties
      parseProperties(_);
      //update properties of sub plots
      if(!TypeUtils.isEmptyObject(modules)){
        //Jimmy/9/19/2012, we may need deal with internalProps.numberOfDimensionsInColumn update
        //we don't need recreate plots but we need rearrange plots and change data
        updatePlotProperties();
      }
      return container;
    };
    
    container.config = function (_) {
      if ( !arguments.length ) return config;
      config = _;
      return container;
    };
    
    container.effectManager = function (_) {
        if ( !arguments.length ) return effectManager;
       
        effectManager = _;
        return container;
      };
    
    container.xCategoryScale = function (_) {
      if ( !arguments.length ) {
        var domain = [];
        for (var i = 0; i < columns; i++){
           domain.push(i);
        }
        var xAxis = modules.xAxis ? modules.xAxis : modules.xAxis2;
        xCategoryScale.domain(domain).rangeBands([0, centerWidth]);
        return xCategoryScale;
      }
      xCategoryScale = _;
      return container;
    };
    
    container.yCategoryScale = function (_) {
      if ( !arguments.length ) {
        var domain = [];
        for (var i = 0; i < rows; i++){
           domain.push(i);
        }
        var yAxis = modules.yAxis ? modules.yAxis : modules.yAxis2;
        yCategoryScale.domain(domain).rangeBands([0, centerHeight]);
        return yCategoryScale;
      }
      yCategoryScale = _;
      return container;
    };
    
    container.modules = function (_) {
      if ( !arguments.length ) {
        if ( TypeUtils.isEmptyObject(modules) ) {
          initialize();
        } 
        return modules;
      }
      modules = _;
      return container;
    };
    
    container.parent = function (_) {
      if ( !arguments.length ) return parent;
      parent = _;
      return container;
    };
    
    container.dispatch = function(_){
      if( !arguments.length){
        return eDispatch;
      }
      eDispatch = _;
      return container;
    };

    container.infoForSizeLegend = function() {
      var plot;
      for ( var i = -1, j = modules.plot.length; ++i < j;) {
        if (plot = modules.plot[i])
          break;
      }
      return {
        space : plot ? (width - centerWidth + plot.infoForSizeLegend().space
            * columns) : 0,
        number : columns,
        plotHeight : plot ? plot.height() : 0
      };
    };
    
    container.plotRegion = function () {
      return {
        selection: selections.plotRoot,
        width: centerWidth,
        height: centerHeight
      };
    };
    
    function renderAxis (id){
      if(selections[id]){
        parent.select('.' + id).datum(modules[id].data()).call(modules[id]);
      }
    }
    
    function render() {
      renderAxis('xAxis');
      renderAxis('xAxis2');
      renderAxis('yAxis');
      renderAxis('yAxis2');
      
      if(selections.plot){
        for(var i = 0, len = selections.plot.length; i < len; i++){
          if(selections.plot[i]){
            selections.plot[i].datum(modules.plot[i].data()).call(modules.plot[i]);
          }
        }
      }
    }
    
    var initializedPlots = 0;
    function initialized(){
      if(++initializedPlots == avaModulesCount){
        initializedPlots = 0;
        eDispatch.initialized();
      }
    }
    
    function showTooltip(evt){
      eDispatch.showTooltip(evt);
    };
    
    function hideTooltip(evt){
      eDispatch.hideTooltip(evt);
    };
    
    return container;
  };
  
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tablecontainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, moduleConstants, fn, feedConstants, Constants) {
    var multiplierFeed = {
    'id' : 'multiplier',
    'name' : 'Chart Multiplier',
    'type' : feedConstants.Type.Dimension,
    'min' : 1,
    'max' : 1,
    'aaIndex' : 1,
    'acceptMND' : 0
  };

  var module = {
    'id' : 'sap.viz.modules.tablecontainer',
    'type' : moduleConstants.Type.Container,
    'name' : 'table container',
    'description': 'Settings for the subcharts layout of multiple charts.',
    //TODO support different layout: row/column/dimensional
    'properties' : {
      'mergeDataRange' : {
        'name' : 'mergeDataRange',
        'supportedValueType' : 'List',
        'supportedValues' : ['ANY DATA RANGE NAME'],
        'defaultValue' : null,
        'description' : 'Set mergeDataRange. Specify names of data range you want to merge, we will generate corresponding functions in this module to do the real merge. for example, if \'primary\' and \'second\' are specified here, two functions will be generated: \'primaryDataRange\' and \'secondDataRange\'. the function name is the range name plus \'DataRange\'. these generated functions support both getter and setter, for setter, you can pass any number of ranges {min:NUM, max:NUM} to it to merge, then you can get the merged result through the getter.',
        'isExported' : false
      },
      'numberOfDimensionsInColumn' : {
        'name' : 'numberOfDimensionsInColumn',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 1,
        'description' : 'Set the specified number of dimensions, retrieved from the end of the dimension list in multiplier, will be put in column when doing multiple layout.'
      },
      'cellPadding' : {
        'name' : 'cellPadding',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 15,
        'description' : 'Set padding between cells of sub plots.'
      },
      'paddingThreshold' : {
        'name' : 'paddingThreshold',
        'supportedValueType' : 'Number',
        'defaultValue' : 0.2,
        'description' : 'Set paddingThreshold, if cellPadding value exceeds the containerSize * threshold, we set it to 0.',
        'isExported' : false
      }
    },
  'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
   },
    //TODO
    'css' : null,
    'feeds' : [multiplierFeed],
    'submodulekeys' : [{
      'key' : 'xAxis',
      'description' : 'Define horizontal axis module in the bottom'
    }, {
      'key' : 'xAxis2',
      'description' : 'Define horizontal axis module in the top'
    }, {
      'key' : 'yAxis',
      'description' : 'Define vertical axis module in the left'
    }, {
      'key' : 'yAxis2',
      'description' : 'Define vertical axis module in the right'
    }, {
      'key' : 'plot',
      'description' : 'Define the plot module in each cell, currently we only support same plot for all cells'
    }],
    'fn' : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.xycontainer',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.xycontainer',
    'type' : Constants.Module.Type.Container,
    'name' : 'single container',
    'properties' : null,
    'css' : null,
    'configure' : null,
    'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    'submodulekeys' : [ {
      'key' : 'xAxis',
      'description' : 'Define horizontal axis module in the bottom'
    }, {
      'key' : 'xAxis2',
      'description' : 'Define horizontal axis module in the top'
    }, {
      'key' : 'yAxis',
      'description' : 'Define vertical axis module in the left'
    }, {
      'key' : 'yAxis2',
      'description' : 'Define vertical axis module in the right'
    }, {
      'key' : 'plot',
      'description' : 'Define the plot module in the center'
    }, {
      'key' : 'background',
      'description' : 'Define the background in the center'
    }
    ],
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.legend',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.legend',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'legend',
    'description': 'The legend is a box containing a symbol and name for each series item or point item in the chart.',
    'properties' : {
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : true,
        'description' : 'Set visibility of legend.'
      },
      'title' : {
        'name' : 'title',
      'description' : 'Settings for legend title.',
        'supportedValueType' : 'Object',
        'supportedValues' : {
        'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set visibility of legend title.'
           }, 
          'text':{
            'name' : 'text',
            'supportedValueType' : 'String',
            'description' : 'Set text of legend title.'
           }
        }
      },
      'isHierarchical' : {
        'name' : 'isHierarchical',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set hierarchy legend. Supported only when legend is located in the right of chart.',
      },
      'position' : {
        'name' : 'position',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'right' ],
        'defaultValue' : 'right',
        'description' : 'Set legend position. Only support legend is located in the right side.',
        'isExported' : false
      },
      'type' : {
        'name' : 'type',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'ColorLegend', 'BubbleColorLegend', 'SizeLegend', 'MeasureBasedColoringLegend' ],
        'defaultValue' : 'ColorLegend',
        'description' : 'Set legend type of Bubble chart. Non-bubble chart is not supported.',
        'isExported' : false
      },
      'alignment' : {
        'name' : 'alignment',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'start', 'middle', 'end' ],
          'defaultValue' : 'start',
          'description' : 'Set alignment of legend.',
          'isExported' : false
      },
      'drawingEffect':{
        'name' : 'drawingEffect',
         'supportedValueType' : 'List',
          'supportedValues' : [ 'normal', 'glossy' ],
          'defaultValue' : 'normal',
          'description' : 'Set drawing effect of legend.',
          'isExported' : true
      }
    },
    'css' : {
      '.viz-legend-title' : {
        'description' : 'Define style for the legend title.',
        'value' : {
          'fill' : 'black',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'bold'
        }
      },
      '.viz-legend-valueLabel' : {
        'description' : 'Define style for the legend label.',
        'value' : {
          'fill' : 'black',
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '12px',
          'font-weight' : 'normal'
        }
      }
    },
    'configure' : null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.title',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(TextUtils, langManager) {
  var title = function(manifest) {
    var width = 500, height = 100; 
    var titleStyle = null;
    var effectManager = null;
    
    var options = {}, size = {
      width : 500,
      height : 100
        }, titleText = undefined;
    
    var chart = function(selection) {
      if (options.visible) {
        updateTitleStyle();
        var wrapper = this.selectAll('text.chart-title').data([titleText]);
        wrapper.exit().remove();
        wrapper.enter().append('text').attr('class', 'chart-title');
        wrapper.attr('style', titleStyle)
               .attr('text-anchor', function(){
                 if (options.alignment == 'right')
                    return 'end';
                 else if (options.alignment == 'left')
                    return 'start';
                 else
                    return 'middle';   
               })
               .attr('x', function() {
                 if (options.alignment == 'right')
                   return width;
                 else if (options.alignment == 'left')
                   return 0;
                 else
                   return (width) / 2; //"center" anyway
               }).attr('y', height/2);
        TextUtils.ellipsis(titleText, wrapper.node(), width, titleStyle.toString());
      }
      
      return chart;
    };

    chart.width = function(value) {
      if(!arguments.length)
        return width;
      width = value;
      return chart;
    };

    chart.height = function(value) {
      if(!arguments.length)
        return height;
      height = value;
      return chart;
    };
    
    chart.size = function(value) {
      if(!arguments.length)
        return size;
      size = value;
      return chart;
    };

    chart.properties = function(properties) {
      if (!arguments.length)
        return options;

      options = manifest.props(properties);

      if (!options.text) {
        titleText = langManager.get('IDS_DEFAULTCHARTTITLE');
      }else{
        titleText = options.text;
      }

      return chart;
    };

    chart.effectManager = function(_) {
      if(!arguments.length)
        return effectManager;
      effectManager = _;
      return chart;
    };
    
    chart.getPreferredSize = function() {
      if (options.visible) {
        updateTitleStyle();
        var titleSize = TextUtils.measure(titleText, titleStyle);
        return {
          hideOversize : true,
          maxSizeConstant : 1 / 3,
          'width' : titleSize.width,
          'height' : titleSize.height
        };
      }
      
      return {
        'width' : 0,
        'height' : 0
      };      
    };
    
    function updateTitleStyle() {
      titleStyle = manifest.cssText('viz-title-label');
    }
    
    chart.properties(null);
    return chart;
  };
  
  return title;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.title',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.title',
    'type' : Constants.Module.Type.Supplementary,
    'name' : 'title',
    'description': "Settings for the chart's main title.",
    'properties' : {
      'visible' : {
        'name' : 'visible',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set visibility of chart title.'
      },
      'text' : {
        'name' : 'text',
        'supportedValueType' : 'String',
        'description' : 'Set chart title text.'
      },
      'alignment' : {
        'name' : 'alignment',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'left', 'center', 'right' ],
        'defaultValue' : 'center',
        'description' : 'Set chart title alignment.'
      }
    },
    'css' : {
      '.viz-title-label' : {
        'description' : 'Define style for the title label.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '16px',
          'font-weight' : 'bold',
          'fill' : '#333333'
        }
      }
    },
    'configure' : null,
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(manifest, ObjectUtils, langManager) {
  /**
   * This is a instantce , which already have been registered into {@link sap.viz.manifest.feeds}.</br>
   * </br>
   * Now, once an item is loaded from {@link sap.viz.manifest.feeds}, it will automatically provide some APIs .</br>
   * </br>
   * @see sap.viz.manifest.feeds#get
   * @class Built-in_Manifest_Objects.feedsManifest
   * @example
   * var pieFeed = manifest.feeds.get(pieId);
   */
  return manifest.registerCategory("feeds", function(obj) {

    var feeds = {};
    obj.feeds.forEach(function(o) {
      feeds[o.id] = o;
      var na = o.name;
      delete o.name;
      Object.defineProperty(o, 'name', {
        set:function(){value = na;},
        get:function(){
          var res = langManager.get(na);
          if(res) return res;
          return na;
        },
         enumerable : true,
      });
    });
    /**
     * This is a instantce , which already have been registered into {@link sap.viz.manifest.feeds}.</br>
     * </br>
     * Now, once an item is loaded from {@link sap.viz.manifest.feeds}, it will automatically provide some APIs .</br>
     * </br>
     * @see sap.viz.manifest.feeds#get
     * @class Built-in_Manifest_Objects.feedsManifest
     * @example
     * var pieFeed = manifest.feeds.get(pieId);
     * @ignore
     */
    Object.defineProperty(obj, "feedsMap", {
      value : feeds,
      writable : false,
      enumerable : false,
      configurable : false
    });

    return obj;
  });
});sap.riv.module(
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(manifest, feedsManifest, ObjectUtils, constants, module,
    langManager) {
  function getModuleByType(modules, type) {
    for ( var i = 0; i < modules.length; ++i) {
      if (modules[i].module.type === type) {
        return modules[i];
      }
      if (modules[i].subModules) {
        var r = getModuleByType(modules[i].subModules, type);
        if (r)
          return r;
      }
    }
    return null;
  }

  function loadFeeds(allFeeds, modules, aaIndexOffset, mndProOffset) {
    if (modules) {
      modules.forEach(function(o) {
        var feeds = o.module.feeds;
        var newAAIndexOffset = aaIndexOffset;
        var newMNDProOffset = mndProOffset;
        if (feeds) {
          var moduleFeeds;
          var feedsId = feeds.id;
          if (feedsId !== undefined) {
            var feedsConfigure = feeds.configure;
            moduleFeeds = feedsManifest.get(feedsId).feedsMap;
            if (feedsConfigure)
              moduleFeeds = ObjectUtils.extend(true, null, moduleFeeds,
                  feedsConfigure);
          } else {
            moduleFeeds = {};
            feeds.forEach(function(feed) {
              moduleFeeds[feed.id] = feed;
            });
          }

          var i;
          for (i in moduleFeeds) {
            var feed = moduleFeeds[i];
            if (feed) {
              feed = ObjectUtils.extend(true, null, feed);
              allFeeds[i] = feed;
              if (feed.type == constants.Feed.Type.Dimension) {
                var aaIndex = feed.aaIndex;
                aaIndex += aaIndexOffset;
                if (newAAIndexOffset < aaIndex)
                  newAAIndexOffset = aaIndex;
                feed.aaIndex = aaIndex;

                var mndPro = feed.acceptMND;
                if (mndPro >= 0) {
                  if (mndProOffset > 0)
                    mndPro += mndProOffset;

                  if (newMNDProOffset < mndPro)
                    newMNDProOffset = mndPro;

                  feed.acceptMND = mndPro;
                }
              }
            }
          }
          if (newMNDProOffset >= 0)
            newMNDProOffset += 1;

        }
        loadFeeds(allFeeds, o.subModules, newAAIndexOffset, newMNDProOffset);
      });
    }
  }
  /**
     * This is a instantce , which already have been registered into {@link sap.viz.manifest.viz}.</br>
     * </br>
     * Now, once an item is loaded from {@link sap.viz.manifest.viz}, it will automatically provide some APIs .</br>
     * </br>
     * @example
     * 
     * var allFeedOfBar = manifest.viz.get(barType).allFeeds();
     *
     * @see sap.viz.manifest.viz#get
     * @class Built-in_Manifest_Objects.vizManifest
     */
  return manifest
      .registerCategory(
          "viz",
          function(obj) {
            var modules = new Array();
            var configModules = obj.modules;
            for ( var moduleRefName in configModules) {
              var moduleRef = configModules[moduleRefName];
              if (moduleRef != null)
                manifest.module.loadModule(modules,
                    configModules[moduleRefName]);
            }

            var feedsConfigure = obj.feeds;
            var allFeeds, vizname = obj.name;
            delete obj.name;
            Object
                .defineProperties(
                    obj,
                    {
                      /**
                         * get the feeds definition of an item in {@link sap.viz.manifest.viz}
                         * @method Built-in_Manifest_Objects.vizManifest#allFeeds
                         * @return {[Object] allFeeds} all feeds definition of an item
                         * @example
                         * 
                         * var allFeedOfBar = manifest.viz.get(barType).allFeeds();
                         *
                         */
                      allFeeds : {
                        value : function() {
                          if (!allFeeds) {
                            var allFeeds = {};
                            loadFeeds(allFeeds, modules, 0, -1);
                            ObjectUtils.extend(true, allFeeds, feedsConfigure);
                            allFeeds = d3.values(allFeeds).filter(function(o) {
                              return o;
                            });
                          }
                          return allFeeds;
                        }
                      },
                      getChartPropCate : {
                        value : function() {
                          return getModuleByType(modules, 'CHART').config.configure.propertyCategory;
                        }
                      },
                      name : {
                        set : function() {
                          value = vizname;
                        },
                        get : function() {
                          var res = langManager.get(vizname);
                          if (res)
                            return res;
                          return vizname;
                        },
                        enumerable : true,
                      }
                    });
            return obj;
          });
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'riv/base',
    name : 'IDS_BASECHART',
    'abstract' : true,
    modules : {
      title : {
        id : 'sap.viz.modules.title',
        configure : {
          propertyCategory : 'title'
        }
      },
      legend : {
        id : 'sap.viz.modules.legend',
        configure : {
          propertyCategory : 'legend'
        }
      }
    },
    dependencies : {

    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiChart = {
    id : 'riv/base/multiple',
    name : 'IDS_BASEMULTIPLECHART',
    base : 'riv/base',
    'abstract' : true,
    modules : {
      main : {
        id : 'sap.viz.modules.tablecontainer',
        configure : {
          propertyCategory : 'multiLayout'
        },
        modules: {
          xAxis2 : {
            id : 'sap.viz.modules.axis',
            configure : {
            'description': 'Settings for the column axis of multiple charts.',
              propertyCategory : 'columnAxis',
              properties : {
                title : {
                  visible : false,
                },
                gridline : {
                  visible : true
                },
                color : '#d8d8d8',
                type : 'category',
                position : 'top'
              },
        propertiesOverride : {                  
                label : {
                isExported : false
                },
                axisline : {
                isExported : false
               }
        }
            }
          },
          yAxis : {
            id : 'sap.viz.modules.axis',
            configure : {
            'description': 'Settings for the row axis of multiple charts.',
              propertyCategory : 'rowAxis',
              properties : {
                type : 'category',
                position : 'left',
                title : {
                  visible : false,
                },
                color : '#d8d8d8',
                gridline : {
                  visible : true
                },
              },
              propertiesOverride : {                  
                label : {
                isExported : false
                },
                axisline : {
                isExported : false
               }
        }
            }
          },
          plot : {
            id : 'sap.viz.modules.xycontainer',
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiXYChart = {
    id : 'riv/base/multiple/xy',
    name : 'IDS_BASEMULTIPLEXYCHART',
    base : 'riv/base/multiple',
    'abstract' : true,
    modules : {
      tooltip : {
        id : 'sap.viz.modules.tooltip',
        configure : {
          propertyCategory : 'tooltip'
        }
      },
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              background : {
                id : 'sap.viz.modules.background',
                configure : {
                  propertyCategory : 'background',
                  properties : {
                    direction : 'vertical'
                  }
                }
              },
            }
          }
        }
      }
    }
  };

  Manifest.register(multiXYChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.controller.Base',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.controller.base',
    'abstract' : true,
    'type' : Constants.Module.Type.Controller,
    'name' : 'controller base module',
    'properties' : null,
    'events' : null,
    'feeds' : null
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.controller.interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.controller.interaction',
    'name' : 'selection',
    'base' : "sap.viz.modules.controller.base",
    'description': 'Settings for the interactions of the chart.',
    'properties' : {
      'selectability' : {
        'name' : 'selectability',
        'supportedValueType': 'Object',
        'supportedValues': [{
           'name' : 'mode',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'single', 'multiple', 'none' ],
          'defaultValue' : 'multiple',
          'description' : 'Set the selection mode. Single means you only can select one at the same time. Multiple means you can select several ones. None means you can not select anything. '
        }],
        'description': 'Settings for selectability.'
      }
    },
    'fn' : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.XY',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var colorFeed = {
    'id' : 'regionColor',
    'name' : 'IDS_REGIONCOLOR',
    'type' : constants.Type.Dimension,
    'min' : 0,
    'max' : 2,
    'aaIndex' : 2,
    'acceptMND' : 1
  };

  var valueAxis1 = {
    'id' : 'primaryValues',
    'name' : 'IDS_PRIMARYVALUES',
    'type' : constants.Type.Measure,
    'min' : 1,
    'max' : constants.Constraints.INF,
    'mgIndex' : 1
  };

  var valueAxis2 = {
    'id' : 'secondaryValues',
    'name' : 'IDS_SECONDARYVALUES',
    'type' : constants.Type.Measure,
    'min' : 0,
    'max' : constants.Constraints.INF,
    'mgIndex' : 2
  };

  var dimension = {
    'id' : 'axisLabels',
    'name' : 'IDS_AXISLABELS',
    'type' : constants.Type.Dimension,
    'min' : 1,
    'max' : 2,
    'acceptMND' : 0,
    'aaIndex' : 1
  };

  var feeds = {
    id : "xy",
    feeds : [ colorFeed, dimension, valueAxis1, valueAxis2 ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.XY',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.xy.base',
    'abstract' : true,
    'type' : Constants.Module.Type.Chart,
    'name' : 'xy base module',
    'datastructure' : 'DATA STRUCTURE DOC',
    'properties' : {  
    'colorPalette':
      {
         'name' : 'colorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColor,
          'description' : 'Set color palette for non_dual chart. Or dual chart\'s color palette if MND is on Category axis.'
      },
        'primaryValuesColorPalette' : {
          'name' : 'primaryValuesColorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColorDualAxis1,
          'description' : 'Set axis 1 color palette for dual chart.',
            'isExported' : false
        },  
        'secondaryValuesColorPalette' : {
          'name' : 'secondaryValuesColorPalette',
          'supportedValueType' : 'StringArray',
          'defaultValue' : Constants.SAPColorDualAxis2,
          'description' : 'Set axis 2 color palette for dual chart.',
            'isExported' : false
        },
        'drawingEffect':{
          'name' : 'drawingEffect',
           'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Set drawing effect of XY.',
            'isExported' : true
        },
    },
    'events' : {
      'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc,
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "xy"
    },
    'css' : null,
    'configure' : null
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var module = {
    'id' : 'sap.viz.modules.xy.bar.base',
    'name' : 'bar',
    base : "sap.viz.modules.xy.base",
    'abstract' : true,
    'properties' : {
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Bool',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'isRoundCorner' : {
        'name' : 'isRoundCorner',
        'supportedValueType' : 'Boolean',
        'defaultValue' : false,
        'description' : 'Set enable/disable round corner of bar.'
      },
      'animation' : {
        'name' : 'animation',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'dataLoading' : {
            'name' : 'dataLoading',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data loading animation of plot area.'
          },
          'dataUpdating' : {
            'name' : 'dataUpdating',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enable/disable data updating animation of plot area.'
          }
        },
        'description' : 'Settings for animation of plot area.'
      }
    }
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.0'},
[

],
function Setup() 
{
  return function(){
    var layerPos = {},//point on svg xy-coordinate
      clientPos = {},  //point on client position
      svgBoundingBox = null; //to improve performance, save all the bound of selected shape
    var lassoHelper, //div holder 
      lassoStart, lassoMove, lassoFinish, //lasso handler 
      start = false, 
      gWrapper = null, 
      gSelection = null, hitTestRect = {}, elementFilter, selectees,
      decorativeRect = null;
    //selection should be a svg element, as some function as svg native function. 
    var lassoSelection = function(selection, options){
      
      lassoHelper = $('<div id="lasso-selection-help" style="position:absolute;pointer-events:none;background:#cccccc;"></div>');
      elementFilter = options && options.filter ? options.filter:'.datapoint';
      gSelection = d3.select(selection).select('.main').length > 0  ? d3.select(selection).select('.main')[0][0] :  selection;
      gWrapper = d3.select(gSelection);
      var bbox = gSelection.getBBox();
      //as SVG limitation, you can not get the event info if you click where there is no shape.
      decorativeRect = gWrapper.insert('rect', 'g').attr('width', bbox.width).attr('height', bbox.height).attr('x', 0).attr('y', 0).attr('fill-opacity', 0);
      lassoStart = options.lassoStart ?options.lassoStart: function(){}, 
      lassoMove = options.lassoMove ? options.lassoMove: function(){}, 
      lassoEnd = options.lassoEnd ? options.lassoEnd: function(){};
      //register event on svg element
      gWrapper.on('mousedown', lassoSelection.start);
      gWrapper.on('mousemove', lassoSelection.move);
      gWrapper.on('mouseup', lassoSelection.end);
      return lassoSelection;
    };
    //intersect two rectangle
    function intersect(a, b) {
        return (a.x <= (b.x + b.width) &&
                b.x <= (a.x + a.width) &&
                a.y <= (b.y + b.height) &&
                b.y <= (a.y + a.height));
    };
    
    //filter the selectees to see whether the shape intersect with hitTestRect. 
    var filter = function(point, size){
      
      hitTestRect.x = point.x;
      hitTestRect.y = point.y;
      hitTestRect.height = size.height;
      hitTestRect.width = size.width;
      
      var res = [];
      //to reduce the time to get the bounding value, restore them into variable.
      if(selectees == null){
        selectees = gWrapper.selectAll(elementFilter);;
      }
      
      selectees.filter(function(d, m){
        var bounding = this.getBoundingClientRect();
        var rect = {
          x : bounding.left,
          y : bounding.top,
          width : bounding.width,
          height : bounding.height
        };
        if(intersect(rect , hitTestRect)){
          res.push(this);
        }
      });

      return res;
    };
    
    lassoSelection.start = function(){
      //as the layerX's issue in IE, so use the other way to calculate the x/y point on svg element.
      //layerX = pageX - svgBounding.left
      //layerY = pageY - svgBounding.top
      svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
      clientPos.x = d3.event.clientX, clientPos.y = d3.event.clientY;
      layerPos.x = clientPos.x - svgBoundingBox.left, layerPos.y = clientPos.y - svgBoundingBox.top;
      
      lassoHelper.css({
        "left": layerPos.x,
        "top": layerPos.y,
        "width": 0,
        "height": 0
      });
      
      //insert the background before the svg element in order to draw the background the behind svg
      lassoHelper.insertBefore(gSelection.ownerSVGElement.parentNode);
      
      var candidates = filter({x:clientPos.x, y:clientPos.y}, {width:0, height:0});
      
      lassoStart(candidates);
      
      start = true;
    };
    
    /**
     * when mouse move, only show the background
     */
    lassoSelection.move = function(){
      if(start){
        svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
        var x1 = layerPos.x, y1 = layerPos.y, x2 = d3.event.clientX - svgBoundingBox.left, y2 = d3.event.clientY - svgBoundingBox.top;
        if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
        if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
        lassoHelper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
      }
    };
    
    lassoSelection.end = function(){
      lassoHelper.css({
        width:0,
        height:0
      });
      lassoHelper.remove();
      svgBoundingBox = gSelection.ownerSVGElement.getBoundingClientRect();
      var x1 = layerPos.x, y1 = layerPos.y, x2 = d3.event.clientX - svgBoundingBox.left, y2 = d3.event.clientY - svgBoundingBox.top;
      var cx1 = clientPos.x, cy1 = clientPos.y , cx2 = d3.event.clientX, cy2 = d3.event.clientY;
      if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; tmp = cx2; cx2 = cx1; cx1 = tmp;}
      if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; tmp = cy2; cy2 = cy1; cy1 = tmp; }
      //lassoHelper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});
      
      if(x1 === x2 && y1 === y2){
        start = false;
      }else{
        var candidates = filter({x:cx1, y:cy1}, {width: x2-x1, height: y2-y1});
        lassoEnd(candidates);
        start = false;
      }
    };
    
    return lassoSelection;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.bar',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, tooltipDataHandler, NumberUtils, lassoSelection, Scaler, Repository) {
  var bar = function(manifest) {
    var tooltipDataHandlerObj;
    var data1,                 // data1 for value axis 1
      data2,                 // data2 for value axis 2
      data,                  // data from measure feed
      seriesData = [],             // seriesData is used to draw chart, it is transferred from data
      primaryAxisTopBoundary = 0,       // max value for value axis 1
      primaryAxisBottomBoundary = 0,
      secondaryAxisTopBoundary = 0,
      gWrapper = null,
      secondaryAxisBottomBoundary = 0;      // max value for value axis 2
    
    var  width,          // chart width
      height,          // chart height
        isDualAxis = false,
        hasMNDonCategoryAxis = false,
          id = Math.floor(Math.random() * 10000),
          colorPalette = [],
          axis1ColorPalette,
            axis2ColorPalette,
            MNDInnerOnColor = false,
            measureOnAxis1 = 0,
            measureOnAxis2 = 0,
          shapePalette = ['squareWithRadius'],      // shape palette for legend
          properties,          // poreperteis that is used to control chart
          eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip','initialized');
    
    var effectManager = null;
    
      var valueScales = [],
        yScale = d3.scale.ordinal(),    // category scale
          xScale = d3.scale.linear(),      // scale for value axis 1
          xScale2 = d3.scale.linear();    // scale for value axis 2
      
      //variable for event
      var decorativeShape = null,           // the shape to show the effect of mouse move
        lastSelected = [],           // the variable to hold all selected shapes
        lastHovered = null,         // last hovered dimention item index
      tooltipVisible = true,  
        isLasso = false;
      
    var indexforSecondaryAxis = 0,        // if data index of seriesData is bigger than it, which means those data should be scaled by xScale2    
      barNumber,              // the number of bar in each group    
      barGroupNumber,            // the number of bar groups 
      barWidth = [],            // array to store all bars' widths.
      barHeight;              // barHeight is fixed and all bars have the same height.
    
    var enableDataLoadingAnimation = true,   // control initialization animation  
      enableDataUpdatingAnimation = true, // control data updating animation
      enableRoundCorner = false,      // enable/disable round corner bar
      clipEdge = true,          // if it is false, the chart can be drawn out of the plot area.
      totalIntervalTime = 1000,      // animation time limited. all animation must be completed within it.
      isOnlyInitAnimation = false;    // for now, only init animation is supported
    
    var defsEnter, 
      roundCornerDefs,
      suffix = Repository.newId();
    
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;
    
      /**
       * Parse options
       */
      var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 

    tooltipVisible = properties.tooltip.enabled;
          
        if(isDualAxis && !hasMNDonCategoryAxis){
            axis1ColorPalette = properties.primaryValuesColorPalette;   
        axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
      axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
        drawingEffect = properties.drawingEffect; 
        
        var colorIndexes = 0;
        if(!hasMNDonCategoryAxis){
          indexforSecondaryAxis = data1.length;
          colorIndexes = seriesData[0].length;   
        }else{
          colorIndexes = seriesData.length * seriesData[0].length;
        }
        colorPalette = [];
        var i = 0;
      if(MNDInnerOnColor){
        var flag = 0, flag2 = 0, j = 0;
        for(i = 0 ; i < indexforSecondaryAxis; i++){
          colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
          flag++;
          if(flag === measureOnAxis1){
            flag2 = 0;
            for(; j <=(colorIndexes-indexforSecondaryAxis); j++){
              if(flag2 >= measureOnAxis2){
                flag = 0;
                break;
              }
              colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              flag2++;
            }
            
          }
        }
      }else{
        for(i = 0; i < colorIndexes; i++){
          if(i < indexforSecondaryAxis){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
          }else if(isDualAxis && !hasMNDonCategoryAxis){
            colorPalette.push(axis2ColorPalette[(i-indexforSecondaryAxis) % axis2ColorPalette.length]);  
          }
        }
        }
      };
      
      /**
       * Create chart
       */
      function chart(selection){

      tooltipDataHandlerObj = tooltipDataHandler();
      
      // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
      if(valueScales.length === 0){ return;}
      
        selection.each(function(){
          barNumber = seriesData[0].length;
        barGroupNumber =  seriesData.length;        
        barHeight = 8 * (yScale.rangeBand()) / (9*barNumber +7 );
        
          var svg = (gWrapper = d3.select(this));
          
          //append decorativeShape bar
          if(decorativeShape == null){
               decorativeShape = d3.select(this).append('rect').attr('visibility', 'hidden').attr('width', width).attr('height',  yScale.rangeBand() - barHeight/2).attr(
                'fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', width).attr('height',  yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden');
          }
        
        
          
          if(defsEnter == null){
          defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
        }else{
          defsEnter.attr('width', width).attr('height', height);
        }    
          
          if(roundCornerDefs == null){      
          roundCornerDefs = svg.append('defs');
        }else{
          if( dataStructureChange || sizeChange || dataValueChange ){
            roundCornerDefs.remove();
            roundCornerDefs = svg.append('defs');
          }
        }
          
        var r = Math.log(barHeight)/Math.log(2);
        if( r < 0 ){
          enableRoundCorner = false;
        }
        var valueScale;
          var barGroup = svg.selectAll('g.bar').data(seriesData), lastBarGroupIndex = seriesData.length -1;
          barGroup.enter().append('g');
          barGroup.attr('class','bar')
            .each( function (perBarGroup,i) {
                var bar = d3.select(this).selectAll('rect').data(perBarGroup), lastBarIndex = seriesData[0].length -1;
                bar.enter().append('rect');
                    bar.attr('fill',function(perRectData,i){
                      perRectData.fillColor = colorPalette [ i % colorPalette.length];
                      var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : perRectData.fillColor,
                          direction : 'vertical'
                      };
                      return effectManager.register(parameter);
                      
                      })
                     .attr('shape-rendering','crispEdges').attr('class', 'datapoint').attr('fill-opacity', 1)
                     .attr('x', function(perRectData){
                       valueScale = valueScales[perRectData.valueAxis];
                       return valueScale(0);
                     });

                  if(enableDataLoadingAnimation && !isOnlyInitAnimation ){
                    // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                    // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                    if(dataStructureChange){
                      bar.attr('y', function(perRectData, m){
                        var y = yScale(i) + barHeight * (barNumber - m  - 1);
                        y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                        return  y;
                      }).attr('height', barHeight).attr('width', 0).attr('class', function(d, m){
                        return 'datapoint series-'+m;
                      });
                      
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, m){
                          var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                          var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                          roundCornerDefs.append('clipPath').attr('id', id)
                              .append('rect').attr('rx', r).attr('ry', r)
                              .attr('width', width + r).attr('height', barHeight).attr('y', y).attr('x',x)
                              .transition().delay(function(d,m){return (m + barNumber * i) * interval;})
                              .attr('x', function(){
                                valueScale = valueScales[perRectData.valueAxis];
                                if(perRectData.val < 0){
                                  return  valueScale(perRectData.val);
                                }else{
                                  return valueScale(0) - r;
                                }
                              })
                              .attr('width',  function(){
                                valueScale = valueScales[perRectData.valueAxis];
                                // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                // the space is reserved
                                if(perRectData.val !== ' ' && perRectData.val !== 0){
                                  var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                  // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                  return  width + r;
                                }else{
                                  return 0;
                                }
                              });
                        return 'url(#' + id + ')'; });
                      }
                  
                      var interval = totalIntervalTime / (barNumber * barGroupNumber);
                      bar.transition().delay(function(d,m){return (m + barNumber * i) * interval;})
                        .attr('x', function(perRectData){
                          valueScale = valueScales[perRectData.valueAxis];
                          if(perRectData.val < 0){
                            return  valueScale(perRectData.val) ;
                          }else{
                            return valueScale(0);
                          }
                        })
                        .attr('width',  function(perRectData){
                          valueScale = valueScales[perRectData.valueAxis];
                          // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                          // the space is reserved
                          if(perRectData.val !== ' ' && perRectData.val !== 0){
                            var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                            // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                            return  width;
                          }else{
                            return 0;
                          }
                        })
                        .each('end', function(d, m){
                        if(m === lastBarIndex && i === lastBarGroupIndex){
                          completeAnimation();
                        }
                      });
                    }
                    // [04 - Sep - 2012 Nick] if the size of plot area is changed, re-scale chart
                    else if(sizeChange){
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, m){
                          var w = parseFloat(this.getAttribute('width')), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                          var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                          roundCornerDefs.append('clipPath').attr('id', id)
                            .append('rect').attr('rx', r).attr('ry', r)
                            .attr('width', w + r).attr('height', h).attr('y', y).attr('x',x)
                            .transition().duration(totalIntervalTime)
                            .attr('x', function(){
                              valueScale = valueScales[perRectData.valueAxis];
                              if(perRectData.val < 0){
                                return  valueScale(perRectData.val);
                              }else{
                                return valueScale(0) - r;
                              }
                            })
                            .attr('width',  function(){
                              valueScale = valueScales[perRectData.valueAxis];
                              // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                              // the space is reserved
                              if(perRectData.val !== ' ' && perRectData.val !== 0){
                                var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                return width + r;
                              }else{
                                return 0;
                              }
                            })
                            .attr('height', barHeight)
                            .attr('y', function(){
                              var y = yScale(i) + barHeight * (barNumber - m - 1);
                              y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                              return  y;
                            });
                          return 'url(#' + id + ')'; });
                      }

                      bar.transition().duration(totalIntervalTime)
                        .attr('x', function(perRectData){
                          valueScale = valueScales[perRectData.valueAxis];
                          if(perRectData.val < 0){
                            return  valueScale(perRectData.val);
                          }else{
                            return valueScale(0);
                          }
                        })
                        .attr('width',  function(perRectData, m){
                          valueScale = valueScales[perRectData.valueAxis];
                          if(perRectData.val !== ' ' && perRectData.val !== 0){
                            var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                            // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                            return width;
                          }else{
                            return 0;
                          }
                        })
                        .attr('height', barHeight)
                        .attr('y', function(d, m){
                          var y = yScale(i) + barHeight * (barNumber - m - 1);
                          y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                          return  y;
                        })
                        .each('end', function(d, m){
                          if(m === lastBarIndex && i === lastBarGroupIndex){
                            completeAnimation();
                          }
                        });
                    }
                    else if(dataValueChange){
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, m){
                          var w = parseFloat(this.getAttribute('width')), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                          var id ='roundCorner-clip' + '-' + m + i  +  suffix;
                          roundCornerDefs.append('clipPath').attr('id', id)
                                .append('rect').attr('rx', r).attr('ry', r)
                                .attr('x',  - r).attr('width', w + r).attr('height', h).attr('y', y)
                                .transition().duration(totalIntervalTime)
                                .attr('width',  function(){
                                    valueScale = valueScales[perRectData.valueAxis];
                                  // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                  // the space is reserved
                                    if(perRectData.val !== ' ' && perRectData.val !== 0){
                                    var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                    // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                    return (width + r);
                                  }else{
                                    return 0;
                                  }
                                 })
                                .attr('height', barHeight)
                                .attr('y', function(){
                                  var y = yScale(i) + barHeight * (barNumber - m - 1);
                                  y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                                  return  y;
                                });
                          return 'url(#' + id + ')'; });
                      }
                      
                      //To seperate dataValueChange, as in size change, we calculate more than data value change.
                      //in value change, only change the width, in size, there are height width, y
                      bar.transition().duration(totalIntervalTime)
                      .attr('width',  function(perRectData){
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val !== ' ' && perRectData.val !== 0){
                          var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                          // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                          return width;
                        }else{
                          return 0;
                        }
                      })
                      .attr('x', function(perRectData){
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val < 0){
                          return  valueScale(perRectData.val) ;
                        }else{
                          return valueScale(0);
                        }
                      })
                      .each('end', function(d, m){
                        if(m === lastBarIndex && i === lastBarGroupIndex){
                          completeAnimation();
                        }
                      });
                    }  
                  }
                  // [04 - Sep - 2012 Nick] if the animation is disabled
                  else{
                    bar.attr('width', function(perRectData){
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val !== ' ' && perRectData.val !== 0){
                          var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                          // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                          return width;
                        }else{
                          return 0;
                        }
                      })
                      .attr('x', function(perRectData){
                        valueScale = valueScales[perRectData.valueAxis];
                        if(perRectData.val < 0){
                          return  valueScale(perRectData.val) ;
                        }else{
                          return valueScale(0);
                        }
                      })
                      .attr('height', barHeight)
                      .attr('y', function(perRectData, m){
                        var y = yScale(i) + barHeight * (barNumber - m - 1);
                        y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                        return  y;
                      });
                    if(enableRoundCorner){
                      bar.attr('clip-path', function(perRectData, m){
                        var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                        roundCornerDefs.append('clipPath').attr('id', id)
                          .append('rect').attr('rx', r).attr('ry', r)
                          .attr('width', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val !== 0){
                              var width = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              return (width + r);
                            }else{
                              return 0;
                            }
                          })
                          .attr('height', barHeight)
                          .attr('y', function(){
                              var y = yScale(i) + barHeight * (barNumber - m - 1);
                              y = y + barHeight/8 * (barNumber - m - 1) + barHeight /2;
                              return  y;
                          })
                          .attr('x', function(){
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val < 0){
                              return  valueScale(perRectData.val);
                            }else{
                              return valueScale(0) - r;
                            }
                          });
                          return 'url(#' + id + ')';
                      });
                    }
                  }
                  bar.exit().remove();
              });
          barGroup.exit().remove();
        
        //reset status
        sizeChange = false, dataStructureChange = false, dataValueChange = false;
        });
        
        if(!enableDataLoadingAnimation){
          completeAnimation();
        }
        
        return chart;
      }
    
    function completeAnimation(){
        eDispatch.initialized();  
    }
    
    /**
     * Mouse over 
     */
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1) || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }

      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + barHeight/4).attr(
          'visibility', 'visible');

      if(i !== lastHovered){
        if (tooltipVisible) {      
          lastHovered = i;
          //this.parentNode.parentNode.parentNode point to the main container
          var transform = gWrapper[0][0].getTransformToElement(gWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          
          var tData = tooltipDataHandlerObj.generateTooltipData(data, seriesData, barGroupNumber-1-i, colorPalette, shapePalette);
          tData.point = {
              x: d3.event.layerX,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tData.plotArea = {
            x : transform.e,
            y : transform.f,
            width : width,
            height : height
          };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
      };
      
      chart.parent = function(){
        return gWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      /**
       * TODO: add desc
       */
      chart.blurOut = function(){
        lastHovered = null;
        decorativeShape.attr('visibility', 'hidden');
      if (tooltipVisible) {      
        eDispatch.hideTooltip();
      }
      };
      
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
      chart.data = function(value){
        if (!arguments.length){
          return data;
         }
        data = value;
        var obj = MNDHandler(data);
        
        data1 = obj["MG1"];
        data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
        }else{
          hasMNDonCategoryAxis = false;
          if(TypeUtils.isExist(data2)){
                isDualAxis = true;
            }else{
                isDualAxis = false;
            }
        }
        
        var _seriesData = dataTransform(data1, data2, obj.color);
        //judge what changed in dataset
        if(seriesData.length !== _seriesData.length || _seriesData[0].length !== seriesData[0].length){
          dataStructureChange = true;
        }else {
          dataValueChange = true;
        }
        seriesData = _seriesData;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      parseOptions();
         return chart;        
      };

      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return properties;
         }
         properties = manifest.props(props);
            parseOptions();
            
         return chart;        
      };
      
      /**
       * TODO: add desc
       */
      var makeScales = function(){
      var domain = [];
      valueScales = [];
      for (var i=0; i < seriesData.length; i++){
           domain.push(i);
        }
        yScale.domain(domain).rangeBands([height, 0]);
        xScale.domain([primaryAxisBottomBoundary, primaryAxisTopBoundary]).range([0, width]).nice();
            Scaler.perfect(xScale);
        if(TypeUtils.isExist(data2) || isDualAxis){
          xScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([0, width]).nice();
                Scaler.perfectDual(xScale, xScale2);
        }else{
          xScale2.range([0, 0]);
        }
        valueScales.push(xScale);
            valueScales.push(xScale2);
      };
      
      /**
       * TODO: add desc. please don't leave empty otherwise jsdoc will complain.
       */
      chart.categoryScale = function(scale){
        if (!arguments.length){
          return yScale;
         }
        yScale = scale;
         return chart;
      };
     
      chart.primaryScale = function(scale){
        if (!arguments.length){
          return xScale;
         }
        xScale = scale;
        valueScales[0] = xScale;
         return chart;
      };
      
      chart.secondScale = function(scale){
        if (!arguments.length){
          return xScale2;
         }
        xScale2 = scale;
        valueScales[1] = xScale2;
         return chart;
      };
      
      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(!hasMNDonCategoryAxis){
          return colorPalette[seriesData[0].length - 1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };     
      
      chart.primaryDataRange = function(range){
        if (!arguments.length){
          return {
            min: primaryAxisBottomBoundary,
            max: primaryAxisTopBoundary
          };
        }
        primaryAxisTopBoundary = range.max;
        primaryAxisBottomBoundary = range.min;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
        return chart;
      };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          return {
            min: secondaryAxisBottomBoundary,
            max: secondaryAxisTopBoundary
          };
        }
        secondaryAxisTopBoundary = range.max;
        secondaryAxisBottomBoundary = range.min;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
        return chart;
      };      
      
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      /**
     * get/set your event dispatch if you support event
     */
      chart.dispatch = function(_){
        if(!arguments.length){
          return eDispatch;
        }
        eDispatch = _;
        return this;
      };
      
      /**
      * get/set your color palette if you support color palette
      */
      chart.colorPalette = function(_){
        if(!arguments.length){
          return colorPalette;
        }
        colorPalette = _;
        return this;
      };

      /**
     * set/get effect manager
    */
    chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return chart;        
    };        
        // chart.primaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis1ColorPalette;
            // }  
            // axis1ColorPalette = _;
            // return this;
        // };
// 
        // chart.secondaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis2ColorPalette;
            // }  
            // axis2ColorPalette = _;
            // return this;
        // };        

      /**
      * get/set your shape Palette if you support shape Palette
      */
      chart.shapePalette = function(_){
        if(!arguments.length){
          return shapePalette;
        }
        shapePalette = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
//      var dataTransform = function(data1,data2){
//        var barGroups = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;
//      var barGroup = [];
//      for(var i=0; i<data1.length; i++){
//        var temp = d3.max(data1[i], function(m){return m.val;});
//        var temp2 = d3.min(data1[i], function(m){return m.val;});
//        if(primaryAxisTopBoundary <temp){
//          primaryAxisTopBoundary = temp;
//        }
//        if(primaryAxisBottomBoundary > temp2){
//            primaryAxisBottomBoundary = temp2;
//        }
//          barGroup.push(data1[i]);
//        }
//      if(data2 != undefined){
//      
//        for(i=0; i<data2.length; i++){
//          var temp = d3.max(data2[i], function(m){return m.val;});
//          var temp2 = d3.min(data2[i], function(m){return m.val;});
//          if(secondaryAxisTopBoundary < temp){
//            secondaryAxisTopBoundary = temp;
//          }
//          if(secondaryAxisBottomBoundary > temp2){
//              secondaryAxisBottomBoundary = temp2;
//          }
//          barGroup.push(data2[i]);
//        }
//      }
//       
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        for(i=0; i< barGroup.length; i++){
//          ds.push(barGroup[i][j]);
//        }
//        barGroups.push(ds);
//      }
//     
//        return barGroups;
//      };
      
      var dataTransform = function(valueAxis1,valueAxis2, colorIndexArray){
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        var barGroups = [];
      // the number of bar in each group
      var barGroupNumber =  valueAxis1[0].length;
      var barGroup = [];
      var temp = 0, temp2 = 0;
      var i = 0, j = 0;
      for(i=0; i < valueAxis1.length; i++){
        if(hasMNDonCategoryAxis){
          for(j = 0;  j< valueAxis1[i].length; j++){
            if(colorIndexArray[j] === 0){
              temp = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 0;
              if(primaryAxisTopBoundary <temp){
                primaryAxisTopBoundary = temp;
              }
              if(primaryAxisBottomBoundary > temp){
                primaryAxisBottomBoundary = temp;
              }
              indexforSecondaryAxis++;
            }else{
              temp2 = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 1;
              if(secondaryAxisTopBoundary < temp2){
                secondaryAxisTopBoundary = temp2;
              }
              if(secondaryAxisBottomBoundary > temp2){
                  secondaryAxisBottomBoundary = temp2;
              }
            }
          }
        }else{
          temp = d3.max(valueAxis1[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis1[i], function(m){return m.val;});
          if(primaryAxisTopBoundary <temp){
            primaryAxisTopBoundary = temp;
          }
          if(primaryAxisBottomBoundary > temp2){
            primaryAxisBottomBoundary = temp2;
          }
        }
        barGroup.push(valueAxis1[i]);
          
        }
      if(valueAxis2 !== undefined){
        for(i=0; i<valueAxis2.length; i++){
          temp = d3.max(valueAxis2[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis2[i], function(m){return m.val;});
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
              secondaryAxisBottomBoundary = temp2;
          }
          barGroup.push(valueAxis2[i]);
        }
      }
      
      for(j=0; j < barGroupNumber; j++){
        var ds = [];
        for(i=0; i< barGroup.length; i++){
          if(!hasMNDonCategoryAxis){
            if( i < valueAxis1.length){
              barGroup[i][j].valueAxis = 0;
            }else{
              barGroup[i][j].valueAxis = 1;
            }
          }
          if(NumberUtils.isNoValue(barGroup[i][j].val)){
            barGroup[i][j].val = ' ';
          }
          ds.push(barGroup[i][j]);
        }
        if(MNDInnerOnColor){
          var dSet = [], flag1=0, flag2=0;
          var n=0;
          for(var m=0; m < valueAxis1.length; m++){
            dSet.push(ds[m]);
            flag1++;
            if(flag1 === measureOnAxis1 && valueAxis2 !== undefined){
              flag2 = 0;
              for(; n<valueAxis2.length; n++){
                if(flag2 >= measureOnAxis2){
                  flag1 = 0;
                  break;
                }
                dSet.push(ds[valueAxis1.length+n]);
                flag2++;
              }
            }
          }
          barGroups.push(dSet);
        }else{
          barGroups.push(ds);
        }
      }
     
        return barGroups;
      };      
      
    properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.bar',
    'name' : 'bar',
    base : "sap.viz.modules.xy.bar.base",
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_bar',
    name : 'IDS_MULTIBARCHART',
    base : 'riv/base/multiple/xy',
    modules : {
      legend : {
        data : {
          aa : [ 3 ]
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'bar',
            orientation : 'left'
          }
        }
      },
      main : {
        controllers : {
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              propertyCategory : 'interaction',
        properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
              }
            }
          }
        },
        configure : {
          properties : {
            'mergeDataRange' : ['primary']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              background : {
                configure : {
                  properties : {
                    direction : 'horizontal',
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  propertyCategory : 'xAxis',
                  properties : {
                    title : {
                      visible : false,
                    },
                    type : 'value',
                    position : 'bottom'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description':'Settings for the category axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'category',
                    position : 'left',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    },
                    gridline : {
              isExported : false
              },
              label : {
                    isExported : false
                    },
                    axisline : {
                    isExported : false
                   }
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.bar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      secondaryValues: {
        max: 0
      },
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, { 
    targetModule : 'main.plot.xAxis',
    target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
    }
      ],
      events : [ {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main',
            type : 'initialized.interaction'
          }, {
              targetModule : 'tooltip',
              listener : 'showTooltip',
              sourceModule : 'main',
              type : 'showTooltip'
          }, {
              targetModule : 'tooltip',
              listener : 'hideTooltip',
              sourceModule : 'main',
              type : 'hideTooltip'
          }, {
            targetModule : 'main.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'legend',
            type : 'highlightedByLegend'
          }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
            }]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.verticalbar',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, Repository, NumberUtils) {
  var vBar = function(manifest) {
    var tooltipDataHandlerObj;
    var data1, 
      data2, 
      data, 
      seriesData = [], 
      primaryAxisTopBoundary = 0, 
      primaryAxisBottomBoundary = 0,
      secondaryAxisTopBoundary = 0,
      secondaryAxisBottomBoundary = 0,
      sWrapper = null;
    
    var width = undefined, 
      height = undefined,
      id = Math.floor(Math.random() * 10000),
      x = 0, 
      y = 0,
      isDualAxis = false,
            colorPalette = [],
            axis1ColorPalette,
            axis2ColorPalette,
            MNDInnerOnColor = false,
            measureOnAxis1 = 0,
            measureOnAxis2 = 0,
      shapePalette = ['squareWithRadius'],
      properties,
      eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
      
    var effectManager = null;
    
      var valueScales = [],
        xScale = d3.scale.ordinal(),
          yScale = d3.scale.linear(),
          yScale2 = d3.scale.linear();


    var decorativeShape, 
      eventLayerShape, 
      lastSelected = [], 
      tooltipVisible = true,
      lastHovered = null;

      
    var indexforSecondaryAxis = 0,
      barNumber,
      barGroupNumber,
      barWidth,
      yPositions = [];
        
    var enableDataLoadingAnimation = true,
      enableDataUpdatingAnimation = true,
      enableRoundCorner = false,
      clipEdge = true,
      totalIntervalTime = 1000,
      isOnlyInitAnimation = false;
    
    var defsEnter, 
      roundCornerDefs,
      suffix = Repository.newId();
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;
    
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'x',
          xScale.rangeBand() * i + barWidth/4).attr(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var xoffset = transform.e;
          
          var tData = tooltipDataHandlerObj.generateTooltipData(data, seriesData, i, colorPalette, shapePalette);
          tData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: d3.event.layerY
          };
                    tData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
      
      };
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          sWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          sWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      

      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
      tooltipVisible = properties.tooltip.enabled;
      drawingEffect = properties.drawingEffect;
      
        if(isDualAxis && !hasMNDonCategoryAxis){
            axis1ColorPalette = properties.primaryValuesColorPalette;   
        axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
      axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
        var colorIndexes = 0;
        if(!hasMNDonCategoryAxis){
          indexforSecondaryAxis = data1.length;
          colorIndexes = seriesData[0].length;   
        }else{
          colorIndexes = seriesData.length * seriesData[0].length;
        }
        colorPalette = [];
        if(MNDInnerOnColor){
        var flag = 0, flag2 = 0, j = 0;
        for(var i=0 ; i < indexforSecondaryAxis; i++){
          colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
          flag++;
          if(flag == measureOnAxis1){
            flag2 = 0;
            for(; j <=(colorIndexes-indexforSecondaryAxis); j++){
              if(flag2 >= measureOnAxis2){
                flag = 0;
                break;
              }
              colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              flag2++;
            }
            
          }
        }
      }else{
        for(var i=0 ; i < colorIndexes; i++){
          if(i < indexforSecondaryAxis){
            colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
          }else if(isDualAxis && !hasMNDonCategoryAxis){
            colorPalette.push(axis2ColorPalette[(i-indexforSecondaryAxis) % axis2ColorPalette.length]);  
          }
        }  
      }
      };
      
      /**
       * Create chart
       */

      function chart(selection){

        tooltipDataHandlerObj = tooltipDataHandler();
        
      // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
      if(valueScales.length == 0) return;
      
        selection.each(function(){
              barNumber = seriesData[0].length;
              barGroupNumber =  seriesData.length;
              barWidth = 8 * (xScale.rangeBand()) / (9*barNumber +7 );
              
                var svg = sWrapper = d3.select(this);

                
                if(decorativeShape == null){
                  decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() - barWidth/2).attr('height',
                height).attr('visibility', 'hidden').attr(
                    'fill', 'rgba(133,133,133, 0.2)');
                }else{
                  decorativeShape.attr('width', xScale.rangeBand() - barWidth/2).attr('height',height).attr('visibility', 'hidden');
                }
    
              //vertical bar
              if(defsEnter == null){
              defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
            }else{
              defsEnter.attr('width', width).attr('height', height);
            }    
              
            if(roundCornerDefs == null){      
              roundCornerDefs = svg.append('defs');
            }else{
              if( dataStructureChange || sizeChange || dataValueChange ){
                roundCornerDefs.remove();
                roundCornerDefs = svg.append('defs')
              }
            }
            
            var r = Math.log(barWidth)/Math.log(2);
            if( r < 0 ){
              enableRoundCorner = false;
            }
            var valueScale;
            
                var barGroup = svg.selectAll('g.bar').data(seriesData), lastBarGroupIndex = seriesData.length -1, lastBarIndex = seriesData[0].length - 1;    
                barGroup.enter().append('g');
                barGroup.attr('class','bar')
                    .each( function (perBarGroup, i) {
                      var bar = d3.select(this).selectAll('rect').data(perBarGroup);
                      bar.enter().append('rect');
                      bar.attr('fill', function(d,i){ 
                        d.fillColor = colorPalette[i % colorPalette.length]; 
                        var parameter = {
                            drawingEffect:drawingEffect,
                            fillColor : d.fillColor,
                            direction : 'horizontal'
                        };
                        return effectManager.register(parameter);})
                         .attr('shape-rendering','crispEdges').attr('class', 'datapoint').attr('fill-opacity', 1);
                      
                      if(enableDataLoadingAnimation && !isOnlyInitAnimation ){
                      // [05 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                      // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                      if(dataStructureChange){
                        bar.attr('width', barWidth).attr('height', 0)
                           .attr('x', function (perRectData, m) {
                             var x = xScale(i) + barWidth * m;
                             x = x + barWidth/8 *(m) + barWidth/2;
                             return x;
                           })
                           .attr('y', function(){
                             // [05 - Sep - 2012 Nick] if one of two axis min values is negative, all bars 
                             // start from yScale(0) (because two scales are synchronized, yScale(0) == yScale2(0))
                             if(primaryAxisBottomBoundary < 0 || secondaryAxisBottomBoundary < 0){
                               return yScale(0);
                             }else{
                               return height;
                             }
                           });
                        
                        if(enableRoundCorner){
                          bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;
                            roundCornerDefs.append('clipPath').attr('id', id)
                                .append('rect').attr('rx', r).attr('ry', r)
                                .attr('x', function () {
                                  var x = xScale(i) + barWidth * m;
                                    x = x + barWidth/8 *(m) + barWidth/2;
                                    return x;
                                })
                                .attr('width', barWidth)
                                .attr('height', r).attr('y', 0)
                                .attr('y', function(d, m){
                                   if(primaryAxisBottomBoundary < 0 || secondaryAxisBottomBoundary < 0){
                                       return yScale(0);
                                     }else{
                                       return height;
                                     }
                                  })
                                .transition().delay(function(d,m){return (m + barNumber * i) * interval})
                                .attr('height', function(){
                                  valueScale = valueScales[perRectData.valueAxis];
                                  // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                  // the space is reserved
                                  if(perRectData.val !== ' ' && perRectData.val != 0){
                                    var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                    // [10 - Sep - 2012 Nick] if the height of one bar is less than 1px, use 1px.
                                    return (height + r); 
                                  }else{
                                    return 0;
                                  }
                                })
                                .attr('y', function () {
                                  valueScale = valueScales[perRectData.valueAxis];
                                  if(perRectData.val >= 0){
                                    return valueScale(perRectData.val);
                                  }else{
                                    return valueScale(0) - r;
                                  }
                                  });
                            return 'url(#' + id + ')'; });
                        }
                        
                        var interval = totalIntervalTime / (barNumber * barGroupNumber);
                        bar.transition().delay(function(d,m){return (m + barNumber * i) * interval})
                          .attr('height', function(perRectData,m){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              return height;
                            }else{
                              return 0;
                            }
                          })
                          .attr('y', function (perRectData) {
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val >= 0){
                              return valueScale(perRectData.val) ;
                            }else{
                              return valueScale(0) ;
                            }
                          })
                          .each('end', function(perRectData, m){
                            if(m === lastBarIndex && i === lastBarGroupIndex){
                              completeAnimation();
                            }
                          });
                      }else if(sizeChange){
                        if(enableRoundCorner){
                          bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                            roundCornerDefs.append('clipPath').attr('id', id).append('rect').attr('rx', r).attr('ry', r)
                                  .attr('width', w).attr('x', x).attr('height', parseFloat(h) + parseFloat(r))
                                  .attr('y', function(){
                                    if(perRectData.val >= 0){
                                      return y;
                                    }else{
                                      return parseFloat(y) - parseFloat(r);
                                    }
                                  })
                                  .transition().duration(totalIntervalTime).attr('width',barWidth)
                                  .attr('height', function(){
                                    valueScale = valueScales[perRectData.valueAxis];
                                    // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                    // the space is reserved
                                    if(perRectData.val !== ' ' && perRectData.val != 0){
                                      var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                      // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                      return  (height + r); 
                                    }else{
                                      return 0;
                                    }
                                  })
                                  .attr('y', function () {
                                    valueScale = valueScales[perRectData.valueAxis];
                                     if(perRectData.val >= 0){
                                       return valueScale(perRectData.val);
                                     }else{
                                       return valueScale(0) - r;
                                     }
                                  }).attr('x', function () {
                                    var x = xScale(i) + barWidth * m;
                                    x = x + barWidth/8 *(m) + barWidth/2;
                                    return x;
                                  });
                            return 'url(#' + id + ')'; });
                        }
                        //bar.transition().delay(function(d,m){return (m + barNumber * i) * interval}).attr('width',  function(d, m){
                        bar.transition().duration(totalIntervalTime).attr('width', barWidth)
                           .attr('height', function(perRectData){
                              valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                              if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              return  height; 
                            }else{
                              return 0;
                            }
                           })
                           .attr('y', function (perRectData) {
                              valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val >= 0){
                              return valueScale(perRectData.val);
                            }else{
                              return valueScale(0) ;
                            }
                           })
                           .attr('x', function (perRectData,m) {
                             var x = xScale(i) + barWidth * m;
                             x = x + barWidth/8 *(m) + barWidth/2;
                             return x;
                           })
                           .each('end', function(d, m){
                             if(m === lastBarIndex && i === lastBarGroupIndex){
                               completeAnimation();
                             }
                           });
                      }else if(dataValueChange){
                        if(enableRoundCorner){
                          bar.attr('clip-path', function(perRectData, m){
                            var w = this.getAttribute('width'), h = this.getAttribute('height'),x = this.getAttribute('x'), y =this.getAttribute('y');
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;  
                            roundCornerDefs.append('clipPath').attr('id', id)
                                .append('rect').attr('rx', r).attr('ry', r)
                                  .attr('x', x).attr('width', barWidth).attr('height', parseFloat(h) + parseFloat(r))
                                  .attr('y', function(){
                                    if(perRectData.val >= 0){
                                      return y;
                                    }else{
                                      return parseFloat(y) - parseFloat(r);
                                    }
                                  })
                                  .transition().duration(totalIntervalTime)
                                  .attr('height', function(){
                                      valueScale = valueScales[perRectData.valueAxis];
                                    // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                                    // the space is reserved
                                      if(perRectData.val !== ' ' && perRectData.val != 0){
                                      var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                      // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                      return (height + r); 
                                    }else{
                                      return 0;
                                    }
                                  }).attr('y', function () {
                                      valueScale = valueScales[perRectData.valueAxis];
                                    if(perRectData.val >= 0){
                                      return valueScale(perRectData.val);
                                    }else{
                                      return valueScale(0) - r;
                                    }
                                  });
                            return 'url(#' + id + ')'; });
                        }
                        
                        //To seperate dataValueChange, as in size change, we calculate more than data value change.
                        //in value change, only change the width, in size, there are height width, y
                        bar.transition().duration(totalIntervalTime)
                          .attr('height', function(perRectData,m){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                            // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                              var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                              // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                              perRectData.height = height;
                              return height; 
                            }else{
                              return 0;
                            }
                          })
                          .attr('y', function (perRectData,m) {
                            valueScale = valueScales[perRectData.valueAxis];
                            if(perRectData.val >= 0){
                              return valueScale(perRectData.val);
                            }else{
                              return valueScale(0) ;
                            }
                          })
                          .each('end', function(d, m){
                            if(m === lastBarIndex && i === lastBarGroupIndex){
                              completeAnimation();
                            }
                          });
                      }
                    }
                      // [05-Sep-2012 Nick] When animation is disabled, the chart is drawed here.
                      else{
                      bar.attr('width', barWidth)
                         .attr('height', function(perRectData){
                            valueScale = valueScales[perRectData.valueAxis];
                            // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                          // the space is reserved
                            if(perRectData.val !== ' ' && perRectData.val != 0){
                            var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                            // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                            perRectData.height = height;
                            return height; 
                          }else{
                            return 0;
                          }
                         })
                         .attr('y', function (perRectData) {
                           valueScale = valueScales[perRectData.valueAxis];
                          if(perRectData.val >= 0){
                            return valueScale(perRectData.val);
                          }else{
                            return valueScale(0) ;
                          }
                         })
                         .attr('x', function (perRectData,m) {
                           var x = xScale(i) + barWidth * m;
                           x = x + barWidth/8 *(m) + barWidth/2;
                           return x;
                         });
                      
                      if(enableRoundCorner){
                          bar.attr('clip-path', function(perRectData, m){
                            var id = 'roundCorner-clip' + '-' + m + i + suffix;    
                          roundCornerDefs.append('clipPath').attr('id', id)
                            .append('rect').attr('rx', r).attr('ry', r)
                            .attr('width', barWidth)
                            .attr('height', function(){
                              valueScale = valueScales[perRectData.valueAxis];
                              // [10 - Sep - 2012 Nick] if the value is invalid number, there is no bar but 
                              // the space is reserved
                              if(perRectData.val !== ' ' && perRectData.val != 0){
                                var height = Math.abs(valueScale(perRectData.val) - valueScale(0));
                                // [10 - Sep - 2012 Nick] if the width of one bar is less than 1px, use 1px.
                                return  (height + r); 
                              }else{
                                return 0;
                              }
                            })
                            .attr('y', function () {
                                 valueScale = valueScales[perRectData.valueAxis];
                                 if(perRectData.val >= 0){
                                   return valueScale(perRectData.val);
                                 }else{
                                   return valueScale(0) - r;
                                 }
                            })
                            .attr('x', function () {
                                var x = xScale(i) + barWidth * m;
                                x = x + barWidth/8 *(m) + barWidth/2;
                                return x;
                              });
                          return 'url(#' + id + ')'; });
                        }
                      }
                      bar.exit().remove();
                });

                barGroup.exit().remove();
                sizeChange = false, dataValueChange = false, dataStructureChange = false;
            
        });
        if(!enableDataLoadingAnimation)
          completeAnimation();
        
        return chart;
      }
      

      function completeAnimation(){
          eDispatch.initialized();
      }
      
    function changeYPosition(d,m){
      var i = d3.interpolate(height,  (m >= indexforSecondaryAxis) ? yScale2(d.val) : yScale(d.val));
        return function(t){ 
          return   i(t);
        }
    };
    
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange =  (width === value)&&!sizeChange ? false:true;
          width = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange ? false:true;
        height = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
    chart.data = function(value){
      if (!arguments.length){
          return data;
      }
        data = value;
        
        var obj = MNDHandler(data);

        data1 = obj["MG1"];
        data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
 
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
        }else{
          hasMNDonCategoryAxis = false;
          if(TypeUtils.isExist(data2)){
                isDualAxis = true;
            }else{
                isDualAxis = false;
            }
        }
        
        var _seriesData = dataTransform(data1,data2, obj.color);
        //judge what changed in dataset
        if(seriesData.length !== _seriesData.length || _seriesData[0].length !== seriesData[0].length){
          dataStructureChange = true;
        }else {
          dataValueChange = true;
        }
        seriesData = _seriesData;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
       return chart;        
    };


      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return properties;
         }
            properties = manifest.props(props);  
            parseOptions();

         return chart;        
      };
     
      /**
       * TODO: add desc
       */
      var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
           domain.push(i);
        }
      
      valueScales = [];
      
        xScale.domain(domain).rangeBands([0, width]);
        yScale.domain([primaryAxisBottomBoundary, primaryAxisTopBoundary]).range([height, 0]).nice();
            Scaler.perfect(yScale);
            if(TypeUtils.isExist(data2) || isDualAxis){
          yScale2.domain([secondaryAxisBottomBoundary, secondaryAxisTopBoundary]).range([height, 0]).nice();
                Scaler.perfectDual(yScale, yScale2);
        }else{
          yScale2.range([0, 0]);
        }
            valueScales.push(yScale);
            valueScales.push(yScale2);
      };
      
      /**
       * TODO: please fill your comments here, or jsdoc will complain.
       */
      chart.categoryScale = function(scale){
        if (!arguments.length){
          return xScale;
         }
        xScale = scale;
         return chart;
      };
     
      chart.primaryScale = function(scale){
        if (!arguments.length){
          return yScale;
         }
        yScale = scale;
        valueScales[0] = yScale;
         return chart;
      };
      
      chart.secondScale = function(scale){
        if (!arguments.length){
          return yScale2;
         }
        yScale2 = scale;
        valueScales[1] = yScale2;
         return chart;
      };

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(!hasMNDonCategoryAxis){
          return colorPalette[seriesData[0].length - 1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };          
      
      chart.primaryDataRange = function(range){
        if (!arguments.length){
          return {
            min: primaryAxisBottomBoundary,
            max: primaryAxisTopBoundary
          };
        }
        primaryAxisTopBoundary = range.max;
        primaryAxisBottomBoundary = range.min;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
        return chart;
      };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          return {
            min: secondaryAxisBottomBoundary,
            max: secondaryAxisTopBoundary
          };
        }
        secondaryAxisTopBoundary = range.max;
        secondaryAxisBottomBoundary = range.min;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
        return chart;
      };    

      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length)
          return y;
        y = _;
        return this;
      };

      chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
      /**
     * set/get effect manager
    */
    chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return chart;        
    };
      
    chart.eventTarget = function (evt) {
      if (evt.type == 'mousemove') {
        return chart.hoverOnPoint;
      } else if (evt.type == 'mouseout') {
        return blurOut;
      }
    };
      
      /**
      * get/set your color palette if you support color palette
      */
      chart.colorPalette = function(_){
        if(!arguments.length){
          return colorPalette;
        }
        colorPalette = _;
        return this;
      };

                
        // chart.primaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis1ColorPalette;
            // }  
            // axis1ColorPalette = _;
            // return this;
        // };
// 
        // chart.secondaryValuesColorPalette = function(_){
            // if(!arguments.length){
                // return axis2ColorPalette;
            // }  
            // axis2ColorPalette = _;
            // return this;
        // };        

      /**
      * get/set your shape Palette if you support shape Palette
      */
      chart.shapePalette = function(_){
        if(!arguments.length){
          return shapePalette;
        }
        shapePalette = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
//      var dataTransform = function(data1,data2){
//        var stackedBarGroup = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;
//      var transferredDataSet = [];
//      for(var i=0; i<data1.length; i++){
//                var temp = d3.max(data1[i], function(m){return m.val;});
//                var temp2 = d3.min(data1[i], function(m){return m.val;});
//                if(primaryAxisTopBoundary <temp){
//                    primaryAxisTopBoundary = temp;
//                }
//                if(primaryAxisBottomBoundary > temp2){
//                    primaryAxisBottomBoundary = temp2;
//                }
//          transferredDataSet.push(data1[i]);
//        }
//      if(data2 != undefined){
//        for(i=0; i<data2.length; i++){
//                    var temp = d3.max(data2[i], function(m){return m.val;});
//                    var temp2 = d3.min(data2[i], function(m){return m.val;});
//                    if(secondaryAxisTopBoundary < temp){
//                        secondaryAxisTopBoundary = temp;
//                    }
//                    if(secondaryAxisBottomBoundary > temp2){
//                        secondaryAxisBottomBoundary = temp2;
//                    }
//          transferredDataSet.push(data2[i]);
//        }
//      }
//       
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        for(i=0; i< transferredDataSet.length; i++){
//          ds.push(transferredDataSet[i][j]);
//        }
//        stackedBarGroup.push(ds);
//      }
//     
//        return stackedBarGroup;
//      };
      
      var dataTransform = function(valueAxis1,valueAxis2, colorIndexArray){
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        var barGroups = [];
      // the number of bar in each group
      var barGroupNumber =  valueAxis1[0].length;
      var barGroup = [];
      var temp = temp2 = 0;
      for(var i=0; i < valueAxis1.length; i++){
        if(hasMNDonCategoryAxis){
          for(var j = 0;  j< valueAxis1[i].length; j++){
            if(colorIndexArray[j] == 0){
              temp = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 0;
              if(primaryAxisTopBoundary <temp){
                primaryAxisTopBoundary = temp;
              }
              if(primaryAxisBottomBoundary > temp){
                primaryAxisBottomBoundary = temp;
              }
              indexforSecondaryAxis++;
            }else{
              temp2 = valueAxis1[i][j].val;
              valueAxis1[i][j].valueAxis = 1;
              if(secondaryAxisTopBoundary < temp2){
                secondaryAxisTopBoundary = temp2;
              }
              if(secondaryAxisBottomBoundary > temp2){
                  secondaryAxisBottomBoundary = temp2;
              }
            }
          }
        }else{
          temp = d3.max(valueAxis1[i], function(m){return m.val;});
          temp2 = d3.min(valueAxis1[i], function(m){return m.val;});
          if(primaryAxisTopBoundary <temp){
            primaryAxisTopBoundary = temp;
          }
          if(primaryAxisBottomBoundary > temp2){
            primaryAxisBottomBoundary = temp2;
          }
        }
        barGroup.push(valueAxis1[i]);
          
        }
      if(valueAxis2 != undefined){
      
        for(i=0; i<valueAxis2.length; i++){
          var temp = d3.max(valueAxis2[i], function(m){return m.val;});
          var temp2 = d3.min(valueAxis2[i], function(m){return m.val;});
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp;
          }
          if(secondaryAxisBottomBoundary > temp2){
              secondaryAxisBottomBoundary = temp2;
          }
          barGroup.push(valueAxis2[i]);
        }
      }
       
       
      for(var j=0; j < barGroupNumber; j++){
        var ds = [];
        for(i=0; i< barGroup.length; i++){
          if(!hasMNDonCategoryAxis){
            if( i < valueAxis1.length){
              barGroup[i][j].valueAxis = 0;
            }else{
              barGroup[i][j].valueAxis = 1;
            }
          }
          if(NumberUtils.isNoValue(barGroup[i][j].val)){
            barGroup[i][j].val = ' ';
          }
          ds.push(barGroup[i][j]);
        }
        if(MNDInnerOnColor){
          var dSet = [], flag1=0, flag2=0;
          var n=0;
          for(var m=0; m < valueAxis1.length; m++){
            dSet.push(ds[m]);
            flag1++;
            if(flag1 == measureOnAxis1 && valueAxis2 != undefined){
              flag2 = 0;
              for(; n<valueAxis2.length; n++){
                if(flag2 >= measureOnAxis2){
                  flag1 = 0;
                  break;
                }
                dSet.push(ds[valueAxis1.length+n]);
                flag2++;
              }
            }
          }
          barGroups.push(dSet);
        }else{
          barGroups.push(ds);
        }
      }
        return barGroups;
      };
    
      properties = manifest.props(null);
      return chart;
  };
  return vBar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.verticalbar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.verticalbar',
    'name' : 'vertical bar',
    base : "sap.viz.modules.xy.bar.base",
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_column',
    name : 'IDS_MULTIVERTICALBARCHART',
    base : 'viz/multi_bar',
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'verticalbar',
            orientation : 'left'
          }
        }
      },
      main : {
        modules: {
          plot : {
            modules : {
              background : {
                configure : {
                  properties : {
                    direction : 'vertical',
                  }
                }
              },
              xAxis : {
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description':'Settings for the category axis of an XY chart.',
                  properties : {
                    type : 'category',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {                   
                    gridline : {
              isExported : false
              },
              label : {
                    isExported : false
                    },
                    axisline : {
                    isExported : false
                   }
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                data : null,
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  properties : {
                    type : 'value',
                    gridline : {
                      visible : true
                    }
                  },
                  propertiesOverride : {                   
                    gridline : {
              isExported : true
              },
              label : {
                    isExported : true
                    },
                    axisline : {
                    isExported : true
                   }
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.verticalbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{  
        multiplier:{
        max:1
      },
        axisLabels:{
        max:1
      },
      secondaryValues: {
        max: 0
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, { targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var multiVBarChart = {
    id : 'viz/multi_dual_column',
    name : 'IDS_MULTIDUALVERTICALBARCHART',
    base : 'viz/multi_column',
    modules : {
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary', 'second']
          }
        },
        modules: {
          plot : {
            modules : {
                 plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
                yAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                  }
                },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                 propertyCategory : 'yAxis2',
                  properties : {
                    title : {
                      visible : false,
                    },
                    type : 'value',
                    position : 'right'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       min: 1,
    max : Number.POSITIVE_INFINITY 
     },
    axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main',
        target : 'secondDataRange',
        sourceModule : 'main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'main.plot.yAxis2',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'secondScale'
      }, {
        targetModule : 'main.plot.yAxis2',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'main.plot.yAxis2',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      },
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.stackedverticalbar',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, ObjectUtils, dispatch, MNDHandler, tooltipDataHandler, ColorSeries, Scaler, Repository, NumberUtils) {
  var bar = function(manifest) {
    var tooltipDataHandlerObj;
        var data, 
          data1 = [[]],
          data2 = [[]],
      seriesData = [], tooltipData = [],
      primaryAxisTopBoundary = 0,
      primaryAxisBottomBoundary = 0,
      secondaryAxisTopBoundary = 0,
      secondaryAxisBottomBoundary = 0,
      gWrapper = null;
    
    var  width = undefined,
      height = undefined,
      x = 0,y = 0,
            isDualAxis = false,
            hasMNDonCategoryAxis = false,
            colorPalette = [],
            axis1ColorPalette,
            axis2ColorPalette,
            MNDInnerOnColor = false,
            measureOnAxis1 = 0,
            measureOnAxis2 = 0,
      shapePalette = ['squareWithRadius'],
      properties,
      eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized');
    
    var effectManager = null;
    
      var valueScales = new Array(2);
        xScale = d3.scale.ordinal(),
          yScale = d3.scale.linear(),
          yScale2 = d3.scale.linear();
      
      var decorativeShape, 
        lastSelected = [], 
      tooltipVisible = true,      
      lastHovered = null;
      
    var barNumber,
      barGroupNumber,
      barNumberinGroup,
      yPositions = [],
      barWidth;
    
    var defsEnter, 
      roundCornerDefs,
      suffix = Repository.newId();

    var enableDataLoadingAnimation = true,
      enableDataUpdatingAnimation = true,
      enableRoundCorner = false,
      clipEdge = true,
      isOnlyInitAnimation = false,
      totalIntervalTime = 800;

    var mode = 'comparison'; //bar display mode
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false, firstRectDrawed = false;
    
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }

      decorativeShape.attr(
          'x',
          xScale.rangeBand() * i + barWidth/4).attr(
          'visibility', 'visible');

      if(lastHovered !== i){
        if (tooltipVisible) {      
          lastHovered = i;
          
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
          var transform = gWrapper.node().getTransformToElement(gWrapper.node().ownerSVGElement);
          var xoffset = transform.e;
          var sumAxis1 = 100, sumAxis2 = 100 , m = 0;
          var tData = tooltipDataHandlerObj.generateTooltipData(data, tooltipData, i, colorPalette, shapePalette, mode === 'percentage'? function(d){
            if(m == seriesData[0][0].length - 1 ){
              m++;
              return sumAxis1 + '%';
            }
            sumAxis1 -= Math.abs(Math.round(d*100));
            if(m > (seriesData[0][0].length - 1)){
              if(m == (barNumberinGroup - 1)){
                m++;
                return sumAxis2 + '%';
              }
              sumAxis2 -= Math.abs(Math.round(d*100));
            }
            m++;
            return Math.abs(Math.round(d*100)) + '%';
          }: null);
          tData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: d3.event.layerY
          };
          tData.plotArea = {
            x : transform.e,
            y : transform.f,
            width : width,
            height : height
          };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
      };
   
      
      function turnToPercentage(){
        for(var i=0, len = seriesData.length; i < len; i++){
            for(var j=0 , rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++){
              var sum = 0, avaCount = 0;;
              for(var k=0; k < rowSeriesData[j].length; k++){
                sum += Math.abs(rowSeriesData[j][k].val);
                if(!rowSeriesData[j][k].isNaN) avaCount++;
              }
              if(sum === 0){
                for(var k=0; k < rowSeriesData[j].length; k++){
                        rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                        }
                }
              }else{
                for(var k=0; k < rowSeriesData[j].length; k++){
                      rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
                      if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                        rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
                      }
                }
              }
              
            }
          }
        };
      
        chart.parent = function(){
          return gWrapper;
        };
        
      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
        eDispatch.hideTooltip();
      }
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        mode = properties.mode === 'percentage'? 'percentage': 'comparison';
        enableDataLoadingAnimation = properties.animation.dataLoading; 
        enableDataUpdatingAnimation = properties.animation.dataUpdating; 
      tooltipVisible = properties.tooltip.enabled;    
        if(isDualAxis && !hasMNDonCategoryAxis){
            axis1ColorPalette = properties.primaryValuesColorPalette;   
        axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
      axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }
      
      drawingEffect = properties.drawingEffect;
            colorPalette = [];
            indexforSecondaryAxis = data1.length; 
            if(MNDInnerOnColor){
        var flag = 0, flag2 = 0, j = 0;
        for(var i=0 ; i < seriesData[0][0].length; i++){
          colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
          flag++;
          if(flag == measureOnAxis1 && isDualAxis && TypeUtils.isExist(seriesData[0][1])){
            flag2 = 0;
            for(; j <= seriesData[0][1].length; j++){
              if(flag2 >= measureOnAxis2){
                flag = 0;
                break;
              }
              colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              flag2++;
            }
            
          }
        }
      }else{
        for(var i=0 ; i < seriesData[0].length; i++){
            for(var j=0; j < seriesData[0][0].length; j++){
               colorPalette.push(axis1ColorPalette[j % axis1ColorPalette.length]);
            }
            if(isDualAxis && TypeUtils.isExist(seriesData[0][1])){
                    for(var j=0; j < seriesData[0][1].length; j++){
                       colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
                    }
                    
                  }
              }  
      }
              
      };
      
      function chart(selection){
        
        tooltipDataHandlerObj = tooltipDataHandler();
        
        //deal with percentage mode
        if(mode === 'percentage'){
          turnToPercentage();
        };
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(!TypeUtils.isExist(yScale) && !TypeUtils.isExist(yScale2)) return;
        
        selection.each(function(){
          
          var indexForAxis2 = data1.length;
          barNumberinGroup = seriesData[0][0].length + ((TypeUtils.isExist(seriesData[0][1])) ? seriesData[0][1].length : 0);
        var barWidthInitial = 8 * (xScale.rangeBand()) / (9*barNumberinGroup +7 );
        
                barNumber = (TypeUtils.isExist(data2)) ? 2 : 1;
                barWidth = 8 * (xScale.rangeBand()) / (9*barNumber +7 );
        
          var svg = gWrapper = d3.select(this);
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() -barWidth/2).attr('height',
                height).attr('visibility', 'hidden').attr(
                'fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', xScale.rangeBand() -barWidth/2).attr('height',height).attr('visibility', 'hidden');
          }

          if(defsEnter == null){
          defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
        }else{
          defsEnter.attr('width', width).attr('height', height);
        }  
          
          if(roundCornerDefs == null){      
          roundCornerDefs = svg.append('defs');
        }else{
          if( dataStructureChange || sizeChange || dataValueChange ){
            roundCornerDefs.remove();
            roundCornerDefs = svg.append('defs');
          }
        }
           
        var r = Math.log(barWidth)/Math.log(2);
        if( r < 0 ){
          enableRoundCorner = false;
        }
        
        var valueScale, tempPos = tempNeg = 0, negativeIndex = postiveIndex = 0;
        
          var barGroup = svg.selectAll('g.bar').data(seriesData);          
          barGroup.enter().append('g');
          barGroup.attr('class','bar')
              .each(function (perGroupData, i) {
                var axisGroup = d3.select(this).selectAll('g.axisGroup').data(perGroupData);     
                axisGroup.enter().append('g');
                axisGroup.attr('class','axisGroup').each( function (perAxisData,j) {  
                  // This is for dual axis
                  var valueScale = (j == 0) ? yScale : yScale2;
                  var startPoint = (j == 0) ? barWidth /2 : (barWidth /2 + barWidth + barWidth/8);
                  var initStartPoint = (j == 0) ? xScale(i) : (xScale(i) + barWidth / 2 + barWidth) ;
                  var fillingColor =  (j == 0) ? axis1ColorPalette : axis2ColorPalette;
                  
                  // This is for pos/neg values.
                  var positiveY = 0, negativeY = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                  
                  var bar = d3.select(this).selectAll('rect').data(perAxisData);
                    bar.enter().append('rect');
                    bar.exit().remove();
                    bar.attr('fill', function(d,colorIndex){  
                      d.fillColor = fillingColor[colorIndex % fillingColor.length];
                      var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : d.fillColor,
                          direction : 'horizontal'
                      };
                      return effectManager.register(parameter);
                    }).attr('shape-rendering','crispEdges').attr('class', 'datapoint').attr('fill-opacity', 1);
                    
                  if(enableDataLoadingAnimation && !isOnlyInitAnimation){
                    // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                    // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                    if(dataStructureChange){
                      bar.attr('x', function(perRectData, m){
                            var x = initStartPoint + barWidthInitial * m;
                          x = x + barWidthInitial/8 *(m) + barWidthInitial/2;
                          return x;
                        })
                        .attr('width', barWidthInitial) .attr('height', 0)
                        .attr('y', function (perRectData, m) {
                          if(perRectData.val >=0 ){
                            positiveY = valueScale(positiveStackedValue);
                            positiveStackedValue += perAxisData[m].val;
                            return positiveY;
                          }else{
                            negativeY = valueScale(negativeStackedValue);
                            negativeStackedValue += perAxisData[m].val;
                            return negativeY;
                          }
                        });
                      // [04 - Sep - 2012 Nick] Round corner enabled. Do the same transition as the bars do.
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  y)
                                        .attr('height',r).attr('width', barWidthInitial)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return negativeY - r;
                                          }else{
                                            return positiveY -  Math.abs(valueScale(perRectData.val) - valueScale(0) );
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                        .attr('x',function(){
                                           var x = xScale(i) + startPoint;
                                           return x;
                                        })
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
                      bar.transition().duration(totalIntervalTime/2)
                         .attr('height', function(perRectData){
                           if(i == 0){
                             firstRectDrawed = true;
                           }
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                         })
                         .attr('y', function (perRectData, m) {
                           if(perRectData.val >= 0 ){
                             return this.y.baseVal.value  -  Math.abs(valueScale(perRectData.val) - valueScale(0) );
                           }else{
                             return this.y.baseVal.value;
                           }
                         });
                      bar.transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                        .attr('width', barWidth)
                        .attr('x', function(perRectData, m){
                            var x = xScale(i) + startPoint;
                          return x;
                        })
                        .each('end', function(d, m){
                         if(firstRectDrawed == false){
                           this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                         }
                         // Fire out event to tell the animation is done.
                         if(m === seriesData[0][0].length - 1 && i == 0){
                           completeAnimation();
                         }
                      });    
                    }else if(sizeChange){
                      var sizeChangeTransition = bar.transition();
                      sizeChangeTransition.duration(totalIntervalTime/2)
                        .attr('width', barWidth)
                        .attr('x', function(perRectData, m){
                          var x = xScale(i) + startPoint;
                          return x;
                        })
                        .attr('height', function(perRectData){
                          if(i == 0){
                            firstRectDrawed = true;
                          }
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                        })
                        .attr('y', function (perRectData, m) {
                           if(perRectData.val >=0 ){
                              positiveStackedValue += perAxisData[m].val;
                            positiveY = valueScale(positiveStackedValue);
                            return positiveY;
                          }else{
                            negativeY = valueScale(negativeStackedValue);
                            negativeStackedValue += perAxisData[m].val;
                            return negativeY;
                          }
                        })
                        .each('end', function(d, m){
                          if(firstRectDrawed == false){
                             this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                           }
                           // Fire out event to tell the animation is done.
                           if(m === seriesData[0][0].length - 1 && i == 0){
                             completeAnimation();
                           }
                        });
                      if(enableRoundCorner){
                        sizeChangeTransition.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var  y = parseFloat(this.y.baseVal.value);
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)
                                        .attr('y',  function(){
                                          return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                        })
                                        .attr('height',this.height.baseVal.value + r).attr('width', this.width.baseVal.value)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return negativeY - r;
                                          }else{
                                            return positiveY;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        .attr('x',function(){
                                           var x = xScale(i) + startPoint;
                                           return x;
                                        })
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
  
                    }else if(dataValueChange){
                      var dataValueChangeTransition = bar.transition();
                      dataValueChangeTransition.duration(totalIntervalTime/2)
                         .attr('height', function(perRectData){
                           if(i == 0){
                             firstRectDrawed = true;
                           }
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                         })
                         .attr('y', function (perRectData, m) {
                           if(perRectData.val >=0 ){
                              positiveStackedValue += perAxisData[m].val;
                            positiveY = valueScale(positiveStackedValue);
                            return positiveY;
                          }else{
                            negativeY = valueScale(negativeStackedValue);
                            negativeStackedValue += perAxisData[m].val;
                            return negativeY;
                          }
                         })
                         .each('end', function(d, m){
                             if(firstRectDrawed == false){
                             this.setAttribute('height', Math.abs(valueScale(d.val) - valueScale(0)));
                           }
                           // Fire out event to tell the animation is done.
                           if(m === seriesData[0][0].length - 1 && i == 0){
                             completeAnimation();
                           }
                        });
                      if(enableRoundCorner){
                        dataValueChangeTransition.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var  y = parseFloat(this.y.baseVal.value);
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)
                                        .attr('y',  function(){
                                          return y - ((indexinGroup === negativeIndexes[j][i]) ? r : 0);
                                        })
                                        .attr('height',this.height.baseVal.value + r).attr('width', this.width.baseVal.value)
                                        .attr('x', this.x.baseVal.value)
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return negativeY - r;
                                          }else{
                                            return positiveY;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
                    }
                  }else{
                      bar.attr('y', function (perRectData, m) {
                          if(perRectData.val >=0 ){
                            positiveStackedValue += perAxisData[m].val;
                            positiveY = valueScale(positiveStackedValue);                          
                            return positiveY;
                          }else{
                            negativeY = valueScale(negativeStackedValue);
                            negativeStackedValue += perAxisData[m].val;
                            return negativeY;
                          }
                           })
                        .attr('x', function(perRectData){
                            var x = xScale(i) + startPoint;
                          return x;
                        })
                        .attr('width', barWidth)
                        .attr('height', function(perRectData){
                           return Math.abs(valueScale(perRectData.val) - valueScale(0) ) ;
                        })
                        .attr('fill', function(d,colorIndex){  
                          d.fillColor = fillingColor[colorIndex % fillingColor.length];
                          var parameter = {
                              drawingEffect:drawingEffect,
                              fillColor : d.fillColor,
                              direction : 'horizontal'
                          };
                          return effectManager.register(parameter);
                        })
                        .attr('shape-rendering','crispEdges').attr('class', 'datapoint');
                        
                      if(enableRoundCorner){
                        bar.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r)      
                                        .attr('y', function () {
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return negativeY - r;
                                          }else{
                                            return positiveY;
                                          }
                                        })
                                        .attr('height',function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r ;
                                        })
                                        
                                        .attr('x',function(){
                                           var x = xScale(i) + startPoint;
                                           return x;
                                        })
                                        .attr('width', barWidth);
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
                    }
                });
 
                  
          });
          if(!enableDataUpdatingAnimation){
            isOnlyInitAnimation = true;
          }
            
          barGroup.exit().remove();
          sizeChange = false, dataValueChange = false, dataStructureChange = false, firstRectDrawed = false;
        });
        if(!enableDataLoadingAnimation)
          completeAnimation();
        
        return chart;
      }
      
      function completeAnimation(){
            eDispatch.initialized();
        };
      
    
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }  
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }  
         return chart;        
      };

      chart.data = function(value){
      if (!arguments.length){
          return data;
      }
      
      data = value;
      var obj = MNDHandler(data);

      var _data1 = obj["MG1"];
          var _data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        tooltipData = [];
        
      if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
          var tempData1 = [], tempData2 = [];
          var tempStackedData1 = [], tempStackedData2 = [];
          for(var i=0; i<_data1.length; i++){
            tempData1 = [];
            tempData2 = [];
            for(var j=0; j<_data1[i].length; j++){
              if(obj.color[j] == 0){
                tempData1.push(_data1[i][j]);
                tempData2.push({
                val:null,
                hasMNDonCategoryAxis : true
              });
              }else{

                tempData1.push({
                val:null,
                hasMNDonCategoryAxis : true
              });
                tempData2.push(_data1[i][j]);
              }
            }
            tempStackedData1.push(tempData1);
            tempStackedData2.push(tempData2);
          }
          _data1 = tempStackedData1;
          _data2 = tempStackedData2;

      }else{
        hasMNDonCategoryAxis = false;
        if(TypeUtils.isExist(_data2)){
          if(! dataStructureChange && (data2.length !== _data2.length || data2[0].length !== _data2[0].length)){
                  dataStructureChange = true;
               }
          isDualAxis = true;
           }else{
              isDualAxis = false;
            }
        }
      
      if(data1.length !== _data1.length || data1[0].length !== _data1[0].length){
            dataStructureChange = true;
          }
      
      var _seriesData = dataHandler(_data1, _data2);
      seriesData = _seriesData;
        data1 = _data1;
        data2 = _data2;
      
        //judge what changed in dataset
        if(!dataStructureChange){
          dataValueChange = true;
        }
        
        if(hasMNDonCategoryAxis){
          for(var i=0; i< seriesData.length; i++){
            var temp = seriesData[i];
            if(temp[0][0].hasMNDonCategoryAxis){
              tooltipData.push(temp[1]);
            }else{
              tooltipData.push(temp[0]);
            }
          }
        }else{
          tooltipData = ObjectUtils.extend(true, {}, seriesData); 
        }
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
      
      return chart;        
    };


    /**
     * set/get properties
    */
    chart.properties = function(props){
      if (!arguments.length){
          return properties;
       }
            properties = manifest.props(props);
            parseOptions();
        
        return chart;        
    };
       

    var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
          domain.push(i);
        }
        xScale.domain(domain).rangeBands([0, width]);

        if(mode === 'percentage'){
          yScale.domain([0,1]).range([height, 0]).nice();
          yScale2.domain([0,1]).range([height, 0]).nice();
          Scaler.perfectDual(yScale, yScale2);
        }else{
          yScale.domain([primaryAxisBottomBoundary,primaryAxisTopBoundary]).range([height, 0]).nice();
          yScale2.domain([secondaryAxisBottomBoundary,secondaryAxisTopBoundary]).range([height, 0]).nice();
          Scaler.perfectDual(yScale, yScale2);
        }
        if(!TypeUtils.isExist(data2)){
            yScale2.range([0, 0]);
        }
    };

    chart.colorPalette = function(Palette){
        if (!arguments.length){
          return colorPalette;
       }
        colorPalette = Palette;
       return chart;        
    };
    
    chart.primaryDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = primaryAxisBottomBoundary < 0 ? primaryAxisBottomBoundary : 0;
          maxt = primaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      primaryAxisTopBoundary = range.max;
      primaryAxisBottomBoundary = range.min;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        makeScales();
      }
      return chart;
    };
      
      chart.secondDataRange = function(range){
        if (!arguments.length){
          var maxt, mint;
          if(mode === 'percentage'){
            maxt = 1;
            mint = 0;
          }else{
            mint = secondaryAxisBottomBoundary< 0 ? secondaryAxisBottomBoundary : 0 ;
          maxt = secondaryAxisTopBoundary;
          }
          return {
            min: mint,
            max: maxt
          };
        }
        secondaryAxisTopBoundary = range.max;
        secondaryAxisBottomBoundary = range.min;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
        return chart;
      };

    chart.categoryScale = function(scale){
        if (!arguments.length){
          return xScale;
       }
        xScale = scale;
       return chart;
    };
       
    chart.primaryScale = function(scale){
        if (!arguments.length){
          return yScale;
       }
        yScale = scale;
        valueScales[0] = yScale;
       return chart;
    };  
    
    chart.secondScale = function(scale){
            if (!arguments.length){
                return yScale2;
            }
            yScale2 = scale;
            valueScales[0] = yScale2;
            return chart;
        };        

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(TypeUtils.isExist(seriesData[0][1]) && !hasMNDonCategoryAxis){
          return axis2ColorPalette[seriesData[0][1].length-1];
        }else{
           //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };  
        
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      /**
     * set/get effect manager
    */
    chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return chart;        
    };
      
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length)
          return y;
        y = _;
        return this;
      };
      
      chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
//        var dataTransform = function(data1,data2){
//            var stackedBarGroup = [];
//            // the number of bar in each group
//            var barGroupNumber =  data1[0].length;;
//            var transferredDataSet = data1;
//            var temp;
//            for(var j=0; j < barGroupNumber; j++){
//                var ds = [];
//                temp = 0
//                for(i=0; i< transferredDataSet.length; i++){
//                    ds.push(transferredDataSet[i][j]);
//                    temp += transferredDataSet[i][j].val;
//                }
//                if(primaryAxisBoundary < temp){
//                    primaryAxisBoundary = temp
//                }
//                stackedBarGroup.push(ds);
//            }
//            if(TypeUtils.isExist(data2)){
//                barGroupNumber =  data2[0].length;;
//                transferredDataSet = data2;
//                for(var j=0; j < barGroupNumber; j++){
//                    temp = 0
//                    for(i=0; i< transferredDataSet.length; i++){
//                        stackedBarGroup[j].push(transferredDataSet[i][j]);
//                        temp += transferredDataSet[i][j].val;
//                    }
//                    if(secondaryAxisBoundary < temp){
//                        secondaryAxisBoundary = temp;
//                    }
//                }
//            }
//            return stackedBarGroup;
//        };
        
        
      var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
        
        var positiveIndex = -1, negativeIndex = -1;
        positiveIndexes = [[],[]], negativeIndexes = [[],[]];
      
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        
        var stackedBarGroupsData = [];
      // the number of bar in each group
      barGroupNumber =  valueAxis1Data[0].length;;
      var temp, temp2;
      for(var j=0; j < barGroupNumber; j++){
        var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
        var oneGroupDataSet = [];
        temp = 0, temp2 = 0;
        positiveIndex = -1, negativeIndex = -1;
        for(var i=0; i< valueAxis1Data.length; i++){
          if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
            valueAxis1Data[i][j].val = 0;
            valueAxis1Data[i][j].isNaN = true;
          }else{
            if(valueAxis1Data[i][j].val >= 0){
              temp += valueAxis1Data[i][j].val;
              positiveIndex = i;
            }else{
              temp2 += valueAxis1Data[i][j].val;
              negativeIndex = i;
            }
          }
          tempDataSetAxis1.push(valueAxis1Data[i][j]);
        }
        positiveIndexes[0].push(positiveIndex);
        negativeIndexes[0].push(negativeIndex);
        
        if(primaryAxisTopBoundary < temp){
          primaryAxisTopBoundary = temp;
        }
        if(primaryAxisBottomBoundary > temp2){
          primaryAxisBottomBoundary = temp2;
        }
        oneGroupDataSet.push(tempDataSetAxis1);
        
        
        if(TypeUtils.isExist(valueAxis2Data)){
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for(i=0; i< valueAxis2Data.length; i++){
            if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
              valueAxis2Data[i][j].val = 0;
              valueAxis2Data[i][j].isNaN = true;
            }else{
              if(valueAxis2Data[i][j].val >= 0){
                temp += valueAxis2Data[i][j].val;
                positiveIndex = i;
              }else{
                temp2 += valueAxis2Data[i][j].val;
                negativeIndex = i;
              }
            }
            tempDataSetAxis2.push(valueAxis2Data[i][j]);
          }
          positiveIndexes[1].push(positiveIndex);
          negativeIndexes[1].push(negativeIndex);
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp
          }
          if(secondaryAxisBottomBoundary > temp2){
            secondaryAxisBottomBoundary = temp2;
          }
          oneGroupDataSet.push(tempDataSetAxis2);
        }
        stackedBarGroupsData.push(oneGroupDataSet);
      }
        return stackedBarGroupsData;
      };
        
      properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.stackedverticalbar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedverticalbar',
      'name' : 'stacked vertical bar',
      base : "sap.viz.modules.verticalbar",
      'properties' : {
        'mode' : {
          'name' : 'mode',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'comparison', 'percentage' ],
          'defaultValue' : 'comparison',
          'description' : 'Set dispaly mode of stacked vertical bar.'
        }
      },
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_dual_stacked_column',
    name : 'IDS_MULTIDUALSTACKEDVERTICALBARCHART',
    base : 'viz/multi_dual_column',
    modules : {
      main : {
        modules: {
          plot : {
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualPercentageStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiVBarChart = {
    id : 'viz/multi_100_dual_stacked_column',
    name : 'IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART',
    base : 'viz/multi_dual_stacked_column',
    modules : {
      main : {
        modules: {
          plot : {
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var multiBarChart = {
    id : 'viz/multi_dual_bar',
    name : 'IDS_MULTIDUALBARCHART',
    base : 'viz/multi_bar',
    modules : {
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary', 'second']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
                 plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
              xAxis:{
                  id : 'sap.viz.modules.axis',
              configure:{
                'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
              }
            },
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'xAxis2',
                  properties : {
                    title : {
                      visible : false,
                    },
                    gridline : {
                      visible : false
                    },
                    type : 'value',
                    position : 'top'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
      }
          },
        }
      },
  },
    feeds:{
      multiplier:{
      max:1
    },
    secondaryValues:{
      min: 1,
      max : Number.POSITIVE_INFINITY 
    },
    axisLabels:{
      max:1
    }
  },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main',
        target : 'secondDataRange',
        sourceModule : 'main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },   {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },   {
        targetModule : 'main.plot.xAxis2',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'secondScale'
      },
   {
        targetModule : 'main.plot.xAxis2',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisTitle'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'main.plot.xAxis2',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    },
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.stackedbar',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(TypeUtils, ObjectUtils, dispatch, MNDHandler,tooltipDataHandler, ColorSeries, Scaler, Repository, NumberUtils) {
  var bar = function(manifest) {
    var tooltipHandlerObj = null;
    var data, 
        data1 = [[]],
        data2 = [[]],
      seriesData = [], tooltipData = [], //in stacked chart the value in tooltip is the same with data in seriesData, but in percentage chart it use the absolute value of negative data.
      primaryAxisTopBoundary = 0,
      primaryAxisBottomBoundary = 0,
      secondaryAxisTopBoundary = 0,
      secondaryAxisBottomBoundary = 0,
      gWrapper = null;
    
    var  width = undefined, 
      height = undefined,
      id = Math.floor(Math.random() * 10000),
      x = 0, y = 0,
          isDualAxis = false,
            colorPalette = [],
            axis1ColorPalette,
            axis2ColorPalette,
            MNDInnerOnColor = false,
            measureOnAxis1 = 0,
            measureOnAxis2 = 0,
      shapePalette = ['squareWithRadius'],
      properties,
      eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized');
      
    var effectManager = null;
    
      var yScale = d3.scale.ordinal(),
          xScale = d3.scale.linear(),
          xScale2 = d3.scale.linear();
      
      var decorativeShape,
      lastSelected = [],
      evtData = [],
      lastHovered = null,
      isLasso = false;
      
    var barNumber = 1,
      barGroupNumber,
      barNumberinGroup,
      barHeight,
      positiveIndexes = [], 
      negativeIndexes = [];
      
    var enableDataLoadingAnimation = true,
      enableDataUpdatingAnimation = true,
      enableRoundCorner = false,
      clipEdge = true,
      hasMNDonCategoryAxis = false,
      isOnlyInitAnimation = false,
      totalIntervalTime = 1000;
    
    var defsEnter, 
      roundCornerDefs,
      suffix = Repository.newId();
    
    var mode = 'comparison'; // bar display mode
    
    var drawingEffect = 'normal';
    
    var sizeChange = false, dataStructureChange = false, dataValueChange = false;
    
    chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.attr(
            'visibility', 'hidden');
        return;
      }

      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + barHeight/4).attr(
          'visibility', 'visible');

      if(i !== lastHovered){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode.parentNode.parentNode point to the main container
          var transform = gWrapper[0][0].getTransformToElement(gWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          var sumAxis1 = 100, sumAxis2 = 100 , m = 0;
          var tData = tooltipHandlerObj.generateTooltipData(data, tooltipData, barGroupNumber-1-i, colorPalette, shapePalette, mode === 'percentage'? function(d){
            if(m == seriesData[0][0].length - 1 ){
              m++;
              return sumAxis1 + '%';
            }
            sumAxis1 -= Math.abs(Math.round(d*100));
            if(m > (seriesData[0][0].length - 1)){
              if(m == (barNumberinGroup - 1)){
                m++;
                return sumAxis2 + '%';
              }
              sumAxis2 -= Math.abs(Math.round(d*100));
            }
            m++;
            return Math.abs(Math.round(d*100)) + '%';
          }: null);
          
          tData.point = {
              x: d3.event.layerX,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tData.plotArea = {
            x : transform.e,
            y : transform.f,
            width : width,
            height : height
          };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
      }
      };
      
      chart.blurOut = function(){
        decorativeShape.attr('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {      
        eDispatch.hideTooltip();
      }
      };
      
      chart.parent = function(){
        return gWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      var parseOptions = function(){
        enableRoundCorner = properties.isRoundCorner;
        mode = properties.mode === 'percentage'? 'percentage': 'comparison';
        enableDataLoadingAnimation =  properties.animation.dataLoading; 
        enableDataUpdatingAnimation =  properties.animation.dataUpdating; 
      tooltipVisible = properties.tooltip.enabled;      
  if(isDualAxis && !hasMNDonCategoryAxis){
            axis1ColorPalette = properties.primaryValuesColorPalette;   
        axis2ColorPalette = properties.secondaryValuesColorPalette;
        }else{
      axis2ColorPalette = properties.colorPalette;
          axis1ColorPalette = properties.colorPalette;
        }

            drawingEffect = properties.drawingEffect;
            
            var indexforSecondaryAxis = data1.length;
            colorPalette = [];
            if(MNDInnerOnColor){
        var flag = 0, flag2 = 0, j = 0;
        for(var i=0 ; i < seriesData[0][0].length; i++){
          colorPalette.push(axis1ColorPalette[i % axis1ColorPalette.length]);
          flag++;
          if(flag == measureOnAxis1 && isDualAxis && TypeUtils.isExist(seriesData[0][1])){
            flag2 = 0;
            for(; j <=seriesData[0][1].length; j++){
              if(flag2 >= measureOnAxis2){
                flag = 0;
                break;
              }
              colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
              flag2++;
            }
            
          }
        }
      }else{
          for(var i=0 ; i < seriesData[0].length; i++){
            for(var j=0; j < seriesData[0][0].length; j++){
               colorPalette.push(axis1ColorPalette[j % axis1ColorPalette.length]);
            }
                  if(isDualAxis && TypeUtils.isExist(seriesData[0][1])){
                    for(var j=0; j < seriesData[0][1].length; j++){
                       colorPalette.push(axis2ColorPalette[j % axis2ColorPalette.length]);  
                    }
                    
                  }
              }
      }                    
      };
      
      function chart(selection){
        
        //deal with percentage mode
        if(mode === 'percentage'){
          turnToPercentage();
        };
        
        tooltipHandlerObj = tooltipDataHandler();
        
        // [19-Oct-2012 Nick] if the size of plot area is too small, there is no value scale created and the whole drawing part is skipped.
        if(!TypeUtils.isExist(xScale) && !TypeUtils.isExist(xScale2)) return;
        
        selection.each(function(){

        barNumber = (TypeUtils.isExist(data2)) ? 2 : 1;
        barHeight = 8 * (yScale.rangeBand()) / (9*barNumber +7 );
        
        barNumberinGroup = seriesData[0][0].length + ((TypeUtils.isExist(seriesData[0][1])) ? seriesData[0][1].length : 0);
        var barHeightInitial = 8 * (yScale.rangeBand()) / (9*barNumberinGroup +7 );
          
        var svg = gWrapper = d3.select(this);
        //append decorativeShape
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', width).attr('height',
            yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden').attr(
                'fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', width).attr('height', yScale.rangeBand() - barHeight/2).attr('visibility', 'hidden');
          }
          
          if(defsEnter == null){
          defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);    
        }else{
          defsEnter.attr('width', width).attr('height', height);
        }  
          
           if(roundCornerDefs == null){      
          roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + suffix);
        }else{
          if( dataStructureChange || sizeChange || dataValueChange ){
            roundCornerDefs.remove();
            roundCornerDefs = svg.append('defs').attr('id', 'round-corner-clip' + suffix);
          }
        }    
        
        var r = Math.log(barHeight)/Math.log(2);
        if( r < 0 ){
          enableRoundCorner = false;
        }
        if(enableDataLoadingAnimation && !isOnlyInitAnimation){
          var barGroup = svg.selectAll('g.bar').data(seriesData);     
            barGroup.enter().append('g');
            barGroup.attr('class','bar').each( function (perGroupData,i) {
              var axisGroup = d3.select(this).selectAll('g.axisGroup').data(perGroupData);     
                axisGroup.enter().append('g');
                axisGroup.attr('class','axisGroup').each( function (perAxisData,j) {  
                  // This is for dual axis
                  var valueScale = (j == 0) ? xScale : xScale2;
                  var startPoint = (j == 0) ? barHeight /2 : (barHeight /2 + barHeight + barHeight/8);
                  var initStartPoint = (j == 0) ? yScale(i) : (yScale(i) + barHeight / 2 + barHeight) ;
                  var fillingColor =  (j == 0) ? axis1ColorPalette : axis2ColorPalette;
                  
                  // This is for pos/neg values.
                  var positiveX = 0, negativeX = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                  
                  var bar = d3.select(this).selectAll('rect').data(perAxisData);
                    bar.enter().append('rect');
                    bar.attr('fill', function(d,colorIndex){  
                      d.fillColor = fillingColor[colorIndex % fillingColor.length];
                      var parameter = {
                          drawingEffect:drawingEffect,
                          fillColor : d.fillColor,
                          direction : 'vertical'
                      };
                      return effectManager.register(parameter);
                    }).attr('shape-rendering','crispEdges').attr('class', 'datapoint').attr('fill-opacity', 1);
                  
                  // [04 - Sep - 2012 Nick] DataStructureChange means the structure of data is changed. 
                  // It means the whole DOM nodes needed to be removed (handled by d3) and append new ones.
                  if(dataStructureChange){
                    bar.attr('height',barHeightInitial)
                       .attr('y', function (perRectData, m) {
                        var y = initStartPoint + barHeightInitial * m;
                        y = y + barHeightInitial/8 *(m) + barHeightInitial /2;
                        return y;
                       })
                       .attr('x', function(perRectData,k){
                         if(perRectData.val >= 0){
                           positiveX = valueScale(positiveStackedValue);
                           positiveStackedValue += perAxisData[k].val;
                                 return positiveX;
                         }else{
                           negativeX = valueScale(negativeStackedValue);
                           negativeStackedValue += perAxisData[k].val;
                           return negativeX;
                         }         
                         return valueScale(0);
                       })
                       .attr('width', 0);

                    // [04 - Sep - 2012 Nick] Round corner enabled. Do the same transition as the bars do.
                    if(enableRoundCorner){
                      bar.attr('clip-path', function(perRectData, indexinGroup){
                        if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                            var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                            var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                      .append('rect').attr('class', 'roundCorner-clip')
                                      .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                      .attr('height',barHeightInitial).attr('width', 0)
                                      .attr('x', this.x.baseVal.value)
                                      .transition().duration(totalIntervalTime/2)
                                      .attr('x',function(){
                                        if(indexinGroup ===  negativeIndexes[j][i] ){
                                          return this.x.baseVal.value - Math.abs(valueScale(perRectData.val) - valueScale(0));
                                        }else{
                                          return this.x.baseVal.value - r;
                                        }
                                      })
                                      .attr('width', function(){
                                         return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                      })
                                      .transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                                      .attr('height',barHeight).attr('y', function(){
                                         var y = yScale(i) + startPoint;
                                         return y;
                                      });
                          return 'url(#' + id + ')' ;
                        }
                         
                      });
                    }
                    negativeStackedValue = 0;
                    bar.transition().duration(totalIntervalTime/2)
                       .attr('width', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0));
                       })
                       .attr('x', function(perRectData, k){
                         if(perRectData.val < 0){
                           negativeStackedValue += perAxisData[k].val;
                           return valueScale(negativeStackedValue);
                         }else{
                           return this.x.baseVal.value;
                         }
                       });
                    
                    bar.transition().delay(totalIntervalTime/2).duration(totalIntervalTime/2)
                       .attr('height',barHeight)
                       .attr('y', function(d, m){
                          var y = yScale(i) + startPoint;
                        return y;
                       })
                       .each('end', function(d, m){
                        //As in large data with animation, transition code will be washed away, we should reset the width of rect in the animation end.
                           this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)) );
                         // Fire out event to tell the animation is done.
                         if(m === seriesData[0][0].length - 1 && i == 0){
                           completeAnimation();
                         }
                       });
                  }
                  else if(sizeChange){
                    var sizeTransition = bar.transition();
                    sizeTransition.duration(totalIntervalTime/2)
                       .attr('width', function(perRectData){
                         return Math.abs(valueScale(perRectData.val) - valueScale(0));
                       })
                       .attr('x', function(perRectData, k){
                         if(perRectData.val >= 0){
                           positiveX = valueScale(positiveStackedValue);
                           positiveStackedValue += perAxisData[k].val;
                                 return positiveX;
                         }else{
                             negativeStackedValue += perAxisData[k].val;
                             negativeX = valueScale(negativeStackedValue);
                             return negativeX;
                         }  
                       })
                       .attr('height',barHeight)
                       .attr('y', function(d, m){
                          var y = yScale(i) + startPoint;
                        return y;
                       })
                       .each('end', function(d, m){
                        this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)));
                         // Fire out event to tell the animation is done.
                         if(m === seriesData[0][0].length - 1 && i == 0){
                           completeAnimation();
                         }
                       });
                    
                      if(enableRoundCorner){
                        sizeTransition.attr('clip-path', function(perRectData, indexinGroup){
                          if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                            var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                            var x = parseFloat(this.x.baseVal.value) ;
                            var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                        .attr('height',this.height.baseVal.value).attr('width', this.width.baseVal.value + r)
                                        .attr('x', function(){
                                          return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                        })
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('x',function(){
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return negativeX;
                                          }else{
                                            return positiveX - r;
                                          }
                                        })
                                        .attr('width', function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                        })
                                        .attr('height',barHeight).attr('y', function(){
                                          var y = yScale(i) + startPoint;
                                          return y;
                                        });
                            return 'url(#' + id + ')' ;
                          }
                           
                        });
                      }
                     

                  }
                  // [04 - Sep - 2012 Nick] Data has the same structure, but the value changed.
                  // TO BE TESTED ! WE DO NOT HAVE THIS WORK FLOW NOW.  
                  else if(dataValueChange){
                    var stateChange = bar.transition();
                      stateChange.duration(totalIntervalTime/2)
                        .attr('width', function(perRectData){
                          return Math.abs(valueScale(perRectData.val) - valueScale(0));
                        })
                        .attr('x', function(perRectData, k){
                          if(perRectData.val >= 0){
                             positiveX = valueScale(positiveStackedValue);
                             positiveStackedValue += perAxisData[k].val;
                                   return positiveX;
                           }else{
                            negativeStackedValue += perAxisData[k].val;
                            negativeX = valueScale(negativeStackedValue);
                            return negativeX;
                           }    
                        })
                        .each('end', function(d, m){
                          this.setAttribute('width', Math.abs(valueScale(d.val) - valueScale(0)));
                          // Fire out event to tell the animation is done.
                          if(m === seriesData[0][0].length - 1 && i == 0){
                            completeAnimation();
                          }
                        });
                        if(enableRoundCorner){
                          stateChange.attr('clip-path', function(perRectData, indexinGroup){
                            if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                              var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                              var x = parseFloat(this.x.baseVal.value) ;
                              var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                        .append('rect').attr('class', 'roundCorner-clip')
                                        .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                        .attr('height',barHeight).attr('width', this.width.baseVal.value - r)
                                        .attr('x', function(){
                                          return x - ((indexinGroup === negativeIndexes[j][i]) ? 0 : r);
                                        })
                                        .transition().duration(totalIntervalTime/2)
                                        .attr('x',function(){
                                          if(indexinGroup === negativeIndexes[j][i]){
                                            return negativeX;
                                          }else{
                                            return positiveX - r;
                                          }
                                        })
                                        .attr('width', function(){
                                           return Math.abs(valueScale(perRectData.val) - valueScale(0)) + r;
                                        });  
                              return 'url(#' + id + ')' ;
                            }
                          });
                        }
                  }
                  bar.exit().remove();  //Nick                
              });
              axisGroup.exit().remove();
          });
          barGroup.exit().remove();
          if(!enableDataUpdatingAnimation){
            isOnlyInitAnimation = true;
          }
        }else{
            var barGroup = svg.selectAll('g.bar').data(seriesData);     
            barGroup.enter().append('g');
            barGroup.attr('class','bar').each( function (perGroupData,i) {
            var axisGroup = d3.select(this).selectAll('g.axisGroup').data(perGroupData);     
              axisGroup.enter().append('g');
              axisGroup.attr('class','axisGroup').each( function (perAxisData,j) {
                
                var valueScale = (j == 0) ? xScale : xScale2;
                var startPoint = (j == 0) ? barHeight /2 : (barHeight /2 + barHeight + barHeight/8);
                var fillingColor =  (j == 0) ? axis1ColorPalette : axis2ColorPalette;
                var positiveX = 0, negativeX = 0,  positiveStackedValue =  0, negativeStackedValue = 0;
                var positiveIndex = 0, negativeIndex = -1;
                
                var bar = d3.select(this).selectAll('rect').data(perAxisData);
                  bar.enter().append('rect');
                  bar.attr('y', function (perRectData, k) {
                    var y = yScale(i) + startPoint;
                    return y;
                  })
                  .attr('x', function(perRectData, k){
                     if(perRectData.val >= 0){
                       positiveX = valueScale(positiveStackedValue);
                       positiveStackedValue += perAxisData[k].val;
                             return positiveX;
                     }else{
                       negativeStackedValue += perAxisData[k].val;
                       return valueScale(negativeStackedValue);
                     }         
                     return valueScale(0);
                  })
                  .attr('width',function(perRectData,k){
                     var width = Math.abs(valueScale(perRectData.val) -  valueScale(0));
                     return width;                   
                  })
                  .attr('height',barHeight)
                  .attr('fill', function(d,colorIndex) {
                    var fillColor = fillingColor[colorIndex % fillingColor.length];
                    var parameter = {
                        drawingEffect:drawingEffect,
                        fillColor : fillColor,
                        direction : 'vertical'
                    };
                    return effectManager.register(parameter);                  
                  })
                  .attr('shape-rendering','crispEdges').attr('class', 'datapoint');
                  
                  if(enableRoundCorner){
                    bar.attr('clip-path', function(perRectData, indexinGroup){
                      if(indexinGroup === negativeIndexes[j][i] || indexinGroup === positiveIndexes[j][i]){
                        var id = 'roundCorner-clip' + '-' + indexinGroup + i + j + suffix;
                        var roundCorner = roundCornerDefs.append('clipPath').attr('id', id)
                                    .append('rect').attr('class', 'roundCorner-clip')
                                    .attr('rx', r).attr('ry', r).attr('y',  this.y.baseVal.value)
                                    .attr('height',barHeight).attr('width', function(){
                                                                  return  Math.abs(valueScale(perRectData.val) - valueScale(0) ) + r;
                                                              });
                        if(indexinGroup === negativeIndexes[j][i]){
                          roundCorner.attr('x',this.x.baseVal.value);
                        }else{
                          roundCorner.attr('x',this.x.baseVal.value - r);  
                        }
            
                        return 'url(#' + id + ')' ;
                      }
                       
                    });
                  }
                bar.exit().remove();
            });
            axisGroup.exit().remove();
          });        
          barGroup.exit().remove();
        }
        
        sizeChange = false, dataValueChange = false, dataStructureChange = false;
        });
        if(!enableDataLoadingAnimation)
          completeAnimation();
        
        return chart;
      }
      
        function turnToPercentage(){
          for(var i=0, len = seriesData.length; i < len; i++){
            for(var j=0 , rowSeriesData = seriesData[i], rowTooltipData = tooltipData[i]; j < rowSeriesData.length; j++){
              var sum = 0, avaCount = 0;;
              for(var k=0; k < rowSeriesData[j].length; k++){
                sum += Math.abs(rowSeriesData[j][k].val);
                if(!rowSeriesData[j][k].isNaN) avaCount++;
              }
              if(sum === 0){
                for(var k=0; k < rowSeriesData[j].length; k++){
                        rowSeriesData[j][k].val = rowSeriesData[j][k].isNaN? 0:1/avaCount ;
                        if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                          rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : 1/avaCount;
                        }
                }
              }else{
                for(var k=0; k < rowSeriesData[j].length; k++){
                      rowSeriesData[j][k].val = Math.abs(rowSeriesData[j][k].val/sum);
                      if(TypeUtils.isExist(rowTooltipData[j]) &&TypeUtils.isExist(rowTooltipData[j][k]) ){
                        rowTooltipData[j][k].val = rowTooltipData[j][k].isNaN? ' ' : rowTooltipData[j][k].val/sum;
                      }
                }
              }
              
            }
          }
        };
      
      function completeAnimation(){
            eDispatch.initialized();
        };
      
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(seriesData)){
          makeScales();
        }
         return chart;        
      };
      /**
     * set/get data, for some modules like Title, it doesn't need data
     */
      chart.data = function(value){
      if (!arguments.length){
          return data;
      }
      data = value;
      var obj = MNDHandler(data);
                 
            var _data1 = obj["MG1"];
            var _data2 = obj["MG2"];
        measureOnAxis1 = obj.MG1Number;
        measureOnAxis2 = obj.MG2Number || 0;
        MNDInnerOnColor = obj.MNDOnColor && obj.MNDInner;
        tooltipData = [];
            
        if(TypeUtils.isExist(obj.color)){
          hasMNDonCategoryAxis = true;
          isDualAxis = true;
          var tempData1 = [], tempData2 = [];
          var tempStackedData1 = [], tempStackedData2 = [];
          for(var i=0; i<_data1.length; i++){
            tempData1 = [];
            tempData2 = [];
            for(var j=0; j<_data1[i].length; j++){
              if(obj.color[j] == 0){
                tempData1.push(_data1[i][j]);
                tempData2.push({
                val:null,
                hasMNDonCategoryAxis : true
              });
              }else{

                tempData1.push({
                val:null,
                hasMNDonCategoryAxis : true
              });
                tempData2.push(_data1[i][j]);
              }
            }
            tempStackedData1.push(tempData1);
            tempStackedData2.push(tempData2);
          }
          _data1 = tempStackedData1;
          _data2 = tempStackedData2;
          
      }else{
        hasMNDonCategoryAxis = false;
            if(TypeUtils.isExist(_data2)){
              if(! dataStructureChange && 
                  (data2.length !== _data2.length || data2[0].length !== _data2[0].length)){
                  dataStructureChange = true;
               }
              isDualAxis = true;
                  }else{
                    isDualAxis = false;
                  }
        }
            
            if(data1.length !== _data1.length || data1[0].length !== _data1[0].length){
            dataStructureChange = true;
          }

      var _seriesData = dataHandler(_data1, _data2, obj.color);
      
        //judge what changed in dataset
        if(!dataStructureChange){
          dataValueChange = true;
        }
        seriesData = _seriesData;
        data1 = _data1;
        data2 = _data2;
        
        if(hasMNDonCategoryAxis){
          for(var i=0; i< seriesData.length; i++){
            var temp = seriesData[i];
            if(temp[0][0].hasMNDonCategoryAxis){
              tooltipData.push(temp[1]);
            }else{
              tooltipData.push(temp[0]);
            }
          }
        }else{
          tooltipData = ObjectUtils.extend(true, {}, seriesData); 
        }
        
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
          makeScales();
        }
      
      parseOptions();
      
      return chart;        
    };


    /**
     * set/get properties
    */
    chart.properties = function(props){
      if (!arguments.length){
          return properties;
       }
            properties = manifest.props(props);
            parseOptions();
        
        return chart;        
    };
       

    var makeScales = function(){
      var domain = [];
      for (var i=0; i < seriesData.length; i++){
          domain.push(i);
        }
        yScale.domain(domain).rangeBands([height, 0]);
        if(mode === 'percentage'){
          xScale.domain([0,1]).range([0, width]).nice();
          xScale2.domain([0,1]).range([0, width]).nice();
          Scaler.perfectDual(xScale, xScale2);
        }else{
          xScale.domain([primaryAxisBottomBoundary,primaryAxisTopBoundary]).range([0, width]).nice();
          xScale2.domain([secondaryAxisBottomBoundary,secondaryAxisTopBoundary]).range([0, width]).nice();
          Scaler.perfectDual(xScale, xScale2);
        }
          if(!TypeUtils.isExist(data2)){
                xScale2.range([0, 0]);
            }
    };

    chart.colorPalette = function(Palette){
        if (!arguments.length){
          return colorPalette;
       }
        colorPalette = Palette;
       return chart;        
    };

    chart.categoryScale = function(scale){
        if (!arguments.length){
          return yScale;
       }
        yScale = scale;
       return chart;
    };
    
    chart.primaryDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = primaryAxisBottomBoundary < 0 ? primaryAxisBottomBoundary : 0;
          maxt = primaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      primaryAxisTopBoundary = range.max;
      primaryAxisBottomBoundary = range.min;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        makeScales();
      }
      return chart;
    };
      
    chart.secondDataRange = function(range){
      if (!arguments.length){
        var maxt, mint;
        if(mode === 'percentage'){
          maxt = 1;
          mint = 0;
        }else{
          mint = secondaryAxisBottomBoundary< 0 ? secondaryAxisBottomBoundary : 0 ;
          maxt = secondaryAxisTopBoundary;
        }
        return {
          min: mint,
          max: maxt
        };
      }
      secondaryAxisTopBoundary = range.max;
      secondaryAxisBottomBoundary = range.min;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        makeScales();
      }
      return chart;
    }; 
       
    chart.primaryScale = function(scale){
        if (!arguments.length){
          return xScale;
       }
        xScale = scale;
       return chart;
    };     
    
    chart.secondScale = function(scale){
            if (!arguments.length){
                return xScale2;
            }
            xScale2 = scale;
            return chart;
        };    

      chart.primaryAxisColor = function(){
        if(isDualAxis && !hasMNDonCategoryAxis){
          return colorPalette[0];
        }else{
          //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };
      
      chart.secondAxisColor = function(){
        if(TypeUtils.isExist(seriesData[0][1]) && !hasMNDonCategoryAxis){
          return axis2ColorPalette[seriesData[0][1].length-1];
        }else{
          //Jimmy/Nick/10/18/2012 we are telling axis to draw with default color
          return undefined;
        }
      };          
        
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      };
      
      /**
     * set/get effect manager
    */
    chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return chart;        
    };
     
      chart.x = function(_){
        if(!arguments.length){
          return x;
        }
        x= _;
        return this;
      };
      
      chart.y = function(_){
        if(!arguments.length)
          return y;
        y = _;
        return this;
      };
      
      chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
//      var dataTransform = function(data1, data2){
//        var stackedBarGroup = [];
//      // the number of bar in each group
//      var barGroupNumber =  data1[0].length;;
//      var transferredDataSet = data1;
//      var temp, temp2;
//      for(var j=0; j < barGroupNumber; j++){
//        var ds = [];
//        temp = 0, temp2 = 0
//        for(i=0; i< transferredDataSet.length; i++){
//          ds.push(transferredDataSet[i][j]);
//          if(transferredDataSet[i][j].val >= 0){
//            temp += transferredDataSet[i][j].val;
//          }else{
//            temp2 += transferredDataSet[i][j].val;
//          }
//        }
//        if(primaryAxisTopBoundary < temp){
//          primaryAxisTopBoundary = temp
//        }
//        if(primaryAxisBottomBoundary > temp2){
//          primaryAxisBottomBoundary = temp2
//        }
//        stackedBarGroup.push(ds);
//      }
//      if(TypeUtils.isExist(data2)){
//          barGroupNumber =  data2[0].length;;
//                transferredDataSet = data2;
//                for(var j=0; j < barGroupNumber; j++){
//                    temp = 0
//                    for(i=0; i< transferredDataSet.length; i++){
//                        stackedBarGroup[j].push(transferredDataSet[i][j]);
//                        temp += transferredDataSet[i][j].val;
//                    }
//                    if(secondaryAxisBoundary < temp){
//                        secondaryAxisBoundary = temp
//                    }
//                }
//            }
//      
//        return stackedBarGroup;
//      };
      
      var dataHandler = function(valueAxis1Data, valueAxis2Data, colorIndexArray){
        
        var positiveIndex = -1, negativeIndex = -1;
      positiveIndexes = [[],[]], negativeIndexes = [[],[]];
      
        primaryAxisTopBoundary = primaryAxisBottomBoundary = 0;
        secondaryAxisTopBoundary = secondaryAxisBottomBoundary = 0;
        
        var stackedBarGroupsData = [];
      // the number of bar in each group
      barGroupNumber =  valueAxis1Data[0].length;;
      var temp, temp2;
      for(var j=0; j < barGroupNumber; j++){
        var tempDataSetAxis1 = [], tempDataSetAxis2 = [];
        var oneGroupDataSet = [];
        temp = 0, temp2 = 0;
        positiveIndex = -1, negativeIndex = -1;
        for(var i=0; i< valueAxis1Data.length; i++){
          if(NumberUtils.isNoValue(valueAxis1Data[i][j].val)){
            valueAxis1Data[i][j].val = 0;
            valueAxis1Data[i][j].isNaN = true;
          }else{
            if(valueAxis1Data[i][j].val >= 0){
              temp += valueAxis1Data[i][j].val;
              positiveIndex = i;
            }else{
              temp2 += valueAxis1Data[i][j].val;
              negativeIndex = i;
            }
          }
          tempDataSetAxis1.push(valueAxis1Data[i][j]);
        }
        positiveIndexes[0].push(positiveIndex);
        negativeIndexes[0].push(negativeIndex);
        
        if(primaryAxisTopBoundary < temp){
          primaryAxisTopBoundary = temp;
        }
        if(primaryAxisBottomBoundary > temp2){
          primaryAxisBottomBoundary = temp2;
        }
        oneGroupDataSet.push(tempDataSetAxis1);
        
        
        if(TypeUtils.isExist(valueAxis2Data)){
          temp = 0, temp2 = 0;
          positiveIndex = -1, negativeIndex = -1;
          for(i=0; i< valueAxis2Data.length; i++){
            positiveIndex = 0, negativeIndex = -1;
            if(NumberUtils.isNoValue(valueAxis2Data[i][j].val)){
              valueAxis2Data[i][j].val = 0;
              valueAxis2Data[i][j].isNaN = true;
            }else{
              if(valueAxis2Data[i][j].val >= 0){
                temp += valueAxis2Data[i][j].val;
                positiveIndex = i;
              }else{
                temp2 += valueAxis2Data[i][j].val;
                negativeIndex = i;
              }
            }
            tempDataSetAxis2.push(valueAxis2Data[i][j]);
          }
          positiveIndexes[1].push(positiveIndex);
          negativeIndexes[1].push(negativeIndex);
          
          if(secondaryAxisTopBoundary < temp){
            secondaryAxisTopBoundary = temp
          }
          if(secondaryAxisBottomBoundary > temp2){
            secondaryAxisBottomBoundary = temp2;
          }
          oneGroupDataSet.push(tempDataSetAxis2);
        }
        stackedBarGroupsData.push(oneGroupDataSet);
      }
      
        return stackedBarGroupsData;
      };
    
      properties = manifest.props(null);
      return chart;
  };
  return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.stackedbar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.stackedbar',
      'name' : 'stacked bar',
      base : "sap.viz.modules.bar",
      'properties' : {
        'mode' : {
          'name' : 'mode',
          'supportedValueType' : 'List',
          'supportedValues' : [ 'comparison', 'percentage' ],
          'defaultValue' : 'comparison',
          'description' : 'Set dispaly mode of stacked bar.'
        }
      },
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_dual_stacked_bar',
    name : 'IDS_MULTIDUALSTACKEDBARCHART',
    base : 'viz/multi_dual_bar',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualPercentageStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_dual_stacked_bar',
    name : 'IDS_MULTIDUALPERCENTAGESTACKEDBARCHART',
    base : 'viz/multi_dual_stacked_bar',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_stacked_column',
    name : 'IDS_MULTISTACKEDVERTICALBARCHART',
    base : 'viz/multi_column',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{  
      multiplier:{
      max:1
    },
      axisLabels:{
      max:1
    },
    secondaryValues: {
      max: 0
    }
  },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },{
    targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_stacked_column',
    name : 'IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART',
    base : 'viz/multi_stacked_column',
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       max: 0
     },
      axisLabels:{
        max:1
      }
    },
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedverticalbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_stacked_bar',
    name : 'IDS_MULTISTACKEDBARCHART',
    base : 'viz/multi_bar',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{  
        multiplier:{
        max:1
      },
        axisLabels:{
        max:1
      },
      secondaryValues: {
        max: 0
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        /**
         * [jimmy/8/8/2012]each node in the path may have several entities
         * like main.plot, we may create several main.plots
         * (here the xycontainer), by using 'main.plot.xAxis'
         * here we actually means for xAxis in each main.plot
         * 
         * in the future, we may need support more complicated dependency resolving
         * like 'the 3rd xycontainer's xAxis', can be described
         * as main.plot[2].xAxis
         */
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },{ 
      targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPercentageStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_100_stacked_bar',
    name : 'IDS_MULTIPERCENTAGESTACKEDBARCHART',
    base : 'viz/multi_stacked_bar',
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       max: 0
     },
      axisLabels:{
        max:1
      }
    },
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.stackedbar',
                configure : {
                  properties : {
                    'mode' : 'percentage'
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Radar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup( Manifest, constants ) {
  var colors = {
    id : "regionColor",
    name : "Region Color",
    type : constants.Type.Dimension,
    min : 0,
    max : 2,
    aaIndex : 2,
    acceptMND : 2
  },
  
  shapes = {
    id : "regionShape",
    name : "Region Shape",
    type : constants.Type.Dimension,
    min : 0,
    max : 2,
    aaIndex : 3,
    acceptMND : 0
  },
  
  axes = {
    id : "radarAxes",
    name : "Radar Axes",
    type : constants.Type.Dimension,
    min : 1,
    max : 1,
    aaIndex : 1,
    acceptMND : 1
  },

  values = {
    id : "radarAxesValues",
    name : "Radar Axes Values",
    type : constants.Type.Measure,
    min : 1,
    max : constants.Constraints.INF,
    mgIndex : 1
  };

  var feeds = {
    id : "radar",
    feeds : [ colors, shapes, axes, values ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.0'},
[

],
function Setup(){
  var ShapeSeries = {
    sapShapes : function(){
      return d3.scale.ordinal().range(['circle', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection']);
    }
  };
  return ShapeSeries;
});sap.riv.module(
{
  qname : 'sap.viz.modules.radar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
}
],
function Setup( callouts, types, texts, evtHub, axis, colorRange, shapeRange, scaler, global, painter, langManager, tooltipDataHandler) {
  return function ( conf ) {
    var width = 0, height = 0, data = {}, properties = {}, angles,
        rescale, styles = {}, radar, valueaxis, yscale = d3.scale.linear(), 
        defaults, brush = {}, colorPalette = [], shapePalette = [], textRuler,
        dispatch, container = null, ranges, selections = {}, arrange, effects;
    
    dispatch = evtHub("selectData", "deselectData", 
      "showTooltip", "hideTooltip", "initialized");
    
    radar = {
      clazz : "spiderweb",
      node : null,
      color : colorRange.sap32(),
      shape : shapeRange.sapShapes(),
      radiusLength : 0,
      radius : d3.scale.linear(),
      anchor : { x : 0, y : 0 },
      radians : [],
      series : [],
      categories : [],
      caption : { 
        node : null,
        name : "category-axis-title",
        width : 0,
        height : 0
      },
      labels : {},
      locked : false,
    };
    
    valueaxis = {
      clazz : "valueaxis",
      anchor : { x : 0, y : 0 },
      ref : axis(global.get("sap.viz.modules.axis")),
      node : null,
      width : 0,
      height : 0
    };
    
    properties = {
      drawingEffect : "normal",
      polarGrid : { visible : true, color : "#d8d8d8" },
      polarAxis : { title : { visible : false, text : "Categories" } },
      valueAxis : { visible : true, title : { visible : false, text : "Value" } },
      line : { width : 2 },
      surface : { fill : { visible : true, transparency : 0.3 } },
      colorPalette : [],
      shapePalette : [],
      marker : { size : 6 },
      tooltip : { enabled : true },
      multichart : false
    };
    
    css = {
      background : "viz-plot-background",
      axisTitle : "viz-axis-title"
    },
    
    styles = {
      spacing : { hgap : 5, vgap : 5 },
      background : { css : { key : "viz-plot-background", def : null } },
      alignment : { horizontal : "center" },
      polaraxis : { 
        clazz : "polar_axis", 
        color : "#6c6c6c", 
        weight : "1px",
        labels : { css : { key : "viz-polar-axis-labels", def : null } },
        title : { css: { key : "viz-polar-axis-title", def : null } }
      },
      polargrid : { clazz : "polar_grid", color : "#d8d8d8", weight : "1px" },
      line : { clazz : "dataline" },
      valueaxis : { clazz : "value_axis", title : { css : { key : "viz-axis-title", def : null } }},
      marker : { clazz : "datapoint", css : { key : "viz-radar-marker", def : null },
                 stroke : "transparent" },
      labels : { color : "#333333", fontSize : "14px", fontWeight : "normal", fontFamily : "Arial" },
      tooltip : { radialOffset : 1 * 10  } // 1em
    };
    
    ranges = {
      dataline : {
        weight : [ 1, 7 ]
      },
      marker : {
        size : [ 4, 32 ]
      }
    };
    
    defaults = {
      options : $.extend( true, {}, properties ),
      styles : $.extend( true, {}, styles ),
      wording : {
        dash : " - ",
        dot : ".",
        slash : " / ",
        ellipsis : "...",
        series : "s",
        data : "d",
        measureIndex : " mi",
        and : " & "
      }
    };
    
    // only deal with domain values
    rescale = function () {
      var series = radar.series, min = arguments[0], max = arguments[1];
      // Measure values are always two-dimensional.
      radar.max = typeof max !== "undefined" ? max :
                  d3.max( d3.merge( d3.merge(series) ), function (_) { return _.val; } );
      radar.min = typeof min !== "undefined" ? min : 
                  d3.min( d3.merge( d3.merge(series) ), function (_) { return _.val; } );
      
      if ( radar.min === radar.max ) {
        if ( radar.min === 0 ) radar.max = 100;
        if ( radar.min < 0 ) radar.max = 0;
        if ( radar.min > 0 ) radar.min = 0;
      }
      
      if ( !radar.min || radar.min === "NaN" ) {
        radar.min = 0;
      }
      if ( !radar.max || radar.max === "NaN" ) {
        radar.max = 0;
      }
    };

    textRuler = function ( text, style ) {
      return texts.fastMeasure(text, style["font-size"] || style.fontSize,
        style["font-weight"] || style.fontWeight, style["font-family"] || style.fontFamily);
    };
    
    /* Layout algorithm. Arguments are preferred widths */
    arrange = function () {
      var sizes = arguments[0],
          axisWidth = sizes.valueaxis, lblW = sizes.lblW, lblH = sizes.lblH,
          caption = sizes.caption,
          pole = {}, w, r, adjust, bbox,
          hgap = styles.spacing.hgap, vgap = styles.spacing.vgap; 
      
      (function layout() {
        if ( lblH > 1/3 * height ) lblH = 0;
        if ( caption.height > 1/3 * height ) caption.height = 0;
        if ( caption.width > 2/3 * width ) caption.width = 0;  
        
        if ( width >= height ) {
          r = ( height - 2 * (lblH + 2 * vgap) - 
            (caption.height !== 0 ? caption.height + 2 * vgap : 0) ) / 2;
          w = 2 * r + 2 * (lblW + 2 * hgap) + axisWidth;
          if ( w > width ) {
            adjust = w - width;
            r = ( height - adjust - 2 * (lblH + 2 * vgap) - 
              (caption.height !== 0 ? caption.height + 2 * vgap : 0) ) / 2;
          }
        } else {
          r = ( width - 2 * (lblW + 2 * hgap) - axisWidth ) / 2;
        }
        
        if ( lblW > r || r <= 0 ) {
          lblW = 0, lblH = 0; 
          caption.width = 0, caption.height = 0; 
          r = layout();
          
          if ( axisWidth > r || r < 0 ) {
            axisWidth = 0;
            r = layout();
            if ( width >= height ) {
              if ( r < height / 2 ) r = height / 2, vgap = 0;
            } else {
              if ( r < width / 2 ) r = width / 2, hgap = 0;
            }
          }
        }
        return r;
      })();
      
      bbox = { // bounding box
        width : axisWidth + 2 * r + 4 * hgap + 2 * lblW,
        height : 2 * ( lblH + r ) + 4 * vgap + 
          (caption.height !== 0 ? caption.height + 2 * vgap : 0)
      };
      
      radar.radiusLength = r;
      valueaxis.width = axisWidth;
      valueaxis.anchor.x = 0;
      valueaxis.anchor.y = lblH + 2 * vgap;
      radar.caption.width = caption.width;
      radar.caption.height = caption.height;
      pole.x = axisWidth + lblW + r + hgap * 2;
      pole.y = lblH + r + vgap * 2;
      caption.x = pole.x;
      caption.y = pole.y + r + lblH + 2 * vgap + caption.height / 2;
      
      var xoffset = 0, yoffset = 0;
      if ( axisWidth ) {
        valueaxis.ref.gridlineLength(pole.x - axisWidth);
        if ( width > height ) {
          xoffset = width / 2 - bbox.width / 2;
          valueaxis.anchor.x += xoffset;
          pole.x += xoffset;
          caption.x += xoffset;
        }
      } else {
        if ( width > height ) {
          xoffset = width / 2 - pole.x;
          pole.x += xoffset;
          caption.x += xoffset;
        } 
      }
      
      //radar.caption.node.attr("transform", "translate(" + caption.x + "," + caption.y + ")");
      radar.caption.node.attr("x", caption.x);
      radar.caption.node.attr("y", caption.y);
      valueaxis.node.attr("transform", "translate(" + 
        valueaxis.anchor.x + "," + valueaxis.anchor.y + ")");
      radar.node.attr("transform", "translate(" + pole.x + "," + pole.y + ")");
      radar.pole = pole;
      radar.labels.width = lblW;
      radar.labels.height = lblH;
    };
    
    /*
     * Creates scale function/object for angular computation.
     * 
     * @param nulls - indexes of empty elements
     * @param N - numbers of non-empty elements
     * @param cardinal - numbers of all elements
     */
    angles = function ( nulls, N, cardinal ) {
      var scale, domain = [], intervals = [], radian = 0, i;
      if ( !nulls.length ) {
        return d3.scale.linear()
          .domain([ 0, cardinal ])
          .range([ 0, 2 * Math.PI ]);
      } else {
        //if ( nulls.length > N ) callouts.error("Invalid argument.");
        for ( i = 0; i < cardinal; i++ ) {
          domain.push(i);
          intervals.push(i / cardinal * 2 * Math.PI);
        }
        for ( i = nulls.length - 1; i >= 0; i-- ) {
          intervals.splice(nulls[i].order, 1);
        }
        return d3.scale.ordinal()
              .domain(domain)
              .range(intervals);
      }
    };
    
    function chart( selection ) {
      selection.each(function (d) {
        var parent = d3.select(this), prefix = defaults.wording;
        valueaxis.node = null;
        radar.node = null;
        radar.radiusLength = 0;
        container = parent;
        
        parent.select(prefix.dot.concat(valueaxis.clazz)).remove();
        parent.select(prefix.dot.concat(radar.clazz)).remove();
        parent.select( prefix.dot + radar.caption.name ).remove();
        
        valueaxis.node = parent.append("g").attr("class", valueaxis.clazz);
        radar.node = parent.append("g").attr("class", radar.clazz);
        radar.caption.node = parent.append("text").attr("class", radar.caption.name);
        
        styles.valueaxis.title.css.def = conf.style(styles.valueaxis.title.css.key);
        styles.marker.css.def = conf.style(styles.marker.css.key);
        styles.polaraxis.labels.css.def = conf.style(styles.polaraxis.labels.css.key);
        
        var cardinal, lblW, lblH, r, i, j, pole = {},
            labels = radar.categories, series = radar.series,
            hgap = styles.spacing.hgap, vgap = styles.spacing.vgap, 
            radians = radar.radians;
        
        var ls = []; // Labels array
        for ( i = 0; i < labels.length; i++ ) {
          ls.push( textRuler(labels[i], styles.polaraxis.labels.css.def) );
        }
        lblW = d3.max( ls, function (_) { return _.width; } );
        lblH = d3.max( ls, function (_) { return _.height; } );

        yscale.domain([radar.min, radar.max])
              .range([200, 0]); // fake radius length
        scaler.perfect(yscale);
        
        valueaxis.ref.scale(yscale).properties({
          label : { visible : true },
          title : {
            visible : properties.valueAxis.title.visible,
            text : properties.valueAxis.title.text
          },
          type : "value",
          position : "left",
          gridline : {
            visible : true,
            showFirstLine : true,
            showLastLine : true,
            type : "dotted"
          }
        });
        
        valueaxis.width = properties.valueAxis.visible ? valueaxis.ref.getPreferredSize().width : 0;
        if ( valueaxis.width > 0.5 * width ) valueaxis.width = 0;
        
        arrange({ 
          valueaxis : valueaxis.width, 
          lblW : lblW,
          lblH : lblH, 
          caption : {
            width : textRuler( properties.polarAxis.title.visible ? 
              properties.polarAxis.title.text : 0, styles.polaraxis.labels.css.def ).width,
            height : textRuler( properties.polarAxis.title.visible ? 
              properties.polarAxis.title.text : 0, styles.polaraxis.labels.css.def).height,
          }});
        
        if ( properties.polarAxis.title.visible && radar.caption.width 
             && radar.caption.height ) {
          radar.caption.node
            .text(properties.polarAxis.title.text)
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .style("font-family", styles.valueaxis.title.css.def["font-family"])
            .style("font-size", styles.valueaxis.title.css.def["font-size"])
            .style("font-weight", styles.valueaxis.title.css.def["font-weight"])
            .style("fill", styles.valueaxis.title.css.def["fill"]);
        }
        
        yscale.range([ radar.radiusLength, 0 ]); // Re-calculate scale
        scaler.perfect(yscale);
        
        valueaxis.ref.scale(yscale);
        if ( properties.valueAxis.visible && valueaxis.width ) {
          valueaxis.node.call(valueaxis.ref);
        }
        
        var line = radar.node.append("g").attr("class", "polaraxes-group")
                  .selectAll(styles.polaraxis.clazz).data(labels);
        // Create nodes upon new data injected
        line.enter()
          .append("g")
          .attr("transform", function (d , i) {
            var rotation = i / labels.length * 360 - 90;
            if ( rotation > -180 && rotation < 180 ) {
              radians.push({ axisIdx : i,
                radian : -1 * rotation * Math.PI / 180 });
            } else { // rotation > 180 and rotation < 270
              radians.push({ axisIdx : i,
                radian : (360 - rotation) * Math.PI / 180 });
            }
            return "rotate("+ rotation +") translate("+ radar.radiusLength +")";
          });
        line.append("svg:line")
          .attr("x2", -1 * radar.radiusLength)
          .style("stroke", effects.register({
            drawingEffect: "normal",
            fillColor: styles.polaraxis.color
          }))
          .style("stroke-width", styles.polaraxis.weight)
          .style("fill", "transparent");
        
        radians.sort( function (a, b) { return a.radian - b.radian; } );
        
        var angle; // Polar angle
        
        if ( radar.labels.width && radar.labels.height ) {
          // Plot category labels
          line.append("g").attr("class", "categoryLabel")
            .append("text")
            .text(function (d, i) { return d; })
            .attr("text-anchor", "middle")
            .attr("alignment-baseline", "middle")
            .attr("transform", function (d, i) {
              angle = i / labels.length * 360 - 90;
              if ( angle % 90 === 0 ) {
                if ( angle === -90 || angle === 270 ) {
                  return "rotate(90) translate(0," + (-1 * ( 
                    textRuler(d, styles.polaraxis.labels.css.def).height / 2 + vgap ) ) +")";
                } else if ( angle === 0 ) {
                  return "translate("+ ( textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) +")";
                } else if ( angle === 180 ) {
                  return "rotate(180) translate(" + ( -1 * ( 
                    textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) ) +")";
                } else {
                  return "rotate(-90) translate(0," + ( 
                    textRuler(d, styles.polaraxis.labels.css.def).height / 2 + vgap ) +")";
                }
              }
              if ( (angle > -90 && angle < 0) || (angle > 0 && angle < 90) ) {
                return "rotate("+ (-1 * angle) +") translate(" + 
                  ( textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap ) +",0)";
              } else {
                return "rotate("+ (-1 * angle) +") translate(" +
                  ( -1 * (textRuler(d, styles.polaraxis.labels.css.def).width / 2 + hgap) ) +",0)";
              }
            })
            .style("font-family", styles.polaraxis.labels.css.def["font-family"])
            .style("font-size", styles.polaraxis.labels.css.def["font-size"])
            .style("fill", effects.register({
              drawingEffect: "normal",
              fillColor: styles.labels.color
            }));        
        }
        
        if ( !radar.min && !radar.max ) {
          dispatch.initialized();
          return;
        }
        
        // Reset value scales to desired orders
        yscale.domain([ radar.max, radar.min ]);
        scaler.perfect(yscale);
        
        cardinal  = radar.categories.length;
        
        // Default polar angle scale
        angle = angles([], cardinal, cardinal);
        
        // Path generator of line data on the radar plate
        var polarLine = d3.svg.line.radial()
          .interpolate("linear")
          .radius(yscale)
          .angle(function (d, i) { return angle(i); });

        var tickValues = yscale.ticks( yscale.tickNum ), polarTicks = [], circle = [];
        for ( i = 0; i < tickValues.length; i++ ) {
          circle = [];
          for ( j = 0; j < labels.length; j++ ) {
            circle.push(tickValues[i]);
          }
          polarTicks.push(circle);
        }

        if ( properties.polarGrid.visible ) {
          radar.node.append("g").attr("class", "polargrid-group")
            .selectAll( "." + styles.polargrid.clazz )
            .data( polarTicks )
          .enter()
            .append("path")
            .attr("class", styles.polargrid.childClazz)
            .attr("d", function (d) { return polarLine(d) + "Z"; })
            .style("fill", "none")
            .style("stroke", effects.register({
              drawingEffect : "normal",
              fillColor : styles.polargrid.color}))
            .style("stroke-width", styles.polargrid.weight);
        }
        
        // Plot actual data
        radar.node.append("g")
          .attr("class", "dataline-group")
          .selectAll( "." + styles.line.clazz )
          .data(series)
        .enter()
          .append("path")
          .attr("class", function (d, i) {
            return prefix.series.concat(i + " ").concat(styles.line.clazz);
           })
          .attr("d", function (d, i) { // Each d is a data series
            if ( !d.length ) return;
            var numbers = [];
            angle = angles([], cardinal, cardinal);
            for ( var n = 0; n < d.length; n++ ) numbers.push(d[n].val);
            if ( numbers.length !== radar.categories.length ) {
              angle = angles(chart.vacants[i], numbers.length, cardinal);
            }
            return polarLine(numbers) + "Z"; 
          })
          .style("fill", function (d, i) {
            if ( !d.length ) return; 
            if ( properties.surface.fill.visible ) {
              return effects.register({
                drawingEffect: "normal",
                fillColor: d[0].color
              });
            }
          })
          .style("fill-opacity", function (d, i) {
            if ( properties.surface.fill.visible ) return properties.surface.fill.transparency;
            else return 0;
          })
          .style("stroke", function (d, i) { 
            if ( !d.length ) return;
            return effects.register({
              drawingEffect: "normal",
              fillColor: d[0].color}); 
          })
          .style("stroke-width", properties.line.width > ranges.dataline.weight[1] || 
             properties.line.width < ranges.dataline.weight[0] ? 
             defaults.options.line.width : properties.line.width
          );
        
        // draw markers
        var markerContainer = radar.node.append("g")
          .attr("class", "marker-container")
          .selectAll("." + styles.marker.clazz)
          .data(series).enter().append("g");

        markerContainer.attr("class", "marker-group").each(function ( datum, index ) { 
          // for each series
          var nulls = chart.vacants[index], radians = [];
          $.each(radar.categories, function ( i, d ) { 
            radians.push(i / cardinal * 2 * Math.PI - 0.5 * Math.PI);
          });
          for ( var i = nulls.length - 1; i >= 0; i-- ) {
            radians.splice(nulls[i].order, 1);
          }
          
          d3.select(this).append("g")
            .attr("class", "marker-series")
            .selectAll("." + styles.marker.clazz)
            .data(datum)
          .enter()
            .append("path")
            .attr("class", function (d, i) {
              return (
                prefix.series + index + " " +       // series index 
                prefix.data + d.order + " " +       // data index 
                styles.marker.clazz +               // class
                prefix.measureIndex + d.ctx.path.mi // measure index
              );
            })
            .attr("transform", function (d, i) {
              var x = yscale(d.val) * Math.cos(radians[i]);
                  y = yscale(d.val) * Math.sin(radians[i]);
              return "translate("+ x + ", " + y + ") rotate(0)";
            })
            .attr("d", function (d, i) {
              return painter.createMarkerData({
                type : d.shape,
                rx : styles.marker.size / 2,
                ry : styles.marker.size / 2,
                borderWidth : 2
              });
            })
            .style("fill", function (d) {
              var parameters = {
                drawingEffect : properties.drawingEffect,
                graphType : d.shape,
                fillColor : d.color,
                direction : 'vertical',
              };
              return effects.register(parameters);
            });
          });
        
        // create place holder elements for empty values
        var phantomMarker = radar.node.append("g")
          .attr("class", "phantom-marker-group")
          .selectAll(".phantom-marker-series").data(chart.vacants)
          .enter().append("g");
          
        phantomMarker
          .attr("class", "phantom-marker-series")
          .each(function ( datum, index ) {
            d3.select(this)
              .selectAll(".phantom-marker")
              .data(datum)
            .enter()
              .append("path")
              .attr("class", function (d, i) {
                return (
                  prefix.series + index + " " +       // series index 
                  prefix.data + d.order + " " +       // data index 
                  prefix.measureIndex + d.ctx.path.mi // measure index
                );
              })
              .style("fill", "none");
          });
        
        dispatch.initialized();
      });
    }
    
    chart.data = function (_) {
      if ( !arguments.length ) return data;
      data = _, radar.series = [], radar.categories = [],
      radar.radians = [],
      shapePalette = [], colorPalette = [], chart.vacants = [];
      
      // Data processing is effective upon the
      // completion of various customizations.
      if ( !chart.caliberated ) return chart;
      
      // Analysis Axis 1 and one Measure Group 
      // are required to be fed to radar chart.
      var aa1 = data.getAnalysisAxisDataByIdx(0).values,
          mg = data.getMeasureValuesGroupDataByIdx(0).values,
          aa2 = data.getAnalysisAxisDataByIdx(1),
          aa3 = data.getAnalysisAxisDataByIdx(2),
          series = [], depth, cardinal, layer, hierarchy = [],
          feedings = {
            aa2 : { fed : aa2 !== null && aa2.values.length ? true : false, axesFed : false, hasMND : false },
            aa3 : { fed : aa3 !== null && aa3.values.length ? true : false, axesFed : false, hasMND : false }
          }, i, j, x;
      
      radar.mndized = aa1[0].type && aa1[0].type.toLowerCase() === "mnd" ? true : false;
      
      // Extracts dimension labels
      for ( i = 0; i < aa1.length; i++ ) {
        layer = [];
        for ( j = 0; j < aa1[i].rows.length; j++ ) {
          layer.push(aa1[i].rows[j].val);
        }
        hierarchy.push(layer);
      }
      
      depth = hierarchy.length, cardinal = hierarchy[0].length;
      if ( depth === 1 ) {
        for ( i = 0; i < cardinal; i++ ) { 
          radar.categories.push(hierarchy[0][i]);
        }
      } else { // splice layered dimension labels
        var column = [];
        for ( i = 0; i < cardinal; i++ ) {
          for ( j = 0; j < depth; j++ ) column.push(hierarchy[j][i]);
          radar.categories.push(column.join(defaults.wording.slash));
          column = [];
        }
      }

      cardinal = mg[0].rows[0].length;

      // deal with two-dimensional data
      if ( radar.mndized ) {
        /*
         * In case of AA1 is MNDized, each of the 
         * analysis axis has the chance of getting 
         * fed by one, two or not any axes at all.
         */
        if ( !feedings.aa2.fed && !feedings.aa3.fed ) {
          colorPalette.push(radar.color(0));
          shapePalette.push(radar.shape(0));
        }
        
        // AA2's always bound to rows in cross-table.
        if ( feedings.aa2.fed ) {
          for ( i = 0; i < aa2.values[0].rows.length; i++ ) {
            colorPalette.push(radar.color(i));
          }
          if ( !feedings.aa3.fed ) shapePalette.push(radar.shape(0));
        }
        
        // AA3's usually bound to columns in cross-table.
        if ( feedings.aa3.fed ) {
          for ( i = 0; i < aa3.values[0].rows.length; i++ ) {
            shapePalette.push(radar.shape(i));
          }
          if ( !feedings.aa2.fed ) colorPalette.push(radar.color(0));
        }
        
        for ( i = 0; i < mg.length; i++ ) {
          for ( j = 0; j < mg[i].rows.length; j++ ) {
            for ( x = 0; x < cardinal; x++ ) {
              mg[i].rows[j][x].color = colorPalette[x] || radar.color(0);
              if ( feedings.aa2.fed ) {
                mg[i].rows[j][x].shape = shapePalette[j] || radar.shape(0);
              } else {
                mg[i].rows[j][x].shape = shapePalette[x] || radar.shape(0);
              }
            }
          }
        }
        
        // Transform measure group into series.
        var entry, temp = [], item = [];
        for ( i = 0; i < mg[0].rows.length; i++ ) {
          entry = [];
          for ( j = 0; j < mg.length; j++ ) {
            entry.push(mg[j].rows[i]);
          }
          temp.push(entry);
        }

        for ( i = 0; i < temp.length; i++ ) {
          // process each same row of cross tables
          for ( x = 0; x < cardinal; x++ ) {
            // loops against columns
            for ( j = 0; j < temp[i].length; j++, nulls = [] ) {
              item.push(temp[i][j][x]);
            }
            series.push(item);
            item = [];
          }
        }
        
        $.each(series, function ( index, item ) {
          var values = item, nulls = [];
          for ( var i = 0; i < values.length; i++ ) {
            values[i].order = i; // actual data index
            if ( values[i].val === null ) nulls.push(values[i]);
          }
          for ( i = values.length - 1; i >= 0; i-- ) {
            if ( values[i].val === null ) values.splice(i, 1);
          }
          chart.vacants.push(nulls);
        });
        
        if ( properties.polarAxis.title.text === "Categories" ) { // not customized
          properties.polarAxis.title.text = langManager.get('IDS_DEFAULTMND');
        }
      } else {
        if ( feedings.aa2.fed ) {
          for ( i = 0; i < aa2.values.length; i++ ) {
            if ( aa2.values[i].type && 
                 aa2.values[i].type.toLowerCase() === "mnd" ) {
              feedings.aa2.hasMND = true;
            }
          }
          if ( feedings.aa2.hasMND ) {
            if ( aa2.values.length >= 2 ) feedings.aa2.axesFed = true;
            else feedings.aa2.axesFed = false;
          } else {
            feedings.aa2.axesFed = true;
          }
        }
        
        if ( feedings.aa3.fed ) {
          for ( i = 0; i < aa3.values.length; i++ ) {
            if ( aa3.values[i].type && 
                 aa3.values[i].type.toLowerCase() === "mnd" ) {
              feedings.aa3.hasMND = true;
            }
          }
          if ( feedings.aa3.hasMND ) {
            if ( aa3.values.length >= 2 ) feedings.aa3.axesFed = true;
            else feedings.aa3.axesFed = false;
          } else {
            feedings.aa3.axesFed = true;
          }
        }
  
        // Extract series values from measure groups
        var colorCursor = 0, shapeCursor = 0, x,
            aa2mndized = feedings.aa2.hasMND && !feedings.aa2.axesFed,
            aa3mndized = feedings.aa3.hasMND && !feedings.aa3.axesFed,
            nulls = [];
            
        for ( i = 0; i < mg.length; i++ ) {
          if ( aa2mndized ) colorPalette.push(radar.color(i));
          if ( aa3mndized ) shapePalette.push(radar.shape(i));
          
          for ( j = 0; j < mg[i].rows.length; j++, nulls = []) {
            // filter out null values
            for ( x = 0; x < mg[i].rows[j].length; x++ ) {
              if ( mg[i].rows[j][x].val === null ) {
                nulls.push(mg[i].rows[j][x]);
              }
              mg[i].rows[j][x].order = x;
            }
            series.push(mg[i].rows[j]);
            chart.vacants.push(nulls);
            
            if ( feedings.aa2.fed ) {
              if ( aa2mndized ) {
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(i);
                }
              } else if ( feedings.aa2.hasMND && feedings.aa2.axesFed ) {
                colorCursor++;
                colorPalette.push(radar.color(colorCursor));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(colorCursor);
                }
              } else {
                colorPalette.push(radar.color(j));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].color = radar.color(j);
                }
              }
            } else {
              // Default value in case aa2 is fed nothing
              colorPalette.push(radar.color(0));
              for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                mg[i].rows[j][x].color = radar.color(0);
              }
            }
            if ( feedings.aa3.fed ) {
              if ( aa3mndized ) {
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].shape = radar.shape(i);
                }
              } else if ( feedings.aa3.hasMND && feedings.aa3.axesFed ) {
                shapeCursor++;
                shapePalette.push(radar.shape(shapeCursor));
                for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                  mg[i].rows[j][x].shape = radar.shape(shapeCursor);
                }
              } else {
                if ( feedings.aa2.fed ) {
                  if ( feedings.aa2.hasMND ) {
                    shapePalette.push(radar.shape(j));
                    for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                      mg[i].rows[j][x].shape = radar.shape(j);
                    }
                  } else {
                    for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                      shapePalette.push(radar.shape(x));
                      mg[i].rows[j][x].shape = radar.shape(x);
                    }
                  }
                }

              }
            } else {
              shapePalette.push(radar.shape(0));
              for ( x = 0; x < mg[i].rows[j].length; x++ ) {
                mg[i].rows[j][x].shape = radar.shape(0);
              }
            }
          }
        }
        for ( i = 0; i < series.length; i++ ) {
          for ( j = series[i].length - 1; j >= 0; j-- ) {
            for ( var n = 0; n < chart.vacants[i].length; n++ ) {
              if ( chart.vacants[i][n].order === j ) series[i].splice(j, 1);
            }
          }
        }
        if ( properties.polarAxis.title.text === "Categories" ) { // not customized
          properties.polarAxis.title.text = aa1[0].col.val;
        }
      }
      if ( properties.valueAxis.title.text === "Value" ) {
        var measures = [];
        for ( i = 0; i < mg.length; i++ ) measures.push(mg[i].col);
        properties.valueAxis.title.text = measures.join(defaults.wording.and);
      }
      
      radar.series = series;
      radar.feedings = feedings;
      if ( !radar.locked ) rescale();
      
      return chart;
    };
    
    chart.primaryDataRange = function (_) {
      if ( !arguments.length ) return { 
        min : radar.min, max : radar.max 
      };
      radar.min = _.min;
      radar.max = _.max;
      rescale(_.min, _.max);
      radar.locked = true;
      return chart;
    };
    
    chart.colorPalette = function (_) {
      if ( !arguments.length ) return colorPalette;
      colorPalette = _;
      return chart;
    };
    
    chart.shapes = function (_) {
      if ( !arguments.length ) return shapePalette;
      shapePalette = _;
      return chart;
    };
    
    chart.dispatch = function (_) {
      if ( !arguments.length ) return dispatch;
      dispatch = _;
      return chart;
    };
    
    chart.properties = function (_) {
      if ( !arguments.length ) return properties;
      properties = conf.props(_);
      getCSSStyle();
      if ( properties.colorPalette.length ) radar.color.range(properties.colorPalette);
      if ( properties.shapePalette.length ) radar.shape.range(properties.shapePalette);
      styles.marker.size = properties.marker.size;
      if ( styles.marker.size > ranges.marker.size[1] ||  styles.marker.size < ranges.marker.size[0]) styles.marker.size =  6;
      styles.polargrid.color = properties.polarGrid.color;
      chart.caliberated = true;
      chart.data(data);
      return chart;
    };
    
    chart.width = function (_) {
      if ( !arguments.length ) return width;
      var changed = width === _ ? false : true;
      width = _;
      if ( types.isEmptyObject(data) && height ) chart.data(data);
      if ( changed && !radar.locked  ) rescale();
      return chart;
    };
    
    chart.height = function (_) {
      if ( !arguments.length ) return height;
      var changed = height === _ ? false : true;
      height = _;
      if ( types.isEmptyObject(data) && width ) chart.data(data);
      if ( changed && !radar.locked ) rescale();
      return chart;
    };
    
    chart.size = function (_) {
      if ( !arguments.length ) return {
        width : width, height : height
      };
      width = _;
      height = _;
      if ( types.isEmptyObject(data) && width && height ) chart.data(data);
      if ( width && height && radar.series.length ) rescale();
      return chart;
    };

    chart.effectManager = function (_) {
      if ( !arguments.length ) return effects;
      effects = _;
      valueaxis.ref.effectManager(effects);
      return chart;
    };
    
    chart.parent = function (_) {
      if ( !arguments.length ) return container;
      container = _;
      return chart;
    };
    
    chart.hoverOnPoint = function ( cursor ) {
      var pole = radar.pole, theta, r,
          prefix = defaults.wording,
          radians = radar.radians,
          point = {
            x : cursor.x - pole.x,
            y : pole.y - cursor.y
          };
      r = Math.sqrt( Math.pow(point.x, 2) + Math.pow(point.y, 2) );
      
      // out of radius range
      if ( r > radar.radiusLength ) {
        if ( typeof chart.last !== "undefined" && 
            (types.isEmptyObject(selections)) ) {
          brush.straight(prefix.dot + prefix.data + chart.last, true);
        }
        // hide tool tip
        if ( properties.tooltip.enabled ) radar.prompt();
        return;
      }
      
      // range is (-PI, PI]
      theta = Math.atan2( point.y, point.x );
      
      // search for the target interval that the angle locates in
      var bisect = d3.bisector(function (d) { return d.radian; }).right,
          intv = bisect(radians, theta), mid, left, right, target;          
      
      if ( intv === 0 ) {
        left = radians.length - 1, right = 0;
        if ( radians[left].radian === Math.PI ) {
          mid = -1 * (Math.PI + Math.abs(radians[right].radian)) / 2;
          target = theta > mid ? target = radians[right].axisIdx : 
                   target = radians[left].axisIdx;
        } else {
          target = radians[0].axisIdx;
        }
      } else if ( intv === radians.length ) {
        target = radians[radians.length - 1].axisIdx;
      } else {
        left = intv - 1, right = intv;
        mid = (radians[left].radian + radians[right].radian) / 2;
        target = theta > mid ? target = radians[right].axisIdx : 
                 target = radians[left].axisIdx;
      }
      
      if ( typeof chart.last !== "undefined" && chart.last !== target ) {
        brush.straight(prefix.dot + prefix.data + chart.last, true);
      }
      
      brush.focus(prefix.dot + prefix.data + target, true);
      
      if ( !types.isEmptyObject(selections) ) {
        brush.dim(prefix.dot + prefix.data + target, true);
        for ( var key in selections ) {
          for ( var i = 0; i < selections[key].length; i++ )
            brush.highlight(selections[key]);
        }
      }
      
      // prompt tool tip if allowed
      if ( properties.tooltip.enabled ) radar.prompt(target);
      
      // Memorize the last processed axis index
      chart.last = target;
    };
    
    chart.clear = function () {
      if ( !arguments[0] ) {
        brush.straight().bright();
        selections = {};
      } else {
        brush.dim();
      }
    };
    
    chart.highlight = function ( objects ) {
      if ( !radar.min && !radar.max ) return;
      
      var target = objects instanceof Array ? objects : [ objects ], query = /[sS][0-9]+/, key;
      brush.highlight(target);
      
      for ( var i = 0, exists = false; i < target.length; i++, exists = false ) {
        key = target[i].className.baseVal.match(query)[0];
        if ( selections[key] ) {
          for ( var j = 0; j < selections[key].length; j++ ) {
            if ( selections[key][j] === target[i] ) exists = true;
          }
          if ( !exists ) selections[key].push(target[i]);
        } else {
          selections[key] = [];
          selections[key].push(target[i]);
        }
      }
      
      var cardinal, seriesOrder;
      for ( var n in selections ) {
        if ( selections.hasOwnProperty(n) ) {
          seriesOrder = n.substr(1);
          cardinal = radar.series[seriesOrder].length;
          highlight(n, selections[n], cardinal);
        }
      }
    };
    
    function highlight( series, datapoints, cardinal ) {
      if ( datapoints.length === cardinal ) {
        brush.highlight2(defaults.wording.dot + series, true);
      } else {
        brush.highlight(datapoints);
      }
    }
    
    chart.unhighlight = function ( object ) {
      var target = object instanceof Array ? object : [object];
      brush.straight(target).dim(target);
      
      $.each(target, function ( index, item ) {
        var series = item.className.baseVal.match(/[sS][0-9]+/)[0];
      
        for ( var key in selections ) {
          for ( var i = 0; i < selections[key].length; i++ ) {
            if ( selections[key][i] === object ) {
              selections[key].splice(i, 1); break;
            }
          }
        }
        brush.straight2(defaults.wording.dot + series)
             .dim(defaults.wording.dot + series);
      });
    };
    
    chart.blurOut = function () {
      dispatch.hideTooltip();
    };
    
    radar.prompt = function () {
      if ( typeof arguments[0] === "undefined" ) { dispatch.hideTooltip(); return; }
      
      var volume, item = {}, elements, target = arguments[0], 
          prefix = defaults.wording, anchor = {}, angle = 0,
          r = radar.radiusLength - styles.tooltip.radialOffset, 
          translation = container[0][0].getTransformToElement(container[0][0].ownerSVGElement),
          i;
      
      for ( i = 0; i < radar.radians.length; i++ ) {
        if ( radar.radians[i].axisIdx === target ) {
          angle = radar.radians[i].radian; break;
        }
      }
      
      anchor.x = r * Math.cos(angle);
      anchor.y = r * Math.sin(angle);
      orient = angle <= 0.5 * Math.PI && angle > -0.5 * Math.PI ? "left" : "right";
      
      volume = {
        body : [],
        plotArea : {
          x : translation.e,
          y : translation.f,
          width : width,
          height : height
        },
        point : { // where tool tip arrow points to
          x : anchor.x + radar.pole.x + translation.e,
          y : anchor.y < 0 ? 
              Math.abs(anchor.y) + radar.pole.y + translation.f : 
              radar.pole.y - anchor.y + translation.f, 
          orientation : orient,
          angle : angle,
          range : {
            x : angle === 0.5 * Math.PI || angle === -0.5 * Math.PI ? 0 : 
                Math.abs(anchor.x),
            y : angle === 0 || angle === Math.PI || angle === -1 * Math.PI ? 0 : 
                Math.abs(anchor.y)
          }
        },
        footer : []
      };

      var aa1 = data.getAnalysisAxisDataByIdx(0).values,
          aa2 = radar.feedings.aa2.fed ? data.getAnalysisAxisDataByIdx(1).values : null,
          aa3 = radar.feedings.aa3.fed ? data.getAnalysisAxisDataByIdx(2).values : null,
          mg = data.getMeasureValuesGroupDataByIdx(0).values;
      
      elements = radar.node.selectAll("." + prefix.data + target);
      var col, row, cardinal, index, i, j, temp;
      
      if ( radar.mndized ) {
        item = { name : radar.categories[target], val : [] };
        
        // normal case
        elements.each(function (d) {
          var entry = {};
          entry.color = d.color;
          entry.shape = d.shape;
          entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
          
          if ( !radar.feedings.aa2.fed && !radar.feedings.aa3.fed ) {
            entry.label = null;
          }
          
          if ( radar.feedings.aa2.fed ) {
            index = properties.multichart ? d.ctx.path.dii_a2 : d.ctx.path.dii_a1;
            for ( i = 0, temp = []; i < aa2.length; i++ ) {
              temp.push(aa2[i].rows[index].val);
            }
            col = temp.join(prefix.slash);
            if ( !radar.feedings.aa3.fed ) entry.label = col;
          }
          
          if ( radar.feedings.aa3.fed ) {
            index = radar.feedings.aa2.fed ? d.ctx.path.dii_a2 : d.ctx.path.dii_a1;
            for ( i = 0, temp = []; i < aa3.length; i++ ) {
              temp.push(aa3[i].rows[index].val);
            }
            if ( radar.feedings.aa2.fed ) {
              row = temp.join(prefix.slash);
              entry.label = col.concat(prefix.slash + row);
            } else {
              col = temp.join(prefix.slash);
              entry.label = col;
            }
          }
          
          item.val.push(entry);
        });
        
        volume.body.push(item);
      } else {
        if ( !radar.feedings.aa2.axesFed && !radar.feedings.aa3.axesFed ) {
          elements.each(function (d) {
            var entry = {}, item = { name : mg[d.ctx.path.mi].col, val : [] };
            entry.color = d.color;
            entry.shape = d.shape;
            entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
            entry.label = null;
            
            item.val.push(entry);
            volume.body.push(item);
          });
        } else {
          for ( var x = 0; x < mg.length; x++ ) {
            item = { name : mg[x].col, val : [] };
            
            elements.each(function (d) {
              var entry = {};
              entry.color = d.color;
              entry.shape = d.shape;
              entry.value = d.val !== null ? d.val : langManager.get('IDS_ISNOVALUE');
              
              var clazz = d3.select(this)[0][0].className.baseVal
                .match(/\smi[0-9]+/);
              if ( clazz !== null ) clazz = clazz[0];
              else return;
              
              temp = [];
              if ( clazz === (prefix.measureIndex + x) ) {
                var aa = aa2 !== null ? aa2 : aa3;
                for ( i = 0; i < aa.length; i++ ) {
                  if ( d.ctx.path.dii_a2 > aa[i].rows.length - 1 ) {
                    d.ctx.path.dii_a2 = aa[i].rows.length - 1;
                  }
                  temp.push(aa[i].rows[d.ctx.path.dii_a2].val);
                }
                entry.label = temp.join(prefix.slash);
              } else return;
              item.val.push(entry);
            });
            volume.body.push(item);
          }
        }
        
        var dimension = {};
        for ( i = 0; i < aa1.length; i++ ) {
          dimension = {};
          dimension.label = aa1[i].col.val;
          dimension.value = aa1[i].rows[target].val;
          volume.footer.push(dimension);
        }
      }
      dispatch.showTooltip(tooltipDataHandler.formatTooltipData(volume));
    };
    
    brush.params = { // UX defined
      stroke : {
        invisible : "transparent",
        natural : conf.style(css.background).fill,
        heavy : "#333333"
      },
      
      weight : {
        natural : properties.line.width,
        heavy : "2px"
      },
      
      opacity : {
        natural : 1,
        low : 0.2
      }
    };
    
    /*
     * Functions of the effects library are
     * state-less. Each of the function accepts
     * one of the two types of arguments: 
     * DOM nodes in array, or
     * CSS class with an optional boolean field
     * in determining whether all elements with
     * the given CSS class will be selected.
     */
    brush.dim = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) { // select everything
        radar.node.selectAll(prefix.dot + styles.line.clazz)
          .attr("opacity", brush.params.opacity.low);
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .attr("opacity", brush.params.opacity.low);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .attr("opacity", brush.params.opacity.low);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .attr("opacity", brush.params.opacity.low);
      } else {
        radar.node.select(arguments[0])
          .attr("opacity", brush.params.opacity.low);
      }
      return brush;
    };
    
    brush.bright = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.line.clazz)
          .attr("opacity", brush.params.opacity.natural);
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .attr("opacity", brush.params.opacity.natural);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .attr("opacity", brush.params.opacity.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .attr("opacity", brush.params.opacity.natural);
      } else {
        radar.node.select(arguments[0])
          .attr("opacity", brush.params.opacity.natural);
      }
      return brush;
    };
    
    // remove all decorations
    brush.straight = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .style("stroke", brush.params.stroke.invisible);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke", brush.params.stroke.invisible);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke", brush.params.stroke.invisible);
      } else {
        radar.node.select(arguments[0])
          .style("stroke", brush.params.stroke.invisible);
      }
      return brush;
    };
    
    // Just recover stroke-width
    brush.straight2 = function () {
      var prefix = defaults.wording;
      if ( !arguments.length ) {
        radar.node.selectAll(prefix.dot + styles.marker.clazz)
          .style("stroke-width", brush.params.weight.natural);
      } else if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke-width", brush.params.weight.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke-width", brush.params.weight.natural);
      } else {
        radar.node.select(arguments[0])
          .style("stroke-width", brush.params.weight.natural);
      }
      return brush;
    };
    
    // Change stroke color and stroke-width
    brush.highlight = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke", brush.params.stroke.heavy)
            .style("stroke-width", brush.params.weight.heavy)
            .attr("opacity", brush.params.opacity.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke", brush.params.stroke.heavy)
          .style("stroke-width", brush.params.weight.heavy)
          .attr("opacity", brush.params.opacity.natural);
      } else {
        radar.node.select(arguments[0])
          .style("stroke", brush.params.stroke.heavy)
          .style("stroke-width", brush.params.weight.heavy)
          .attr("opacity", brush.params.opacity.natural);
      }
      return brush;
    };
    
    // Just thicken stroke-width
    brush.highlight2 = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke-width", brush.params.weight.heavy)
            .attr("opacity", brush.params.opacity.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke-width", brush.params.weight.heavy)
          .attr("opacity", brush.params.opacity.natural);
      } else {
        radar.node.select(arguments[0])
          .style("stroke-width", brush.params.weight.heavy)
          .attr("opacity", brush.params.opacity.natural);
      }
      return brush;
    };
    
    brush.focus = function () {
      if ( !arguments.length ) return;
      if ( arguments[0] instanceof Array ) {
        for ( var i = 0; i < arguments[0].length; i++ ) {
          d3.select(arguments[0][i])
            .style("stroke", brush.params.stroke.natural)
            .style("stroke-width", brush.params.weight.natural);
        }
      } else if ( arguments[1] ) {
        radar.node.selectAll(arguments[0])
          .style("stroke", brush.params.stroke.natural)
          .style("stroke-width", brush.params.weight.natural);
      } else {
        radar.node.select(arguments[0])
          .style("stroke", brush.params.stroke.natural)
          .style("stroke-width", brush.params.weight.natural);
      }
      return brush;
    };
    
    function getCSSStyle() {
      var cssDef;
      if (cssDef = conf.style('viz-radar-marker')) {
        if (cssDef['stroke']) {
          styles.marker.stroke = cssDef['stroke'];
        }
      }
    }
    
    return chart;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.radar',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.Radar',
  version : '4.0.0'
}
],
function Setup( Manifest, Constants, fn ) {
  var module = {
    id : "sap.viz.modules.radar",
    type : Constants.Module.Type.Chart,
    name : "radar",
    description : "Radar module properties",
    properties : {
      drawingEffect : {
        name : 'drawingEffect',
        supportedValueType : 'List',
        supportedValues : [ 'normal', 'glossy' ],
        defaultValue : 'normal',
        description : 'Set drawing effect of radar.',
        isExported : true
      },
      polarGrid : {
        name : "polarGrid",
        supportedValueType : "Object",
        supportedValues : {
          visible : {
            name : "visible",
            supportedValueType : "Boolean",
            defaultValue : true,
            description : "Set polar gridline visibility switch."
          },
          color : {
            name : "color",
            supportedValueType : "String",
            defaultValue : "#d8d8d8",
            description : "Set polar gridline color."
          }
        },
        description : "Settings for Polar gridline customizations."
      },
      valueAxis : {
        name : "valueAxis",
        supportedValueType : "Object",
        supportedValues : {
          visible : {
            name : "visible",
            supportedValueType : "Boolean",
            defaultValue : true,
            description : "Set value axis visibility switch."
          },
          title : {
            name : "title",
            supportedValueType : "Object",
            supportedValues : {
              visible : {
                name : "visible",
                supportedValueType : "Boolean",
                defaultValue : false,
                description : "Set value axis title visibility switch."
              },
              text : {
                name : "text",
                supportedValueType : "String",
                defaultValue : "Value",
                description : "Set value axis title text."
              },
            },
            description : "Settings for value axis title."
          }
        },
        description : "Settings for value axis at side bar."
      },
      polarAxis : {
        name : "polarAxis",
        supportedValueType : "Object",
        supportedValues : {
          title : {
            name : "title",
            description: "Settings for polar axis title.",
            supportedValueType : "Object",
            supportedValues : {
              visible : {
                name : "visible",
                supportedValueType : "Boolean",
                defaultValue : false,
                description : "Set category axis visibility switch."
              },
              text : {
                name : "text",
                supportedValueType : "String",
                defaultValue : "Categories",
                description : "Set category axis text."
              }
            }
          }
        },
        description : "Settings for polar axes customizations."
      },
      colorPalette : {
        name : "colorPalette",
        defaultValue : Constants.SAPColor,
        description : "Set marker color customizations."
      },
      shapePalette : {
        name : "shapePalette",
        supportedValueType : "StringArray",
        defaultValue : [ "circle", "diamond", "triangle-up", "triangle-down", 
                  "triangle-left", "triangle-right", "cross", "intersection" ],
        supportedValues : [ "circle", "diamond", "triangle-up", "triangle-down", 
                  "triangle-left", "triangle-right", "cross", "intersection" ],
        description : 'Set marker shape customizations.'
      },
      line : {
        name : "line",
        description : "Settings for line customizations.",
        supportedValueType : "Object",
        supportedValues : {
          width : {
            name : 'width',
            supportedValueType : 'PositiveInt',
            defaultValue : 2,
            description : "Line weight settings. Range is [1, 7]"
          }
        }
      },
      surface : {
        name : "surface",
        supportedValueType : "Object",
        supportedValues : {
          fill : {
            name : 'fill',
            supportedValueType : 'Object',
            supportedValues : {
              visible : {
                name : 'visible',
                supportedValueType : 'Boolean',
                defaultValue : true,
                description : 'Set enable/disable fill effect for polar area.'
              },
              transparency : {
                name : 'transparency',
                supportedValueType : 'Double',
                defaultValue : 0.3,
                //min : '0',
                //max : '1',
                description : 'Set alpha value for polar area fill color.'
              },
            }
          }
        },
        description : "Settings for Surface customizations."
      },
      marker : {
        name : "marker",
        //description : "Settings for data point marker customizations.",
        supportedValueType : "Object",
        supportedValues : {
          size : {
            name : "size",
            supportedValueType : "PositiveInt",
            defaultValue : 6,
            min : 4,
            max : 32,
            description : "Set marker size customization."
          }
        },
        description : "Settings for marker/data point graphics."
      },
      tooltip : {
        name : "tooltip",
        supportedValueType : "Object",
        supportedValues : {
          enabled : {
            name : "enabled",
            supportedValueType : "Boolean",
            supportedValues : [ true, false ],
            defaultValue : true,
            description : "Set tooltip enablement."
          }
        },
        description : "Settings for tooltip customization."
      },
    },
    events : {
      selectData : Constants.Module.Event.SelectData.desc,
      deselectData : Constants.Module.Event.DeSelectData.desc,
      showTooltip : Constants.Module.Event.TooltipShow.desc,
      hideTooltip : Constants.Module.Event.TooltipHide.desc
    },
    feeds : {
      id : "radar"
    },
    css : {
      ".viz-plot-background" : {
        description : "Define style for the plot background.",
        value : {
          fill : "#ffffff",
        }
      },
      ".viz-radar-marker" : {
        description : 'Define style for marker in radar.',
        value : {
          stroke : "transparent",
        },
      },
      ".viz-axis-title" : {
        description : "Font style for polar axis title.",
        value : {
          fill : "#333333",
          "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
          "font-size" : "14px",
          "font-weight" : "bold"
        }
      },
      ".viz-polar-axis-labels" : {
        description : "Font styles for polar axis labels.",
        value : {
          "font-family" : "'Open Sans', Arial, Helvetica, sans-serif",
          "fill" : "#646464",
          "font-size" : "11px",
          "font-weight" : "bold"
        }
      }
    },
    configure : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiRadarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiRadarChart = {
    id : 'viz/multi_radar',
    name : 'IDS_MULTIRADARCHART',
    base : 'riv/base/multiple/xy',
    modules : {
      legend : {
        data : {
          aa : [ 3]
        }
      },
      tooltip : {
        id : "sap.viz.modules.tooltip",
        configure : {
          properties : {
            chartType : "radar",
            orientation : "left"
          }
        }
      },
      main : {
        controllers : {
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              propertyCategory : 'interaction',
              properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
              }
            }
          }
        },
        configure : {
          properties : {
            'mergeDataRange' : ['primary']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.radar',
                configure : {
                  description: 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : "plotArea",
                  properties : {
                    multichart : true
                  }
                }
              },
              background : {
                configure : {
                  propertyCategory : 'background',
                  properties : {
                    visible : false,
                  }
                }
              },
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        acceptMND : 0,
        max : 2
      },
      regionShape : {
        max : 0
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : "legend",
        target : "colorPalette",
        sourceModule : "main.plot.plot",
        source : "colorPalette"
      }, 
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapes'
      }
      ], 
      events : [ 
      {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main',
        type : 'hideTooltip'
      }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
      }]
    }
  };

  Manifest.register(multiRadarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'riv/basehorizontalchart',
      name : 'IDS_BASEHORIZONTALCHART',
     'abstract' : true,
      modules : {
        title : {
          id : 'sap.viz.modules.title',
          configure : {
              propertyCategory : 'title'
          }
        },
        legend : {
          id : 'sap.viz.modules.legend',
          data : {
              aa : [ 2 ]
          },
          configure : {
              propertyCategory : 'legend'
          }
        },
        tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'bar',
              orientation : 'left'
            }
          }
        },
        /**
             * 'sizeLegend' : {}
             */
        main : {
          id : 'sap.viz.modules.xycontainer',
          modules : {
            xAxis : {
              id : 'sap.viz.modules.axis',
              configure : {
              'description': 'Settings for the value axis of an XY chart.',
                propertyCategory : 'xAxis',
                properties : {
                  type : 'value',
                  position : 'bottom'
                }
              }
            },

            yAxis : {
              id : 'sap.viz.modules.axis',
              data : {
                  aa : [ 1 ]
              },
              configure : {
              'description': 'Settings for the category axis of an XY chart.',
                propertyCategory : 'yAxis',
                properties : {
                  type : 'category',
                  position : 'left',
                  gridline : {
                    visible : false
                  }
                },
                propertiesOverride : {
                  gridline : {
                    isExported : false
                  },
                  label : {
                  isExported : false
                  },
                  axisline : {
                  isExported : false
                  }
                }
              }
            },
      
      background : {
        id: 'sap.viz.modules.background',
        configure : {
          propertyCategory : 'background',
          properties : {
            direction : 'horizontal'
          }
        }
      }
          }
        }
      },
      
      dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        } ],
        events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        } ]
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalboxplot',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, Scaler, NumberUtils,tooltipDataHandler) {
  var boxplot = function(manifest) {

    var sWrapper = null, 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
    var  dimensions = {
        'sap.viz.modules.horizontalboxplot.dimension' : {
                'key' : 'sap.viz.modules.horizontalboxplot.dimension',
                'values' : null
        }
      };

    var width = undefined, 
      height = undefined, 
        yScale = d3.scale.ordinal(),
          xScale = d3.scale.linear(),
      yDimensionScale = d3.scale.ordinal(),
      decorativeShape,
      boxWidth,
      boxHeight,
      lastHovered = null,
      tooltipVisible = true,
      scaleMinMax = {
          min: 0,
          max: 0
      },
      effectManager = null,
      drawingEffect = 'normal';
    
        var _properties = {},
        eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    
    var outLierLayout = {
      width : '1',
      color : '#000000'
    };

    var quartileLayout = {
      width: '0',
      midLineColor: '#000000'
    };
    
    var lowOutLiersObj = [], highOutLiersObj = [], whiskersObj = [], lowWhiskerObj = [], highWhiskerObj = [], quartilesObj = [], outLiersObj = [];
    
    var makeScales = function() {
      var domain = [];
      for ( var i = 0; i < seriesData.length; i++) {
        domain.push(i);
      }
      yScale.domain(domain).rangeBands([0, height]);
      yDimensionScale.domain(dimensionDomain).rangeBands([0, height]);    
      xScale.domain([ scaleMinMax.min, scaleMinMax.max ]).range([ 0, width]).nice();
      Scaler.perfect(xScale);

    };
    chart.dimensionData = function(_)
    {
      if (!arguments.length){
        return dimensions;
      }
      dimensions = _;
      return chart;    
    };
    
    function locateBoundary(data) {
      if (TypeUtils.isExist(data)) {
        length = data.length;
        var firstLoop = false;
        for (var i = 0; i < length; i++) {
          if (data[i].length > 0) {
            if (!firstLoop) {
              scaleMinMax = findMinMax(data[i]);
              firstLoop = true;
            } else {
              var tmp = findMinMax(data[i]);
              if (tmp) {
                if (tmp.min < scaleMinMax.min) {
                  scaleMinMax.min = tmp.min;
                }
                if (tmp.max > scaleMinMax.max) {
                  scaleMinMax.max = tmp.max;
                }
              }
              
            }
          }
        }
      }
    }
    
    function findMinMax(range) {
      var minMax = {min:0, max:0};
      if (TypeUtils.isExist(range)) {
        range.sort( function(aObj, bObj) { return aObj.val - bObj.val; });
        
        minMax = {min: range[0].val, max: range[range.length - 1].val};
      }
      return minMax;
    }

    function clearBoxData() {
      lowOutLiersObj = [];
      highOutLiersObj = [];
      whiskersObj = [];
      lowWhiskerObj = [];
      highWhiskerObj = [];
      quartilesObj = [];
      outLiersObj = [];
    }
    
    function clearGlobalData() {
      dimensionGroup = []; 
      dimensionDomain = []; 
      seriesData = []; 
      legendData = []; 
      regionData = []; 
      dimensionData = []; 
      boxplotData = []; 
    }

    function even(n) {
      return (n & 1) == 0;
    }

    function median(distribution, start, end) {
      var n = end - start + 1;
      if (n <= 0)
        return -1;

      var ret;
      var ctxValue = distribution[start + Math.floor((n + 1) / 2) - 1].ctx;

      if (even(n)) {
        ret = (distribution[start + Math.floor((n + 1) / 2) - 1].val + distribution[start
            + Math.floor((n + 1) / 2)].val) / 2;
      } else {
        ret = distribution[start + Math.floor((n + 1) / 2) - 1].val;
      }
      return {
        'ctx' : ctxValue,
        'val' : ret
      };
    }

    function setDistribution(distribution) {

      if (distribution && distribution.length > 0) {
        var n = distribution.length,
          box = {
            'Maximum:': null,
            '3rd Quartile:': null,
            'Median:': null,
            '1st Quartile:': null,
            'Minimum:': null  
          };
        
            midLine = median(distribution,  0,  n - 1);
            box['Median:'] = midLine;
            
          // Q1 is the median of the first half of the set; we add the median to
            // it if the whole set length is even
            var bak = distribution[Math.floor(n / 2)];
            distribution[Math.floor(n / 2)] = midLine;
            var boxBottom = median(distribution, 0, Math.floor(n / 2));
            distribution[Math.floor(n / 2)] = bak;
            
            // Q3 is the median of the second half of the set; we add the median to
            // it if the whole set length is even
            bak = distribution[Math.floor((n - 1) / 2)];
            distribution[Math.floor((n - 1) / 2)] = midLine;
            var boxTop  = median(distribution, Math.floor((n - 1) / 2), n - 1);
            distribution[Math.floor((n - 1) / 2)] = bak;
            box['3rd Quartile:'] = boxTop;
            box['1st Quartile:'] = boxBottom;
            
        // inter-quartile range
        var iqr = boxTop.val - boxBottom.val;
        // lower adjacent limit
        var lal = boxBottom.val - 1.5 * iqr;
        // upper adjacent limit
        var ual = boxTop.val + 1.5 * iqr;

        // search for the lowest non outlier
        var i = 0;
        while (distribution[i].val < lal)
          i++;
        lowWhisker = distribution[i];
        box['Minimum:'] = lowWhisker;

        if (lowWhisker) {
          if (boxBottom) {
            if (boxBottom.val != lowWhisker.val) {
              lowWhiskerObj.push({
                'pair' : [boxBottom, lowWhisker],
                'ctx' : [boxBottom.ctx, lowWhisker.ctx],
                'val' : [boxBottom.val, lowWhisker.val]
              });
            }
          }
        }

        // low outliers are all the values lower than lowest non outlier
        for ( var k = 0; k < i; k++)
          outLiersObj.push(distribution[k]);

        // search for the largest non outlier
        var j = n - 1;
        while (distribution[j].val > ual)
          j--;
        highWhisker = distribution[j];
        box['Maximum:'] = highWhisker;

        for ( var k = 0; k < n - j - 1; k++)
          outLiersObj.push(distribution[j + 1 + k]);

        if (outLiersObj.length > 0)
          box['outLiers(s)'] = outLiersObj.length;
        // if (lowWhiskerObj.length == 1) {
        // whiskersObj.push(lowWhiskerObj[0]);
        // }

        // if (highWhiskerObj.length == 1) {
        // whiskersObj.push(highWhiskerObj[0]);
        // }

        if (highWhisker) {
          if (boxTop) {
            if (boxTop.val != highWhisker.val) {
              highWhiskerObj.push({
                'pair' : [highWhisker, boxTop],
                'ctx' : [highWhisker.ctx, boxTop.ctx],
                'val' : [highWhisker.val, boxTop.val]
              });
            }
          }
        }

        if (boxBottom && boxTop && midLine) {
          if (boxBottom.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxBottom, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val]
            });
          } else if (midLine.val == boxTop.val || midLine.val == boxBottom.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxTop.ctx, boxBottom.ctx],
              'val' : [boxTop.val, boxBottom.val]
            });
          } else {
            quartilesObj.push({
              'pair' : [boxTop, midLine],
              'midLine': midLine,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val]
            });
            quartilesObj.push({
              'pair' : [midLine, boxBottom],
              'midLine': midLine,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val]
            });
          }
        }
        
        boxplotData.push(box);
      }
    }
      
    function chart(selection) { 
      
      selection.each(function() {
          
        boxNumber = 1, boxGroupNumber = seriesData.length, boxHeight = 8 * (yScale.rangeBand()) / (9 * boxNumber + 7);
  
          var svg = sWrapper = d3.select(this);
          svg.selectAll('g.box').remove();
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', width).attr('height', yScale.rangeBand() - boxHeight/2).style('visibility', 'hidden').attr('fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', width).attr('height', yScale.rangeBand() - boxHeight/2).style('visibility', 'hidden');
          }
          
          var boxGroup = svg.selectAll('g.box').data(seriesData);

          boxGroup.enter().append('g');
        boxGroup.attr('class', 'box').each( function(boxData, outerIndex) {
              
            if (boxData.length == 0) {
              boxplotData.push({});
              return;
            }
            
            boxData = boxData.sort(function(aObj, bObj) { return aObj.val - bObj.val; });
    
                var arrLength = boxData.length, min = boxData[0], max = boxData[arrLength - 1];
    
                setDistribution(boxData);
    
                var outLiersSelector = d3.select(this).selectAll('circle.outliers').data(outLiersObj);
                outLiersSelector.enter().append('circle');
                outLiersSelector.attr('cy', function(outLier) {
                  var y = yScale(outerIndex) + boxHeight;
                  return y;
                })
                .attr('cx', function(outLier, num) {
                  var x = xScale(outLier.val);
                  return x;
                })
                .attr('r', '2')
                //.attr('shape-rendering', 'crispEdges')
                .attr('stroke', effectManager.register(
                                                    {
                                                  drawingEffect : 'normal',
                                                  fillColor : outLierLayout.color
                                                  }
                                                      )
             )
                .attr('stroke-width', outLierLayout.width)
                .attr('fill', 'none')
                .attr('class', 'datapoint outliers');
                
                outLiersSelector.exit().remove();
    
                var quartileSelector = d3.select(this).selectAll('rect.quartile').data(quartilesObj);
                quartileSelector.enter().append('rect');
                quartileSelector.attr('y', function(quartile) {
                  var y = yScale(outerIndex) + boxHeight / 2;
                  return y;
                })
                .attr('x', function(quartile, num) {
                  var x = xScale(quartile.pair[1].val);
                  return x;
                })
                .attr('height', boxHeight)
                .attr('width', function(quartile, num) {
                  var width = 0;
                  var pairDiff = quartile.pair[0].val - quartile.pair[1].val;
                  if (pairDiff == 0) {
                    width = 1;
                  } else {
                    width = xScale(quartile.pair[0].val) - xScale(quartile.pair[1].val);
                  }
  
                  return width;
                })
                .attr('shape-rendering', 'crispEdges')
                .attr( 'fill', function(d){
                  var parameter = {
                      drawingEffect : drawingEffect,
                      fillColor : boxColorPalette[outerIndex % boxColorPalette.length],
                      direction : 'vertical'
                    };
            return effectManager.register(parameter);                
                })
                .attr('stroke-width', quartileLayout.width)
                //.attr('stroke', '#000000')
                .attr('class', 'datapoint quartile');
                
                if (quartilesObj.length == 2) {
                  var midLineYStart = yScale(outerIndex) + boxHeight / 2;
                  var midLineYEnd = midLineYStart + boxHeight;
                  var midLineXStart = midLineXEnd = xScale(quartilesObj[0].midLine.val);
                  var lineSelector = d3.select(this);
                  lineSelector.append('line')
                  .attr('x1', midLineXStart)
                  .attr('y1', midLineYStart)
                  .attr('x2', midLineXEnd)
                  .attr('y2', midLineYEnd)
                  .attr('stroke', '#ffffff')
                  .attr('stroke-width', 1)
                  .attr('shape-rendering', 'crispEdges')
                  .attr('class', 'midline');
                }
                
                quartileSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.rectlowwhisker').data(lowWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector.attr('y', function(whisker) {
                  var y = yScale(outerIndex) + boxHeight / 2;
                  horizontalLineYStart = horizontalLineYEnd = y + boxHeight / 2 ;
                  verticalLineYStart = y;
                  verticalLineYEnd = y + boxHeight;
                  return y;
                  })
                  .attr('x', function(whisker) {
                    var x = xScale(whisker.pair[1].val);
                    horizontalLineXStart = x;
                    verticalLineXStart = verticalLineXEnd = x;
                    return x;
                   })
                  .attr('height', boxHeight)
                    .attr('width', function(whisker) {
                      var width = xScale(whisker.pair[0].val) - xScale(whisker.pair[1].val);
                      horizontalLineXEnd = xScale(whisker.pair[1].val) + width;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke', function(d){
                           var parameter = {
                                 drawingEffect : 'normal',
                                 fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                                };
                         return effectManager.register(parameter);  
                             }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'lineverticallowwhisker');
                    
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', horizontalLineXStart)
                    .attr('y1', horizontalLineYStart)
              .attr('x2', horizontalLineXEnd)
                    .attr('y2', horizontalLineYEnd)
                    .attr('stroke', effectManager.register(
                                            {
                                              drawingEffect : 'normal',
                                              fillColor : '#000000'
                                            }
                                          )
                               )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'linehorizontallowwhisker');
                    return width;
                    })
                .attr('shape-rendering', 'crispEdges')
                .attr('fill-opacity', '0')
                .attr('stroke-width', '0')
                .attr('class', 'datapoint rectlowwhisker');
                
                whiskerSelector.exit().remove();
                
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.recthighwhisker').data(highWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector
                    .attr('y', function(whisker) {
                      var y = yScale(outerIndex) + boxHeight / 2;
              horizontalLineYStart = horizontalLineYEnd = y + boxHeight / 2;
              verticalLineYStart = y;
              verticalLineYEnd = y + boxHeight;
                      return y;
                      })
                    .attr('x', function(whisker, num) {
                      var x = xScale(whisker.pair[1].val);
                    horizontalLineXStart = x;
                    verticalLineXStart = verticalLineXEnd = xScale(whisker.pair[0].val);
                      return x;
                      })
                    .attr('height', boxHeight)
                    .attr('width', function(whisker, num) {
                      var width = xScale(whisker.pair[0].val) - xScale(whisker.pair[1].val);
                      horizontalLineXEnd = xScale(whisker.pair[1].val) + width;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke',  function(d){
                              var parameter = {
                           drawingEffect : 'normal',
                           fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                          };
                              
                                    return effectManager.register(parameter);  
                                }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'lineverticalhighwhisker');
  
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', horizontalLineXStart)
                      .attr('y1', horizontalLineYStart)
                      .attr('x2', horizontalLineXEnd)
                      .attr('y2', horizontalLineYEnd)
                      .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'linehorizontalhighwhisker');
                       
                      return width;
                      })
                      .attr('shape-rendering', 'crispEdges')
                      .attr('fill-opacity', '0')
                      .attr('stroke-width', '0')
                      .attr('class', 'datapoint recthighwhisker');
                
                whiskerSelector.exit().remove();
                
                clearBoxData();
          eDispatch.initialized();
          
          });
          boxGroup.exit().remove();
      });
    return chart;
    };
  
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }
      
      width = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };
      
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };    
  
    function getTooltipData(index) {
      
      var tooltipData =  {
          'body': [],
          'footer': []
        },
        internalIndex = 0;
      
      if (regionData) {

        var body = {
          'name': null,
          'val': []
        };
        
        internalIndex = index % regionData.length;
        body.name = regionData[internalIndex].name;
  
        if (regionData[internalIndex].label != null && regionData[internalIndex].shape != null && boxColorPalette[internalIndex] != null) {
          var item = {
              'shape': null,
              'color': null,
              'label': null,
              'value': null
            };
          
          item.shape = regionData[internalIndex].shape;
          item.color = boxColorPalette[internalIndex];
          item.label = regionData[internalIndex].label;
          body.val.push(item);
        }
        
        if (boxplotData) {
          
          if (boxplotData[index]) {

            for (var i in boxplotData[index]) {
              var item = {
                  'shape': null,
                  'color': null,
                  'label': null,
                  'value': null
                };
              item.label = i;
              if (boxplotData[index][i]) {
                if (i == 'outLiers(s)') {
                  item.value = boxplotData[index][i];
                } else {
                  item.value = boxplotData[index][i].val;
                }
              }
              body.val.push(item);
            }
          }
        }
        
        tooltipData.body.push(body);
      }
      
      if (dimensionData) {
        internalIndex = Math.floor(index / regionData.length);
        for (var i = 0; i < dimensionData.length; i++) {
          
          if (dimensionData[i].rows.length > 0) {
            var footer = {
                'label': null,
                'value': null
              };
            footer.label = dimensionData[i].col.val;
            footer.value = dimensionData[i].rows[internalIndex].val;
            
            tooltipData.footer.push(footer);
          }
        }
      }
      
      return tooltipData;
    }
    
    function generateTooltipData() {
      
      if (dimensions) {
        for (var i in dimensions) {
          dimensionData = dimensions[i].values;
        }
      }
      
      if (legendData) {
        var legendList = legendData.values;
        if (legendList.length > 1) {
          if (legendList[0].type == 'MND') {
            //mnd scan
            for (var mndIndex = 0; mndIndex < legendList[0].rows.length; mndIndex++) {

              //vertical scan
              for (var m = 0; m < legendList[1].rows.length; m++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.name = legendList[0].rows[mndIndex].val;
                var label = '';
                
                //horizontal scan
                for (var n = 1; n < legendList.length; n++) {
                  var seperator = ' / ';
                  if (n == legendList.length - 1) seperator = '';
                  label += legendList[n].rows[m].val + seperator;
                }
                legendObj.label = label;
                regionData.push(legendObj);
              }    

            }
          } else if (legendList[legendList.length - 1].type == 'MND') {

            for (var m = 0; m < legendList[0].rows.length; m++) {

              var label = '';
              for (var n = 0; n < legendList.length - 1; n++) {
                var seperator = ' / ';
                if (n == legendList.length - 2) seperator = '';
                label += legendList[n].rows[m].val + seperator;              
              }
              

              for (var mndIndex = 0; mndIndex < legendList[legendList.length - 1].rows.length; mndIndex++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.label = label;
                legendObj.name = legendList[legendList.length - 1].rows[mndIndex].val;
                regionData.push(legendObj);
              }
            }
          } 
        } else {
          for (var m = 0; m < legendList[0].rows.length; m++) {
            var legendObj = {
                'name': null,
                'shape': null,
                'color': null,
                'label': null
              };
            legendObj.name = legendList[0].rows[m].val;
            regionData.push(legendObj);
          }
        }
      }
      
      for (var k = 0; k < regionData.length; k++) {
        //regionData[k].color = boxColorPalette[k % boxColorPalette.length];
        regionData[k].shape = 'squareWithRadius';
      }
    }

    function setElementAttribute(element, attribute, value) {
      if (element) {
        var className = element.getAttribute('class');
        if(className.indexOf('recthighwhisker') == -1 && className.indexOf('rectlowwhisker') == -1
           && className.indexOf('linehorizontalhighwhisker') == -1 && className.indexOf('lineverticalhighwhisker') == -1
           && className.indexOf('linehorizontallowwhisker') == -1 && className.indexOf('lineverticallowwhisker') == -1) {
          element.setAttribute(attribute, value);
        }else if (className.indexOf('recthighwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('linehorizontalhighwhisker') != -1 || nodeClassName.indexOf('lineverticalhighwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }
        } else if(className.indexOf('rectlowwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('linehorizontallowwhisker') != -1 || nodeClassName.indexOf('lineverticallowwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }        
        }      
      }
    }
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, elemsLen = elems.length; i < elemsLen; i++) {
          var item = elems[i];
          setElementAttribute(item, 'opacity', 1);
          }
        }else{
        setElementAttribute(elems, 'opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
          var item = elems[i];
          setElementAttribute(item, 'opacity', 0.2);
          }
        }else{
        setElementAttribute(elems, 'opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          sWrapper.selectAll('.datapoint').attr('opacity', 1);
          sWrapper.selectAll('.lineverticallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.lineverticalhighwhisker').attr('opacity', 1);
          sWrapper.selectAll('.linehorizontallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.linehorizontalhighwhisker').attr('opacity', 1);
        }else{
          sWrapper.selectAll('.datapoint').attr('opacity', 0.2);
          sWrapper.selectAll('.lineverticallowwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.lineverticalhighwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.linehorizontallowwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.linehorizontalhighwhisker').attr('opacity', 0.2);
        }
        
        sWrapper.selectAll('.recthighwhisker').attr('opacity', 0);
        sWrapper.selectAll('.rectlowwhisker').attr('opacity', 0);
      };
  
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(yOnModule - yScale.rangeBand()*i - 0.5 * yScale.rangeBand() ) <= 0.5 * yScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.style(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'y',
          yScale.rangeBand() * i + boxHeight/4).style(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element.
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var yoffset = transform.f;
          
          var tooltipData = getTooltipData(i);
          
          tooltipData.point = {
              x: d3.event.layerX,
              y: yScale.rangeBand()*i + 0.5 * yScale.rangeBand() + yoffset
          };
          tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      }
      
      };
  
      chart.blurOut = function(){
        decorativeShape.style('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      function makeSubGroup(row, start, end, groups, parentGroupIndex) {
      if (row && start <= end && end < row.length) {
        var subStart = subEnd = pos = start;
        while (pos <= end) {
          while (((pos+1) <= end) && (row[pos + 1].val == row[pos].val)) {
            subEnd++;
            pos++;
          }
            
          groups.push({
            'val': row[subStart],
            'parentGroupIndex': parentGroupIndex,
            'start': subStart,
            'end': subEnd
          });
          pos++;
          subStart = subEnd = pos;
        }          
      }
    }

    
    function generateGroup(row) {
      var curGroups = [];
      if (row) {
        var mapLen = dimensionGroup.length;
        var preGroups = mapLen > 0?dimensionGroup[mapLen - 1].val : null;
        if (preGroups) {
          for (var i = 0, len = preGroups.length; i < len; i++) {
            var preGroup = preGroups[i];
            var start = preGroup.start;
            var end = preGroup.end;
            makeSubGroup(row, start, end, curGroups, i );
          }
        } else {
          makeSubGroup(row, 0, row.length - 1, curGroups, null);
        }
      }
      return curGroups;
    }

    function dataTransform(originalData) {
      if (originalData) {
        var originalDimension = originalData.getAnalysisAxisDataByIdx(0);
        legendData = originalData.getAnalysisAxisDataByIdx(1);
        if (originalDimension) {
          var len = originalDimension.values.length;
          if (len == 1) {
            dimensionGroup.push({'col': originalDimension.values[0].col.val, 'val': []});
          } else {
            for (var i = 0; i < len - 1; i++) {
              var row = originalDimension.values[i].rows;
              dimensionGroup.push({'col': originalDimension.values[i].col.val, 'val': generateGroup(row)});
            }
          }
        }
      }
    }
    
    function caculateLeavesNum(start, end) {
      
      var len = dimensionGroup.length, num = 0, index = 0, leavesGroups = dimensionGroup[len - 1].val;
      while (leavesGroups[index].start != start) {
        index++;
      }      
      while (leavesGroups[index].end != end) {
        num++;
        index++;
      }
      num++;
      return num;
    }

    function generateDimensions() {
      if (dimensionGroup) {
        var len = dimensionGroup.length, groups = null;
        
        groups = dimensionGroup[len - 1].val;
        if (groups.length == 0) {
          dimensionDomain.push(0);
          dimensionDomain.push(1);
        } else {
          for (var i = 0, lenScale = groups.length; i < lenScale; i++) {
            dimensionDomain.push(i);
          }
        }
        
        if (groups.length == 0) {
          dimensions['sap.viz.modules.horizontalboxplot.dimension'].values = [{'col': {'val': dimensionGroup[len - 1].col}, 'rows': []}];
        } else {
          
          var scaleValues = [];
          for (var j = 0; j < len; j++) {
            var obj = {
              'col': {'val': ''},
              'rows': []
            };
            obj.col.val = dimensionGroup[j].col;
            var rowGroups = dimensionGroup[j].val;
            for (var k = 0,  lenRowGroups =  rowGroups.length; k < lenRowGroups; k++) {
              var start = rowGroups[k].start, end = rowGroups[k].end, num = caculateLeavesNum(start, end);
              for (var m = 0; m < num; m++) {
                obj.rows.push({'val': (rowGroups[k].val.val == null)?defaultString:rowGroups[k].val.val});
              }
            }
            
            scaleValues.push(obj);
          }
              
          dimensions['sap.viz.modules.horizontalboxplot.dimension'].values = scaleValues;
        }        
      }      
    }
  
    function createColorPalette(length) {
      boxColorPalette = [];
      if (colorPalette.length > 0) {
        for( var i = 0; i < length; ++i) {
          boxColorPalette.push(colorPalette[i % colorPalette.length]);
        }
      }
    }
      function parseOptions(){
      tooltipVisible = _properties.tooltip.enabled ;
        colorPalette = _properties.colorPalette;
        drawingEffect = _properties.drawingEffect;
      }
      
    chart.data = function(value) {
      if (!arguments.length) {
        return _data;
      }
      
      clearGlobalData();
      parseOptions();
      
      _data = value;
        var obj = MNDHandler(_data);
        dataTransform(_data);
        dataMG1 = obj["MG1"];
        
      var len = dataMG1.length;
      var groups = dimensionGroup[dimensionGroup.length - 1].val;
      if (groups.length != 0) {
        for (var i = 0, groupsLen = groups.length; i < groupsLen; i++) {
          var start = groups[i].start, end = groups[i].end;
          for (var j = 0; j < len; j++) {
            var row = [], left = start, right = end;
            for (;left <= right; left++) {
              if (!NumberUtils.isNoValue(dataMG1[j][left].val))
                row.push(dataMG1[j][left]);
            }
            seriesData.push(row);
          }
        }
      } else {
        for (var j = 0; j < len; j++) {
          var row = [];
          for (var m = 0; m < dataMG1[j].length; m++) {
            if (!NumberUtils.isNoValue(dataMG1[j][m].val)) {
              row.push(dataMG1[j][m]);
            } 
          }
          seriesData.push(row);
        }
      }
        
      locateBoundary(seriesData);
      generateDimensions();
      
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
        makeScales();
      }
      
      generateTooltipData();
            createColorPalette(regionData.length);
      
      return chart;
    };
    
    chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
    chart.properties = function(props){

        if (!arguments.length){
          return _properties;
         }
      
      _properties = manifest.props(props);
            parseOptions();
            createColorPalette(regionData.length);
            
         return chart;        
      };
    
    chart.categoryScale = function(scale){
      if (!arguments.length){
        return yDimensionScale;
      }
      yDimensionScale = scale;
      return chart;
     };
     
     chart.primaryScale = function(scale){
       if (!arguments.length){
         return xScale;
       }
       xScale = scale;
       return chart;
     };
  
    chart.colorPalette = function(Palette){
      if (!arguments.length){
        return colorPalette;
      }
      colorPalette = Palette;
      return chart;
     };
  
     chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
    /**
     * set/get effect manager
     */
    chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return chart;        
     };
    _properties = manifest.props(null);
    return chart;
  };

  return boxplot;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalBoxplot',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.horizontalboxplot',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.horizontalboxplot',
    'name' : 'horizontal boxplot',
    base : "sap.viz.modules.xy.base",
    'properties' : { 
          'secondaryValuesColorPalette' : null,
          'tooltip' : {
            'name' : 'tooltip',
            'supportedValueType' : 'Object',
            'supportedValues' : {
              'enabled' : {
                'name' : 'enabled',
                'supportedValueType' : 'Bool',
                'defaultValue' : true,
                'description' : 'Set enabled/disabled tooltip.'
              }
            },
            'isExported' : false,
            'description' : 'Settings for tooltip related properties.'
          }
    },
    'feeds' : {
      configure : {
          secondaryValues:null,
          axisLabels:{
          acceptMND: -1,
          min : 1,
          max : 1
        }
    }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalBoxplotChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalBoxplot',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/horizontal_boxplot',
      name : 'IDS_HORIZONTALBOXPLOTCHART',
      base : 'riv/basehorizontalchart',
      modules : {
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'horizontalboxplot',
                  orientation : 'left'
                }
              }
          },
          main : {
              modules : {
                yAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                plot : {
                    id : 'sap.viz.modules.horizontalboxplot',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              },
          controllers : {
              'interaction' : {
                    id : 'sap.viz.modules.controller.interaction',
                    configure : {
                          propertyCategory : 'interaction'
                    }
                }
        }
          }
      },

     dependencies : {
       attributes : [ {
         targetModule : 'main.yAxis',
         target : 'scale',
         sourceModule : 'main.plot',
         source : 'categoryScale'
          },{
            targetModule : 'main.xAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'primaryScale'
          },{
         targetModule : 'main.xAxis',
         target : 'title',
         sourceModule : 'main.plot',
         source : 'primaryAxisTitle'
          },{
              targetModule : 'main.yAxis',
              target : 'independentData',
              sourceModule : 'main.plot',
              source : 'dimensionData'
          },{
            targetModule : 'legend',
            target : 'colorPalette',
            sourceModule : 'main.plot',
            source : 'colorPalette'
          }, {
            targetModule : 'legend',
            target : 'setSelectionMode',
            sourceModule : 'main.interaction',
            source : 'getSelectionMode'
          } ],
           events : [ {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized'
          }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
          }, {
          targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }
          ]
        }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'riv/baseverticalchart',
      name : 'IDS_BASEVERTICALCHART',
      'abstract' : true,
      modules : {
        title : {
          id : 'sap.viz.modules.title',
          configure : {
              propertyCategory : 'title'
          }
        },
        legend : {
          id : 'sap.viz.modules.legend',
          data : {
              aa : [ 2 ]
          },
          configure : {
              propertyCategory : 'legend'
          }
        },
        tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'verticalbar',
              orientation : 'left'
            }
          }
        },
        main : {
          id : 'sap.viz.modules.xycontainer',
          modules : {
            yAxis : {
              id : 'sap.viz.modules.axis',
              configure : {
              'description': 'Settings for the value axis of an XY chart.',
               propertyCategory : 'yAxis',
                properties : {
                  type : 'value',
                  position : 'left'
                }
              }
            },

            xAxis : {
              id : 'sap.viz.modules.axis',
              data : {
                  aa : [ 1 ]
              },
              configure : {
              'description': 'Settings for the category axis of an XY chart.',
                propertyCategory : 'xAxis',
                properties : {
                  type : 'category',
                  position : 'bottom',
                  gridline : {
                    visible : false
                  }
                },
                propertiesOverride : {
                  gridline : {
                      isExported : false
                    },
                    label : {
                    isExported : false
                    },
                    axisline : {
                    isExported : false
                   }
                }
                    
              }
            },
      
      background : {
        id: 'sap.viz.modules.background',
        configure : {
          propertyCategory : 'background',
          properties : {
            direction : 'vertical'
          }
        }
      }
          }
        }
      },
      dependencies : {
        attributes : [ {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        } ],
         events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        } ]
      }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.verticalboxplot',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, Scaler, NumberUtils, langManager,tooltipDataHandler) {
  var boxplot = function(manifest) {

    var sWrapper = null, 
      dimensionGroup = [], 
      dimensionDomain = [], 
      seriesData = [], 
      legendData = [], 
      regionData = [], 
      dimensionData = [], 
      boxplotData = [],
      colorPalette = [],
      boxColorPalette = [],
      _data = null; 
    var  dimensions = {
        'sap.viz.modules.verticalboxplot.dimension' : {
                'key' : 'sap.viz.modules.verticalboxplot.dimension',
                'values' : null
        }
      };

    var width = undefined, 
      height = undefined, 
      xScale = d3.scale.ordinal(), 
      yScale = d3.scale.linear(), 
      xDimensionScale = d3.scale.ordinal(),
      decorativeShape,
      boxWidth,
      lastHovered = null,
      tooltipVisible = true,
      scaleMinMax = {
          min: 0,
          max: 0
      },
      effectManager = null,
      drawingEffect = 'normal',
      defaultString = langManager.get('IDS_ISNOVALUE');
    
        var _properties = {},
          eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    
    var outLierLayout = {
      width : '1',
      color : '#000000'
    };

    var quartileLayout = {
      width: '0',
      midLineColor: '#000000'
    };
    
    var lowOutLiersObj = [], highOutLiersObj = [], whiskersObj = [], lowWhiskerObj = [], highWhiskerObj = [], quartilesObj = [], outLiersObj = [];
    
    var makeScales = function() {
      var domain = [];
      for ( var i = 0; i < seriesData.length; i++) {
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([0, width]);
      xDimensionScale.domain(dimensionDomain).rangeBands([0, width]);    
      yScale.domain([ scaleMinMax.min, scaleMinMax.max ]).range([ height, 0 ]).nice();
      Scaler.perfect(yScale);

    };
    
    chart.dimensionData = function(_)
    {
      if (!arguments.length){
        return dimensions;
      }
      dimensions = _;
      return chart;    
    };
    
    function locateBoundary(data) {
      if (TypeUtils.isExist(data)) {
        length = data.length;
        var firstLoop = false;
        for (var i = 0; i < length; i++) {
          if (data[i].length > 0) {
            if (!firstLoop) {
              scaleMinMax = findMinMax(data[i]);
              firstLoop = true;
            } else {
              var tmp = findMinMax(data[i]);
              if (tmp) {
                if (tmp.min < scaleMinMax.min) {
                  scaleMinMax.min = tmp.min;
                }
                if (tmp.max > scaleMinMax.max) {
                  scaleMinMax.max = tmp.max;
                }
              }
              
            }
          }
        }
      }
    }
    
    function findMinMax(range) {
      var minMax = {min:0, max:0};
      if (TypeUtils.isExist(range)) {
        range.sort( function(aObj, bObj) { return aObj.val - bObj.val; });
        
        minMax = {min: range[0].val, max: range[range.length - 1].val};
      }
      return minMax;
    }

    function clearBoxData() {
      lowOutLiersObj = [];
      highOutLiersObj = [];
      whiskersObj = [];
      lowWhiskerObj = [];
      highWhiskerObj = [];
      quartilesObj = [];
      outLiersObj = [];
    }
    
    function clearGlobalData() {
      dimensionGroup = []; 
      dimensionDomain = []; 
      seriesData = []; 
      legendData = []; 
      regionData = []; 
      dimensionData = []; 
      boxplotData = []; 
    }

    function even(n) {
      return (n & 1) == 0;
    }

    function median(distribution, start, end) {
      var n = end - start + 1;
      if (n <= 0)
        return -1;

      var ret;
      var ctxValue = distribution[start + Math.floor((n + 1) / 2) - 1].ctx;

      if (even(n)) {
        ret = (distribution[start + Math.floor((n + 1) / 2) - 1].val + distribution[start
            + Math.floor((n + 1) / 2)].val) / 2;
      } else {
        ret = distribution[start + Math.floor((n + 1) / 2) - 1].val;
      }
      return {
        'ctx' : ctxValue,
        'val' : ret
      };
    }

    function setDistribution(distribution) {

      if (distribution && distribution.length > 0) {
        var n = distribution.length,
          box = {
            'Maximum:': null,
            '3rd Quartile:': null,
            'Median:': null,
            '1st Quartile:': null,
            'Minimum:': null  
          };
        
            midLine = median(distribution,  0,  n - 1);
            box['Median:'] = midLine;
            
          // Q1 is the median of the first half of the set; we add the median to
            // it if the whole set length is even
            var bak = distribution[Math.floor(n / 2)];
            distribution[Math.floor(n / 2)] = midLine;
            var boxBottom = median(distribution, 0, Math.floor(n / 2));
            distribution[Math.floor(n / 2)] = bak;
            
            // Q3 is the median of the second half of the set; we add the median to
            // it if the whole set length is even
            bak = distribution[Math.floor((n - 1) / 2)];
            distribution[Math.floor((n - 1) / 2)] = midLine;
            var boxTop  = median(distribution, Math.floor((n - 1) / 2), n - 1);
            distribution[Math.floor((n - 1) / 2)] = bak;
            box['3rd Quartile:'] = boxTop;
            box['1st Quartile:'] = boxBottom;
            
        // inter-quartile range
        var iqr = boxTop.val - boxBottom.val;
        // lower adjacent limit
        var lal = boxBottom.val - 1.5 * iqr;
        // upper adjacent limit
        var ual = boxTop.val + 1.5 * iqr;

        // search for the lowest non outlier
        var i = 0;
        while (distribution[i].val < lal)
          i++;
        lowWhisker = distribution[i];
        box['Minimum:'] = lowWhisker;

        if (lowWhisker) {
          if (boxBottom) {
            if (boxBottom.val != lowWhisker.val) {
              lowWhiskerObj.push({
                'pair' : [boxBottom, lowWhisker],
                'ctx' : [boxBottom.ctx, lowWhisker.ctx],
                'val' : [boxBottom.val, lowWhisker.val]
              });
            }
          }
        }

        // low outliers are all the values lower than lowest non outlier
        for ( var k = 0; k < i; k++)
          outLiersObj.push(distribution[k]);

        // search for the largest non outlier
        var j = n - 1;
        while (distribution[j].val > ual)
          j--;
        highWhisker = distribution[j];
        box['Maximum:'] = highWhisker;

        for ( var k = 0; k < n - j - 1; k++)
          outLiersObj.push(distribution[j + 1 + k]);

        if (outLiersObj.length > 0)
          box['outLiers(s)'] = outLiersObj.length;
        // if (lowWhiskerObj.length == 1) {
        // whiskersObj.push(lowWhiskerObj[0]);
        // }

        // if (highWhiskerObj.length == 1) {
        // whiskersObj.push(highWhiskerObj[0]);
        // }

        if (highWhisker) {
          if (boxTop) {
            if (boxTop.val != highWhisker.val) {
              highWhiskerObj.push({
                'pair' : [highWhisker, boxTop],
                'ctx' : [highWhisker.ctx, boxTop.ctx],
                'val' : [highWhisker.val, boxTop.val]
              });
            }
          }
        }

        if (boxBottom && boxTop && midLine) {
          if (boxBottom.val == boxTop.val) {
            quartilesObj.push({
              'pair' : [boxBottom, boxBottom],
              'midLine': null,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val]
            });
          } else if (midLine.val == boxTop.val || midLine.val == boxBottom.val) {
            quartilesObj.push({
              'pair' : [boxTop, boxBottom],
              'midLine': null,
              'ctx' : [boxTop.ctx, boxBottom.ctx],
              'val' : [boxTop.val, boxBottom.val]
            });
          } else {
            quartilesObj.push({
              'pair' : [boxTop, midLine],
              'midLine': midLine,
              'ctx' : [boxTop.ctx],
              'val' : [boxTop.val]
            });
            quartilesObj.push({
              'pair' : [midLine, boxBottom],
              'midLine': midLine,
              'ctx' : [boxBottom.ctx],
              'val' : [boxBottom.val]
            });
          }
        }
        
        boxplotData.push(box);
      }
    }
      
    function chart(selection) { 
      
      selection.each(function() {
          
        boxNumber = 1, boxGroupNumber = seriesData.length, boxWidth = 8 * (xScale.rangeBand()) / (9 * boxNumber + 7);
  
          var svg = sWrapper = d3.select(this);
          svg.selectAll('g.box').remove();
          
          if(decorativeShape == null){
            decorativeShape = svg.append('rect').attr('width', xScale.rangeBand() - boxWidth/2).attr('height', height).style('visibility', 'hidden').attr('fill', 'rgba(133,133,133, 0.2)');
          }else{
            decorativeShape.attr('width', xScale.rangeBand() - boxWidth/2).attr('height',height).style('visibility', 'hidden');
          }
          
          var boxGroup = svg.selectAll('g.box').data(seriesData);

          boxGroup.enter().append('g');
        boxGroup.attr('class', 'box').each( function(boxData, outerIndex) {
              
            if (boxData.length == 0) {
              boxplotData.push({});
              return;
            }
            
            boxData = boxData.sort(function(aObj, bObj) { return aObj.val - bObj.val; });
    
                var arrLength = boxData.length, min = boxData[0], max = boxData[arrLength - 1];
    
                setDistribution(boxData);
    
                var outLiersSelector = d3.select(this).selectAll('circle.outliers').data(outLiersObj);
                outLiersSelector.enter().append('circle');
                outLiersSelector.attr('cx', function(outLier) {
                  var x = xScale(outerIndex) + boxWidth;
                  return x;
                })
                .attr('cy', function(outLier, num) {
                  var y = yScale(outLier.val);
                  return y;
                })
                .attr('r', '2')
                //.attr('shape-rendering', 'crispEdges')
                .attr('stroke', effectManager.register(
                                                    {
                                                  drawingEffect : 'normal',
                                                  fillColor : outLierLayout.color
                                                }
                                                      )
             )
                .attr('stroke-width', outLierLayout.width)
                .attr('fill', 'none')
                .attr('class', 'datapoint outliers');
                
                outLiersSelector.exit().remove();

                var quartileSelector = d3.select(this).selectAll('rect.quartile').data(quartilesObj);
                quartileSelector.enter().append('rect');
                quartileSelector.attr('x', function(quartile) {
                  var x = xScale(outerIndex) + boxWidth / 2;
                  return x;
                })
                .attr('y', function(quartile, num) {
                  var y = yScale(quartile.pair[0].val);
                  return y;
  
                })
                .attr('width', boxWidth)
                .attr('height', function(quartile, num) {
                  var height = 0;
                  var pairDiff = quartile.pair[1].val - quartile.pair[0].val;
                  if (pairDiff == 0) {
                    height = 1;
                  } else {
                    height = yScale(quartile.pair[1].val) - yScale(quartile.pair[0].val);
                  }
  
                  return height;
                })
                .attr('shape-rendering', 'crispEdges')
                .attr( 'fill', function(d){
                  var parameter = {
                      drawingEffect : drawingEffect,
                      fillColor : boxColorPalette[outerIndex % boxColorPalette.length],
                      direction : 'horizontal'
                    };
            return effectManager.register(parameter);   
                })
                .attr('stroke-width', quartileLayout.width)
                //.attr('stroke', '#000000')
                .attr('class', 'datapoint quartile');
                
                if (quartilesObj.length == 2) {
                  var midLineXStart = xScale(outerIndex) + boxWidth / 2;
                  var midLineXEnd = midLineXStart + boxWidth;
                  var midLineYStart = midLineYEnd = yScale(quartilesObj[0].midLine.val);
                  var lineSelector = d3.select(this);
                    lineSelector.append('line')
                    .attr('x1', midLineXStart)
                    .attr('y1', midLineYStart)
                    .attr('x2', midLineXEnd)
                    .attr('y2', midLineYEnd)
                    .attr('stroke', '#ffffff')
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'midline');
                }
                
                quartileSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.rectlowwhisker').data(lowWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector.attr('x', function(whisker) {
                  var x = xScale(outerIndex) + boxWidth / 2;
                  horizontalLineXStart = x;
                  horizontalLineXEnd = x + boxWidth;
                  verticalLineXStart = verticalLineXEnd = x + boxWidth / 2;
                  return x;
                  })
                  .attr('y', function(whisker) {
                    var tmpPair = whisker.pair;
                    var y = yScale(tmpPair[0].val);
                    verticalLineYStart = y;
                    horizontalLineYStart = horizontalLineYEnd = yScale(tmpPair[1].val);
                    return y;
                  })
                  .attr('width', boxWidth)
                  .attr('height', function(whisker) {
                    var height = yScale(whisker.pair[1].val) - yScale(whisker.pair[0].val);
                    verticalLineYEnd = yScale(whisker.pair[1].val);
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', verticalLineXStart)
                    .attr('y1', verticalLineYStart)
                    .attr('x2', verticalLineXEnd)
                    .attr('y2', verticalLineYEnd)
                    .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'lineverticallowwhisker');
                    
                    var lineSelector = d3.select(this.parentNode);
                    lineSelector.append('line')
                    .attr('x1', horizontalLineXStart)
                    .attr('y1', horizontalLineYStart)
                    .attr('x2', horizontalLineXEnd)
                    .attr('y2', horizontalLineYEnd)
                    .attr('stroke', function(d){
                          var parameter = {
                         drawingEffect : 'normal',
                         fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                        };
                                   return effectManager.register(parameter);  
                                }
                         )
                    .attr('stroke-width', 1)
                    .attr('shape-rendering', 'crispEdges')
                    .attr('class', 'linehorizontallowwhisker');
                    return height;
                    })
                  .attr('shape-rendering', 'crispEdges')
                  .attr('fill-opacity', '0')
                  .attr('stroke-width', '0')
                  .attr('class', 'datapoint rectlowwhisker');
                
                whiskerSelector.exit().remove();
    
                var verticalLineXStart = 0, verticalLineYStart = 0, verticalLineXEnd = 0, verticalLineYEnd = 0;
                var horizontalLineXStart = 0, horizontalLineYStart = 0, horizontalLineXEnd = 0, horizontalLineYEnd = 0;
                var whiskerSelector = d3.select(this).selectAll('rect.recthighwhisker').data(highWhiskerObj);
                whiskerSelector.enter().append('rect');
                whiskerSelector
                    .attr('x', function(whisker) {
                      var x = xScale(outerIndex) + boxWidth / 2;
                      horizontalLineXStart = x;
                      horizontalLineXEnd = x + boxWidth;
                      verticalLineXStart = verticalLineXEnd = x + boxWidth / 2;
                      return x;
                      })
                    .attr('y', function(whisker, num) {
                      var tmpPair = whisker.pair;
                      var y = yScale(tmpPair[0].val);
                      verticalLineYStart = y;
                      horizontalLineYStart = horizontalLineYEnd = yScale(tmpPair[0].val);
                      return y;
                      })
                    .attr('width', boxWidth)
                    .attr('height', function(whiskersObj, num) {
                      var height = yScale(whiskersObj.pair[1].val) - yScale(whiskersObj.pair[0].val);
                      verticalLineYEnd = verticalLineYStart + height;
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', verticalLineXStart)
                      .attr('y1', verticalLineYStart)
                      .attr('x2', verticalLineXEnd)
                      .attr('y2', verticalLineYEnd)
                      .attr('stroke', effectManager.register(
                                      {
                                        drawingEffect : 'normal',
                                        fillColor : '#000000'
                                      }
                                    )
                                 )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'lineverticalhighwhisker');
  
                      var lineSelector = d3.select(this.parentNode);
                      lineSelector.append('line')
                      .attr('x1', horizontalLineXStart)
                      .attr('y1', horizontalLineYStart)
                      .attr('x2', horizontalLineXEnd)
                      .attr('y2', horizontalLineYEnd)
                      .attr('stroke', function(d){
                            var parameter = {
                         drawingEffect : 'normal',
                         fillColor : boxColorPalette[outerIndex % boxColorPalette.length]
                        };
                                   return effectManager.register(parameter);  
                                }
                           )
                      .attr('stroke-width', 1)
                      .attr('shape-rendering', 'crispEdges')
                      .attr('class', 'linehorizontalhighwhisker');
                       
                      return height;
                      })
                    .attr('shape-rendering', 'crispEdges')
                    .attr('fill-opacity', '0')
                    .attr('stroke-width', '0')
                    .attr('class', 'datapoint recthighwhisker');
                
                whiskerSelector.exit().remove();
                
                clearBoxData();
          eDispatch.initialized();
          
          });  
          boxGroup.exit().remove();
      });
    return chart;
    };
  
    chart.width = function(value) {
      if (!arguments.length) {
        return width;
      }
      
      width = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };
      
    chart.height = function(value) {
      if (!arguments.length) {
        return height;
      }

      height = value;
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height) && TypeUtils.isExist(seriesData)) {
        makeScales();
      }
      return chart;
    };    
  
    function getTooltipData(index) {
      
      var tooltipData =  {
          'body': [],
          'footer': []
        },
        internalIndex = 0;
      
      if (regionData) {

        var body = {
          'name': null,
          'val': []
        };
        
        internalIndex = index % regionData.length;
        body.name = regionData[internalIndex].name;
  
        if (regionData[internalIndex].label != null && regionData[internalIndex].shape != null && boxColorPalette[internalIndex] != null) {
          var item = {
              'shape': null,
              'color': null,
              'label': null,
              'value': null
            };
          
          item.shape = regionData[internalIndex].shape;
          item.color = boxColorPalette[internalIndex];
          item.label = regionData[internalIndex].label;
          body.val.push(item);
        }
        
        if (boxplotData) {
          
          if (boxplotData[index]) {

            for (var i in boxplotData[index]) {
              var item = {
                  'shape': null,
                  'color': null,
                  'label': null,
                  'value': null
                };
              item.label = i;
              if (boxplotData[index][i]) {
                if (i == 'outLiers(s)') {
                  item.value = boxplotData[index][i];
                } else {
                  item.value = boxplotData[index][i].val;
                }
              }
              body.val.push(item);
            }
          }
        }
        
        tooltipData.body.push(body);
      }
      
      if (dimensionData) {
        internalIndex = Math.floor(index / regionData.length);
        for (var i = 0; i < dimensionData.length; i++) {
          
          if (dimensionData[i].rows.length > 0) {
            var footer = {
                'label': null,
                'value': null
              };
            footer.label = dimensionData[i].col.val;
            footer.value = dimensionData[i].rows[internalIndex].val;
            
            tooltipData.footer.push(footer);
          }
        }
      }
    
      return tooltipData;
    }
    
    function generateTooltipData() {
      
      if (dimensions) {
        for (var i in dimensions) {
          dimensionData = dimensions[i].values;
        }
      }
      
      if (legendData) {
        var legendList = legendData.values;
        if (legendList.length > 1) {
          if (legendList[0].type == 'MND') {
            //mnd scan
            for (var mndIndex = 0; mndIndex < legendList[0].rows.length; mndIndex++) {

              //vertical scan
              for (var m = 0; m < legendList[1].rows.length; m++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.name = legendList[0].rows[mndIndex].val;
                var label = '';
                
                //horizontal scan
                for (var n = 1; n < legendList.length; n++) {
                  var seperator = ' / ';
                  if (n == legendList.length - 1) seperator = '';
                  label += legendList[n].rows[m].val + seperator;
                }
                legendObj.label = label;
                regionData.push(legendObj);
              }    

            }
          } else if (legendList[legendList.length - 1].type == 'MND') {

            for (var m = 0; m < legendList[0].rows.length; m++) {

              var label = '';
              for (var n = 0; n < legendList.length - 1; n++) {
                var seperator = ' / ';
                if (n == legendList.length - 2) seperator = '';
                label += legendList[n].rows[m].val + seperator;              
              }
              

              for (var mndIndex = 0; mndIndex < legendList[legendList.length - 1].rows.length; mndIndex++) {
                var legendObj = {
                    'name': null,
                    'shape': null,
                    'color': null,
                    'label': null
                  };
                legendObj.label = label;
                legendObj.name = legendList[legendList.length - 1].rows[mndIndex].val;
                regionData.push(legendObj);
              }
            }
          } 
        } else {
          for (var m = 0; m < legendList[0].rows.length; m++) {
            var legendObj = {
                'name': null,
                'shape': null,
                'color': null,
                'label': null
              };
            legendObj.name = legendList[0].rows[m].val;
            regionData.push(legendObj);
          }
        }
      }
      
      for (var k = 0; k < regionData.length; k++) {
        //regionData[k].color = boxColorPalette[k % boxColorPalette.length];
        regionData[k].shape = 'squareWithRadius';
      }
    }

    function setElementAttribute(element, attribute, value) {
      if (element) {
        var className = element.getAttribute('class');
        if(className.indexOf('recthighwhisker') == -1 && className.indexOf('rectlowwhisker') == -1
           && className.indexOf('linehorizontalhighwhisker') == -1 && className.indexOf('lineverticalhighwhisker') == -1
           && className.indexOf('linehorizontallowwhisker') == -1 && className.indexOf('lineverticallowwhisker') == -1) {
          element.setAttribute(attribute, value);
        }else if (className.indexOf('recthighwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('linehorizontalhighwhisker') != -1 || nodeClassName.indexOf('lineverticalhighwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }
        } else if(className.indexOf('rectlowwhisker') != -1) {
          var nodeList = element.parentNode.querySelectorAll('line');
          if (nodeList) {
            for (var j = 0, nodeListLen = nodeList.length; j < nodeListLen; j++) {
              var nodeClassName = nodeList[j].getAttribute('class');
              if (nodeClassName.indexOf('linehorizontallowwhisker') != -1 || nodeClassName.indexOf('lineverticallowwhisker') != -1) {
                nodeList[j].setAttribute(attribute, value);
              }
            }
          }        
        }      
      }
    }
    
      chart.parent = function(){
        return sWrapper;
      };
      
      chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, elemsLen = elems.length; i < elemsLen; i++) {
          var item = elems[i];
          setElementAttribute(item, 'opacity', 1);
          }
        }else{
        setElementAttribute(elems, 'opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
          var item = elems[i];
          setElementAttribute(item, 'opacity', 0.2);
          }
        }else{
        setElementAttribute(elems, 'opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          sWrapper.selectAll('.datapoint').attr('opacity', 1);
          sWrapper.selectAll('.lineverticallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.lineverticalhighwhisker').attr('opacity', 1);
          sWrapper.selectAll('.linehorizontallowwhisker').attr('opacity', 1);
          sWrapper.selectAll('.linehorizontalhighwhisker').attr('opacity', 1);
        }else{
          sWrapper.selectAll('.datapoint').attr('opacity', 0.2);
          sWrapper.selectAll('.lineverticallowwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.lineverticalhighwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.linehorizontallowwhisker').attr('opacity', 0.2);
          sWrapper.selectAll('.linehorizontalhighwhisker').attr('opacity', 0.2);
        }
        
        sWrapper.selectAll('.recthighwhisker').attr('opacity', 0);
        sWrapper.selectAll('.rectlowwhisker').attr('opacity', 0);
      };
  
      chart.hoverOnPoint = function(point){
        var xOnModule = point.x, yOnModule = point.y;
      // find the closet dimension
      var i = -1;
      while (i < seriesData.length) {
        if (Math.abs(xOnModule - xScale.rangeBand()*i - 0.5 * xScale.rangeBand() ) <= 0.5 * xScale.rangeBand()) {
          break;
        }
        i++;
      }

      if (i > (seriesData.length - 1)
          || i < 0) {
        decorativeShape.style(
            'visibility', 'hidden');
        return;
      }
      
      decorativeShape.attr(
          'x',
          xScale.rangeBand() * i + boxWidth/4).style(
          'visibility', 'visible');
      
      if(lastHovered !== i){
        if (tooltipVisible) {
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element.
          var transform = sWrapper[0][0].getTransformToElement(sWrapper[0][0].ownerSVGElement);
          var xoffset = transform.e;

          var tooltipData = getTooltipData(i);
          
          tooltipData.point = {
              x: xScale.rangeBand()*i + 0.5 * xScale.rangeBand() + xoffset,
              y: d3.event.layerY
              };
          tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : width,
                        height : height
                    };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
        }
      }
      
      };
  
      chart.blurOut = function(){
        decorativeShape.style('visibility', 'hidden');
        lastHovered = null;
      if (tooltipVisible) {
          eDispatch.hideTooltip();
      }
      };
      
      function makeSubGroup(row, start, end, groups, parentGroupIndex) {
      if (row && start <= end && end < row.length) {
        var subStart = subEnd = pos = start;
        while (pos <= end) {
          while (((pos+1) <= end) && (row[pos + 1].val == row[pos].val)) {
            subEnd++;
            pos++;
          }
            
          groups.push({
            'val': row[subStart],
            'parentGroupIndex': parentGroupIndex,
            'start': subStart,
            'end': subEnd
          });
          pos++;
          subStart = subEnd = pos;
        }          
      }
    }

    
    function generateGroup(row) {
      var curGroups = [];
      if (row) {
        var mapLen = dimensionGroup.length;
        var preGroups = mapLen > 0?dimensionGroup[mapLen - 1].val : null;
        if (preGroups) {
          for (var i = 0, len = preGroups.length; i < len; i++) {
            var preGroup = preGroups[i];
            var start = preGroup.start;
            var end = preGroup.end;
            makeSubGroup(row, start, end, curGroups, i );
          }
        } else {
          makeSubGroup(row, 0, row.length - 1, curGroups, null);
        }
      }
      return curGroups;
    }

    function dataTransform(originalData) {
      if (originalData) {
        var originalDimension = originalData.getAnalysisAxisDataByIdx(0);
        legendData = originalData.getAnalysisAxisDataByIdx(1);
        if (originalDimension) {
          var len = originalDimension.values.length;
          if (len == 1) {
            dimensionGroup.push({'col': originalDimension.values[0].col.val, 'val': []});
          } else {
            for (var i = 0; i < len - 1; i++) {
              var row = originalDimension.values[i].rows;
              dimensionGroup.push({'col': originalDimension.values[i].col.val, 'val': generateGroup(row)});
            }
          }
        }
      }
    }
    
    function caculateLeavesNum(start, end) {
      
      var len = dimensionGroup.length, num = 0, index = 0, leavesGroups = dimensionGroup[len - 1].val;
      while (leavesGroups[index].start != start) {
        index++;
      }      
      while (leavesGroups[index].end != end) {
        num++;
        index++;
      }
      num++;
      return num;
    }

    function generateDimensions() {
      if (dimensionGroup) {
        var len = dimensionGroup.length, groups = null;
        
        groups = dimensionGroup[len - 1].val;
        if (groups.length == 0) {
          dimensionDomain.push(0);
          dimensionDomain.push(1);
        } else {
          for (var i = 0, lenScale = groups.length; i < lenScale; i++) {
            dimensionDomain.push(i);
          }
        }
        
        if (groups.length == 0) {
          dimensions['sap.viz.modules.verticalboxplot.dimension'].values = [{'col': {'val': dimensionGroup[len - 1].col}, 'rows': []}];
        } else {
          
          var scaleValues = [];
          for (var j = 0; j < len; j++) {
            var obj = {
              'col': {'val': ''},
              'rows': []
            };
            obj.col.val = dimensionGroup[j].col;
            var rowGroups = dimensionGroup[j].val;
            for (var k = 0,  lenRowGroups =  rowGroups.length; k < lenRowGroups; k++) {
              var start = rowGroups[k].start, end = rowGroups[k].end, num = caculateLeavesNum(start, end);
              for (var m = 0; m < num; m++) {
                obj.rows.push({'val': (rowGroups[k].val.val == null)?defaultString:rowGroups[k].val.val});
              }
            }
            
            scaleValues.push(obj);
          }
              
          dimensions['sap.viz.modules.verticalboxplot.dimension'].values = scaleValues;
        }        
      }      
    }
    
    function createColorPalette(length) {
      boxColorPalette = [];
      if (colorPalette.length > 0) {
        for( var i = 0; i < length; ++i) {
          boxColorPalette.push(colorPalette[i % colorPalette.length]);
        }
      }
    }
    
      function parseOptions(){  
      tooltipVisible = _properties.tooltip.enabled;
        colorPalette = _properties.colorPalette;
        drawingEffect = _properties.drawingEffect;
      }
      
    chart.data = function(value) {
      if (!arguments.length) {
        return _data;
      }
      
      clearGlobalData();
      parseOptions();
      
      _data = value;
        var obj = MNDHandler(_data);
        dataTransform(_data);
        dataMG1 = obj["MG1"];
        
      var len = dataMG1.length;
      var groups = dimensionGroup[dimensionGroup.length - 1].val;
      if (groups.length != 0) {
        for (var i = 0, groupsLen = groups.length; i < groupsLen; i++) {
          var start = groups[i].start, end = groups[i].end;
          for (var j = 0; j < len; j++) {
            var row = [], left = start, right = end;
            for (;left <= right; left++) {
              if (!NumberUtils.isNoValue(dataMG1[j][left].val))
                row.push(dataMG1[j][left]);
            }
            seriesData.push(row);
          }
        }
      } else {
        for (var j = 0; j < len; j++) {
          var row = [];
          for (var m = 0; m < dataMG1[j].length; m++) {
            if (!NumberUtils.isNoValue(dataMG1[j][m].val)) {
              row.push(dataMG1[j][m]);
            } 
          }
          seriesData.push(row);
        }
      }
        
      locateBoundary(seriesData);
      generateDimensions();
      
      if (TypeUtils.isExist(width) && TypeUtils.isExist(height)) {
        makeScales();
      }
      
      generateTooltipData();
            createColorPalette(regionData.length);
      
      return chart;
    };
    
    chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  _data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
    chart.properties = function(props){

        if (!arguments.length){
          return _properties;
         }
      
      _properties = manifest.props(props);
            parseOptions();
            createColorPalette(regionData.length);
            
         return chart;        
      };
    
    chart.categoryScale = function(scale){
      if (!arguments.length){
        return xDimensionScale;
      }
      xDimensionScale = scale;
      return chart;
     };
     
     chart.primaryScale = function(scale){
       if (!arguments.length){
         return yScale;
       }
       yScale = scale;
       return chart;
     };
  
    chart.colorPalette = function(Palette){
      if (!arguments.length){
        return colorPalette;
      }
      colorPalette = Palette;
      return chart;
     };
  
     chart.dispatch = function(_){
        if(!arguments.length)
          return eDispatch;
        eDispatch = _;
        return this;
      };
      
      /***
       * set/get effect manager
     ***/
    chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return this;        
     };
    _properties = manifest.props(null);
    return chart;
  };

  return boxplot;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.VerticalBoxplot',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.verticalboxplot',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
  var module = {
    'id' : 'sap.viz.modules.verticalboxplot',
    'name' : 'vertical boxplot',
    base : "sap.viz.modules.xy.base",
    'properties' : { 
          'secondaryValuesColorPalette' : null,
          'tooltip' : {
            'name' : 'tooltip',
            'supportedValueType' : 'Object',
            'supportedValues' : {
              'enabled' : {
                'name' : 'enabled',
                'supportedValueType' : 'Bool',
                'defaultValue' : true,
                'description' : 'Set enabled/disabled tooltip.'
              }
            },
            'isExported' : false,
            'description' : 'Settings for tooltip related properties.'
          }
    },
    'feeds' : {
      configure : {
          secondaryValues:null,
          axisLabels:{
          acceptMND: -1,
          min : 1,
          max : 1
        }
      }
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.VerticalBoxplotChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBoxplot',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/boxplot',
      name : 'IDS_VERTICALBOXPLOTCHART',
      base : 'riv/baseverticalchart',
      modules : {
          tooltip : {
              id : 'sap.viz.modules.tooltip',
              configure : {
                propertyCategory : 'tooltip',
                properties : {
                  chartType : 'verticalboxplot',
                  orientation : 'left'
                }
              }
          },
          main : {
              modules : {
                xAxis : {
                  id : 'sap.viz.modules.axis',
                  configure : {
                    properties : {
                      isIndependentMode : true
                    }
                  }
                },
                plot : {
                    id : 'sap.viz.modules.verticalboxplot',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              },
              controllers : {
                'interaction' : {
                    id : 'sap.viz.modules.controller.interaction',
                    configure : {
                          propertyCategory : 'interaction'
                    }
                }
              }
          }
      },

     dependencies : {
       attributes : [ {
         targetModule : 'main.yAxis',
         target : 'scale',
         sourceModule : 'main.plot',
         source : 'primaryScale'
          },{
         targetModule : 'main.yAxis',
         target : 'title',
         sourceModule : 'main.plot',
         source : 'primaryAxisTitle'
          },{
            targetModule : 'main.xAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'categoryScale'
          },{
              targetModule : 'main.xAxis',
              target : 'independentData',
              sourceModule : 'main.plot',
              source : 'dimensionData'
          },{
            targetModule : 'legend',
            target : 'colorPalette',
            sourceModule : 'main.plot',
            source : 'colorPalette'
          },{
            targetModule : 'legend',
            target : 'setSelectionMode',
            sourceModule : 'main.interaction',
            source : 'getSelectionMode'
          } ],
           events : [ {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
          }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
          }, {
            targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
          }
          ]
        }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.combination',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {

  var module = {
    base : "sap.viz.modules.xy.base",
    'id' : 'sap.viz.modules.combination',
    'name' : 'combination',
    'properties' : {
    'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Bool',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled data loading animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
     },
     'bar' : {
          'name' : 'bar',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'isRoundCorner' : {
            'name' : 'isRoundCorner',
            'supportedValueType' : 'Boolean',
            'defaultValue' : false,
            'description' : 'Set enable/disable round corner of bar.'
          }
          },
          'description' : 'Settings for bar properties.'     
     }, //bar
     'line' : {
          'name' : 'line',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'width' : {
            'name' : 'width',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : 2,
            'description' : 'Set width of line, range[1,7]. When beyond the range, the line width is default size 2.'
          },
          'marker' : {
            'name' : 'marker',
            'description' : 'Set marker/data point graphics settings.',
            'supportedValueType' : 'Object',
            'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Bool',
              'defaultValue' : false,
              'description' : 'Set to show marker or not.'
            },
            'shape' : {
              'name' : 'shape',
              'supportedValueType' : 'StringArray',
              'supportedValues' : ['circle', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection'],
              'defaultValue' : 'circle',
              'description' : 'Set marker shapes for chart.'
            },
            'size' : {
              'name' : 'size',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : "6",
              'min' : '4',
              'max' : '32',
              'description' : 'Set marker size of data point.'
            }
            }
              }
            },
        'description' : 'Settings for line properties.'
       } //line
    }, 
    fn : fn,
    'feeds' : {
      configure : {
        'secondaryValues':
        {
          max:0
        }
      }
  }
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.horizontalcombination',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {

  var module = {
    base : "sap.viz.modules.combination",
    'id' : 'sap.viz.modules.horizontalcombination',
    'name' : 'horizontalcombination',
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.line',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, Repository) 
{
  return function(manifest) 
  {
    var width, height;
    var data_ = null, props;
    //alistar zhu
    var randomSuffix = Repository.newId();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "#cccccc";
    var selectedColor = "#333333";
    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgLinesGroup, svgLightLinesGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    var hasMND;
    var bMNDOnColor;
    var bMNDInner;
    var effectManager = null;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };

    var valueAxis2Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };
    var colorPalette = [];
    var PREFIXAXIS1 = 'axis1';
    var PREFIXAXIS2 = 'axis2';

    var bAnimationComplete = false;
    var enableDataLoadingAnimation = true;

    var selectedMarkerNum = 0;

    // clip defs for enimation

    var clipRect;
    
    var OPACITY = 0.4;
    function line(selection) {
      //selection.each(generate);
      
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      return line;
    }

    line.width = function(value) {
      if (!arguments.length)
        return width;
      width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };

    line.height = function(value) {
      if (!arguments.length)
        return height;
      height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return line;
    };
    

    /*;
     * get/set properties
     */
    line.properties = function(_) {
      if (!arguments.length)
        return props;
        
      props = manifest.props(_);
      if(props.marker.size < 4 || props.marker.size > 32) props.marker.size = 6;
      if(props.width < 1 || props.width > 7) props.width = 2;
      enableDataLoadingAnimation =  props.animation.dataLoading;
      
      getCSSStyle();

      createColorPalette();
      return line;
    };
    
     line.primaryAxisColor = function(){
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
          return effectManager.register({graphType:"line", fillColor: valueAxis1Data.colorPalette[0]});
        }else{
          return null;
        }
      };
        
      line.secondAxisColor = function(){
        return effectManager.register({graphType:"line", fillColor:  valueAxis2Data.colorPalette[0]});
      };     
        
    /**
     * get/set your event dispatch if you support event
     */
    line.dispatch = function(_){
      if(!arguments.length)
        return eDispatch;
      eDispatch = _;
      return line;
    };
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    line.data = function(value){
      if (!arguments.length){
        return data_;
      }
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      valueAxis2Data.data = obj["MG2"];

      hasMND = obj["hasMND"];
      bMNDOnColor = obj["MNDOnColor"];
      bMNDInner = obj["MNDInner"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_))
        computeScales();
      createColorPalette();
      return line;        
    };
    
    line.shapePalette = function(_){
        if(!arguments.length){
          return shapePalette;
        }
        shapePalette = _;
        return this;
      };
      
      line.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      line.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
    /**
     * set/get effect manager
     */
    line.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return line;        
     };
     
    /**
     * get color palette
     */
    line.getColorPalette = function() {
      if(colorPalette.length == 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };

    line.shapePalette = function(){
      if(!arguments.length)
        return [props.marker.shape];
      return line;
    };

    line.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return line;
    };

    line.secondaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis2Data.scale;
      }
      valueAxis2Data.scale = scale;
      return line;
    };

    line.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return line;

    };

    line.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis1Data.scale.domain()[0],
          max: valueAxis1Data.scale.domain()[1]
        };
      }
      valueAxis1Data.topValue = range.max;
      valueAxis1Data.bottomValue = range.min;

      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        valueAxis1Data.scale.domain([valueAxis1Data.bottomValue, valueAxis1Data.topValue]).range ([height, 0]).nice();
        Scaler.perfect(valueAxis1Data.scale);
      }
      return line;
    };

    line.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis2Data.scale.domain()[0],
          max: valueAxis2Data.scale.domain()[1]
        };
      }
      valueAxis2Data.topValue = range.max;
      valueAxis2Data.bottomValue = range.min;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        valueAxis2Data.scale.domain([valueAxis2Data.bottomValue, valueAxis2Data.topValue]).range ([height, 0]).nice();
        Scaler.perfect(valueAxis2Data.scale);
      }
      return line;
    };
    line.parent = function() { 
      return g;
    };

    /**
     * get/set size
     */
    line.size = function(w, h) {
      if (arguments.length == 0)
        return {
          width : line.width(),
          height : line.height()
        };
      line.width(w).height(h);
      return line;
    };
    
    line.clear = function (gray) {
      deselectedAllHandler();
      if (gray == null){
        lightAll();
      } else {
        grayAll();
      }
    };

    line.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        if(!processOneAxisSelect(valueAxis1Data, marker ))
          processOneAxisSelect(valueAxis2Data, marker );

      }
    };

    line.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];

        if(!processOneAxisDeselect(valueAxis1Data, marker))
          processOneAxisDeselect(valueAxis2Data, marker);
      }

    };
    
    line.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if(point0 < 0 || point0 > width)
        return;

      var xIndex = getCategoryIndex(point0);
      if(preHighLightIndex == xIndex) return;
      var xCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      changeGroupMarker(xIndex, "visible", bgColor);  

      preHighLightIndex = xIndex;


      if (props.hoverline.visible) {
        mouseMoveLine.attr("x1", xCoord).attr("x2", xCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }

      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        pt.x = xScale(xIndex) + xScale.rangeBand() / 2 + matrix.e;
        pt.y = height / 4 + matrix.f;
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
          x : matrix.e,
          y : matrix.f,
          width : width,
          height : height
        };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }

    };

    line.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    
    props = manifest.props(null);
    return line;

    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length == 0)
        return;
      minMax.max = Number(d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      }));
      minMax.min = Number(d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      }));
      
      if(NumberUtils.isNoValue(minMax.max )) return null;
      
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / height ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5/ height;
      }else{
        var temp = (minMax.max - minMax.min) * 5 / height;
        minMax.min -= temp;
        minMax.max += temp;
      }
    
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
    
      if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        valueAxis1Data.colorPalette = props.primaryValuesColorPalette;
      else 
        valueAxis1Data.colorPalette = props.colorPalette;
      
      valueAxis2Data.colorPalette = props.secondaryValuesColorPalette;
      
      if (hasMND && bMNDOnColor && bMNDInner) {
        var dva1 = data_.getMeasureValuesGroupDataByIdx(0);
        var dva2 = data_.getMeasureValuesGroupDataByIdx(1);
        var mg1mNum=0, mg2mNum=0, mNum=0, colorAxisDataNum=0;
        if (dva1 && dva1.values.length>0) { 
          mg1mNum = dva1.values.length;
          colorAxisDataNum = dva1.values[0].rows.length;
        }
        if (dva2 && dva2.values.length>0) {
          mg2mNum = dva2.values.length;
          colorAxisDataNum = dva2.values[0].rows.length;
        }

        for (var i=0; i<colorAxisDataNum; i++) {
          for (var j=0; j<mg1mNum; j++) {
            colorPalette.push(valueAxis1Data.colorPalette[i*mg1mNum+j % valueAxis1Data.colorPalette.length])
          }
          for (var j=0; j<mg2mNum; j++){
            colorPalette.push(valueAxis2Data.colorPalette[i*mg2mNum+j % valueAxis2Data.colorPalette.length])
          }
        }
      } else {
        for( var i = 0; i < valueAxis1Data.data.length; ++i)
          colorPalette.push(valueAxis1Data.colorPalette[i % valueAxis1Data.colorPalette.length]);
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        {
          for( var i = 0; i < valueAxis2Data.data.length; ++i)
            colorPalette.push(valueAxis2Data.colorPalette[i % valueAxis2Data.colorPalette.length]);
        }
      }
    }

    function calculateScale(axisValue)
    {
      if(axisValue.data && axisValue.data.length > 0)
      { 
        if(axisValue.topValue == null)
        {
          var minMax = calculateMinMax(axisValue);
          if(!minMax)
            axisValue.scale.domain([0, 0]).range ([height, 0]);
          else  
            axisValue.scale.domain([minMax.min, minMax.max]).range ([height, 0]).nice();
        }
        else
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([height, 0]).nice();
        Scaler.perfect(axisValue.scale);
      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    };

    function computeScales()
    {
      var domain = [];
      var categoryNum = 0;
      if (valueAxis1Data.data.length != 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([0, width]);
      calculateScale(valueAxis1Data);
      calculateScale(valueAxis2Data);
      if (valueAxis1Data.data && valueAxis1Data.data.length > 0 &&
        valueAxis2Data.data && valueAxis2Data.data.length > 0) {
        Scaler.perfectDual(valueAxis1Data.scale, valueAxis2Data.scale);
      }
    };

    function changeGroupMarker(groupIndex, visible, borderColor)
    {
      if(groupIndex == undefined || groupIndex == null)
        return;

      for(var seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis1Data);
          if(!props.marker.visible)
          {
            if(selectedMarkerNum > 0)
              d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
            else
              d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
          }
        }
      }  

      if(!valueAxis2Data.data) return;

      for(var seriesIndex = 0; seriesIndex < valueAxis2Data.data.length; ++seriesIndex)
      {
        if(!valueAxis2Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis2Data);
          if(!props.marker.visible)
          {
            if(selectedMarkerNum > 0)
              d3.select(valueAxis2Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
            else
              d3.select(valueAxis2Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
          }
        }
      }
    };

    function changeOneMarker(seriesIndex, xIndex, borderColor, valueAxis)
    {
      d3.select(valueAxis.markers[seriesIndex][xIndex]).attr("stroke",  borderColor);
    };

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (valueAxis1Data.data.length != 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      if(index > categoryNum - 1) index = categoryNum - 1;
      if(index < 0) index = 0;
      return index;
    };

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] == marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }

      changeOneMarker(yi, xi, selectedColor, valueAxis);
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", 1).attr("visibility", "visible");
      valueAxis.selectedMarkers[yi][xi] = true;
    
      if(xi > 0 && valueAxis.selectedMarkers[yi][xi - 1])
        valueAxis.highLines[yi][xi - 1].attr("visibility", "visible");
      if(xi < valueAxis.highLines[0].length && valueAxis.selectedMarkers[yi][xi + 1])
        valueAxis.highLines[yi][xi].attr("visibility", "visible");
      
      ++selectedMarkerNum;
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] == marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi == preHighLightIndex){
        changeOneMarker(yi, xi, bgColor, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, props.style.marker.stroke, valueAxis);
      }
      
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", OPACITY);
      if(!props.marker.visible && xi != preHighLightIndex)
        d3.select(valueAxis.markers[yi][xi]).attr("visibility", "hidden");
      valueAxis.selectedMarkers[yi][xi] = false;
    
      if(xi > 0 && valueAxis.selectedMarkers[yi][xi - 1])
        valueAxis.highLines[yi][xi - 1].attr("visibility", "hidden");
      if(xi < valueAxis.highLines[0].length && valueAxis.selectedMarkers[yi][xi + 1])
        valueAxis.highLines[yi][xi].attr("visibility", "hidden");
  
      --selectedMarkerNum;
    }

    

    function processNullValue(axisValue)
    {
      var result = {
          data:[],
          color:[]
      };

      for(var i = 0; i < axisValue.length; ++i)
      {
        var preIndex = 0;
        for(var j = 0; j < axisValue[i].length; ++j)
        {
          if(NumberUtils.isNoValue(axisValue[i][j].val))
          {
            if(j > preIndex)
            {
              var arr = [];
              for(var k = preIndex; k < j; k++)
              {
                var obj = axisValue[i][k];
                obj.x = k;  
                arr.push(obj);
              }
              result.data.push(arr);
              result.color.push(i);
            }
            preIndex = j + 1;
          }
        }
        
        if(preIndex < axisValue[i].length)
        {
          var arr = [];
          for(var k = preIndex; k <  axisValue[i].length; k++)
          {
            var obj = axisValue[i][k];
            obj.x = k;
            arr.push(obj);
          }
          result.data.push(arr);
          result.color.push(i);
        }
      }
      return result;
    };
    
    function processOneAxis(axisValue, prefix)
    {
      if(axisValue.data == null || axisValue.data.length == 0)
        return;
      var axisGroup = svgLinesGroup.select("g." + prefix);
      if(axisGroup.empty())
      {
        axisGroup = svgLinesGroup.append("svg:g").attr("class", prefix);
      }
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      var result = processNullValue(axisValue.data);
      
      var lines = axisGroup.selectAll("." + "lines").data(result.data);
      
      lines.enter().append("path").attr('class', "lines")
        .attr("stroke-width", props.width).attr("stroke-linejoin", "round");
      lines.exit().remove();

      var line = d3.svg.line().x(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).
      y(function(d) {  return axisValue.scale(d.val); });
      
      
      lines.attr("transform", 
          function(d, i) {
            d3.select(this).attr("d", line(d))
            .attr("stroke",  function (){
                var para = { graphType:"line", 
                fillColor:axisValue.colorPalette[result.color[i] %  axisValue.colorPalette.length]};
                return effectManager.register(para);
                });
      });
      
      // draw highlight lines
      var lightLineGroup = svgLightLinesGroup.selectAll("g." + prefix);
      if(lightLineGroup.empty())
      {
        lightLineGroup = svgLightLinesGroup.append("svg:g").attr("class", prefix);
      }
      var groups = lightLineGroup.selectAll("g").data(axisValue.data);
      groups.enter().append("g");
      groups.exit().remove();
      axisValue.highLines = [];
      groups.attr("transform", function(d,i) {
        d3.select(this).selectAll(".lightLine").remove();
        axisValue.highLines.push([]);
        for(var j = 1 ; j < d.length; ++j)
        {
          if(NumberUtils.isNoValue(d[j].val) || NumberUtils.isNoValue(d[j-1].val) )
            axisValue.highLines[i].push(null);
          else
            axisValue.highLines[i].push(d3.select(this).append("svg:line").attr("class", "lightLine").attr("x1",  xScale(j-1) + xScale.rangeBand() / 2).
              attr("y1",axisValue.scale(d[j-1].val)).attr("x2",xScale(j) + xScale.rangeBand() / 2).attr("y2", axisValue.scale(d[j].val))
              .attr("stroke-width", props.width).attr("stroke",  
                  axisValue.colorPalette[i %  axisValue.colorPalette.length]).attr("visibility", "hidden"));
        }
      });
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
      var markerGroup = svgMarkersGroup.select("g." + prefix);
      if(markerGroup.empty())
        markerGroup = svgMarkersGroup.append("svg:g").attr("class", prefix);
      groups = markerGroup.selectAll("g.marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible)
        visible  = "visible";
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".datapoint").data(d);
        DrawUtil.createElements(seriesMarkers.enter(),{shape: props.marker.shape, className: "datapoint"} );
        seriesMarkers.exit().remove();
        var markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(this);
        
          var parameter = {
              drawingEffect:props.drawingEffect,
              graphType: props.marker.shape,
              fillColor : axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction : 'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              node:d3.select(this),
              visibility: visible
          };

          DrawUtil.drawGraph(parameter, effectManager);
          return  "translate(" + (xScale(index) + xScale.rangeBand() / 2) + "," + axisValue.scale(point.val) + ")";  
        });

        axisValue.markers.push(markerArr); 
      });

    };

    function processOneAxisDeselectAll(valueAxis, xIndex)
    {
      if(selectedMarkerNum == 0 || !valueAxis.selectedMarkers || valueAxis.selectedMarkers.length == 0)
        return;

      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) continue;
          
          if(groupIndex == xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, bgColor, valueAxis);
            if(!props.marker.visible)
              d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", "visible");
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, props.style.marker.stroke, valueAxis);
            if(!props.marker.visible)
              d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("visibility", "hidden");
          }
        
          valueAxis.selectedMarkers[seriesIndex][groupIndex] = false;
        }
      }
    }

    function deselectedAllHandler()
    {
      var xpoint = d3.event.clientX - g.node().getBoundingClientRect().left;
      var xIndex = getCategoryIndex(xpoint);

      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      processOneAxisDeselectAll(valueAxis2Data, xIndex);
      selectedMarkerNum = 0;
    }

    
    function renderChart(selection)
    {  
  
      if(!g) g = selection.append("svg:g");

      if(!mouseMoveLine) mouseMoveLine = g.append("svg:line");
      mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", height)
      .attr("stroke-width", 1).attr("stroke", hoverColor)
      .attr("visibility", "hidden").attr("stroke-linejoin", "round");


      if(!svgLinesGroup)
      {
        svgLinesGroup = g.append("svg:g").attr("class", "datalines");
        svgLightLinesGroup = g.append("svg:g").attr("class", "lightLines");
        svgMarkersGroup = g.append("svg:g").attr("class", "markers");
      }
      selectedMarkerNum = 0;
      lightAll();
      

      if(!clipRect)
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
        
      clipRect
        .attr("x", 0).attr("y", 0).attr("height", height).attr("width", (enableDataLoadingAnimation ? 0 : width));

      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLightLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      if(enableDataLoadingAnimation )
      {
        bAnimationComplete = true;
        var totalNumber = 0;
        var interval = width / 50;
        var func = setInterval(function(d){
          if(totalNumber >= width)
          {
            clearInterval(func);
            eDispatch.initialized();
          }
          else
          {
            totalNumber += interval;
            clipRect.attr("width", totalNumber);
          }
        },
        20);
      }else {
          eDispatch.initialized();
          clipRect.attr("width", width);
      }
        
      processOneAxis(valueAxis1Data, PREFIXAXIS1);
      processOneAxis(valueAxis2Data, PREFIXAXIS2);
    };

    function lightAll() {
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS1).selectAll(".lightLine").attr("visibility", "hidden");
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS2).selectAll(".lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", 1);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.marker").selectAll(".datapoint").attr("opacity", 1);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.marker").selectAll(".datapoint").attr("opacity", 1);
    }

    function grayAll() {
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS1).selectAll(".lightLine").attr("visibility", "hidden");
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS2).selectAll(".lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.marker").selectAll(".datapoint").attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.marker").selectAll(".datapoint").attr("opacity", OPACITY);
    }
    
    function getCSSStyle() {
      if (!props.style)
        props.style = {};
        
      var cssDef;
      if (Manifest.get('sap.viz.modules.background')) {
        if (cssDef = Manifest.get('sap.viz.modules.background').style('viz-plot-background')) {
          if (cssDef['fill']) {
            bgColor = cssDef['fill'];
          }
        }
      }
      if (!props.style.marker)
        props.style.marker = {};
      if (cssDef = manifest.style('viz-line-marker')) {
        if (cssDef['stroke']) {
          props.style.marker.stroke = cssDef['stroke'];
        }
      }
    }
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.line',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Base',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.line',
    'name' : 'line',
     base : 'sap.viz.modules.xy.base',
    'properties' : {
    'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Bool',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Settings for tooltip related properties.'
      },
      'width' : {
        'name' : 'width',
        'supportedValueType' : 'PositiveInt',
        'defaultValue' : 2,
        'min' : '1',
        'max' : '7',
        'description' : 'Set width of line, range[1,7]. When beyond the range, the line width is default size 2.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enable/disable data loading animation of plot area.'
            }
          },
          'description' : 'Settings for tooltip related properties.'
     },
      'hoverline' : {
          'name' : 'hoverline',
          'supportedValueType' : 'Object',
          'description' : 'Settings for hoverline properties.',
          'supportedValues' : {
            'visible' : {
              'name' : 'visible',
              'supportedValueType' : 'Bool',
              'defaultValue' : true,
              'description' : 'Set to enabled/disabled hoverline or not.',
            },
          },
      },
      'marker' : {
        'name' : 'marker',
      'description': 'Settings for marker/data point graphics',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Bool',
            'defaultValue' : false,
            'description' : 'Set show marker or not.'
          },
          'shape' : {
            'name' : 'shape',
            'supportedValueType' : 'List',
        'supportedValues' : ['circle', 'diamond', 'triangle-up', 'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection'],
            'defaultValue' : 'circle',
            'description' : 'Set marker shapes for chart.'
          },
          'size' : {
            'name' : 'size',
            'supportedValueType' : 'PositiveInt',
            'defaultValue' : "6",
            'min' : '4',
            'max' : '32',
            'description' : 'Set marker size of data point, range[4,32]. When beyond the range, the marker size is default size 6.'
          },
        },
      },
    },
    'css' : {
      '.viz-line-marker' : {
        'description' : 'Define style for marker in line.',
        'value' : {
          'stroke' : 'transparent',
        },
      },
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalline',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.BoundingBox',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(dispatch, MNDHandler, TypeUtils, Scaler, ColorSeries, BoundingBox, NumberUtils, langManager, DrawUtil, TooltipDataHandler, Manifest, Repository) 
{
  return function(manifest) 
  {
    var width, height;
    var data_ = null, props;
    var randomSuffix = Repository.newId();
    //alex su
    var tooltipData = null;
    var _tooltipDataHandler;

    var bgColor = "#FFFFFF";
    var hoverColor = "gray";
    var selectedColor = "#333333";
    var xScale = d3.scale.ordinal();
    var mouseMoveLine;
    var preHighLightIndex;
    var g;
    var svgMarkersGroup, svgLinesGroup, svgLightLinesGroup;
    var eDispatch = new dispatch('showTooltip', 'hideTooltip', 'initialized');
    var hasMND;
    var bMNDOnColor;
    var bMNDInner;
    var effectManager = null;
    var valueAxis1Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };

    var valueAxis2Data = {
        data: [],
        scale: d3.scale.linear(),
        colorPalette:null,
        selectedMarkers: null,
        markers:[],
        bottomValue: null,
        topValue:null,
        highLines:[]
    };
    var colorPalette = [];
    var PREFIXAXIS1 = 'axis1';
    var PREFIXAXIS2 = 'axis2';

    var bAnimationComplete = false;
    var enableDataLoadingAnimation = true;

    var selectedMarkerNum = 0;

    // clip defs for enimation

    var clipRect;    
    var OPACITY = 0.4;

    function horizontalline(selection) {
      //selection.each(generate);
      
      //alex su
      _tooltipDataHandler = TooltipDataHandler();
      
      renderChart(selection);
      return horizontalline;
    }

    horizontalline.width = function(value) {
      if (!arguments.length)
        return width;
      width = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };

    horizontalline.height = function(value) {
      if (!arguments.length)
        return height;
      height = value;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_)){
        computeScales();
      }
      return horizontalline;
    };
    
    /*;
     * get/set properties
     */
    horizontalline.properties = function(_) {
      if (!arguments.length)
        return props;
        
      props = manifest.props(_);
      if(props.marker.size < 4 || props.marker.size > 32) props.marker.size = 6;
      if(props.width < 1 || props.width > 7) props.width = 2;
      enableDataLoadingAnimation =  props.animation.dataLoading;
      
      getCSSStyle();
      
      createColorPalette();
      return horizontalline;
    };
    horizontalline.primaryAxisColor = function(){
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0){
          return effectManager.register({graphType:"line", fillColor: valueAxis1Data.colorPalette[0]});
        }else{
          return null;
        }
      };
        
      horizontalline.secondAxisColor = function(){
        return effectManager.register({graphType:"line", fillColor:  valueAxis2Data.colorPalette[0]});
      };     
    /**
     * get/set your event dispatch if you support event
     */
    horizontalline.dispatch = function(_){
      if(!arguments.length)
        return eDispatch;
      eDispatch = _;
      return horizontalline;
    };
          
    /**
     * set/get data, for some modules like Title, it doesn't need data
     */
    horizontalline.data = function(value){
      if (!arguments.length){
        return data_;
      }
      data_ = value;
      var obj = MNDHandler(data_);
      valueAxis1Data.data = obj["MG1"];
      valueAxis2Data.data = obj["MG2"];

      hasMND = obj["hasMND"];
      bMNDOnColor = obj["MNDOnColor"];
      bMNDInner = obj["MNDInner"];
      //alex su
      tooltipData = TooltipDataHandler.dataTransform(obj);
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data_))
        computeScales();
      createColorPalette();
      return horizontalline;        
    };

    horizontalline.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      horizontalline.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  data_.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
    horizontalline.effectManager = function(value) {
      if (!arguments.length)
        return effectManager;
      
      effectManager = value;
      
      return horizontalline;
    };
    /**
     * get color palette
     */
    horizontalline.getColorPalette = function() {
      if(colorPalette.length == 0)
      {
        createColorPalette();
      }
      return colorPalette;
    };


    horizontalline.shapePalette = function(_){
      if(!arguments.length)
        return [props.marker.shape];
      return horizontalline;
    };


    horizontalline.primaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis1Data.scale;
      }
      valueAxis1Data.scale = scale;
      return horizontalline;
    };

    horizontalline.secondaryScale = function(scale)
    {
      if(!arguments.length)
      {
        return valueAxis2Data.scale;
      }
      valueAxis2Data.scale = scale;
      return horizontalline;
    };

    horizontalline.categoryScale = function(scale)
    {
      if(!arguments.length)
      {
        return xScale;
      }
      xScale = scale;
      return horizontalline;

    };

    horizontalline.primaryDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis1Data.scale.domain()[0],
          max: valueAxis1Data.scale.domain()[1]
        };
      }
      valueAxis1Data.topValue = range.max;
      valueAxis1Data.bottomValue = range.min;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        valueAxis1Data.scale.domain([valueAxis1Data.bottomValue, valueAxis1Data.topValue]).range ([0, width]).nice();
        Scaler.perfect(valueAxis1Data.scale);
      }
      return horizontalline;
    };

    horizontalline.secondDataRange = function(range){
      if (!arguments.length){
        return {
          min: valueAxis2Data.scale.domain()[0],
          max: valueAxis2Data.scale.domain()[1]
        };
      }
      valueAxis2Data.topValue = range.max;
      valueAxis2Data.bottomValue = range.min;
      if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
        valueAxis2Data.scale.domain([valueAxis2Data.bottomValue, valueAxis2Data.topValue]).range ([0, width]).nice();
        Scaler.perfect(valueAxis2Data.scale);
      }
      return horizontalline;
    };
    horizontalline.parent = function() { 
      return g;
    };

    /**
     * get/set size
     */
    horizontalline.size = function(w, h) {
      if (arguments.length == 0)
        return {
          width : horizontalline.width(),
          height : horizontalline.height()
        };
      horizontalline.width(w).height(h);
      return horizontalline;
    };
    
    horizontalline.clear = function (gray) {
      deselectedAllHandler();
      if (gray == null){
        lightAll();
      } else {
        grayAll();
      }
    };

    horizontalline.highlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }

      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];
        if(!processOneAxisSelect(valueAxis1Data, marker ))
          processOneAxisSelect(valueAxis2Data, marker );

      }
    };
    horizontalline.unhighlight = function (elements) {
      var elementArray;
      if (elements instanceof Array) {
        elementArray = elements;
      } else {
        elementArray = [];
        elementArray.push(elements);
      }
      
      for (var i=0; i<elementArray.length; i++)
      {
        var marker = elementArray[i];

        if(!processOneAxisDeselect(valueAxis1Data, marker))
          processOneAxisDeselect(valueAxis2Data, marker);
      }
    };
    horizontalline.hoverOnPoint = function(point)
    {  
      var point0 = point.x, point1 = point.y;
      if(point1 < 0 || point1 > height)
        return;

      var xIndex = getCategoryIndex(point1);
      if(preHighLightIndex == xIndex) return;
      var yCoord = xScale(xIndex) + xScale.rangeBand() / 2;
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      changeGroupMarker(xIndex, "visible", bgColor);  

      preHighLightIndex = xIndex;
      if (props.hoverline.visible) {
        mouseMoveLine.attr("y1", yCoord).attr("y2", yCoord);
        mouseMoveLine.attr("visibility", "visible");
      } else {
        mouseMoveLine.attr("visibility", "hidden");
      }
      if (props.tooltip.enabled) {
        var pt = {};
        var matrix = g.node().getTransformToElement(g.node().ownerSVGElement);
        pt.x = width * 3 / 4 + matrix.e;
        pt.y = yCoord + matrix.f;
        //var globalPoint = pt.matrixTransform(g.node().parentNode.parentNode.getScreenCTM().inverse());
        //var tData = generateTooltipData(xIndex);
        //alex su
        var tData = _tooltipDataHandler.generateTooltipData(data_, 
               tooltipData, 
               xIndex, 
               colorPalette, 
               [props.marker.shape]);
        tData.point = pt;
        tData.plotArea = {
            x : matrix.e,
            y : matrix.f,
            width : width,
            height : height
          };
        eDispatch.showTooltip(TooltipDataHandler.formatTooltipData(tData));
      }
    };
    
    horizontalline.blurOut = function()
    {  
      mouseMoveLine.attr("visibility", "hidden");
      changeGroupMarker(preHighLightIndex, "hidden", props.style.marker.stroke);
      preHighLightIndex = null;
      if (props.tooltip.enabled) { 
        eDispatch.hideTooltip();
      }
    };
    function calculateMinMax(axisValue)
    {
      var minMax = {
          min:null,
          max:null
      };
      if(!axisValue.data || axisValue.data.length == 0)
        return null;
      minMax.max = Number(d3.max(axisValue.data, function(d){
        return d3.max(d, function(_){ return _.val;});
      }));
      minMax.min = Number(d3.min(axisValue.data, function(d){
        return d3.min(d, function(_){ return _.val;});
      }));
      if(NumberUtils.isNoValue(minMax.max )) return null;
      if(minMax.min >= 0)
      {
        minMax.min = 0;
        minMax.max += minMax.max * 5 / width ;
      }
      else if(minMax.max <= 0){
        minMax.max = 0;
        minMax.min +=  minMax.min * 5 / width;
      }else{
        var temp = (minMax.max - minMax.min) * 5 / width;
        minMax.min -= temp;
        minMax.max += temp;
      }
    
      return minMax;
    }

    function createColorPalette()
    {
      colorPalette = [];
      
      if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        valueAxis1Data.colorPalette = props.primaryValuesColorPalette ;
      else 
        valueAxis1Data.colorPalette = props.colorPalette;

      valueAxis2Data.colorPalette = props.secondaryValuesColorPalette;
      
      if (hasMND && bMNDOnColor && bMNDInner) {
        var dva1 = data_.getMeasureValuesGroupDataByIdx(0);
        var dva2 = data_.getMeasureValuesGroupDataByIdx(1);
        var mg1mNum=0, mg2mNum=0, mNum=0, colorAxisDataNum=0;
        if (dva1 && dva1.values.length>0) { 
          mg1mNum = dva1.values.length;
          colorAxisDataNum = dva1.values[0].rows.length;
        }
        if (dva2 && dva2.values.length>0) {
          mg2mNum = dva2.values.length;
          colorAxisDataNum = dva2.values[0].rows.length;
        }

        for (var i=0; i<colorAxisDataNum; i++) {
          for (var j=0; j<mg1mNum; j++) {
            colorPalette.push(valueAxis1Data.colorPalette[i*mg1mNum+j % valueAxis1Data.colorPalette.length])
          }
          for (var j=0; j<mg2mNum; j++){
            colorPalette.push(valueAxis2Data.colorPalette[i*mg2mNum+j % valueAxis2Data.colorPalette.length])
          }
        }
      } else {
        for( var i = 0; i < valueAxis1Data.data.length; ++i)
          colorPalette.push(valueAxis1Data.colorPalette[i % valueAxis1Data.colorPalette.length]);
        if(valueAxis2Data.data && valueAxis2Data.data.length > 0)
        {
          for( var i = 0; i < valueAxis2Data.data.length; ++i)
            colorPalette.push(valueAxis2Data.colorPalette[i % valueAxis2Data.colorPalette.length]);
        }
      }
    }

    function calculateScale(axisValue)
    {
      if(axisValue.data && axisValue.data.length > 0 )
      {
        if( axisValue.topValue == null)
        {
          var minMax = calculateMinMax(axisValue);
          if(!minMax)
            axisValue.scale.domain([0, 0]).range ([0, width]);
          else
            axisValue.scale.domain([minMax.min, minMax.max]).range ([0, width]).nice();
        }
        else
          axisValue.scale.domain([axisValue.bottomValue, axisValue.topValue]).range ([0, width]).nice();
        
        Scaler.perfect(axisValue.scale);
      }
      else{
        axisValue.scale.domain([0,0]).range([0,0]);
      }
      return axisValue.scale;
    };

    function computeScales()
    {
      var domain = [];
      var categoryNum = 0;
      if (valueAxis1Data.data.length != 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }
      for (var i=0; i < categoryNum; i++){
        domain.push(i);
      }
      xScale.domain(domain).rangeBands([height, 0]);
      calculateScale(valueAxis1Data);
      calculateScale(valueAxis2Data);  
      if (valueAxis1Data.data && valueAxis1Data.data.length > 0 &&
        valueAxis2Data.data && valueAxis2Data.data.length > 0) {
        Scaler.perfectDual(valueAxis1Data.scale, valueAxis2Data.scale);
      }
    };

    function changeGroupMarker(groupIndex, visible, borderColor)
    {
      if(groupIndex == undefined || groupIndex == null)
        return;

      for(var seriesIndex = 0; seriesIndex < valueAxis1Data.data.length; ++seriesIndex)
      {   
        if(!valueAxis1Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis1Data);
          if(!props.marker.visible)
          {
            if(selectedMarkerNum > 0)
              d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
            else
              d3.select(valueAxis1Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
          }
        }
      }  

      if(!valueAxis2Data.data) return;

      for(var seriesIndex = 0; seriesIndex < valueAxis2Data.data.length; ++seriesIndex)
      {
        if(!valueAxis2Data.selectedMarkers[seriesIndex][groupIndex])
        {
          changeOneMarker(seriesIndex, groupIndex, borderColor, valueAxis2Data);
          if(!props.marker.visible)
          {
            if(selectedMarkerNum > 0)
              d3.select(valueAxis2Data.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY).attr("visibility", visible);
            else
              d3.select(valueAxis2Data.markers[seriesIndex][groupIndex]).attr("opacity", 1).attr("visibility", visible);
          }
        }
      }
    };



    function changeOneMarker(seriesIndex, xIndex, borderColor, valueAxis)
    {
      d3.select(valueAxis.markers[seriesIndex][xIndex]).attr("stroke",  borderColor);
    };

    function getCategoryIndex(val)
    {
      var index = val / xScale.rangeBand();
      index = Math.floor(index);
      var categoryNum = 0;
      if (valueAxis1Data.data.length != 0) {
        categoryNum = valueAxis1Data.data[0].length;
      } else {
        categoryNum = valueAxis2Data.data[0].length;
      }      
      if(index > categoryNum - 1) index = categoryNum - 1;
      if(index < 0) index = 0;
      return categoryNum - 1 - index;
    };

    function processOneAxisSelect(valueAxis, marker) {
      var findFlag = false, yi, xi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] == marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } //for j
      }//for i

      if (!findFlag) {
        return false;
      }

      if (valueAxis.selectedMarkers[yi][xi]) {
        return true;
      }

      changeOneMarker(yi, xi, selectedColor, valueAxis);
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", 1).attr("visibility", "visible");
      valueAxis.selectedMarkers[yi][xi] = true;
    
      if(xi > 0 && valueAxis.selectedMarkers[yi][xi - 1])
        valueAxis.highLines[yi][xi - 1].attr("visibility", "visible");
      if(xi < valueAxis.highLines[0].length && valueAxis.selectedMarkers[yi][xi + 1])
        valueAxis.highLines[yi][xi].attr("visibility", "visible");
      
      ++selectedMarkerNum;
    }

    function processOneAxisDeselect (valueAxis, marker) {
      var xi = preHighLightIndex;

      var findFlag = false, yi;
      for(var i = 0; i < valueAxis.markers.length && !findFlag; i++)
      {
        var xMarks = valueAxis.markers[i];
        for (var j = 0; j<xMarks.length && !findFlag ; j++)
        {
          if(xMarks[j] == marker) {
            findFlag = true;
            yi = i;
            xi = j;
          }
        } 
      }

      if (!findFlag) {
        return false;
      }

      if (!valueAxis.selectedMarkers[yi][xi]){
        return true;
      }

      if(xi == preHighLightIndex){
        changeOneMarker(yi, xi, bgColor, valueAxis);
      }
      else{
        changeOneMarker(yi, xi, props.style.marker.stroke, valueAxis);
      }
      
      d3.select(valueAxis.markers[yi][xi]).attr("opacity", OPACITY );
      if(!props.marker.visible && xi != preHighLightIndex)
        d3.select(valueAxis.markers[yi][xi]).attr("visibility", "hidden");
      valueAxis.selectedMarkers[yi][xi] = false;
  
      if(xi > 0 && valueAxis.selectedMarkers[yi][xi - 1])
        valueAxis.highLines[yi][xi - 1].attr("visibility", "hidden");
      if(xi < valueAxis.highLines[0].length && valueAxis.selectedMarkers[yi][xi + 1])
        valueAxis.highLines[yi][xi].attr("visibility", "hidden");
  
      --selectedMarkerNum;
    }

    
    function processNullValue(axisValue)
    {
      var result = {
          data:[],
          color:[]
      };

      for(var i = 0; i < axisValue.length; ++i)
      {
        var preIndex = 0;
        for(var j = 0; j < axisValue[i].length; ++j)
        {
          if(NumberUtils.isNoValue(axisValue[i][j].val))
          {
            if(j > preIndex)
            {
              var arr = [];
              for(var k = preIndex; k < j; k++)
              {
                var obj = axisValue[i][k];
                obj.x = k;  
                arr.push(obj);
              }
              result.data.push(arr);
              result.color.push(i);
            }
            preIndex = j + 1;
          }
        }
        
        if(preIndex < axisValue[i].length)
        {
          var arr = [];
          for(var k = preIndex; k <  axisValue[i].length; k++)
          {
            var obj = axisValue[i][k];
            obj.x = k;
            arr.push(obj);
          }
          result.data.push(arr);
          result.color.push(i);
        }
      }
      return result;
    };
    
    function processOneAxis(axisValue, prefix)
    {
      if(axisValue.data == null || axisValue.data.length == 0)
        return;
      var axisGroup = svgLinesGroup.select("g." + prefix);
      if(axisGroup.empty())
      {
        axisGroup = svgLinesGroup.append("svg:g").attr("class", prefix);
      }
      axisValue.selectedMarkers = new Array(axisValue.data.length);
      axisValue.markers = [];
      var result = processNullValue(axisValue.data);
      
      var lines = axisGroup.selectAll("." + "lines").data(result.data);
      
      lines.enter().append("path").attr('class', "lines")
        .attr("stroke-width", props.width).attr("stroke-linejoin", "round");
      lines.exit().remove();
      var line = d3.svg.line().y(function(d,i) { return xScale(d.x) + xScale.rangeBand() / 2; }).x(function(d) {  return axisValue.scale(d.val); });
      lines.attr("transform", 
          function(d, i) {
            d3.select(this).attr("d", line(d))
            .attr("stroke",  function (){
                var para = { graphType:"line", 
                fillColor:axisValue.colorPalette[result.color[i] %  axisValue.colorPalette.length]};
                return effectManager.register(para);
                });
      });
      
      // draw highlight lines
      var lightLineGroup = svgLightLinesGroup.selectAll("g." + prefix);
      if(lightLineGroup.empty())
      {
        lightLineGroup = svgLightLinesGroup.append("svg:g").attr("class", prefix);
      }
      var groups = lightLineGroup.selectAll("g").data(axisValue.data);
      groups.enter().append("g");
      groups.exit().remove();
      axisValue.highLines = [];
      groups.attr("transform", function(d,i){
         d3.select(this).selectAll(".lightLine").remove();
        axisValue.highLines.push([]);
        for(var j = 1 ; j < d.length; ++j)
        {
          if(NumberUtils.isNoValue(d[j].val) || NumberUtils.isNoValue(d[j-1].val) )
            axisValue.highLines[i].push(null);
          else
            axisValue.highLines[i].push(d3.select(this).append("svg:line").attr("class", "lightLine").attr("x1", axisValue.scale(d[j-1].val)).
              attr("y1", xScale(j-1) + xScale.rangeBand() / 2).attr("x2",axisValue.scale(d[j].val)).attr("y2", xScale(j) + xScale.rangeBand() / 2)
              .attr("stroke-width", props.width).attr("stroke",  
                  axisValue.colorPalette[i %  axisValue.colorPalette.length]).attr("visibility", "hidden"));    
        }
        
      });
      
      // draw markers
      for(var seriesIndex = 0; seriesIndex < axisValue.data.length; ++seriesIndex)
      {
        axisValue.selectedMarkers[seriesIndex] = [];
        for(var dataIndex = 0; dataIndex < axisValue.data[0].length; ++dataIndex)
        {
          axisValue.selectedMarkers[seriesIndex][dataIndex] = false;
        }
      }
      var markerGroup = svgMarkersGroup.select("g." + prefix);
      if(markerGroup.empty())
        markerGroup = svgMarkersGroup.append("svg:g").attr("class", prefix);
      groups = markerGroup.selectAll("g.marker").data(axisValue.data);
      groups.enter().append("svg:g").attr("class", "marker");
      groups.exit().remove();
      
      var visible = "hidden";
      if(props && props.marker && props.marker.visible)
        visible  = "visible";
      groups.attr("transform", function(d, i) {
        
        var seriesMarkers = d3.select(this).selectAll(".datapoint").data(d);
        DrawUtil.createElements(seriesMarkers.enter(),{shape: props.marker.shape, className: "datapoint"} );
        seriesMarkers.exit().remove();
        var markerArr = [];
        seriesMarkers.attr("transform",function(point, index)
        {   
          if(NumberUtils.isNoValue(point.val))
          { 
              d3.select(this).remove();
              markerArr.push(null);
              return;
          }
          markerArr.push(this);
          var parameter = {
              drawingEffect: props.drawingEffect,
              graphType: props.marker.shape,
              fillColor: axisValue.colorPalette[i % axisValue.colorPalette.length],
              direction :'vertical',
              rx: props.marker.size / 2,
              ry: props.marker.size / 2,
              borderWidth: 2,
              borderColor: props.style.marker.stroke,
              node:d3.select(this),
              visibility: visible
          };
          DrawUtil.drawGraph(parameter, effectManager);
          return "translate(" + axisValue.scale(point.val)+ "," + (xScale(index) + xScale.rangeBand() / 2)  + ")"; 
        });

        axisValue.markers.push(markerArr);
      });


    };

    function processOneAxisDeselectAll(valueAxis,  xIndex)
    {
      if(selectedMarkerNum == 0 || !valueAxis.selectedMarkers || valueAxis.selectedMarkers.length == 0)
        return;

      
      for(var seriesIndex = 0; seriesIndex < valueAxis.selectedMarkers.length; ++seriesIndex)
      {
        for(var groupIndex = 0; groupIndex < valueAxis.selectedMarkers[0].length; ++groupIndex)
        {
          if(!valueAxis.selectedMarkers[seriesIndex][groupIndex]) continue;
          
          if(groupIndex == xIndex)
          {
            changeOneMarker(seriesIndex, groupIndex, bgColor, valueAxis);
            if(!props.marker.visible)
              d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("opacity", OPACITY ).attr("visibility", "visible");
          }
          else
          {
            changeOneMarker(seriesIndex, groupIndex, props.style.marker.stroke, valueAxis);
            if(!props.marker.visible)
              d3.select(valueAxis.markers[seriesIndex][groupIndex]).attr("visibility", "hidden");
          }
          valueAxis.selectedMarkers[seriesIndex][groupIndex] = false;
        }
      }
    }

    function deselectedAllHandler()
    {
      var ypoint = d3.event.clientY - g.node().getBoundingClientRect().top;
      var xIndex = getCategoryIndex(ypoint);
      processOneAxisDeselectAll(valueAxis1Data, xIndex);
      processOneAxisDeselectAll(valueAxis2Data, xIndex);
      selectedMarkerNum = 0;
    }

    
    
    function renderChart(selection)
    {
      if(!g) {
        g = selection.append("svg:g");  
      }

      if(!mouseMoveLine)
        mouseMoveLine = g.append("svg:line");

      mouseMoveLine.attr("x1", 0).attr("y1", 0).attr("x2", width).attr("y2", 0)
      .attr("stroke-width", 1).attr("stroke", hoverColor)
      .attr("visibility", "hidden").attr("stroke-linejoin", "round");
      if(!svgLinesGroup)
      {
        svgLinesGroup = g.append("svg:g").attr("class", "datalines");
        svgLightLinesGroup = g.append("svg:g").attr("class", "lightLines");
        svgMarkersGroup = g.append("svg:g").attr("class", "markers");
      }
      if(!clipRect)
        clipRect = g.append("svg:defs").append("svg:clipPath").attr("id", "clip1_" + randomSuffix).append("rect");
      
      clipRect.attr("x", 0).attr("y", (enableDataLoadingAnimation ? height : 0)).attr("height", (enableDataLoadingAnimation ? 0 : height)).attr("width", width);
      selectedMarkerNum = 0;
      lightAll();
      svgMarkersGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");
      svgLightLinesGroup.attr("clip-path", "url(#clip1_" + randomSuffix + ")").attr("fill", "none");

      if(enableDataLoadingAnimation)
      {
        bAnimationComplete = true;

        var totalNumber = 0;
        var interval = height / 50;
        var func = setInterval(function(d){
          if(totalNumber >= height)
          {
            clearInterval(func);
            eDispatch.initialized();
          }
          else
          {
            totalNumber += interval;
            clipRect.attr("height", totalNumber);
            clipRect.attr("y", height - totalNumber);
          }
        },
        20);
      }else
        eDispatch.initialized();
      processOneAxis(valueAxis1Data, PREFIXAXIS1);
      processOneAxis(valueAxis2Data, PREFIXAXIS2);

    };

    function lightAll() {
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS1).selectAll(".lightLine").attr("visibility", "hidden");
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS2).selectAll(".lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", 1);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.marker").selectAll(".datapoint").attr("opacity", 1);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.marker").selectAll(".datapoint").attr("opacity", 1);
    }

    function grayAll() {
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS1).selectAll(".lightLine").attr("visibility", "hidden");
      svgLightLinesGroup.selectAll("g." +  PREFIXAXIS2).selectAll(".lightLine").attr("visibility", "hidden");
      svgLinesGroup.attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS1).selectAll("g.marker").selectAll(".datapoint").attr("opacity", OPACITY);
      svgMarkersGroup.selectAll("g." +  PREFIXAXIS2).selectAll("g.marker").selectAll(".datapoint").attr("opacity", OPACITY);
    }
    
    function getCSSStyle() {
      if (!props.style)
        props.style = {};
        
      var cssDef;
      if (Manifest.get('sap.viz.modules.background')) {
        if (cssDef = Manifest.get('sap.viz.modules.background').style('viz-plot-background')) {
          if (cssDef['fill']) {
            bgColor = cssDef['fill'];
          }
        }
      }
      if (!props.style.marker)
        props.style.marker = {};
      if (cssDef = manifest.style('viz-line-marker')) {
        if (cssDef['stroke']) {
          props.style.marker.stroke = cssDef['stroke'];
        }
      }
    }
    
    props = manifest.props(null);
    return horizontalline;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.horizontalline',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.horizontalline',
    'name' : 'horizontalline',
    base : 'sap.viz.modules.line',
    
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
}
],
function Setup (Manifest) {
  var chart={
    base : 'riv/basehorizontalchart',
    id:'viz/horizontal_combination',
    name:'IDS_HORIZONTALCOMBINATIONCHART',
    modules:{
      tooltip : {
        configure : {
        properties : {
          chartType : 'horizontalline',
          orientation : 'left'
        }
        }
      },
      main:{
        controllers : {
          'interaction' : {
          id : 'sap.viz.modules.controller.interaction',
          configure : {
            propertyCategory : 'selectability'
          }
          }
        },        
        modules:{
          plot:{
            id:'sap.viz.modules.horizontalcombination',
            configure:{
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory:'plotArea'
            }
          }
        }
      }
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule:'legend',
          target:'shapes',
          sourceModule:'main.plot',
          source:'shapePalette'
        },{
            targetModule : 'legend',
            target : 'setSelectionMode',
            sourceModule : 'main.interaction',
            source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
            targetModule : 'main.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'legend',
            type : 'highlightedByLegend'
        }, {
                targetModule : 'legend',
              listener : 'deselectLegend',
              sourceModule : 'main.interaction',
              type : 'deselectLegend'
        }  
      ]      
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualHorizontalCombinationChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalCombination',
  version : '4.0.0'
}
],
 function Setup (Manifest, Constants) {
  var chart={
    id:'viz/dual_horizontal_combination',
    name:'IDS_DUALHORIZONTALCOMBINATIONCHART',
    base : 'viz/horizontal_combination',
    modules:{
      main:{
        modules:{
                  plot: {
                    configure: {
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: true
                        },
                        secondaryValuesColorPalette: {
                          isExported: true
                        }
                      }
                    }
                  },
                  xAxis:{
                        id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                  },
          'xAxis2' : {
            'id' : 'sap.viz.modules.axis',
            'configure' : {
                        'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
            'propertyCategory' : 'xAxis2',
            'properties' : {
              'type' : 'value',
              'position' : 'top',
              'gridline' : {
                'visible' : false
              }
            }
            }
          },
          
        }
      }
    },
    feeds:{
      secondaryValues: {
        min: 1,
        max: Number.POSITIVE_INFINITY 
      }
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.xAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        },{
          targetModule : 'main.xAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        },{
          targetModule : 'main.xAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'main.xAxis2',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'secondAxisTitle'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule:'legend',
          target:'shapes',
          sourceModule:'main.plot',
          source:'shapePalette'
        }
      ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
}
],
function Setup (Manifest) {
  var chart={
    base : 'riv/baseverticalchart',
    id:'viz/combination',
    name:'IDS_COMBINATIONCHART',
    modules:{
      tooltip : {
        configure : {
        properties : {
          chartType : 'line',
          orientation : 'left'
        }
        }
      },
      main:{
        controllers : {
          'interaction' : {
          id : 'sap.viz.modules.controller.interaction',
          configure : {
            propertyCategory : 'interaction'
          }
          }
        },        
        modules:{
          plot:{
            id:'sap.viz.modules.combination',
            configure:{
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory:'plotArea'
            }
          }
        }
      }
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.yAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        }, {
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule:'legend',
          target:'shapes',
          sourceModule:'main.plot',
          source:'shapePalette'
        },{
            targetModule : 'legend',
            target : 'setSelectionMode',
            sourceModule : 'main.interaction',
            source : 'getSelectionMode'
        }
      ],
      events : [ 
        {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
            targetModule : 'main.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'legend',
            type : 'highlightedByLegend'
        }, {
                targetModule : 'legend',
              listener : 'deselectLegend',
              sourceModule : 'main.interaction',
              type : 'deselectLegend'
        } 
      ]      
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualCombinationChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Combination',
  version : '4.0.0'
}
],
 function Setup (Manifest, Constants) {
  var chart={
    id:'viz/dual_combination',
    name:'IDS_DUALCOMBINATIONCHART',
    base : 'viz/combination',
    modules:{
      main:{
        modules:{
                  plot: {
                    configure: {
                      propertiesOverride:{
                        primaryValuesColorPalette:{
                          isExported: true
                        },
                        secondaryValuesColorPalette: {
                          isExported: true
                        }
                      }
                    }
                  },
                  yAxis:{
                        id : 'sap.viz.modules.axis',
                    configure:{
                      'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                    }
                  },
          yAxis2 : {
            id : 'sap.viz.modules.axis',
            configure : {
                        'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
            propertyCategory : 'yAxis2',
            properties : {
              type : 'value',
              position : 'right',
              gridline : {
                visible : false
              }
            }
            }
          },
                  
        }
      }
    },
    feeds:{
      secondaryValues: {
        min: 1,
        max: Number.POSITIVE_INFINITY 
      }
    },
    dependencies:{
      attributes:[
        {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        },{
          targetModule : 'main.yAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondaryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.yAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        }, {
          targetModule : 'main.yAxis2',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'secondAxisTitle'
        },{
          targetModule : 'main.yAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        },{
          targetModule : 'main.yAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
          targetModule:'legend',
          target:'shapes',
          sourceModule:'main.plot',
          source:'shapePalette'
        }
      ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/line',
    name : 'IDS_LINECHART',
    base: 'riv/baseverticalchart',
    
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'line',
            orientation : 'left'
          }
        }
      },
      main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
                    properties : {
                      supportedEventNames: ['mouseup', 'mousemove']
                    }
                  }
                }
              },
        'modules' : {
          plot : {
            id : 'sap.viz.modules.line',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
     
    },
    feeds:{
      secondaryValues: {
        max:0
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
      targetModule : 'main.yAxis',
      target : 'title',
      sourceModule : 'main.plot',
      source : 'primaryAxisTitle'
    }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
            }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
        }, {
            targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
          } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_line',
    name : 'IDS_DIUALLINECHART',
    base: 'viz/line',
    'modules' : {
    
      /**
       * 'sizeLegend' : {}
       */
      main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction'
                  }
                }
              },
       
        modules : {
         
          /**
           * 'xAxis2' : { },
           */
        
            plot : {
              configure: {
                propertiesOverride:{
                  primaryValuesColorPalette:{
                    isExported: true
                  },
                  secondaryValuesColorPalette: {
                    isExported: true
                  }
                }
              }
            },
            yAxis:{
                  id : 'sap.viz.modules.axis',
             configure:{
                'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
              }
            },
          yAxis2 : {
            id : 'sap.viz.modules.axis',
            configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
              propertyCategory : 'yAxis2',
              properties : {
                type : 'value',
                position : 'right',
                gridline : {
                  visible : false
                }
              }
            }
          },
      
        }
      }
    },
    
    feeds:{
      secondaryValues: {
        min : 1,
        max : Number.POSITIVE_INFINITY 
      },
       axisLabels:{
        acceptMND : -1,
        max: 1
        },
      regionColor:{
        acceptMND: 0
      }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
      dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        }, {
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'getColorPalette'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.yAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondaryScale'
        }, {
      targetModule : 'main.yAxis',
      target : 'title',
      sourceModule : 'main.plot',
      source : 'primaryAxisTitle'
      }, {
      targetModule : 'main.yAxis2',
      target : 'title',
      sourceModule : 'main.plot',
      source : 'secondAxisTitle'
      },{
            targetModule : 'main.yAxis',
            target : 'color',
            sourceModule : 'main.plot',
            source : 'primaryAxisColor'
          }, {
            targetModule : 'main.yAxis2',
            target : 'color',
            sourceModule : 'main.plot',
            source : 'secondAxisColor'
          },{
          targetModule : 'legend',
          target : 'shapes',
          sourceModule : 'main.plot',
          source : 'shapePalette'
        } ]
      }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/horizontal_line',
    name : 'IDS_HORIZONTALLINECHART',
    base : 'riv/basehorizontalchart',
    'modules' : {
     tooltip : {
        configure : {
          properties : {
            chartType : 'horizontalline',
            orientation : 'left'
          }
        }
      },
          
      'main' : {
         controllers : {
            'interaction' : {
              id : 'sap.viz.modules.controller.interaction',
              configure : {
                propertyCategory : 'interaction',
                properties : {
                  supportedEventNames: ['mouseup', 'mousemove']
                }
              }
            }
          },
        'modules' : {
        
          'plot' : {
            'id' : 'sap.viz.modules.horizontalline',
            'configure' : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              'propertyCategory' : 'plotArea'
            }
          }
        }
      }
    },
    feeds:{
      secondaryValues: {
        max: 0
      }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : [ {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.xAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapePalette'
      } , {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      }],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
      }  , {
            targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
        }, {
            targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
          }]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualHorizontalLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    'id' : 'viz/dual_horizontal_line',
    'name' : 'IDS_DUALHORIZONTALLINECHART',
    'base' : 'viz/horizontal_line',
     'modules' : {
      
      /**
       * 'sizeLegend' : {}
       */
      'main' : {
        'id' : 'sap.viz.modules.xycontainer',
        'modules' : {
       
            plot: {
               configure: {
                propertiesOverride:{
                  primaryValuesColorPalette:{
                    isExported: true
                  },
                  secondaryValuesColorPalette: {
                    isExported: true
                  }
                }
              }
            },
            xAxis:{
                  id : 'sap.viz.modules.axis',
              configure:{
                'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
              }
            },
          'xAxis2' : {
            'id' : 'sap.viz.modules.axis',
            'configure' : {
                'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
              'propertyCategory' : 'xAxis2',
              'properties' : {
                'type' : 'value',
                'position' : 'top',
                'gridline' : {
                  'visible' : false
                }
              }
            }
          },
          
        }
      }
    },
    
    feeds:{
      secondaryValues: {
        min : 1,
        max : Number.POSITIVE_INFINITY 
      },
      axisLabels:{
        acceptMND : -1,
        max: 1
        },
        regionColor:{
          acceptMND: 0
        }
    },
    /**
     * the dependencies will be resolved globally to allow modules inside
     * container depend on modules outside, so the keys should be globally
     * unique
     */
    dependencies : {
      attributes : [ {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'getColorPalette'
      }, {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'secondaryScale'
      }, {
        targetModule : 'main.xAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'primaryAxisTitle'
      }, {
        targetModule : 'main.xAxis2',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'secondAxisTitle'
      }, {
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.xAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        },{
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapePalette'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.waterfall',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, NumberUtils, tooltipDataHandler, Scaler, langManager) {
  var waterfall = function(manifest) {
    var width, height, barSize;
    var data, orignalData;
    var effectManager = null;
    var categoryScale = d3.scale.ordinal(),
          primaryScale = d3.scale.linear();
      
    var _data = [];
        dataStructureChange = false,
        dataValueChange = false,
        sizeChange = false,
        colorPalette = ColorSeries.sap32().range();

        var properties;
        
    var primaryAxisMinValue = 0, 
        primaryAxisMaxValue = 0;
    
    //variable for event
        var decorativeShape,                    // the shape to show the effect of mouse move
            eventLayerShape,                   // the shape to trigger event
            lastSelected = [],                  // the variable to hold all selected shapes
            lastHovered = null,                 // last hovered dimention item index
      tooltipVisible = true,
            eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized'),
            isLasso = false;
            
        var enableDataLoadingAnimation = true,
            enableDataUpdatingAnimation = true,
            totalIntervalTime = 800,
            isOnlyInitAnimation = false;
        
        var defsEnter = null, 
            roundCornerDefs = null,
            sWrapper = null;
        var drawingEffect = 'normal';
        
        //alex su
    var defaultString = langManager.get('IDS_ISNOVALUE');

        
        chart.hoverOnPoint = function(point){
            var xOnModule = point.x, yOnModule = point.y;
            // find the closet dimension
            var i = -1;
            while (i < data[0].length) {
                if (Math.abs(xOnModule - categoryScale.rangeBand()*i - 0.5 * categoryScale.rangeBand() ) <= 0.5 * categoryScale.rangeBand()) {
                    break;
                }
                i++;
            }

            if (i > (data[0].length - 1)
                    || i < 0) {
                decorativeShape.style(
                        'visibility', 'hidden');
                return;
            }
            
            decorativeShape.attr('x', categoryScale.rangeBand() * i +  barSize/8).style('visibility', 'visible');
            
            if(lastHovered !== i){
        if (tooltipVisible) {      
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
          var xoffset = sWrapper.node().getTransformToElement(sWrapper.node().ownerSVGElement).e;
          var tData = getTooltipData(i);
          tData.point = {
              x: categoryScale.rangeBand()*i + 0.5 * categoryScale.rangeBand() + xoffset,
              y: d3.event.layerY
          };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
            }
            
        };        
      
        chart.blurOut = function(){
            decorativeShape.style('visibility', 'hidden');
            lastHovered = null;
      if (tooltipVisible) {
        eDispatch.hideTooltip();
      }
        };
        
        chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          sWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          sWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      chart.parent = function(){
        return sWrapper;
      };
        
      /**
       * Parse options
       */
      var parseOptions = function(){
          drawingEffect = properties.drawingEffect;
            enableRoundCorner = properties.enableRoundCorner;
            enableDataLoadingAnimation =  properties.animation.dataLoading; 
            enableDataUpdatingAnimation =  properties.animation.dataLoading; 
      tooltipVisible = properties.tooltip.enabled;
      };

      
      /**
       * Create chart
       */
      function chart(selection){
        
        if(!TypeUtils.isExist(primaryScale)) return;
        
        parseOptions();
        
        selection.each(function(){
          //remove event when chart is redo animation   
        
        var plotHeight = chart.height();
        var plotWidth = chart.width();
        
          var barNumber = data[0].length;
                    barSize = 2 * (categoryScale.rangeBand()) / 3 ;
        
          var svg = sWrapper = d3.select(this);          
        
        //append decorativeShape bar
                if(decorativeShape == null){
                        decorativeShape = d3.select(this).append('rect')
                                            .style('visibility', 'hidden').attr('width', categoryScale.rangeBand() - barSize/4)
                                            .attr('height',  plotHeight)
                                            .attr('fill', 'rgba(133,133,133, 0.2)');
                }else{
                  decorativeShape.attr('width',  categoryScale.rangeBand() - barSize/4).attr('height',  plotHeight).style('visibility', 'hidden');
                }

                if(defsEnter == null){
                    defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);       
                }else{
                    defsEnter.attr('width', width).attr('height', height);
                }       
                
                var lastRectIndex = data[0].length - 1;
                
                var waterfall = svg.selectAll('g.waterfall').data(data);
                    waterfall.enter().append('g').attr('class','waterfall');
                    waterfall.each(function(d,i){
                        var rect = d3.select(this).selectAll('rect').data(d);
                        var sum = 0, tempSum = 0, height = [], yCoordinator = [];
                        var interval = totalIntervalTime / (d.length);
                        rect.enter().append('rect');
            rect.exit().remove();
            rect.attr('fill',function(d,j){
                          var parameters = {
                              drawingEffect:drawingEffect,
                              fillColor : colorPalette[i],
                              direction : 'horizontal'
                          };
                          return effectManager.register(parameters);
                        })
                         .attr('shape-rendering','crispEdges').attr('class', 'datapoint').attr('fill-opacity', 1);
                                                    
                        rect.each(function(d,j){
                              if(d.val != defaultString){
                                var barHeight;
                                sum += d.val;
                                if(sum > tempSum){
                                  barHeight = primaryScale(tempSum) - primaryScale(sum);
                                          height.push(barHeight);
                                  yCoordinator.push(primaryScale(sum));
                                }else{
                                  barHeight = primaryScale(sum) - primaryScale(tempSum);
                                          height.push(barHeight);
                                  yCoordinator.push(primaryScale(tempSum));
                                }
                                tempSum = sum;
                              }else{
                                height.push(4);
                                var yPoint;
                                if(sum > tempSum){
                                  yPoint = primaryScale(sum);
                                }else{
                                  yPoint = primaryScale(tempSum);
                                }
                              
                              if(yPoint == plotHeight){
                                yPoint -= 4;
                              }
                              yCoordinator.push(yPoint);
                              }
                        });
                        
                      
                        if(enableDataLoadingAnimation && !isOnlyInitAnimation ){
                            if(dataStructureChange){
                                sum = 0, tempSum = 0,
                                rect.attr('y', function(d, j){
                        var y;
                        if(d.val != defaultString){
                          sum += d.val;
                          y = primaryScale(tempSum);
                          tempSum = sum;
                        }else{
                          y = primaryScale(tempSum);
                        }
                        return y;
                                     })
                                    .attr('height', 0)
                                    .attr('width',barSize);
                                rect.attr('x', function(d,j){
                                        var x = categoryScale(j) + barSize/4;
                                        return x;
                                });
                               sum = 0, tempSum = 0;
                               var animation = rect.transition()
                                   animation.delay(function(d,m){return (m) * interval}) 
                                   animation.attr('y',function(d,j){
                                                        return yCoordinator[j];
                                   });
                                   animation.attr('height',function(d,j){
                                        return height[j];
                                   });
                                   animation.each('end',function(d,j){
                                        if(j == lastRectIndex){
                                            completeAnimation();
                                        }
                                   });
                            }else if(sizeChange){
                                   var animation = rect.transition();
                                   animation.attr('x',function(d,j){
                                        var x = categoryScale(j) + barSize/4;
                                        return x;
                                   });
                                   animation = rect.transition();                                   
                                   animation.delay(function(d,m){return (m+1) * interval})
 
                                   animation.attr('y',function(d,j){
                                        return yCoordinator[j];
                                   });
                                   animation.attr('height',function(d,j){
                                        return height[j];
                                   });  
                                   animation.attr('width',function(d,j){
                                        return barSize;
                                   });  
                                   animation.each('end',function(d,j){
                                        if(j == lastRectIndex){
                                            completeAnimation();
                                        }
                                   });                                 
                            }else if(dataValueChange){
                                var animation = rect.transition();
                                animation.delay(function(d,m){return (m) * interval});
                                animation.attr('y',function(d,j){
                                     return yCoordinator[j];
                                });
                                animation.attr('height',function(d,j){
                                     return height[j];
                                });
                                animation.each('end',function(d,j){
                                     if(j == lastRectIndex){
                                         completeAnimation();
                                     }
                                });                                  
                            }
                        }else{
                            sum = 0, tempSum = 0,
                            rect.attr('y', function(d, j){return yCoordinator[j];})
                                .attr('x', function(d,j){
                                            var x = categoryScale(j) + barSize/4;
                                            return x;
                                    }).attr('height',function(d,j){
                                            return height[j];
                                    }).attr('width',barSize);
                            
                            completeAnimation();
                        }
                        rect.exit().remove();
                    });
                    
                    sizeChange = false, dataStructureChange = false, dataValueChange = false;
             
        });
  
        return chart;
      };
        
        function completeAnimation(){
            eDispatch.initialized();
        };
    
    chart.dispatch = function(_){
            if(!arguments.length)
                return eDispatch;
            eDispatch = _;
            return this;
        };
    
      /**
      * set/get width
      */
      chart.width = function(value){
          if (!arguments.length){
            return width;
          }
          sizeChange = (width === value)&&!sizeChange? false:true;
          width = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
          makeScales();
        }
          return chart;
      };

      /**
      * set/get height
      */
      chart.height = function(value){
        if (!arguments.length){
          return height;
         }
        sizeChange = (height === value)&&!sizeChange? false:true;
        height = value;
        if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
          makeScales();
        }
         return chart;        
      };

      /**
      * set/get data, for some modules like Title, it doesn't need data
      */
      chart.data = function(value){
        if (!arguments.length){
          return data;
         }
        data = originalData = value;        
        var obj = MNDHandler(data);
            
            data = obj["MG1"];
            
            for(var i = 0;  i< data.length; i++){
              for(var j = 0; j < data[i].length; j++){
                if(NumberUtils.isNoValue(data[i][j].val)){
                    data[i][j].val = defaultString;
            }
              }
            }
        
            //judge what changed in dataset
            if(data.length !== _data.length || data[0].length !== _data[0].length){
                dataStructureChange = true;
            }else {
                dataValueChange = true;
            }
            _data = data;
            
            primaryAxisMaxValue =1,  primaryAxisMinValue = 0;
            
            //primaryAxisMinValue = d3.min(data[0], function(d){ return d.val});
            //primaryAxisMaxValue = d3.max(data[0], function(d){ return d.val});
            var posTemp = 0, negTemp = 0;
            for(var i=0; i<data[0].length; i++){
              if(!NumberUtils.isNoValue( data[0][i].val)){
                if (data[0][i].val < 0){
                  negTemp = posTemp + data[0][i].val;
                }
                posTemp += data[0][i].val;
                if(posTemp > primaryAxisMaxValue){
                  primaryAxisMaxValue = posTemp;
                }
                if(negTemp < primaryAxisMinValue){
                  primaryAxisMinValue = negTemp;
                }
              }
            }

            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
                makeScales();
            }
            
            parseOptions();
            
         return chart;        
      };

      chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  originalData.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  originalData.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      /**
      * set/get properties
      */
      chart.properties = function(props){
        if (!arguments.length){
          return properties;
         }
         
      properties = manifest.props(props);
    
      colorPalette = properties.colorPalette;
      //updateScales();

         return chart;        
      };
      
      /**
       * TODO: add desc
       */
      var makeScales = function(){
      var domain = [];
            for (var i=0; i < data[0].length; i++){
                 domain.push(i);
            }
            categoryScale.domain(domain).rangeBands([0, width]);
            primaryScale.domain([primaryAxisMinValue, primaryAxisMaxValue]).range([height, 0]).nice();
            Scaler.perfect(primaryScale);
      };
      
        //Alex su
        var getTooltipData = function(index){
        var body = {
            'name':null,
            'val': [],
        };
        body.name = handleNull(originalData.getMeasureValuesGroupDataByIdx(0).values[0].col);
        var item = {
            'shape': 'squareWithRadius',
            'color': colorPalette[0],
            'label': null,
            'value': handleNull(originalData.getMeasureValuesGroupDataByIdx(0).values[0].rows[0][index].val)
        };
        body.val.push(item);
        var footer = {
            'label': handleNull(originalData.getAnalysisAxisDataByIdx(0).values[0].col.val),
            'value': handleNull(originalData.getAnalysisAxisDataByIdx(0).values[0].rows[index].val)
        };
        
          var tooltipData = {
              'body':[],
              'footer':[],
          };
          tooltipData.body.push(body);
          tooltipData.footer.push(footer);
          return tooltipData;
        };

    
    var handleNull = function(_){
      if (_ === null || _ === undefined)
        return defaultString;
      else 
        return _;
    };

      
      /**
       * TODO: add desc
       */
      chart.categoryScale = function(scale){
        if (!arguments.length){
          return categoryScale;
         }
        categoryScale = scale;
         return chart;
      };
     
      chart.primaryScale = function(scale){
        if (!arguments.length){
          return primaryScale;
         }
        primaryScale = scale;
         return chart;
      };
      
      chart.secondScale = function(scale){
       
         return chart;
      };      
      
      /**
      * get preferred size
      * @return {
          'width': NUMBER,
          'height' : NUMBER
        }
      */
      chart.getPreferredSize = function(){
        
      }; 
      
      /**
      * get/set your color palette if you support color palette
      */
      chart.colorPalette = function(_){
        if(!arguments.length){
          return colorPalette;
        }
        colorPalette = _;
        return this;
      };

      /**
      * get/set your shape Palette if you support shape Palette
      */
      chart.shapePalette = function(_){
        if(!arguments.length){
          return shapePalette;
        }
        shapePalette = _;
        return this;
      };      
      
      
      /**
     * set/get effect manager
     */
        chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return this;        
    };
    
      chart.properties(null);
      return chart;
  };
  return waterfall;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.Waterfall',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.waterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.BaseBar',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
    var module = {
      'id' : 'sap.viz.modules.waterfall',
      'name' : 'waterfall',
      base : "sap.viz.modules.xy.bar.base",
      'properties' : {
        'enableRoundCorner' : null,
        'secondaryValuesColorPalette' : null
      },
      fn : fn,
      'feeds' : {
          configure : {
            'regionColor':null,
            'secondaryValues':null,
            'axisLabels':{
              max:1,
              acceptMND:-1,
              maxStackedDims : 1 
            },
            'primaryValues':
            {
              max:1
            }
          }
      }
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.WaterfallChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Waterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/waterfall',
      name : 'IDS_WATERFALLCHART',
      base : 'riv/baseverticalchart',
      modules : {
          legend : null,        
          main : {
      controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
                    properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                    }
                  }
                }
              },
              modules : {
                plot : {
                    id : 'sap.viz.modules.waterfall',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
          }
      },
      dependencies : {
          attributes : [ {
            targetModule : 'main.yAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'primaryScale'
          },{
            targetModule : 'main.xAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'categoryScale'
          },null,{
      targetModule : 'main.yAxis',
            target : 'title',
            sourceModule : 'main.plot',
            source : 'primaryAxisTitle'
      }],
           events : [ {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main.plot',
            type : 'hideTooltip'
          }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
          } ]
        }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.modules.horizontalwaterfall',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.MNDHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
}
],
function Setup(TypeUtils, dispatch, MNDHandler, ColorSeries, NumberUtils, tooltipDataHandler, Scaler, langManager) {
    var bar = function(manifest) {
        var width, height, barSize;
        var data, orignalData;
        var effectManager = null;
        var categoryScale = d3.scale.ordinal(),
            primaryScale = d3.scale.linear();
            
        var _data = [], gWrapper,
            dataStructureChange = false,
            dataValueChange = false,
            sizeChange = false,
            colorPalette = ColorSeries.sap32().range();
        
        var properties;
        
        var primaryAxisMinValue = 0, 
            primaryAxisMaxValue = 0;
        
        //variable for event
        var decorativeShape,                    // the shape to show the effect of mouse move
            eventLayerShape,                   // the shape to trigger event
            lastSelected = [],                  // the variable to hold all selected shapes
            lastHovered = null,                 // last hovered dimention item index
      tooltipVisible = true,  
            eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized');
            
        var enableDataLoadingAnimation = true,
            enableDataUpdatingAnimation = true,
            totalIntervalTime = 800,
            isOnlyInitAnimation = false;
        
        var defsEnter, 
            roundCornerDefs;
        var drawingEffect = 'normal';
        
        //alex su
    var defaultString = langManager.get('IDS_ISNOVALUE');
        
        chart.hoverOnPoint = function(point){
            var  xOnModule = point.x, yOnModule = point.y;
            // find the closet dimension
            var i = -1;
            while (i < data[0].length) {
                if (Math.abs(yOnModule - categoryScale.rangeBand()*i - 0.5 * categoryScale.rangeBand() ) <= 0.5 * categoryScale.rangeBand()) {
                    break;
                }
                i++;
            }

            if (i > (data[0].length - 1)
                    || i < 0) {
                decorativeShape.style(
                        'visibility', 'hidden');
                return;
            }
            
            decorativeShape.attr('y', categoryScale.rangeBand() * i + barSize / 8 ).style('visibility', 'visible');
            
            if(lastHovered !== i){
        if (tooltipVisible) {      
          lastHovered = i;
          //this.parentNode point to plot graphic. it is different from bar chart as in bar chart it should get the yoffset which can get it from mian graphic element
          var transform = gWrapper.node().getTransformToElement(gWrapper.node().ownerSVGElement);
          var yoffset = transform.f;
          var tData = getTooltipData(i);
          tData.point = {
              x: d3.event.layerY,
              y: categoryScale.rangeBand()*i + 0.5 * categoryScale.rangeBand() + yoffset
          };
          eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tData));
        }
            }
            
        };        
        
        chart.blurOut = function(){
            decorativeShape.style('visibility', 'hidden');
            lastHovered = null;
      if (tooltipVisible) {
        eDispatch.hideTooltip();
      }
        };
        
        chart.highlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 1);
          }
        }else{
          elems.setAttribute('fill-opacity', 1);
        }
      };
      
      chart.unhighlight = function(elems){
        if(elems instanceof Array){
          for(var i = 0, len = elems.length; i < len; i++){
            elems[i].setAttribute('fill-opacity', 0.2);
          }
        }else{
          elems.setAttribute('fill-opacity', 0.2);
        }
      };
      
      chart.clear = function(gray){
        if( gray == null){
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 1);
        }else{
          gWrapper.selectAll('.datapoint').attr('fill-opacity', 0.2);
        }
      };
      
      chart.parent = function(){
        return gWrapper;
      };
            
        /**
         * Parse options
         */
        var parseOptions = function(){
            drawingEffect = properties.drawingEffect;
            enableRoundCorner = properties.enableRoundCorner;
            enableDataLoadingAnimation =  properties.animation.dataLoading; 
            enableDataUpdatingAnimation =  properties.animation.dataLoading; 
      tooltipVisible = properties.tooltip.enabled;
        };

        
        /**
         * Create chart
         */
        function chart(selection){
            
            
            if(!TypeUtils.isExist(primaryScale)) return;
          
            parseOptions();
            
            selection.each(function(){
                //remove event when chart is redo animation  
                
                var plotHeight = chart.height();
                var plotWidth = chart.width();
                
                var barNumber = data[0].length;
                    barSize = 2 * (categoryScale.rangeBand()) / 3 ;
                
                var svg = gWrapper = d3.select(this);              
                
                //append decorativeShape bar
                if(decorativeShape == null){
                        decorativeShape = d3.select(this).append('rect')
                                            .style('visibility', 'hidden').attr('height', categoryScale.rangeBand() - barSize/4)
                                            .attr('width',  plotWidth)
                                            .attr('fill', 'rgba(133,133,133, 0.2)');
                }else{
                  decorativeShape.attr('width', width).attr('height',   categoryScale.rangeBand() - barSize/4).style('visibility', 'hidden');
                }

                if(defsEnter == null){
                    defsEnter = svg.append('defs').append('clipPath').append('rect').attr('width', width).attr('height', height);       
                }else{
                    defsEnter.attr('width', width).attr('height', height);
                }       
                
                var lastRectIndex = data[0].length - 1;
                
                var waterfall = svg.selectAll('g.waterfall').data(data);
                    waterfall.enter().append('g').attr('class','waterfall');
                    waterfall.each(function(d,i){
                        var rect = d3.select(this).selectAll('rect').data(d);
                        var sum = 0, tempSum = 0, width = [], xCoordinator = [];
                        var interval = totalIntervalTime / (d.length);
                        rect.enter().append('rect');
            rect.exit().remove();
            rect.attr('fill',function(d,j){  
                          var parameters = {
                            drawingEffect:drawingEffect,
                            fillColor : colorPalette[i],
                            direction : 'vertical'
                        };
                        return effectManager.register(parameters);})
                        .attr('shape-rendering','crispEdges').attr('class', 'datapoint').attr('fill-opacity', 1);
                                                    
                        rect.each(function(d,j){
                            if(d.val != defaultString){
                              var barWidth;
                                    sum += d.val;
                                    if(sum > tempSum){
                                      barWidth = primaryScale(sum) - primaryScale(tempSum);
                                      width.push(barWidth);
                                        xCoordinator.push(primaryScale(tempSum));                                       
                                    }else{
                                      barWidth = primaryScale(tempSum) - primaryScale(sum);
                                      width.push(barWidth);
                                        xCoordinator.push(primaryScale(sum));
                                    }
                                    tempSum = sum;
                            }else{
                              width.push(4);
                            var xPoint;
                            if(sum > tempSum){
                              xPoint = primaryScale(tempSum);
                            }else{
                              xPoint = primaryScale(sum);
                            }
                          
                          if(xPoint == plotWidth){
                            xPoint -= 4;
                          }
                          xCoordinator.push(xPoint);
                          }
                        });
                        
                      
                        if(enableDataLoadingAnimation && !isOnlyInitAnimation ){
                            if(dataStructureChange){
                                sum = 0, tempSum = 0,
                                rect.attr('x', function(d, j){
                                        var x;
                                        if(d.val != defaultString){
                                          sum += d.val;
                                          x = primaryScale(tempSum);
                                          tempSum = sum;
                                        }else{
                                          x = primaryScale(tempSum);
                                        }  
                                        return x;
                                        })
                                    .attr('height', barSize)
                                    .attr('width',0);
                                rect.attr('y', function(d,j){
                                        var y = categoryScale(j) + barSize/4;
                                        return y;
                                });
                               sum = 0, tempSum = 0;
                               var animation = rect.transition()
                                   animation.delay(function(d,m){return (m) * interval}) 
                                   animation.attr('x',function(d,j){
                                                        return xCoordinator[j];
                                   });
                                   animation.attr('width',function(d,j){
                                        return width[j];
                                   });
                                   animation.each('end',function(d,j){
                                        if(j == lastRectIndex){
                                            completeAnimation();
                                        }
                                   });
                            }else if(sizeChange){
                                   var animation = rect.transition();
                                   animation.attr('y',function(d,j){
                                        var y = categoryScale(j) + barSize/4;
                                        return y;
                                   });
                                   animation = rect.transition();                                   
                                   animation.delay(function(d,m){return (m+1) * interval})
 
                                   animation.attr('x',function(d,j){
                                        return xCoordinator[j];
                                   });
                                   animation.attr('height',function(d,j){
                                        return barSize;
                                   });  
                                   animation.attr('width',function(d,j){
                                        return width[j];
                                   });  
                                   animation.each('end',function(d,j){
                                        if(j == lastRectIndex){
                                            completeAnimation();
                                        }
                                   });                                 
                            }else if(dataValueChange){
                                var animation = rect.transition();
                                animation.delay(function(d,m){return (m) * interval});
                                animation.attr('x',function(d,j){
                                     return xCoordinator[j];
                                });
                                animation.attr('width',function(d,j){
                                     return width[j];
                                });
                                animation.each('end',function(d,j){
                                     if(j == lastRectIndex){
                                         completeAnimation();
                                     }
                                });                                  
                            }
                        }else{
                            sum = 0, tempSum = 0,
                            rect.attr('x', function(d, j){return xCoordinator[j];})
                                .attr('y', function(d,j){
                                        var y = categoryScale(j) + barSize/4;
                                        return y;
                                })
                                .attr('width',function(d,j){return width[j];})
                                .attr('height',barSize);
                            
                            completeAnimation();
                        }
                        rect.exit().remove();
                    });                   
                    
                    sizeChange = false, dataStructureChange = false, dataValueChange = false;
                 
            });
    
            return chart;
        };
        
        function completeAnimation(){
            eDispatch.initialized();
        };
        
        chart.dispatch = function(_){
            if(!arguments.length)
                return eDispatch;
            eDispatch = _;
            return this;
        };
        
        /**
        * set/get width
        */
        chart.width = function(value){
            if (!arguments.length){
              return width;
            }
        sizeChange = (width === value)&&!sizeChange? false:true;
            width = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
                makeScales();
            }
            return chart;
        };

        /**
        * set/get height
        */
        chart.height = function(value){
            if (!arguments.length){
                return height;
            }
        sizeChange = (height === value)&&!sizeChange? false:true;
            height = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
                makeScales();
            }
            return chart;           
        };

        /**
        * set/get data, for some modules like Title, it doesn't need data
        */
        chart.data = function(value){
            if (!arguments.length){
                return data;
            }
            data = originalData = value;            
            var obj = MNDHandler(data);
            
            data = obj["MG1"];
            
            for(var i = 0;  i< data.length; i++){
              for(var j = 0; j < data[i].length; j++){
                if(NumberUtils.isNoValue(data[i][j].val)){
                    data[i][j].val = defaultString;
            }
              }
            }
        
            //judge what changed in dataset
            if(data.length !== _data.length || data[0].length !== _data[0].length){
                dataStructureChange = true;
            }else {
                dataValueChange = true;
            }
            _data = data;
            
            primaryAxisMaxValue =1,  primaryAxisMinValue = 0;
            
            //primaryAxisMinValue = d3.min(data[0], function(d){ return d.val});
            //primaryAxisMaxValue = d3.max(data[0], function(d){ return d.val});
            var posTemp = 0, negTemp = 0;
            for(var i=0; i<data[0].length; i++){
              if(!NumberUtils.isNoValue( data[0][i].val)){
                if (data[0][i].val < 0){
                  negTemp = posTemp + data[0][i].val;
                }
                posTemp += data[0][i].val;
                if(posTemp > primaryAxisMaxValue){
                  primaryAxisMaxValue = posTemp;
                }
                if(negTemp < primaryAxisMinValue){
                  primaryAxisMinValue = negTemp;
                }
              }
            }

            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
                makeScales();
            }
            parseOptions();
            return chart;           
        };

        chart.primaryAxisTitle = function(_){
        if(!arguments.length){
          var titles =  originalData.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
      chart.secondAxisTitle = function(_){
        if(!arguments.length){
          var titles =  originalData.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
      };
      
        /**
        * set/get properties
        */
        chart.properties = function(props){
            if (!arguments.length){
                return properties;
            }   
      properties = manifest.props(props);
      colorPalette = properties.colorPalette;
      //updateScales();

            return chart;
        };
        
        /**
     * set/get effect manager
     */
        chart.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return chart;        
     };
        /**
         * TODO: add desc
         */
        var makeScales = function(){
            var domain = [];
            for (var i=0; i < data[0].length; i++){
                 domain.push(i);
            }
            categoryScale.domain(domain).rangeBands([0, height]);
            primaryScale.domain([primaryAxisMinValue, primaryAxisMaxValue]).range([0, width]).nice();
            Scaler.perfect(primaryScale);
        };
        
        //Alex su
        var getTooltipData = function(index){
        var body = {
            'name':null,
            'val': [],
        };
        body.name = handleNull(originalData.getMeasureValuesGroupDataByIdx(0).values[0].col);
        var item = {
            'shape': 'squareWithRadius',
            'color': colorPalette[0],
            'label': null,
            'value': handleNull(originalData.getMeasureValuesGroupDataByIdx(0).values[0].rows[0][index].val)
        };
        body.val.push(item);
        var footer = {
            'label': handleNull(originalData.getAnalysisAxisDataByIdx(0).values[0].col.val),
            'value': handleNull(originalData.getAnalysisAxisDataByIdx(0).values[0].rows[index].val)
        };
        
          var tooltipData = {
              'body':[],
              'footer':[],
          };
          tooltipData.body.push(body);
          tooltipData.footer.push(footer);
          return tooltipData;
        };
        
    var handleNull = function(_){
      if (_ === null || _ === undefined)
        return defaultString;
      else 
        return _;
    };

        /**
         * TODO: add desc
         */
        chart.categoryScale = function(scale){
            if (!arguments.length){
                return categoryScale;
            }
            categoryScale = scale;
            return chart;
        };
       
        chart.primaryScale = function(scale){
            if (!arguments.length){
                return primaryScale;
            }
            primaryScale = scale;
            return chart;
        };
        
        chart.secondScale = function(scale){
         
            return chart;
        };      
        
        /**
        * get preferred size
        * @return {
            'width': NUMBER,
            'height' : NUMBER
          }
        */
        chart.getPreferredSize = function(){
            
        }; 
        
        /**
        * get/set your color palette if you support color palette
        */
        chart.colorPalette = function(_){
            if(!arguments.length){
                return colorPalette;
            }
            colorPalette = _;
            return this;
        };

        /**
        * get/set your shape Palette if you support shape Palette
        */
        chart.shapePalette = function(_){
            if(!arguments.length){
                return shapePalette;
            }
            shapePalette = _;
            return this;
        };      
        
        chart.properties(null);
        return chart;
    };
    return bar;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.xy.HorizontalWaterfall',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.horizontalwaterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Waterfall',
  version : '4.0.0'
}
],
function Setup(Manifest, fn) {
    var module = {
      'id' : 'sap.viz.modules.horizontalwaterfall',
      'name' : 'horizontal waterfall',
      base : "sap.viz.modules.waterfall",
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.HorizontalWaterfallChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalWaterfall',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/horizontal_waterfall',
      name : 'IDS_HORIZONTALWATERFALLCHART',
      base : 'riv/basehorizontalchart',
      modules : {
          legend : null, 
          main : {
            controllers : {
                  'interaction' : {
                    id : 'sap.viz.modules.controller.interaction',
                    configure : {
                      propertyCategory : 'interaction',
                      properties : {
                        supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                      }
                    }
                  }
              },
              modules : {
                plot : {
                    id : 'sap.viz.modules.horizontalwaterfall',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
          }
      },
      dependencies : {
          attributes : [ {
            targetModule : 'main.xAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'primaryScale'
          },{
            targetModule : 'main.yAxis',
            target : 'scale',
            sourceModule : 'main.plot',
            source : 'categoryScale'
          },null,{
        targetModule : 'main.xAxis',
            target : 'title',
            sourceModule : 'main.plot',
            source : 'primaryAxisTitle'
      }],
          events : [ {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main.plot',
            type : 'showTooltip'
          }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main.plot',
            type : 'hideTooltip'
          }, {
              targetModule : 'main.interaction',
              listener : 'registerEvent',
              sourceModule : 'main.plot',
              type : 'initialized.interaction'
           } ]
        }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Bar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/bar',
      name : 'IDS_BARCHART',
      base : 'riv/basehorizontalchart',
      modules : {
          main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
                    properties : {
                      supportedEventNames: ['mouseup', 'mousemove', 'touchstart']
                    }
                  }
                }
              },
              modules : {
                plot : {
                    id : 'sap.viz.modules.bar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                }
              }
          }
      },
      feeds:{
        secondaryValues: {
          max: 0
        }// or null
      },
     dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
          targetModule : 'main.xAxis',
          target : 'title',
          sourceModule : 'main.plot',
          source : 'primaryAxisTitle'
        },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
        events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
            targetModule : 'main.interaction',
            listener : 'registerEvent',
            sourceModule : 'main.plot',
            type : 'initialized.interaction'
          },{
            targetModule : 'main.interaction',
            listener : 'highlightedByLegend',
            sourceModule : 'legend',
            type : 'highlightedByLegend'
            }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
            } ]
      }      
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.VerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/column',
      name : 'IDS_VERTICALBARCHART',
      base : 'riv/baseverticalchart',
      modules : {
          main : {
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction',
          properties : {}
                  }
                }
              },      
              modules : {
                plot : {
                    id : 'sap.viz.modules.verticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                },
              }
          }
      },
      feeds:{
        secondaryValues: {
          max: 0
        }// or null
      },
      dependencies : {
        attributes : [ {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.yAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'main.yAxis',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
        } ],
         events : [ {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
            targetModule : 'legend',
          listener : 'deselectLegend',
          sourceModule : 'main.interaction',
          type : 'deselectLegend'
      }]
      }
    };
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_bar',
    name : 'IDS_DUALBARCHART',
    base : 'viz/bar',
      modules : {
          main : {
              modules : {
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
                xAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                  }
                },
                xAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                      'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'xAxis2',
                        properties : {
                            type : 'value',
                            position : 'top',
                            gridline : {
                                visible : false
                            }
                        }
                    }
                },
         
              },
          },
      },
    feeds:{
    secondaryValues: {
      min : 1,
      max : Number.POSITIVE_INFINITY 
    }// or null
    },
      dependencies : {
        attributes : [ {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.xAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondScale'
        }, {
          targetModule : 'main.xAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.xAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        }, {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        },{
      targetModule : 'main.xAxis',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'primaryAxisTitle'
    }, {
      targetModule : 'main.xAxis2',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'secondAxisTitle'
    },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
    },
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var chart = {
    id : 'viz/dual_column',
    name : 'IDS_DUALVERTICALBARCHART',
    base : 'viz/column',
      modules : {
          main : {
              modules : {
                plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
              yAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                  }
                },
                yAxis2 : {
                    id : 'sap.viz.modules.axis',
                    configure : {
                        'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                        propertyCategory : 'yAxis2',
                        properties : {
                            type : 'value',
                            position : 'right'
                        }
                    }
                },
              },
          }
      },
    feeds:{
      secondaryValues: {
        min : 1,
        max : Number.POSITIVE_INFINITY 
      }
    },
      dependencies : {
        attributes : [ {
          targetModule : 'main.yAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'primaryScale'
        }, {
          targetModule : 'main.yAxis2',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'secondScale'
        }, {
          targetModule : 'main.yAxis',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'primaryAxisColor'
        }, {
          targetModule : 'main.yAxis2',
          target : 'color',
          sourceModule : 'main.plot',
          source : 'secondAxisColor'
        }, {
          targetModule : 'main.xAxis',
          target : 'scale',
          sourceModule : 'main.plot',
          source : 'categoryScale'
        }, {
      targetModule : 'main.yAxis2',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'secondAxisTitle'
    },{
      targetModule : 'main.yAxis',
       target : 'title',
       sourceModule : 'main.plot',
       source : 'primaryAxisTitle'
    },{
          targetModule : 'legend',
          target : 'colorPalette',
          sourceModule : 'main.plot',
          source : 'colorPalette'
        },{
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
        } ],
    },
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_column',
      name : 'IDS_STACKEDVERTICALBARCHART',
      base : 'viz/column',
      feeds:{
        secondaryValues: {
          max: 0
        }
      },
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/dual_stacked_column',
      name : 'IDS_DUALSTACKEDVERTICALBARCHART',
      base : 'viz/dual_column',
      modules : {
          main : {
            modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
          }
      }
    };
    
    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualPercentageStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/100_dual_stacked_column',
      name : 'IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART',
      base : 'viz/dual_stacked_column',
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                        properties : {
                             mode : 'percentage',
                        }
                    }
                  }
              }
          }
      }    
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/stacked_bar',
      name : 'IDS_STACKEDBARCHART',
      base : 'viz/bar',
      feeds:{
        secondaryValues: {
          max: 0
        }
      },
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/dual_stacked_bar',
      name : 'IDS_DUALSTACKEDBARCHART',
      base : 'viz/dual_bar',
      modules : {
          main : {
            modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                        propertyCategory : 'plotArea'
                    }
                  }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.DualPercentageStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
    var chart = {
      id : 'viz/100_dual_stacked_bar',
      name : 'IDS_DUALPERCENTAGESTACKEDBARCHART',
      base : 'viz/dual_stacked_bar',
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                        properties : {
                             mode : 'percentage',
                        }
                    }
                  }
              }
          }
      }  
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageStackedBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_stacked_bar',
      name : 'IDS_PERCENTAGESTACKEDBARCHART',
      base : 'viz/stacked_bar',
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.xy.PercentageStackedVerticalBarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.StackedVerticalBar',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var chart = {
      id : 'viz/100_stacked_column',
      name : 'IDS_PERCENTAGESTACKEDVERTICALBARCHART',
      base : 'viz/stacked_column',
      modules : {
          main : {
              modules : {
                  plot : {
                    id : 'sap.viz.modules.stackedverticalbar',
                    configure : {
                        properties : {
                             mode : 'percentage'
                        }
                    }
                  }
              }
          }
      }
    };

    Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Pie',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "pie",
    feeds : [ {
      'id' : 'pieSectorColor',
      'name' : 'Sector Color',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1
    }, {
      'id' : 'pieSectorSize',
      'name' : 'Sector Size',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.tooltip',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(TextUtils, UADetector, Repository) {
  var moduleManifest;
  var wrapperClass = "tooltip", caretClass = "caret", minRadius = 8.9 * 14 / 2;
  var caretAngle = 60, textsVSpacing = 8;
  //alistar zhu
  var randomSuffix = Repository.newId();
  var shadowFilterId = "tooltip-caret-shadow-" + randomSuffix;
  var textClassNamesInTheme = [ "viz-pie-tooltip-label-dimensions",
      "viz-pie-tooltip-label-value", "viz-pie-tooltip-label-percentage" ];

  function renderCaret(p) {
    return p.append("svg:path").attr("class", caretClass).attr("d", "M 0 0");
  }

  function createShadowFilterDef(defs) {
    var ns = defs.namespaceURI;
    var shadowFilter = defs.appendChild(document.createElementNS(ns, "filter"));
    shadowFilter.id = shadowFilterId;

    var feGaussianBlur = shadowFilter.appendChild(document.createElementNS(ns,
        "feGaussianBlur"));
    feGaussianBlur.setAttribute("in", "SourceAlpha");
    feGaussianBlur.setAttribute("stdDeviation", 3);
    feGaussianBlur.setAttribute("result", "blur");

    var feMerges = shadowFilter.appendChild(document.createElementNS(ns,
        "feMerge"));
    feMerges.appendChild(document.createElementNS(ns, "feMergeNode"))
        .setAttribute("in", "blur");
    feMerges.appendChild(document.createElementNS(ns, "feMergeNode"))
        .setAttribute("in", "SourceGraphic");
  }

  function renderTexts(p) {
    var texts = [];
    for ( var i = 0; i < 3; i++) {
      texts[i] = p.append("svg:text").attr("class", textClass(i)).datum(
          function(d) {
            return {
              text : ""
            };
          });
    }
  }

  function texts(p) {
    return p.selectAll("text");
  }

  function applyTextStyles(texts, moduleManifest) {
    texts.attr("style", function(d, i) {
      var className = textClassNamesInTheme[i];
      return moduleManifest.cssText(className);
    });
  }

  function textClass(i) {
    return "label" + (i + 1);
  }

  function adjustTexts(texts) {
    var textClass1 = textClass(1);
    var text1Height;
    texts.each(function(d) {
      d.r = d3.select(this.parentNode).datum().r;
    }).filter("." + textClass1).attr("dy", function(d) {
      var dy = 0, txt = d.text;
      if (UADetector.isIE()) {
        dy = TextUtils.verticalCentralOffset(txt, this);
      }

      TextUtils.ellipsisInCircle(txt, this, d.r, 0);
      text1Height = this.getBBox().height;

      return dy;
    });
    texts.filter(":not(." + textClass1 + ")").attr(
        "dy",
        function(d, i) {
          var txt = d.text;
          var txtHeight = TextUtils.measure(txt, this).height;

          var dy = (UADetector.isIE() ? (i == 0 ? 0 : txtHeight)
              : (txtHeight / 2))
              + text1Height / 2 + textsVSpacing;

          var maxLength = Math.sqrt(Math.pow(d.r, 2)
              - Math.pow(txtHeight + text1Height / 2 + textsVSpacing, 2)) * 2;

          TextUtils.ellipsis(txt, this, maxLength);
          if (i == 0)
            dy = -dy;

          return dy;
        });
  }

  function normalizeAngle(a) {
    a %= 360;

    if (a < 0)
      a += 360;
    return a;
  }

  function caretRotateTween(el, endAngle) {
    var transformList = el.transform.baseVal;
    var startAngle = transformList.numberOfItems == 0 ? 0
        : normalizeAngle(transformList.getItem(0).angle);

    var endAngles = new Array();
    endAngles[0] = normalizeAngle(endAngle);
    endAngles[1] = endAngles[0] - 360;
    endAngles[2] = endAngles[0] + 360;

    var minRange = 360, index = null;
    for ( var i = 0; i < endAngles.length; i++) {
      var range = Math.abs(endAngles[i] - startAngle);
      if (range < minRange) {
        minRange = range;
        index = i;
      }
    }

    var interpolator = d3.interpolateNumber(startAngle, endAngles[index]);
    return function(t) {
      return "rotate(" + interpolator(t) + ")";
    };
  }

  function computeCaretSize(or) {
    if (or >= 12 * 14)
      return 14;

    if (or >= 8 * 14)
      return 0.8 * 14;

    return 0.5 * 14;
  }

  return function() {
    function tooltip(p) {
      var wrapper = p.selectAll("g." + wrapperClass).data(function(d, i) {
        var data = new Array();
        if (d.or > minRadius)
          data.push({
            r : d.ir,
            caretSize : computeCaretSize(d.or)
          });
        return data;
      });
      wrapper.exit().remove();

      texts(wrapper).call(applyTextStyles, moduleManifest).call(adjustTexts);

      var enterWrapper = wrapper.enter().append("svg:g").attr("class",
          wrapperClass).style("opacity", 0).attr("visibility", "hidden").attr(
          "pointer-events", "none").call(renderCaret).call(renderTexts);

      texts(enterWrapper).call(applyTextStyles, moduleManifest);
    }

    tooltip.createShadowFilterDef = createShadowFilterDef;

    tooltip.defaultStyle = function(parentClass) {
      return "."
          + parentClass
          + " ."
          + wrapperClass
          + " text{dominant-baseline:central}."
          + parentClass
          + " ."
          + wrapperClass
          + " ."
          + caretClass
          + "{fill:#fff;"
          + (UADetector.isSafari() ? "-webkit-svg-shadow: 0 0 10px rgba(0, 0, 0, 0.25)"
              : "filter:url(#" + shadowFilterId + ")") + "}";
    };

    tooltip.moduleManifest = function(_) {
      moduleManifest = _;
    };

    tooltip.select = function(p) {
      var wrapper = p.selectAll("g." + wrapperClass);
      if (wrapper.empty())
        return null;

      return {
        show : function() {
          wrapper.attr("visibility", null).transition().duration(200).style(
              "opacity", 1);
          return this;
        },
        hide : function() {
          wrapper.transition().each("end", function() {
            wrapper.attr("visibility", "hidden");
          }).duration(200).style("opacity", 0);
          return this;
        },
        texts : function() {
          var values = arguments;
          texts(wrapper).each(function(d, i) {
            d.text = values[i];
          }).call(adjustTexts);
          return this;
        },
        caret : function() {
          var caret = wrapper.select("." + caretClass);

          return {
            show : function() {
              caret.attr("d", function(d) {
                var x = Math.tan(caretAngle * Math.PI / 360) * d.caretSize;
                var y = Math.sqrt(d.r * d.r - x * x);
                return "M 0 " + -(y + d.caretSize) + " L " + x + " " + -y
                    + " A " + d.r + " " + d.r + " 0 1 1 " + -x + " " + -y
                    + " Z";
              });
              return this;
            },
            hide : function() {
              caret.attr("d",
                  function(d) {
                    return "M 0 " + d.r + " A " + d.r + " " + d.r + " 0 1 1 0 "
                        + -d.r + " A " + d.r + " " + d.r + " 0 1 1 0 " + d.r
                        + " Z";
                  });
              return this;
            },
            rotateTo : function(angle) {
              caret.transition().duration(200).attrTween("transform",
                  function() {
                    return caretRotateTween(this, angle * 180 / Math.PI);
                  });

              return this;
            }
          };
        }
      };
    };

    return tooltip;
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
}
],
function Setup(Constants, NumberUtils) {
  var CSSCLASS_SECTOR = 'viz-pie-sector';
  var pieLayout = d3.layout.pie().sort(null).value(function(d) {
    return d.v;
  });

  function SectorData(mvObject, dimValueObjects, color, r, value, startAngle,
      endAngle, p) {
    this.dimValueObjects = dimValueObjects;
    this.color = color;
    this.r = r;
    this._value = value;
    this.startAngle = startAngle;
    this.endAngle = endAngle;
    this.p = p;

    var i;
    for (i in mvObject) {
      this[i] = mvObject[i];
    }
  }

  SectorData.prototype = {
    midAngle : function() {
      return (this.endAngle + this.startAngle) / 2;
    },

    dimValues : function() {
      return this.dimValueObjects.map(function(o) {
        return o.val;
      });
    },

    value : function(format) {
      var v = this._value;
      if (format)
        return d3.format(format)(v);
      return v;
    },

    proportion : function(format) {
      var v = (this.endAngle - this.startAngle) / (2 * Math.PI);
      if (format)
        return d3.format(format)(v);
      return v;
    }
  };

  function sectorDatas(d, effectManager) {
    var mvs = d.measure.rows[0];
    var dimensions = d.dimensions;

    var domain = new Array();
    var datas = mvs.map(function(mv, i) {
      domain.push(i);
      return {
        v : mv.val,
        i : i
      };
    }).filter(function(o) {
      var v = o.v;
      return (!NumberUtils.isNoValue(v)) && v > 0;
    });

    var color = d.color.domain(domain);
    var r = d.or;
    var result = pieLayout(datas).map(function(data) {
      var index = data.data.i;
      var fillID = effectManager.register({
        drawingEffect : d.drawingEffect,
        graphType : 'sector',
        fillColor : color(index),
        direction : 'vertical',
        radius : r
      });
      return new SectorData(mvs[index], dimensions.map(function(dimVs) {
        return dimVs.rows[index];
      }), fillID, r, data.value, data.startAngle, data.endAngle, d.p);
    });
    return result;
  }

  var module = function() {
    function sector(sectorGroup, effectManager) {
      var sectors = module.all(sectorGroup).data(function(d) {
        return sectorDatas(d, effectManager);
      });
      sectors.exit().remove();
      sectors.enter().append("svg:path").attr("class",
          Constants.CSS.CLASS.DATAPOINT + ' ' + CSSCLASS_SECTOR);
      sectors.attr("fill", function(d) {
        return d.color;
      }).attr("d", d3.svg.arc().outerRadius(function(d) {
        return d.r;
      }));
    }

    return sector;
  };

  module.all = function(sectorGroup) {
    return sectorGroup.selectAll("path");
  };

  module.cssText = function(moduleManifest) {
    return '.' + CSSCLASS_SECTOR + '{'
        + moduleManifest.cssText(CSSCLASS_SECTOR) + '}';
  };

  return module;
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie.selection',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.0'
}
],
function Setup(sectorModule) {
  var selectedSectorClass = "selectedSector";
  var selectedClass = "selected";

  function select(sect, flag, noAnimation) {
    sect.classed(selectedSectorClass, flag);

    if (!noAnimation)
      sect = sect.transition().duration(200);

    sect.attr("transform", function(d) {
      var dx = dy = 0;
      if (flag) {
        if (this.parentNode.childNodes.length != 1) {
          var a = d.midAngle();
          var r = d.r;
          var sectorMoveOffset;
          if (r >= 96)
            sectorMoveOffset = 6;
          else if (r >= 24)
            sectorMoveOffset = 4;
          else
            sectorMoveOffset = 2;
          dx = sectorMoveOffset * Math.sin(a);
          dy = -sectorMoveOffset * Math.cos(a);
        }
      }

      return "translate(" + dx + "," + dy + ")";
    });
  }

  function selected(sect) {
    return sect.classed(selectedSectorClass);
  }

  return function() {
    return {
      allSelected : function(sectorGroup) {
        return sectorGroup.selectAll("." + selectedSectorClass);
      },

      select : function(s, flag) {
        select(s, flag);
      },

      clear : function(g, flag) {
        g.classed(selectedClass, flag);
      },

      defaultStyle : function(hoverSectorClass, sectorGroupClass) {
        var selectedGroupClass = "." + sectorGroupClass + "." + selectedClass;
        return selectedGroupClass + "{fill-opacity:0.4}" + " ."
            + selectedSectorClass + "," + selectedGroupClass + " ."
            + hoverSectorClass + "{fill-opacity:1}";
      },

      clearAll : function(sectorGroup) {
        sectorGroup.classed(selectedClass, false);
        this.allSelected(sectorGroup).call(select, false, true);
      }
    };
  };
});sap.riv.module(
{
  qname : 'sap.viz.modules.pie',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.pie.sector',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.pie.selection',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.pie.tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(sectorModule, selectionModule, tooltip, TextUtils,
    ColorSeriesGenerator, dispatch, UADetector, FunctionUtils, TypeUtils,
    Repository) {
  var horizontalMarginRatio = 2.414;
  // Alistar zhu
  var randomSuffix = Repository.newId();
  var innerRadiusRatio = function(outerRadius) {
    // 12em
    // return outerRadius >= 12 * 14 ? horizontalMarginRatio : 1.618;
    return horizontalMarginRatio;
  };

  var padding = 6;

  var loadingAnimationDuration = 600;
  var defaultColorPalette = ColorSeriesGenerator.sap32();

  var id = "viz-pie";
  var defsId = id + "-defs" + randomSuffix;

  var clipPathIdPrefix = id + "-clipPath-";
  var wrapperClass = id, backgroundClass = "background", donutTitleClass = wrapperClass
      + "-donut-title", hoverSectorClass = "hoverSector", sectorGroupClass = "sectorgroup";

  var _dispatch = dispatch("selectData", "deselectData", "initialized");
  var selection = selectionModule();

  var tooltipFunc = tooltip();

  var sectorFunc = sectorModule();

  var defaultStyle = "."
      + wrapperClass
      + "{font-family:'Open Sans',Arial,Helvetica,sans-serif;text-anchor:middle}"
      + "." + wrapperClass + " ." + backgroundClass + "{fill-opacity:0;}"
      + " ." + donutTitleClass
      + "{font-weight:bold;font-size:16px;fill:#333;dominant-baseline: middle}"
      + tooltipFunc.defaultStyle(wrapperClass)
      + selection.defaultStyle(hoverSectorClass, sectorGroupClass);

  function rotateTootltipBySector(d, tip, caret) {
    if (!caret)
      caret = tip.caret();
    caret.show().rotateTo(d.midAngle());
    tip.texts(d.dimValues().join(" - "), d.value(d.p.tooltip.valueFormat),
        d.proportion(d.p.tooltip.percentageFormat)).show();
  }

  function donutTitle(wrapper) {
    var text = wrapper.selectAll("text." + donutTitleClass).data(function(d) {
      return d.p.isDonut ? [ {
        width : d.ir,
        title : d.measure.col
      } ] : [];
    });
    text.exit().remove();
    text.enter().insert("svg:text", ":nth-child(2)").attr("class",
        donutTitleClass);

    text.each(function(d) {
      TextUtils.ellipsisInCircle(d.title, this, d.width, 0);
    });
  }

  function calculateOuterRadiusByHeight(h) {
    return h / 2 - padding;
  }

  function calculateOuterRadiusByWidth(w) {
    return Math.max(w / 2 / (1 + 1 / horizontalMarginRatio), padding
        * horizontalMarginRatio);
  }

  function calculateOuterRadius(w, h, maxRadius) {
    if (maxRadius) {
      return Math.min(h / 2, w / 2);
    }
    return Math.min(calculateOuterRadiusByHeight(h),
        calculateOuterRadiusByWidth(w));
  }

  function calculateInnerRadius(outerRadius) {
    return outerRadius / innerRadiusRatio(outerRadius);
  }

  var clipPathArc = d3.svg.arc();

  function clipPathTween(d) {
    var clipPathInterpolate = d3.interpolateNumber(d.startAngle, d.endAngle);
    return function(t) {
      d.endAngle = clipPathInterpolate(t);
      return clipPathArc(d);
    };
  }

  function defStyles(defs, manifest) {
    var style = d3.select(defs).selectAll("style").data(
        [ defaultStyle + sectorModule.cssText(manifest) ]);

    style.exit().remove();
    style.enter().append("style");
    style.text(String);
  }

  function highlight(el, flag, onSector, tip, sectorGroup) {
    selection.select(TypeUtils.isArray(el) ? d3.selectAll(el) : d3.select(el),
        flag);
    if (onSector === false)
      refreshTooltip(tip, sectorGroup);
  }

  function refreshTooltip(tip, sectorGroup) {
    if (!tip)
      return;

    var selectedSectors = selection.allSelected(sectorGroup);

    if (selectedSectors.empty())
      tip.hide();
    else {
      var d = sectorGroup.datum();
      if (!d.p.tooltip.visible)
        tip.hide();
      else {
        var sum = 0;
        var proportionSum = 0;
        var numer = 0;
        selectedSectors.each(function(d) {
          sum += d.val;
          proportionSum += d.proportion();
          numer++;
        });
        var caret = tip.caret();
        if (numer == 1) {
          rotateTootltipBySector(selectedSectors.datum(), tip, caret);
        } else {
          tip.texts(numer + " selected", d3.format(d.p.tooltip.valueFormat)
              (sum), d3.format(d.p.tooltip.percentageFormat)(proportionSum));
          caret.hide();
        }
      }
    }
  }

  function fireInitializedEvent(d) {
    if (d.domInitialized && (!d.animation || d.animationEnd))
      _dispatch.initialized({
        name : 'initialized'
      });
  }

  var result = function(manifest) {
    tooltipFunc.moduleManifest(manifest);

    var width = null, height = null, data = null, props = null, colorPalette;
    var effectManager = null;
    var widthFunctor, heightFunctor, propsFunctor = FunctionUtils.noop;

    var parent, sectorGroup, wrapper, tip;

    function pie() {
      parent = this;

      var root = this.node().ownerSVGElement;
      var defs = root.getElementById(defsId);
      if (!defs) {
        defs = document.createElementNS(root.namespaceURI, "defs");
        root.insertBefore(defs, root.childNodes[0]);
        defs.id = defsId;
        tooltipFunc.createShadowFilterDef(defs);

        effectManager.setContainer(d3.select(defs));
      }

      defStyles(defs, manifest);

      wrapper = this.selectAll("g." + wrapperClass).data(pieWrapperData(data));
      wrapper.exit().each(
          function(d) {
            document.documentElement.removeEventListener("keydown",
                d.keydownListener);
            delete d.keydownListener;
          }).remove();

      var enterWrapper = wrapper.enter().append("g")
          .attr("class", wrapperClass);

      enterWrapper.append("svg:g").attr("class", sectorGroupClass);

      wrapper.attr(
          "transform",
          function(d) {
            if (d.p.alignCenter) {
              return null;
            }
            return "translate(" + d.w / 2 + ","
                + (d.p.valign == "center" ? d.h / 2 : (d.or + padding)) + ")";
          }).select("." + backgroundClass).attr("width", function(d) {
        return d.w;
      }).attr("height", function(d) {
        return d.h;
      }).attr("x", function(d) {
        return -d.w / 2;
      }).attr("y", function(d) {
        return -d.h / 2;
      });

      var clipPath = wrapper.selectAll(function() {
        var result = new Array();
        Array.prototype.forEach.call(this.childNodes, function(node) {
          if (node.tagName == 'clipPath')
            result.push(node);
        });
        return result;
      }).data(function(d) {
        var result = new Array();
        var isDonut = d.p.isDonut;
        var animation = d.animation = d.p.animation.dataLoading;
        if (isDonut || animation) {
          result.push({
            innerRadius : isDonut ? d.ir : 0,
            outerRadius : d.or + padding,
            startAngle : 0,
            endAngle : Math.PI * 2,
            animation : animation
          });
        }
        return result;
      });

      clipPath.exit().remove();
      clipPath.enter().append("svg:clipPath").attr(
          "id",
          function() {
            var id, k = 0;
            while (true) {
              id = clipPathIdPrefix + (k++) + randomSuffix;
              if (!document.getElementById(id))
                break;
            }
            this.parentNode.querySelector("." + sectorGroupClass).setAttribute(
                "clip-path", "url(#" + id + ")");
            return id;
          }).append("svg:path").attr("clip-rule", "evenodd").attr("d",
          clipPathArc);

      wrapper.call(donutTitle);
      sectorGroup = wrapper.select("g").call(sectorFunc, effectManager);

      selection.clearAll(sectorGroup);

      wrapper.call(tooltipFunc);
      tip = tooltipFunc.select(wrapper);
      if (tip)
        tip.hide();

      clipPath.filter(function(d) {
        return d.animation;
      }).select(":first-Child").transition().duration(loadingAnimationDuration)
          .each(
              "end",
              function(d) {
                var clipPathNode = this.parentNode;
                var wrapperNode = clipPathNode.parentNode;
                if (d.innerRadius == 0) {
                  wrapperNode.removeChild(clipPathNode);
                  wrapperNode.querySelector("." + sectorGroupClass)
                      .removeAttribute("clip-path");
                }
                var wrapperData = d3.select(wrapperNode).datum();
                wrapperData.animationEnd = true;
                fireInitializedEvent(wrapperData);
              }).attrTween("d", clipPathTween);

      clipPath.filter(function(d) {
        return !d.animation;
      }).select(":first-Child").attr("d", clipPathArc);

      wrapper.each(function(d) {
        d.domInitialized = true;
        fireInitializedEvent(d);
      });
    }

    function pieWrapperData(d) {
      var parentNode = this.parentNode;
      var p = manifest.props(propsFunctor.apply(parentNode, arguments));
      var w = widthFunctor.apply(parentNode, arguments);
      var h = heightFunctor.apply(parentNode, arguments);
      var or = calculateOuterRadius(w, h, p.maxRadius);
      var colorRange = d3.functor(colorPalette).apply(parentNode, arguments);

      var result = {
        w : w,
        h : h,
        p : p,
        or : or,
        ir : calculateInnerRadius(or),
        color : colorRange ? d3.scale.ordinal().range(colorRange)
            : defaultColorPalette.copy(),
        measure : d.getMeasureValuesGroupDataByIdx(0).values[0],
        dimensions : d.getAnalysisAxisDataByIdx(0).values
      };
      result.drawingEffect = result.p.drawingEffect;

      return [ result ];
    }

    pie.parent = function() {
      return parent;
    };

    pie.clear = function(flag) {
      selection.clear(sectorGroup, flag);
      return pie;
    };

    pie.highlight = function(el, onSector) {
      highlight(el, true, onSector, tip, sectorGroup);
      return pie;
    };

    pie.unhighlight = function(el, onSector) {
      highlight(el, false, onSector, tip, sectorGroup);
      return pie;
    };

    pie.mouseover = function(el) {
      var s = d3.select(el);
      s.classed(hoverSectorClass, true);

      var d = s.datum();
      if (d.p.tooltip.visible) {
        if (tip) {
          rotateTootltipBySector(d, tip, undefined);
        }
      } else {
        if (tip) {
          tip.hide();
        }
      }
      return pie;
    };

    pie.mouseout = function(el) {
      var sect = d3.select(el);
      if (UADetector.isIE())
        setTimeout(function() {
          sect.classed(hoverSectorClass, false);
        }, 0);
      else
        sect.classed(hoverSectorClass, false);

      if (!tip)
        return;

      refreshTooltip(tip, sectorGroup);
      return pie;
    };

    /**
     * get/set width
     */
    pie.width = function(_) {
      if (arguments.length == 0)
        return width;
      width = _;
      widthFunctor = d3.functor(width);
      return pie;
    };

    /**
     * get/set height
     */
    pie.height = function(_) {
      if (arguments.length == 0)
        return height;
      height = _;
      heightFunctor = d3.functor(height);
      return pie;
    };

    /**
     * get/set size
     */
    pie.size = function(w, h) {
      if (arguments.length == 0)
        return {
          width : this.width(),
          height : this.height()
        };
      pie.width(w).height(h);
      return pie;
    };

    /**
     * get/set data
     */
    pie.data = function(_) {
      if (arguments.length == 0)
        return data;
      data = _;
      return pie;
    };

    /**
     * get event dispath
     */
    pie.dispatch = function(_) {
      return _dispatch;
    };

    /**
     * get/set properties
     */
    pie.properties = function(_) {
      if (arguments.length == 0)
        return props;
      props = _;
      propsFunctor = d3.functor(props);

      if (typeof (props) === "function")
        colorPalette = function(d, i) {
          return propsFunctor.apply(this, arguments).colorPalette;
        };
      else if (props.colorPalette)
        colorPalette = props.colorPalette;
      return pie;
    };

    /**
     * get/set effect manager
     */
    pie.effectManager = function(_) {
      if (arguments.length == 0)
        return effectManager;

      effectManager = _;

      return pie;
    };

    /**
     * get/set color palette
     */
    pie.colorPalette = function(_) {
      if (arguments.length == 0) {
        return colorPalette || defaultColorPalette.range();
      }
      colorPalette = _;
      return pie;
    };
    return pie;
  };

  return result;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.pie',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.Pie',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.pie',
    'type' : Constants.Module.Type.Chart,
    'name' : 'pie',
    'properties' : {
      'animation' : {
        'name' : 'animation',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'dataLoading' : {
            'name' : 'dataLoading',
            'supportedValueType' : 'Boolean',
            'defaultValue' : true,
            'description' : 'Set enabled/disabled data loading animation of plot area.'
          }
        },
        'description' : 'Settings for animation of plot area.'
      },
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set the color palette for sectors.'
      },
      'isDonut' : {
        'name' : 'isDonut',
        'supportedValueType' : 'Bool',
        'defaultValue' : false,
        'description' : 'Set whether is a donut or pie.'
      },
      'valign' : {
        'name' : 'valign',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'top', 'center' ],
        'defaultValue' : "top",
        'description' : 'Set vertical aligment.',
        'isExported' : false
      },
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'visible' : {
            'name' : 'visible',
            'supportedValueType' : 'Bool',
            'defaultValue' : true,
            'description' : 'Set whether tooltip is enabled.'
          },
          'valueFormat' : {
            'name' : 'valueFormat',
            'supportedValueType' : 'String',
            'defaultValue' : 'n',
            'description' : 'Set the number format of measure value in tooltip.'
          },
          'percentageFormat' : {
            'name' : 'percentageFormat',
            'supportedValueType' : 'String',
            'defaultValue' : ".0%",
            'description' : 'Set the number format of percentage label in tooltip.'
          }
        },
        'description' : 'Settings for tooltip related properties.'
      },
        'drawingEffect':{
          'name' : 'drawingEffect',
          'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Set drawing effect of Pie.',
            'isExported' : true
        }
    },
    'events' : {
      'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc
    },
    'feeds' : {
      id : "pie"
    },
    'css' : {
      '.viz-pie-tooltip-label-dimensions' : {
        'description' : 'Define style for the first label(dimension values) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '14px',
          'font-weight' : 'normal',
          'fill' : '#000'
        }
      },
      '.viz-pie-tooltip-label-value' : {
        'description' : 'Define style for the second label(measure value) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '18px',
          'font-weight' : 'bold',
          'fill' : '#000'
        }
      },
      '.viz-pie-tooltip-label-percentage' : {
        'description' : 'Define style for the third label(percentage) in tooltip.',
        'value' : {
          'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
          'font-size' : '16px',
          'font-weight' : 'normal',
          'fill' : '#333'
        }
      },
      '.viz-pie-sector' : {
        'description' : 'Define style for sector in pie.',
        'value' : {
          'stroke' : 'transparent',
        }
      },
    },
    fn : fn
  };

  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var multiChart = {
    id : 'viz/multi_pie',
    name : 'IDS_MULTIPIECHART',
    base : 'riv/base/multiple',
    modules : {
      legend : {
        data : {
          aa : [ 2 ]
        }
      },
      main : {
        configure : {
          properties : {
            'cellPadding' : 5
          }
        },
        controllers : {
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout',
                    'touchstart' ]
              }
            }
          }
        },
        modules : {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.pie',
                configure : {
                  'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  properties : {
                    valign : "center"
                  }
                }
              }
            }
          }
        }
      }
    },
    feeds : {
      multiplier : {
        acceptMND : 0,
        max : 2
      },
      pieSectorSize : {
        max : constants.Constraints.INF
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main',
        type : 'initialized.interaction'
      }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
      } ]
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDonutChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiChart = {
    id : 'viz/multi_donut',
    name : 'IDS_MULTIDONUTCHART',
    base : 'viz/multi_pie',
    modules : {
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.pie',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea',
                  properties : {
                      'isDonut' : true
                  }
                }
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(multiChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var pieChart = {
    id : 'riv/base/single',
    name : 'IDS_BASESINGLECHART',
    base : 'riv/base',
    'abstract' : true,
    modules : {
      main : {
        id : 'sap.viz.modules.xycontainer',
      }
    }
  };

  Manifest.register(pieChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Pie',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var pieChart = {
    id : 'viz/pie',
    name : 'IDS_PIECHART',
    base : 'riv/base/single',
    modules : {
      legend : {
        data : {
          aa : [ 1 ]
        }
      },
      main : {
        controllers : {
          'interaction' : {
            id : 'sap.viz.modules.controller.interaction',
            configure : {
              propertyCategory : 'interaction',
              properties : {
                supportedEventNames : [ 'mouseup', 'mouseover', 'mouseout',
                    'touchstart' ]
              }
            }
          }
        },
        modules : {
          plot : {
            id : 'sap.viz.modules.pie',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main.plot',
        type : 'initialized.interaction'
      }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
      } ]
    }
  };

  Manifest.register(pieChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.pie.DonutChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var donutChart = {
    'id' : 'viz/donut',
    'name' : 'IDS_DONUTCHART',
    base : 'viz/pie',
    'modules' : {
      'main' : {
        'modules' : {
          'plot' : {
            'configure' : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              'propertyCategory' : 'plotArea',
              'properties' : {
                'isDonut' : true
              }
            }
          }
        }
      }
    }
  };

  Manifest.register(donutChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_line',
    name : 'IDS_MULTILINECHART',
    base : 'riv/base/multiple/xy',
    modules : {
      legend : {
        data : {
          aa : [ 3 ]
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'line',
            orientation : 'left'
          }
        }
      },
    
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary']
          }
        },
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'interaction'
                  }
                }
              },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                },
                configure : {
                  'description':'Settings for the category axis of an XY chart.',
                  propertyCategory : 'xAxis',
                  properties : {
                    title : {
                      visible : false,
                    },
                    gridline : {
                      visible : false
                    },
                    type : 'category',
                    position : 'bottom'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    },
                    gridline : {
                isExported : false
                    },
                    label : {
                      isExported : false
                      },
                      axisline : {
                      isExported : false
                     }
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  propertyCategory : 'yAxis',
                  properties : {
                    type : 'value',
                    position : 'left'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.line',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
      secondaryValues: {
        max: 0
      },
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      }
      ],
      events : [  {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main',
            type : 'showTooltip'
        }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main',
            type : 'hideTooltip'
        } , {
          targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
      }, {
          targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.HorizontalLine',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_horizontal_line',
    name : 'IDS_MULTIHORIZONTALLINECHART',
    base : 'viz/multi_line',
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'horizontalline',
            orientation : 'left'
          }
        }
      },  
      main : {
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              background : {
                configure : {
                  properties : {
                    direction : 'horizontal',
                  }
                }
              },
              xAxis : {
                id : 'sap.viz.modules.axis',
                data : null,
                configure : {
                  'description':'Settings for the value axis of an XY chart.',
                  properties : {
                    type : 'value',
                    gridline : {
                      visible : true
                    }
                  },
                  propertiesOverride : {                   
                    gridline : {
              isExported : true
              },
              label : {
                    isExported : true
                    },
                    axisline : {
                    isExported : true
                   }
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                data : {
                  aa : [ 1 ]
                }, 
                configure : {
                     'description':'Settings for the category axis of an XY chart.',
                  properties : {
                    type : 'category',
                    gridline : {
                      visible : false
                    }
                  },
                  propertiesOverride : {                   
                    gridline : {
              isExported : false
              },
              label : {
                    isExported : false
                    },
                    axisline : {
                    isExported : false
                   }
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.horizontalline',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       max: 0
     },
      axisLabels:{
        max:1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },{
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, 
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualHorizontalLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var multiBarChart = {
    id : 'viz/multi_dual_horizontal_line',
    name : 'IDS_MULTIDUALHORIZONTALLINECHART',
    base : 'viz/multi_horizontal_line',
    modules : {
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary', 'second']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
                 plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
                xAxis:{
                      id : 'sap.viz.modules.axis',
                  configure:{
                    'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
                  }
                },
              xAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'xAxis2',
                  properties : {
                    title : {
                      visible : false,
                    },
                    type : 'value',
                    position : 'top'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       min: 1,
    max : Number.POSITIVE_INFINITY 
     },
      axisLabels:{
        max:1,
        acceptMND: -1
      },
      regionColor:{
        acceptMND: 1
      }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main',
        target : 'secondDataRange',
        sourceModule : 'main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'main.plot.xAxis2',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'secondaryScale'
      },{
        targetModule : 'main.plot.xAxis2',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisTitle'
      }
      ,
      {
        targetModule : 'main.plot.xAxis',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'main.plot.xAxis2',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      }, 
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiDualLineChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.xy.Line',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.controller.Interaction',
  version : '4.0.0'
}
],
function Setup(Manifest,Constants) {
  var multiVBarChart = {
    id : 'viz/multi_dual_line',
    name : 'IDS_MULTIDUALLINECHART',
    base : 'viz/multi_line',
    modules : {
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['primary', 'second']
          }
        },
              controllers : {
                'interaction' : {
                  id : 'sap.viz.modules.controller.interaction',
                  configure : {
                    propertyCategory : 'selectability'
                  }
                }
              },
        modules: {
          plot : {
            modules : {
                 plot: {
                  configure: {
                    propertiesOverride:{
                      primaryValuesColorPalette:{
                        isExported: true
                      },
                      secondaryValuesColorPalette: {
                        isExported: true
                      }
                    }
                  }
                },
              yAxis:{
                  id : 'sap.viz.modules.axis',
              configure:{
                'description':'Settings for the value axis at left or bottom of an XY chart with 2 value axis.'
              }
            },
              yAxis2 : {
                id : 'sap.viz.modules.axis',
                configure : {
                  'description':'Settings for the value axis at right or top of an XY chart with 2 value axis.',
                  propertyCategory : 'yAxis2',
                  properties : {
                    title : {
                      visible : false,
                    },
                    gridline : {
                      visible : false
                    },
                    type : 'value',
                    position : 'right'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
      max:1
     },
     secondaryValues:
     {
       min: 1,
    max : Number.POSITIVE_INFINITY 
     },
    axisLabels:{
      max:1,
      acceptMND: -1
    },
    regionColor:{
      acceptMND: 1
    }
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'primaryDataRange',
        sourceModule : 'main.plot.plot',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'primaryDataRange',
        sourceModule : 'main',
        source : 'primaryDataRange'
      },
      {
        targetModule : 'main',
        target : 'secondDataRange',
        sourceModule : 'main.plot.plot',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'secondDataRange',
        sourceModule : 'main',
        source : 'secondDataRange'
      },
      {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'primaryScale'
      },{
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisTitle'
      },
      {
        targetModule : 'main.plot.yAxis2',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'secondaryScale'
      }, {
        targetModule : 'main.plot.yAxis2',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisTitle'
      },
      
      {
        targetModule : 'main.plot.yAxis',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'primaryAxisColor'
      },
      {
        targetModule : 'main.plot.yAxis2',
        target : 'color',
        sourceModule : 'main.plot.plot',
        source : 'secondAxisColor'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'categoryScale'
      },
      {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'getColorPalette'
      },
      {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapePalette'
      }
      ],
      events : [  {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main',
            type : 'showTooltip'
        }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main',
            type : 'hideTooltip'
        } ]
    }
  };

  Manifest.register(multiVBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.Scatter',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "scatter",
    feeds : [ {
      'id' : 'regionColor',
      'name' : 'Region Color',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1
    }, {
      'id' : 'regionShape',
      'name' : 'Region Shape',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 2,
      'acceptMND': -1
    }, {
      'id' : 'primaryValues',
      'name' : 'Primary Values',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'secondaryValues',
      'name' : 'Secondary Values',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 2
    }, {
      'id' : 'bubbleWidth',
      'name' : 'Bubble Width',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 3
    }, {
      'id' : 'bubbleHeight',
      'name' : 'Bubble Height',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 4
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.bubble',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ShapeSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.lassoSelection',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Scaler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.DrawUtil',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
}
],
function Setup(dispatch, ColorSeries, ShapeSeries, TypeUtils, Repository, TextUtils, lassoSelection, Scaler, NumberUtils, DrawUtil, langManager, tooltipDataHandler) 
{
    return function(manifest) 
    {
        var width = 500, height = 300, padding = 0;
        var data = null, props = {};
        var xScale = d3.scale.linear();
        var yScale = d3.scale.linear();
        var wScale, hScale;
        var wMax,wMin,hMax,hMin,xMax,xMin,yMax,yMin;
  //zhu alistar
   var randomSuffix = Repository.newId();
        function resetBoundaryValues(){
          wMax = 0; wMin = Number.MAX_VALUE;
          hMax = 0; hMin = Number.MAX_VALUE;
          xMax = 0; // max value for xAxis
          xMin = 0; // min value for xAxis
          yMax = 0; // max value for yAxis
          yMin = 0; // max value for yAxis  
        };
        resetBoundaryValues();
        var distinctValuesObj;
        var bubbleScale = 1/6;
        var color = ColorSeries.sap32().range(), shape = ShapeSeries.sapShapes().range();
        var markers = [];
        var g, defs, tooltipX, tooltipY, crossX, crossY;
        var selectionStatus = [];
        var tooltipVisible = true;
        var markerStyle = {
            'stroke' : '#ffffff',
            'stroke-width' : 1
        };
        var selectedMarkerStyle = {
            'stroke' : '#333333',
            'stroke-width' : 1
        };
        var animateTime = 1000;
        var enableDataLoadingAnimation = true,  // control initialization animation 
            enableDataUpdatingAnimation = true, // control data updating animation
            bFirstCreation = true;
        var eDispatch = new dispatch('selectData', 'deselectData', 'showTooltip', 'hideTooltip', 'initialized');
        var _selection;
        var sizeLegendTitle = null;
        var drawingEffect = 'normal';
        var effectManager = null;
        var markerSize = 10;
        var animationComplete = false;
        
        function bubble(selection) {
            _selection = selection;
            renderChart(selection);
            bFirstCreation = false;
            return bubble;
        }

        bubble.width = function(value) {
            if (!arguments.length)
                return width;
            width = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
        computeScales();
        }
            return bubble;
        };

        bubble.height = function(value) {
            if (!arguments.length)
                return height;
            height = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
        computeScales();
        }
            return bubble;
        };
        bubble.padding = function(value){
            if(!arguments.length)
                return padding;
            padding = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
        computeScales();
        }
            return bubble;
        };
        bubble.valueAxis1Scale = function(value){
          if(!arguments.length)
                return xScale;
            xScale = value;
            return bubble;
        };
        bubble.valueAxis2Scale = function(value){
          if(!arguments.length)
                return yScale;
            yScale = value;
            return bubble;
        };
        
        bubble.valueAxis1DataRange = function(range){
          if (!arguments.length){
            return {
              min: xMin,
              max: xMax
            };
          }
          xMax = range.max;
          xMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.valueAxis2DataRange = function(range){
          if (!arguments.length){
            return {
              min: yMin,
              max: yMax
            };
          }
          yMax = range.max;
          yMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.bubbleWidthDataRange = function(range){
          if (!arguments.length){
            return {
              distinctValuesObj : distinctValuesObj,
              min: wMin,
              max: wMax
            };
          }
          wMax = range.max;
          wMin = range.min;
          distinctValuesObj = range.distinctValuesObj;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.bubbleHeightDataRange = function(range){
          if (!arguments.length){
            return {
              min: hMin,
              max: hMax
            };
          }
          hMax = range.max;
          hMin = range.min;
          if(TypeUtils.isExist(width) && TypeUtils.isExist(height)){
            computeScales();
          }
          return bubble;
        };
        
        bubble.colorPalette = function(value){
        if(!arguments.length){
          return color;
        }
        color = value;
        return bubble;
      };
      bubble.shapes = function(value){
        if(!arguments.length){
          return shape;
        }
        shape = value;
        return bubble;
      };
      bubble.sizeLegend = function() {
           var heightFeed = data.getMeasureValuesGroupDataByIdx(3);
           var hasHeightFeed = (TypeUtils.isExist(heightFeed) && heightFeed.values.length > 0);
          return {      
              bubbleScale : bubbleScale,
              space : padding,
              scale : wScale,
              data : sizeData(),
              title : sizeLegendTitle,
              hasHeightFeed : hasHeightFeed
          };
      };
        bubble.dispatch = function(_){
            if(!arguments.length)
                return eDispatch;
            eDispatch = _;
            return this;
        };

         /**
            * set/get data, for some modules like Title, it doesn't need data
            */
        bubble.data = function(value){
            if (!arguments.length){
                return data;
            }
            data = value;
            if(TypeUtils.isExist(width) && TypeUtils.isExist(height)&& TypeUtils.isExist(data)){
              calculateBoundaryValues();
              computeScales();
            }
            return bubble;            
        };

        bubble.valueAxis1Title = function(_){
          if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(0), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
        };
        
        bubble.valueAxis2Title = function(_){
          if(!arguments.length){
          var titles =  data.getMeasureValuesGroupDataByIdx(1), title = [];
          if(titles){
            for(var i=0, len =titles.values.length; i< len;i++ ){
              title.push(titles.values[i].col);
            }
          }
          return title.join('/');
        }
        return this;
        };
        /**
        * set/get properties
        */
        bubble.properties = function(_){
            if (!arguments.length){
                return props;
            }
            props = manifest.props(_);
            parseOptions();
            return bubble;            
        };
        
        /**
     * set/get effect manager
     */
        bubble.effectManager = function(_){
        if (!arguments.length){
            return effectManager;
       }
          
        effectManager = _;
        
       return bubble;        
     };
     
        function parseOptions() {
            color = props.colorPalette;
            shape = props.shapePalette;
            tooltipVisible = props.tooltip.enabled;
            drawingEffect = props.drawingEffect;
            enableDataLoadingAnimation =  props.animation.dataLoading;
      enableDataUpdatingAnimation =  props.animation.dataUpdating;
      // necessary to check, since markerSize is N/A for bubble chart
      var _markerSize = props.markerSize;
      markerSize = TypeUtils.isExist(_markerSize) && _markerSize <= 32 && _markerSize >= 4 ? _markerSize : markerSize;
            if(props.xScaleType && props.xScaleType == "log") {
                xScale = d3.scale.log();
            }
        };
        
        function calculateBoundaryValues() {
            resetBoundaryValues();
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            distinctValuesObj = {};

            for (var i = 0; i < measureFeed1.values[0].rows.length; i++) {
                for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
                    var x = measureFeed1.values[0].rows[i][j].val;
                    var y = measureFeed2.values[0].rows[i][j].val;
                    var w = bubbleWidthFeed && bubbleWidthFeed.values.length && TypeUtils.isExist(bubbleWidthFeed.values[0].rows[i][j].val) ? Math.abs(bubbleWidthFeed.values[0].rows[i][j].val) : null;
                    var h;
                    if (bubbleHeightFeed && bubbleHeightFeed.values.length) {
                        if (TypeUtils.isExist(bubbleHeightFeed.values[0].rows[i][j].val)) {
                            h = Math.abs(bubbleHeightFeed.values[0].rows[i][j].val);
                        } else {
                            h = null;
                        }
                    } else {
                        h = w;
                    }

                    if (!NumberUtils.isNoValue(w)) {
                        distinctValuesObj[w] = '';
                    } 
                    xMax = x > xMax ? x : xMax;
                    xMin = x < xMin ? x : xMin;
                    yMax = y > yMax ? y : yMax;
                    yMin = y < yMin ? y : yMin;
                    wMax = w > wMax ? w : wMax;
                    wMin = w < wMin ? w : wMin;
                    hMax = h > hMax ? h : hMax;
                    hMin = h < hMin ? h : hMin;
                }
            }
        };
    
        function computeScales() {

          var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
          var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
          if(props.xScaleRange){
            xScale.domain([props.xScaleRange.min, props.xScaleRange.max]).range([padding, width - padding]).nice();
          }else
            xScale.domain([xMin * (1 + bubbleScale), xMax * (1 + bubbleScale)]).range([padding, width - padding]).nice();
          Scaler.perfect(xScale);
          yScale.domain([yMin * (1 + bubbleScale), yMax * (1 + bubbleScale)]).range([height - padding, padding]).nice();
          Scaler.perfect(yScale);
          

          var rMax;
          //[Jimmi/8/17/2012]here we means if you don't feed data for width and height, we won't change the scale even if the data range
          //has been passed by  bubbleWidthDataRange and bubbleHeightDataRange
          if (bubbleWidthFeed && bubbleWidthFeed.values.length && wMax != wMin) {
              if(props.wScaleMax)
                wScale = bubbleSizeScale(props.wScaleMax, true, bubbleHeightFeed);
              else
                wScale = bubbleSizeScale(wMax, true, bubbleHeightFeed);
              sizeLegendTitle = bubbleWidthFeed.values[0].col;
          } else {
              wScale = function(value) {
                  return markerSize;
              };
          }
          
          if (bubbleHeightFeed && bubbleHeightFeed.values.length && hMax != hMin) {
              hScale = bubbleSizeScale(hMax, false);
          } else {
            if(wScale && hMax > hMin){
              hScale = wScale;
            }else{
              hScale = function(value) {
                  return markerSize;
              };
            }
          }
        };
        
        function renderChart(selection) {
            // TODO: avoid repeat drawing data when re-draw
            if (g) {
                g.remove();
            }
            if (defs) {
                defs.remove();
            }
            
            //we will share tooltip-x and tooltip-y between modules in a same chart
            var parent = d3.select(selection.node().ownerSVGElement.parentNode);
            if (tooltipVisible && parent.select('svg.sc-tooltip-x').node() == null) {
              parent.append('svg').style('position', 'absolute').attr('class', 'sc-tooltip-x').attr('pointer-events', 'none').attr('width', '0').attr('height', 0);
            }
            tooltipX = parent.select('svg.sc-tooltip-x');
            if (tooltipVisible && parent.select('svg.sc-tooltip-y').node() == null) {
              parent.append('svg').style('position', 'absolute').attr('class', 'sc-tooltip-y').attr('pointer-events', 'none').attr('width', '0').attr('height', 0);
            }
            tooltipY = parent.select('svg.sc-tooltip-y');
            
            getThemeStyleDef();
            
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var colorFeed = data.getAnalysisAxisDataByIdx(0);
            var shapeFeed = data.getAnalysisAxisDataByIdx(1);
            
           
            var clipPathId = 'edge-clip-' + randomSuffix;
            defs = selection.append('defs');
            defs.append('clipPath').attr('id', clipPathId).append('rect').attr('width', width).attr('height', height);
            
            g = selection.append('g');  
            g.attr('clip-path', 'url(#' + clipPathId + ')');  
            
            g.append('rect')
                    .attr('x', 0)
                    .attr('y', 0)
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill-opacity', 0)
                    .attr('id', 'event-rect' + randomSuffix);
            crossX = g.append('line').attr('id', 'cross-x-' + randomSuffix).attr('stroke-width', 1).attr('stroke', '#cccccc').attr('shape-rendering','crispEdges').attr('visibility', 'hidden');
            crossY = g.append('line').attr('id', 'cross-y-' + randomSuffix).attr('stroke-width', 1).attr('stroke', '#cccccc').attr('shape-rendering','crispEdges').attr('visibility', 'hidden');
            
            var colorIndex = 0;
            var colorContainer = {};
            
            function renderByShape(i, renderShape, renderArray) {
                for (var j = 0; j < measureFeed1.values[0].rows[i].length; j++) {
                    // Currently just group by the first dimension in hierarchy
                    var colorFeedVal = (colorFeed && colorFeed.values.length  > 0) ? colorFeed.values[0].rows[j].val : 0;
                    var colorValue;
                    if (colorContainer[colorFeedVal]) {
                        colorValue = colorContainer[colorFeedVal];
                    } else {
                        colorValue = color[colorIndex % color.length];
                        colorContainer[colorFeedVal] = colorValue;
                        colorIndex++;
                    }
                    var x = measureFeed1.values[0].rows[i][j].val;
                    var y = measureFeed2.values[0].rows[i][j].val;
                    var w = bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].val : null;
                    var h = bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].val : null;
                    
                    var renderData = {
                        x : x,
                        y : y,
                        w : w, 
                        h : h,
                        colorIndex : j,
                        shapeIndex : i,
                        colorValue : colorValue,
                        shapeValue : renderShape,
                        val : [x, y, w, h],
                        ctx : [
                            measureFeed1.values[0].rows[i][j].ctx, 
                            measureFeed2.values[0].rows[i][j].ctx,
                            bubbleWidthFeed && bubbleWidthFeed.values.length ? bubbleWidthFeed.values[0].rows[i][j].ctx : null,
                            bubbleHeightFeed && bubbleHeightFeed.values.length ? bubbleHeightFeed.values[0].rows[i][j].ctx : null
                        ]
                    };
                    
                    if (!NumberUtils.isNoValue(x) && !NumberUtils.isNoValue(y)) {
                        renderArray.push(renderData);
                    }
                }
            };
            
            
            
            
            var renderArray = [];
            if (shapeFeed && shapeFeed.values.length > 0) {
                for (var i = 0, shapeIndex = 0, shapeContainer = {}; i < shapeFeed.values[0].rows.length; i++) {
                    // Currently just group by the first dimension in hierarchy
                    var shapeFeedVal = shapeFeed.values[0].rows[i].val;
                    var renderShape;
                    if (shapeContainer[shapeFeedVal]) {
                        renderShape = shapeContainer[shapeFeedVal];
                    } else {
                        renderShape = shape[shapeIndex % shape.length];
                        shapeContainer[shapeFeedVal] = renderShape;
                        shapeIndex++;
                    }
                    renderByShape(i, renderShape, renderArray);
                }
            } else {
                renderByShape(0, shape[0], renderArray);
            }

            // sort to draw big shape first
            renderArray.sort(function(a, b) {
                var ah = a.h == null ? a.w : a.h;
                var bh = b.h == null ? b.w : b.h;
                return Math.abs(b.w * bh) - Math.abs(a.w * ah);
            });
            
            var completedArray = 0;
            animationComplete = false;
            hideTooltip();
            function checkAnimationCompleted(d, m) {
                completedArray++;
                if (completedArray == renderArray.length) {
                  animationComplete = true;
                    eDispatch.initialized();
                }
            };
 
            var enableAnimation = (enableDataLoadingAnimation && bFirstCreation) || (enableDataUpdatingAnimation && !bFirstCreation);
            for (var i = 0; i < renderArray.length; i++) {
                var x = renderArray[i].x, 
                    y = renderArray[i].y, 
                    w = renderArray[i].w, 
                    h = bubbleHeightFeed && bubbleHeightFeed.values.length ? renderArray[i].h : w, 
                    colorValue = renderArray[i].colorValue, 
                    renderShape = renderArray[i].shapeValue;
                    
                    
                var markerShape;
                
                var rx = wScale(w) / 2,
                  ry = hScale(h) / 2;
                var aniTime = 0;
                if (enableAnimation)
                  aniTime = animateTime;
                var element = DrawUtil.createElements(g, {shape: renderShape, className: "viz-correlation-marker datapoint"} );
                var parameter = {
                  drawingEffect: drawingEffect,
                  fillColor: colorValue,
                  graphType: renderShape,
                  direction: 'vertical',
                  rx: rx,
                  ry: ry,
                  borderWidth:  markerStyle['stroke-width'],
                  borderColor: markerStyle['stroke'],
                  node:element,
                  visibility: "visible",
                  animateTime: aniTime,
                  endFunc: checkAnimationCompleted
                };

                DrawUtil.drawGraph(parameter, effectManager).attr('opacity', '0.8').attr('transform', 'translate(' + xScale(x) + ',' + yScale(y) + ')');    
            }
            
            if (!enableAnimation) {
              animationComplete = true;
                eDispatch.initialized();
            }
            
            selection.selectAll('.viz-correlation-marker').data(renderArray);
        }
        
        function bubbleSizeScale(vMax, wh, heightFeed) {
            // even 0 value for bubble size, still render a small size shape
            return function(value) {
                if (NumberUtils.isNoValue(value)) {
                    return 4;
                }
                var range;
                if (wh) {
                    range = !heightFeed && height < width ? height : width;
                } else {
                    range = height;
                }
                var r = Math.pow(Math.abs(value) / vMax, 0.5) * (range - padding) * bubbleScale;
                return r > 4 ? r : 4;
            };
        }
        
        function getThemeStyleDef() {
            var markerThemeStyle = manifest.style('viz-correlation-marker');
            if(markerThemeStyle){
                if(markerThemeStyle['stroke']){
                    markerStyle['stroke'] = markerThemeStyle['stroke'];
                }
                if(markerThemeStyle['stroke-width']){
                    markerStyle['stroke-width'] = markerThemeStyle['stroke-width'];
                }
            }
            var selectedMarkerThemeStyle = manifest.style('viz-correlation-marker-selected');
            if(selectedMarkerThemeStyle){
                if(selectedMarkerThemeStyle['stroke']){
                    selectedMarkerStyle['stroke'] = selectedMarkerThemeStyle['stroke'];
                }
                if(selectedMarkerThemeStyle['stroke-width']){
                    selectedMarkerStyle['stroke-width'] = selectedMarkerThemeStyle['stroke-width'];
                }
            }
        };
        
        function sizeData() {
            var wDistinctValues = 0;
            for (var i in distinctValuesObj) {
                wDistinctValues++;
            }
            if (wDistinctValues == 0) {
                return [];
            } else if (wDistinctValues == 1) {
                return [wMax];
            } else if (wDistinctValues == 2) {
                return [wMax, wMin];
            } else {
                return [wMax, (wMax + wMin) / 2, wMin];
            }
        };
        
        bubble.parent = function() {
            return _selection;
        };

        bubble.mouseover = function(target) {
            var item = d3.select(target);
            if(item == undefined || item.node() == null || !animationComplete) return;
            if (item.attr('id') != null && (item.attr('id') == ('event-rect' + randomSuffix) 
                || item.attr('id').indexOf('cross-x-') >= 0
                || item.attr('id').indexOf('cross-y-') >= 0)) {
                return;
            }
            var val = item.datum();
            item.attr('opacity', '1');
            crossX.attr('visibility', 'visible')
                    .attr('x1', 0)
                    .attr('y1', yScale(val.y))
                    .attr('x2', width)
                    .attr('y2', yScale(val.y));
            crossY.attr('visibility', 'visible')
                    .attr('x1', xScale(val.x))
                    .attr('y1', 0)
                    .attr('x2', xScale(val.x))
                    .attr('y2', height);
            if (tooltipVisible) {
                showTooltip(val, _selection[0][0].getTransformToElement(_selection[0][0].ownerSVGElement));
            }
            
        };
        
        bubble.mouseout = function(target, isHighlighted) {
            var item = d3.select(target);
            if(item == undefined || item.node() == null || !animationComplete) {return;}
            if (item.attr('id') == ('event-rect' + randomSuffix)) {
                return;
            }

            if (isHighlighted) {
                item.attr('opacity', '0.8');
            } else {
                item.attr('opacity', '0.2');
            }
            
            crossX.attr('visibility', 'hidden');
            crossY.attr('visibility', 'hidden');
            
            hideTooltip();
        };
        
        function showTooltip(val, transform) {
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var colorFeed = data.getAnalysisAxisDataByIdx(0);
            var shapeFeed = data.getAnalysisAxisDataByIdx(1);
            
            var tooltipData = {
                body: [],
                footer: []
            };
            //push color footer to tooltipData
            for (var i = 0, len = (colorFeed ? colorFeed.values.length : 0); i < len; i++) {
              var footer = {};
              footer.label = colorFeed.values[i].col.val;
              footer.value = colorFeed.values[i].rows[val.colorIndex].val;
              tooltipData.footer.push(footer);
            }
            //push shape footer to tooltipData
            for (var i = 0, len = (shapeFeed ? shapeFeed.values.length : 0); i < len; i++) {
              var footer = {};
              footer.label = shapeFeed.values[i].col.val;
              footer.value = shapeFeed.values[i].rows[val.shapeIndex].val;
              tooltipData.footer.push(footer);
            }
            
            tooltipData.body.push({
              name: measureFeed1.values[0].col,
              val: [{
                color: val.colorValue,
                shape: val.shapeValue,
                value : val.x
              }]
            });
            
            tooltipData.body.push({
              name: measureFeed2.values[0].col,
              val:[{
                color: val.colorValue,
                shape: val.shapeValue,
                value: val.y
              }]
            });
            
            if (bubbleWidthFeed && bubbleWidthFeed.values.length > 0) {
              tooltipData.body.push({
                  name:bubbleWidthFeed.values[0].col,
                  val: [{
                    color: val.colorValue,
                  shape: val.shapeValue,
                    value: NumberUtils.isNoValue(val.w) ? langManager.get('IDS_ISNOVALUE') : val.w
                  }]
                });
            }
            if (bubbleHeightFeed && bubbleHeightFeed.values.length > 0) {
              tooltipData.body.push({
                  name:bubbleHeightFeed.values[0].col,
                  val:[{
                    color: val.colorValue,
                  shape: val.shapeValue,
                    value: NumberUtils.isNoValue(val.h) ? langManager.get('IDS_ISNOVALUE') : val.h
                  }]
                });
            }

            tooltipData.point = {
               x : xScale(val.x),
                   y : yScale(val.y) + transform.f
            };
            tooltipData.plotArea = {
             x : transform.e,
                 y : transform.f,
                 width : width,
                 height : height
            };
            
            eDispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
            
            drawXYTooltip(val.x, tooltipX, {x : xScale(val.x), y : yScale(val.y)}, transform, 'x');
            drawXYTooltip(val.y, tooltipY, {x : xScale(val.x), y : yScale(val.y)}, transform, 'y');
        };
        
        function hideTooltip() {
            if (tooltipVisible) {
                eDispatch.hideTooltip();
                tooltipX.selectAll('g').remove();
                tooltipY.selectAll('g').remove();
            }
        };
        
        function drawXYTooltip(value, container, point, transform, axis) {
            var font = {
                size : '12px',
                weight : 'bold',
                family : '"Open Sans", Arial, Helvetica, sans-serif'
            };
            var valueSize = TextUtils.fastMeasure(value, font.size, font.weight, font.family);
            container.attr('width', valueSize.width + 20).attr('height', valueSize.height + 10);
            container.wrapper = container.append('g');
            container.wrapper.append('rect')
                    .attr('x', 1)
                    .attr('y', 1)
                    .attr('rx', 4)
                    .attr('ry', 4)
                    .attr('width', valueSize.width + 18)
                    .attr('height', valueSize.height + 8)
                    .attr('fill', '#ffffff')
                    .attr('stroke', '#000000')
                    .attr('stroke-width', 1);
            container.wrapper.append('text')
                    .attr('x', 10)
                    .attr('y', valueSize.height + 3)
                    .attr('fill', '#000000')
                    .style('font', font.weight + ' ' + font.size + ' ' + font.family)
                    .text(value);
            if ('y' === axis) {
                container.style('left', transform.e - container.attr('width') + 1 + 'px').style('top',( point.y + transform.f - container.attr('height') / 2 ) + 'px');
            } else if ('x' === axis) {
                container.style('left', point.x + transform.e -  container.attr('width') / 2 + 'px').style('top', transform.f + height - 1 + 'px');
            }
        };

        function getChangedValues(changedArray) {
            var measureFeed1 = data.getMeasureValuesGroupDataByIdx(0);
            var measureFeed2 = data.getMeasureValuesGroupDataByIdx(1);
            var bubbleWidthFeed = data.getMeasureValuesGroupDataByIdx(2);
            var bubbleHeightFeed = data.getMeasureValuesGroupDataByIdx(3);
            var result = [];
            for (var i = 0; i < changedArray.length; i++) {
                var colorIndex = changedArray[i].colorIndex;
                var shapeIndex = changedArray[i].shapeIndex;
                
                result.push([
                    measureFeed1.values[0].rows[shapeIndex][colorIndex],
                    measureFeed2.values[0].rows[shapeIndex][colorIndex],
                    bubbleWidthFeed && bubbleWidthFeed.values.length > 0 ? bubbleWidthFeed.values[0].rows[shapeIndex][colorIndex] : null,
                    bubbleHeightFeed && bubbleHeightFeed.values.length > 0 ? bubbleHeightFeed.values[0].rows[shapeIndex][colorIndex] : null
                ]);
            }
            return result;
        };
        
        bubble.highlight = function(elems) {
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    d3.select(elems[i]).attr('class', 'viz-correlation-marker-selected datapoint').attr('opacity', '0.8').attr('stroke', selectedMarkerStyle['stroke']).attr('stroke-width', selectedMarkerStyle['stroke-width']);
                }
            } else {
                d3.select(elems).attr('class', 'viz-correlation-marker-selected datapoint').attr('opacity', '0.8').attr('stroke', selectedMarkerStyle['stroke']).attr('stroke-width', selectedMarkerStyle['stroke-width']);
            }
        };
        
        bubble.unhighlight = function(elems) {
            if (TypeUtils.isArray(elems)) {
                for (var i = 0, len = elems.length; i < len; i++) {
                    d3.select(elems[i]).attr('class', 'viz-correlation-marker datapoint').attr('opacity', '0.2').attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);;
                }
            } else {
                d3.select(elems).attr('class', 'viz-correlation-marker datapoint').attr('opacity', '0.2').attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            }
        };
        
        bubble.clear = function(gray) {
            var allMarks = _selection.selectAll('.datapoint').attr('class', 'viz-correlation-marker datapoint').attr('stroke', markerStyle['stroke']).attr('stroke-width', markerStyle['stroke-width']);
            if (gray) {
                allMarks.attr('opacity', '0.2');
            } else {
                allMarks.attr('opacity', '0.8');
            }
            
        };
    bubble.properties(null);
        return bubble;
    };
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.bubble',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.Scatter',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.bubble',
    'type' : Constants.Module.Type.Chart,
    'name' : 'bubble',
    'data' : 'DATA STRUCTURE DOC',
    'properties' : {
      'colorPalette' : {
        'name' : 'colorPalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : Constants.SAPColor,
        'description' : 'Set marker color of bubble.'
      },
      'shapePalette' : {
        'name' : 'shapePalette',
        'supportedValueType' : 'StringArray',
        'defaultValue' : [ 'circle', 'square', 'diamond', 'triangle-up',
            'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection' ],
        'supportedValues' : [ 'circle', 'square', 'diamond', 'triangle-up',
              'triangle-down', 'triangle-left', 'triangle-right', 'cross', 'intersection' ],
        'description' : 'Set marker shape of bubble.'
      },
      'tooltip' : {
        'name' : 'tooltip',
        'supportedValueType' : 'Object',
        'supportedValues' : {
          'enabled' : {
            'name' : 'enabled',
            'supportedValueType' : 'Bool',
            'defaultValue' : true,
            'description' : 'enabled/disabled tooltip.'
          }
        },
        'isExported' : false,
        'description' : 'Set tooltip related properties.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : 'true',
              'description' : 'enable/disable data loading animation of bubble/scatter.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : 'true',
              'description' : 'enable/disable data updating animation of bubble/scatter.'
            }
          },
          'description' : 'Set animation of bubble/scatter.'
        },
        'drawingEffect':{
          'name' : 'drawingEffect',
           'supportedValueType' : 'List',
            'supportedValues' : [ 'normal', 'glossy' ],
            'defaultValue' : 'normal',
            'description' : 'Drawing effect of bubble marker.',
            'isExported' : true
        }
    },
    'events' : {
        'selectData' : Constants.Module.Event.SelectData.desc,
        'deselectData' : Constants.Module.Event.DeSelectData.desc,
        'showTooltip' : Constants.Module.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
    'feeds' : {
      id : "scatter",
      configure : {
        bubbleWidth:
        {
          min:1
        }
      }
    },
    'css' : {
      '.viz-correlation-marker' : {
        'description' : 'Define stroke style for correlation marker.',
        'value' : {
          'stroke' : '#ffffff',
          'stroke-width' : 1
        }
      },
      '.viz-correlation-marker-selected' : {
        'description' : 'Define stroke style for selcted correlation marker.',
        'value' : {
          'stroke' : '#333333',
          'stroke-width' : 1
        }
      }
    },
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants) {
  var module = {
    'id' : 'sap.viz.modules.scatter',
    base : 'sap.viz.modules.bubble',
    'name' : 'scatter',
    'properties' : {
        'markerSize' : {
            'name' : 'markerSize',
              'supportedValueType' : 'PositiveInt',
              'defaultValue' : "10",
              'description' : 'Set marker size of data point. The available range is from 4 to 32.'
        }
    },
    'feeds' : {
      configure : {
        bubbleWidth : null,
        bubbleHeight : null
      }
    }
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.ScatterInMatrix',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants) {
    var module = {
      'id' : 'sap.viz.modules.scatterInMatrix',
      base : 'sap.viz.modules.scatter',
      'name' : 'scatterInMatrix',
      'feeds' : null
    };
    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.ScatterMatrix',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
    var feeds = {
      id : "scattermatrix",
      feeds : [ {
        'id' : 'regionColor',
        'name' : 'Region Color',
        'type' : constants.Type.Dimension,
        'min' : 0,
        'max' : 1,
        'aaIndex' : 1,
        'acceptMND': -1
      }, {
        'id' : 'regionShape',
        'name' : 'Region Shape',
        'type' : constants.Type.Dimension,
        'min' : 0,
        'max' : 1,
        'aaIndex' : 2,
        'acceptMND': -1
      }, {
        'id' : 'primaryValues',
        'name' : 'Primary Values',
        'type' : constants.Type.Measure,
        'min' : 2,
        'max' : constants.Constraints.INF,
        'mgIndex' : 1
      }]
    };
    Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.scattermatrixcontainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.MultiChartDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
}
],
function Setup(TypeUtils, Objects, Functions, layout, MultiChartDataHandler, Manifest, TextUtils, dispatch) {

    return function() {
        var width = 0, height = 0, subWidth = 0, subHeight = 0, effectManager = null,
        properties = {}, data = {}, config = {}, modules = {}, selections = {}, parent = null, // a d3 selection
        dataHandler = null, plotLabels = [];
        var plotTitleVisible = true;
        var isTitleHidden = false;
        var eDispatch = new dispatch('initialized', 'showTooltip', 'hideTooltip'), avaPlotCount = 0;
        var font = {};

        function load(moduleId) {
            return Manifest.module.get(moduleId).fn;
        }
        
        function getThemeStyleDef() {
            var titleStyle = Manifest.module.get(config.id).style('viz-matrix-sub-title');
            if(titleStyle) {
                if(titleStyle['fill']){
                    font.fill = titleStyle['fill'];
                }
                if(titleStyle['font-family']){
                    font.family = titleStyle['font-family'];
                }
                if(titleStyle['font-size']){
                    font.size = titleStyle['font-size'];
                }
                if(titleStyle['font-weight']){
                    font.weight = titleStyle['font-weight'];
                }
            }
        };
        
        function initializePlot() {
          var plotConfig = config.modules.plot;
          if (!plotConfig)
              return;
          delete modules.plot;
          modules.plot = [];
          var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
          for (var colI = 0; colI < measureNum; colI++) {
              for (var rowI = 0; rowI < measureNum; rowI++) {
                  var plotI = modules.plot[rowI * measureNum + colI] = load(plotConfig.id)();
                  plotI.config(plotConfig);
                  plotI.effectManager(effectManager);
                  avaPlotCount++;
                  if(plotI.dispatch){
                      var dis =  plotI.dispatch();
                        if(dis.initialized) dis.on('initialized.scattermatrixcontainer', initialized);
                        if(dis.showTooltip) dis.on('showTooltip.scattermatrixcontainer', showTooltip);
                        if(dis.hideTooltip) dis.on('hideTooltip.scattermatrixcontainer', hideTooltip);
                   }
              }
          }
        }
        
        function updatePlotProperties() {
          if (TypeUtils.isExist(properties.multiLayout) && TypeUtils.isExist(properties.multiLayout.plotTitle) && TypeUtils.isExist(properties.multiLayout.plotTitle.visible)) {
              plotTitleVisible = properties.multiLayout.plotTitle.visible;
          }
          
          var plots = modules.plot;
          if(plots){
            var plotConfig = config.modules.plot;
            if (!plotConfig)
                return;
            var props = null, usrProps, sysProps;
            if (plotConfig.configure) {
                if (plotConfig.configure.propertyCategory) {
                    usrProps = properties[plotConfig.configure.propertyCategory] || {};
                }
                sysProps = plotConfig.configure.properties || {};
                props = {};
                Objects.extend(true, props, sysProps, usrProps);
            } else {
                props = properties;
            }

            for(var i = 0, len = plots.length; i < len; i++){
              if (props) {
                plots[i].properties(props);
              }
            }
          }
          getThemeStyleDef();
        }
        
        function updatePlotData() {
          plotLabels = [];//can we split data label updating outside?
          dataHandler = new MultiChartDataHandler(data, "measures");
          var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
          for (var colI = 0; colI < measureNum; colI++) {
              for (var rowI = 0; rowI < measureNum; rowI++) {
                  var dataI = dataHandler.getSubDataAdapterByMeasures({
                      row : rowI,
                      col : colI
                  });
                  var plotI = modules.plot[rowI * measureNum + colI];
                  plotI.data(dataI);
                  
                  var plotLabel = plotLabels[rowI * measureNum + colI];
                  if(!plotLabel) plotLabel = plotLabels[rowI * measureNum + colI] = {};
                  //we may already have other members here in plotLabel, do not remove them while updating
                  plotLabel.empty = (colI == rowI);
                  plotLabel.label = (colI == rowI 
                          ? dataI.getMeasureValuesGroupDataByIdx(0).values[0].col 
                          : dataI.getMeasureValuesGroupDataByIdx(0).values[0].col + ' - ' + dataI.getMeasureValuesGroupDataByIdx(1).values[0].col);
              }
          }
        }
        
        function initializePlotElements() {
          delete selections.plot;
          parent.select('.plot').remove();
          if (modules.plot && !selections.plot) {
            var splots = selections.plot = [];
            var plotRoot = selections.plotRoot = parent.append('g').attr('class', 'plot');
            for (var i = 0, len = modules.plot.length; i < len; i++) {
                splots[i] = plotRoot.append('g').attr('class', 'plot' + i);

                var plotI = modules.plot[i];
                var subModules = plotI.parent(splots[i]).modules();

                for (var m in subModules )
                if (subModules.hasOwnProperty(m))
                    modules['plot[' + i + ']' + '.' + m] = subModules[m];
            }
          }
        }

        function initialize() {
            if (TypeUtils.isEmptyObject(config))
                Functions.error('Container configuration missing');

            avaPlotCount = 0;
            initializePlot();
            updatePlotProperties();
            updatePlotData();
            initializePlotElements();
        };
        
        function relayout() {
            if (TypeUtils.isEmptyObject(modules) || !width || !height)
                return;
            
            var measureNum = data.getMeasureValuesGroupDataByIdx()[0].values.length;
            subWidth = width / measureNum;
            subHeight = height / measureNum;
            var labelSize = getMaxLabelSize();
            var labelHeight = labelSize.height;
            if (!plotTitleVisible || labelSize.width > subWidth || labelSize.height > subHeight / 3) {
                labelSize.height = 0;
                isTitleHidden = true;
            }
            for (var colI = 0; colI < measureNum; colI++) {
                for (var rowI = 0; rowI < measureNum; rowI++) {
                    
                    var plotI = modules.plot[rowI * measureNum + colI];
                    var splotI = selections.plot[rowI * measureNum + colI];
                    plotI.width(subWidth).height(subHeight - labelHeight);
                    splotI.attr('transform', 'translate(' + (subWidth * colI) + ',' + (subHeight * rowI) + ')');
                }
            }
        };

        function container(selection) {
            selection.each(function(data) {
                parent = selection;
                if (TypeUtils.isEmptyObject(modules))
                    initialize();
                relayout();
                render();
            });
            return container;
        }


        container.width = function(_) {
            if (!arguments.length)
                return width;
            if (width !== _) {
                width = _;
                relayout();
            }
            return container;
        };

        container.height = function(_) {
            if (!arguments.length)
                return height;
            if (height !== _) {
                height = _;
                relayout();
            }
            return container;
        };

        container.size = function(_) {
            if (!arguments.length)
                return {
                    'width' : width,
                    'height' : height
                };
            if (height !== _.height || width !== _.width) {
                height = _.height;
                width = _.width;
                relayout();
            }
            return container;
        };

        container.data = function(_) {
            if (!arguments.length)
                return data;
            data = _;
            if(!TypeUtils.isEmptyObject(modules)){
              //TODO Jimmy/9/11/2012 currently we can't know
              //whether it's a data change only (without schema change)
              //but we do have chance in new data model. for now, we just
              //update everything

              avaPlotCount = 0;
              initializePlot();
              updatePlotProperties();
              updatePlotData();
              initializePlotElements();
            }
            return container;
        };

        container.properties = function(_) {
            if (!arguments.length)
                return properties;
            properties = _;
            if(!TypeUtils.isEmptyObject(modules)){
              updatePlotProperties();
            }
            return container;
        };

        container.config = function(_) {
            if (!arguments.length)
                return config;
            config = _;
            return container;
        };

        container.modules = function(_) {
            if (!arguments.length) {
                if (TypeUtils.isEmptyObject(modules)) {
                    initialize();
                }
                return modules;
            }
            modules = _;
            return container;
        };

        container.parent = function(_) {
            if (!arguments.length)
                return parent;
            parent = _;
            return container;
        };

        container.dispatch = function(_){
          if( !arguments.length){
            return eDispatch;
          }
          eDispatch = _;
          return container;
        };
        
        container.effectManager = function(_) {
            if (!arguments.length)
                return effectManager;
            effectManager = _;
            return container;
        };
        
        function render() {

            if (selections.plot) {
                for (var i = 0, len = selections.plot.length; i < len; i++) {
                    if (plotLabels[i].empty) {
                        renderLabel(selections.plot[i], plotLabels[i], subHeight / 2);
                        initialized();
                    } else {
                        selections.plot[i].datum(modules.plot[i].data()).call(modules.plot[i]);
                        renderLabel(selections.plot[i], plotLabels[i], subHeight);
                    }
                    
                }
            }
            isTitleHidden = false;
        };
        
        function renderLabel(plot, labelObj, ybaseline) {
            if (labelObj.shape) {
                labelObj.shape.remove();
            }
            
            if (isTitleHidden) {
                return;
            }
            
            var labelSize = TextUtils.fastMeasure(labelObj.label, font.size, font.weight, font.family);
            
            labelObj.shape = plot.append('text').attr('class', 'sub-plot-title')
                    .attr('text-anchor', 'middle')
                    .attr('x', subWidth / 2)
                    .attr('y', ybaseline - labelSize.height / 2)
                    .attr('fill', font.fill)
                    .style('font-weight', font.weight).style('font-size', font.size).style('font-family', font.family)
                    .attr('dominant-baseline', 'middle')
                    .style('cursor', 'default');
            TextUtils.ellipsis(labelObj.label, labelObj.shape.node(), subWidth - 5 /* leave some padding */, "font:" + font.weight + ' ' + font.size + ' ' + font.family);
        };
        
        function getMaxLabelSize() {
            var maxWidth = 0, maxHeight = 0;
            for (var i = 0, len = plotLabels.length; i < len; i++) {
                var size = TextUtils.fastMeasure(plotLabels[i].label, font.size, font.weight, font.family);
                maxHeight = size.height > maxHeight ? size.height : maxHeight;
                maxWidth = size.width > maxWidth ? size.width : maxWidth;
            }
            return {
                width : maxWidth,
                height : maxHeight
            };
        }
        
        var initializedPlots = 0;
        function initialized(){
          if(++initializedPlots == avaPlotCount){
            initializedPlots = 0;
            eDispatch.initialized();
          }
        }
        
        function showTooltip(evt){
          eDispatch.showTooltip(evt);
        };
        
        function hideTooltip(evt){
          eDispatch.hideTooltip(evt);
        };
        
        return container;
    };

});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.ScatterMatrixContainer',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.scattermatrixcontainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.ScatterMatrix',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
    
    var module = {
      'id' : 'sap.viz.modules.scattermatrixcontainer',
        'type' : Constants.Module.Type.Container,
        'name' : 'Scatter Matrix Container',
        'description': 'Settings for the subcharts layout of Scatter Matrix chart.',
        'properties' : {
            'plotTitle' : {
              'name' : 'plotTitle',
        'description': 'Settings for plot title.',
              'supportedValueType' : 'Object',
              'supportedValues' : {
                'visible' : {
                  'name' : 'visible',
                  'supportedValueType' : 'Boolean',
                  'defaultValue' : true,
                  'description' : 'Set visibility of sub plot title.'
                }
              },
            }
        },
        'css' : {
            '.viz-matrix-sub-title' : {
                'description' : 'Define style for the sub plot title.',
                'value' : {
                    'fill' : 'black',
                    'font-family' : "'Open Sans', Arial, Helvetica, sans-serif",
                    'font-size' : '12px',
                    'font-weight' : 'bold'
                }
            }
        },
        'feeds' : { 
            id : 'scattermatrix'
        },
    'events' : {
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc
    },
        'submodulekeys' : [{
          'key': 'plot',
          'description': 'Define the plot module in each cell, currently we only support same plot for all cells'
        }],
        'fn' : fn
    };
    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.ScatterMatrixChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Title',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.ScatterMatrixContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Legend',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.ScatterInMatrix',
  version : '4.0.0'
}
],
function Setup(Manifest) {
    var scatterMatrix = {
        id : 'viz/scatter_matrix',
        name : 'IDS_SCATTERMATRIXCHART',
        base : 'riv/base',
        modules : {

            legend : {
                data : { 
                    aa :[1, 2]
                }, 
                configure : { 
                    properties : { 
                        type :'BubbleColorLegend'
                    }
                }
            },

            tooltip : { 
                id : 'sap.viz.modules.tooltip',
                configure : { 
                    propertyCategory : 'tooltip',
                    properties : { 
            chartType: 'scattermatrix',
                        orientation :'left'
                    }
                }
            },

            main : {
                id : 'sap.viz.modules.scattermatrixcontainer',
                
                configure : {
                    propertyCategory : 'multiLayout'
                },
                  
                controllers : {
                    'interaction' : { 
                        id : 'sap.viz.modules.controller.interaction',
                        configure : { 
                            propertyCategory :'interaction'
                        }
                    }
                },
                
                modules : {
                    plot : {
                        id : 'sap.viz.modules.xycontainer',
                        modules : {
                            xAxis : {
                                id : 'sap.viz.modules.axis',
                                data : {
                                    mg : [1]
                                },
                                configure : {
                                'description': 'Settings for the x axis of a normal bubble or scatter plot.',
                                    propertyCategory : 'xAxis',
                                    properties : {
                                        type : 'value',
                                        position : 'bottom',
                                        gridline : {
                                            visible : false
                                        }
                                    }
                                }
                            },

                            yAxis : {
                                id : 'sap.viz.modules.axis',
                                data : {
                                    mg : [2]
                                },
                                configure : {
                              'description': 'Settings for the y axis of a normal bubble or scatter plot.',
                                   propertyCategory : 'yAxis',
                                    properties : {
                                        type : 'value',
                                        position : 'left',
                                        gridline : {
                                            visible : false
                                        }
                                    }
                                }
                            },
              
              background : {
                id: 'sap.viz.modules.background',
                configure : {
                  propertyCategory : 'background',
                  properties : {
                    direction : 'vertical'
                  }
                }
              },
              
                            plot : {
                                id : 'sap.viz.modules.scatterInMatrix',
                                configure : {
                              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                                    propertyCategory : 'plotArea'
                                }
                            }
                        }
                    }
                }
            }
        },
        dependencies : {
            attributes : [{
                targetModule : 'main.plot.yAxis',
                target : 'scale',
                sourceModule : 'main.plot.plot',
                source : 'valueAxis2Scale'
            }, {
                targetModule : 'main.plot.xAxis',
                target : 'scale',
                sourceModule : 'main.plot.plot',
                source : 'valueAxis1Scale'
            }, {
                targetModule : 'main.plot.xAxis',
                target : 'title',
                sourceModule : 'main.plot.plot',
                source : 'valueAxis1Title'
            }, {
                targetModule : 'main.plot.yAxis',
                target : 'title',
                sourceModule : 'main.plot.plot',
                source : 'valueAxis2Title'
            }, {
                targetModule : 'legend',
                target : 'colorPalette',
                sourceModule : 'main.plot.plot',
                source : 'colorPalette'
            }, {
                targetModule : 'legend',
                target : 'shapes',
                sourceModule : 'main.plot.plot',
                source : 'shapes'
            }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
            }],

            events :[{
                targetModule : 'tooltip',
                listener : 'showTooltip',
                sourceModule : 'main',
                type : 'showTooltip'
            }, {
                targetModule : 'tooltip',
                listener : 'hideTooltip',
                sourceModule : 'main',
                type : 'hideTooltip'
            }, {
                targetModule : 'main.interaction',
                listener : 'registerEvent',
                sourceModule : 'main',
                type : 'initialized.interaction'
            }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }]

        }
    };

    Manifest.register(scatterMatrix);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseMultipleXYChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_scatter',
    name : 'IDS_MULTISCATTERCHART',
    base : 'riv/base/multiple/xy',
   
    modules : {
      legend : {
        data : {
          aa : [ 2,3 ]
        },
        configure : {
         properties : {
            type : 'BubbleColorLegend'
          }
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'scatter',
            orientation : 'left'
          }
        }
      },
      main : {
        controllers : {
            'interaction' : { 
                    id : 'sap.viz.modules.controller.interaction',
                configure : { 
                    propertyCategory :'interaction'
                }
            }
        },
          
        configure : {
          properties : {
            'mergeDataRange' : ['valueAxis1', 'valueAxis2']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              xAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                'description': 'Settings for the x axis of a normal bubble or scatter plot.',
                 propertyCategory : 'xAxis',
                  properties : {
                    title : {
                      visible : false
                    },
                    type : 'value',
                    position : 'bottom'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              /**
               * 'xAxis2' : { },
               */
    
              yAxis : {
                id : 'sap.viz.modules.axis',
                configure : {
                'description': 'Settings for the y axis of a normal bubble or scatter plot.',
                  propertyCategory : 'yAxis',
                  properties : {
                    title : {
                      visible : false
                    },
                    type : 'value',
                    position : 'left'
                  },
                  propertiesOverride : {
                    title : {
                      isExported : false
                    }                    
                  }
                }
              },
              
              plot : {
                id : 'sap.viz.modules.scatter',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
      multiplier:{
        acceptMND:-1
       }
   },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'valueAxis1DataRange',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'valueAxis1DataRange',
        sourceModule : 'main',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'main',
        target : 'valueAxis2DataRange',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'valueAxis2DataRange',
        sourceModule : 'main',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapes'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
    }
      ],
      events : [  {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main',
          type : 'initialized.interaction'
        }, {
            targetModule : 'tooltip',
            listener : 'showTooltip',
            sourceModule : 'main',
            type : 'showTooltip'
        }, {
            targetModule : 'tooltip',
            listener : 'hideTooltip',
            sourceModule : 'main',
            type : 'hideTooltip'
        },{
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
        }, {
          targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        } ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.MultiBubbleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.XYContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TableContainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var multiBarChart = {
    id : 'viz/multi_bubble',
    name : 'IDS_MULTIBUBBLECHART',
    base : 'viz/multi_scatter',
    modules : {
      legend : {
        data : {
          aa : [ 2, 3 ]
        }
      },
      sizeLegend : {
        id : 'sap.viz.modules.legend',
        configure : {
          'description': 'The size legend is a box mapping the charts data shapes\' size to the value by some typical symbols and associated indication values.',
          propertyCategory : 'sizeLegend',
          properties : {
            type : 'SizeLegend'
          }
        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'bubble',
            orientation : 'left'
          }
        }
      },
      main : {
        configure : {
          properties : {
            'mergeDataRange' : ['valueAxis1', 'valueAxis2', 'bubbleWidth', 'bubbleHeight']
          }
        },
        modules: {
          plot : {
            id : 'sap.viz.modules.xycontainer',
            modules : {
              plot : {
                id : 'sap.viz.modules.bubble',
                configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
                  propertyCategory : 'plotArea'
                }
              }
            }
          }
        }
      }
    },
    feeds:{
        multiplier:{
          acceptMND:-1
         },
         secondaryValues: {
         max: 1
      }// or null
    },
    dependencies : {
      attributes : [
      {
        targetModule : 'main.xAxis2',
        target : 'scale',
        sourceModule : 'main',
        source : 'xCategoryScale'
      }, 
      {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main',
        source : 'yCategoryScale'
      },
      {
        targetModule : 'main',
        target : 'valueAxis1DataRange',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'valueAxis1DataRange',
        sourceModule : 'main',
        source : 'valueAxis1DataRange'
      },
      {
        targetModule : 'main',
        target : 'valueAxis2DataRange',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'valueAxis2DataRange',
        sourceModule : 'main',
        source : 'valueAxis2DataRange'
      },
      {
        targetModule : 'main',
        target : 'bubbleWidthDataRange',
        sourceModule : 'main.plot.plot',
        source : 'bubbleWidthDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'bubbleWidthDataRange',
        sourceModule : 'main',
        source : 'bubbleWidthDataRange'
      },
      {
        targetModule : 'main',
        target : 'bubbleHeightDataRange',
        sourceModule : 'main.plot.plot',
        source : 'bubbleHeightDataRange'
      },
      {
        targetModule : 'main.plot.plot',
        target : 'bubbleHeightDataRange',
        sourceModule : 'main',
        source : 'bubbleHeightDataRange'
      },
      {
        targetModule : 'main.plot.xAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'scale',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'main.plot.xAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'main.plot.yAxis',
        target : 'title',
        sourceModule : 'main.plot.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot.plot',
        source : 'shapes'
      }, {
          targetModule : 'sizeLegend',
          target : 'sizeLegendInfo',
          sourceModule : 'main.plot.plot',
          source : 'sizeLegend'
        }
      ]
    }
  };

  Manifest.register(multiBarChart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/scatter/single/base',
    name : 'IDS_BASEBUBBLECHART',
    'abstract' : true,
    base : 'riv/base/single',
    modules : {
      legend : {
        data : {
          aa : [ 1, 2 ]
        },
        configure : {
          properties : {
            type : 'BubbleColorLegend'
          }
        }
      },
      tooltip : {
        id : 'sap.viz.modules.tooltip',
        configure : {
          propertyCategory : 'tooltip',
          properties : {
            orientation : 'left'
          }
        }
      },
      main : {

            controllers : {
                'interaction' : { 
                    id : 'sap.viz.modules.controller.interaction',
                    configure : { 
                        propertyCategory :'interaction'
                    }
                }
            },

        modules : {
          xAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              mg : [ 1 ]
            },
            configure : {
              'description': 'Settings for the x axis of a normal bubble or scatter plot.',
              propertyCategory : 'xAxis',
              properties : {
                type : 'value',
                position : 'bottom',
                gridline : {
                  visible : false
                }
              }
            }
          },
          yAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              mg : [ 2 ]
            },
            configure : {
                'description': 'Settings for the y axis of a normal bubble or scatter plot.',
              propertyCategory : 'yAxis',
              properties : {
                type : 'value',
                position : 'left',
                gridline : {
                  visible : true
                }
              }
            }
          },
        
        background : {
        id: 'sap.viz.modules.background',
        configure : {
          propertyCategory : 'background',
          properties : {
            direction : 'vertical'
          }
        }
        },
        }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'valueAxis1Scale'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'valueAxis2Scale'
      }, {
        targetModule : 'main.xAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'valueAxis1Title'
      }, {
        targetModule : 'main.yAxis',
        target : 'title',
        sourceModule : 'main.plot',
        source : 'valueAxis2Title'
      }, {
        targetModule : 'legend',
        target : 'colorPalette',
        sourceModule : 'main.plot',
        source : 'colorPalette'
      }, {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapes'
      }, {
        targetModule : 'legend',
        target : 'setSelectionMode',
        sourceModule : 'main.interaction',
        source : 'getSelectionMode'
      }],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      }, {
          targetModule : 'main.interaction',
          listener : 'registerEvent',
          sourceModule : 'main.plot',
          type : 'initialized.interaction'
        }, {
        targetModule : 'main.interaction',
        listener : 'highlightedByLegend',
        sourceModule : 'legend',
        type : 'highlightedByLegend'
        }, {
        targetModule : 'legend',
        listener : 'deselectLegend',
        sourceModule : 'main.interaction',
        type : 'deselectLegend'
        }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.ScatterChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Scatter',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/scatter',
    name : 'IDS_SCATTERCHART',
    base : "viz/scatter/single/base",
    modules : {
      tooltip : {
        configure : {
          properties : {
            chartType : 'scatter'
          }
        }
      },
      main : {
        modules : {
          plot : {
            id : 'sap.viz.modules.scatter',
            configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.scatter.BubbleChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.scatter.BaseBubbleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Bubble',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/bubble',
    name : 'IDS_BUBBLECHART',
    base : "viz/scatter/single/base",
    modules : {
      sizeLegend : {
        id : 'sap.viz.modules.legend',
        configure : {
          'description': 'The size legend is a box mapping the charts data shapes\' size to the value by some typical symbols and associated indication values.',
          propertyCategory : 'sizeLegend',
          properties : {
            type : 'SizeLegend'
          },
          propertiesOverride :{
            isHierarchical : {
                  isExported : false
              }
          }

        }
      },
      tooltip : {
        configure : {
          properties : {
            chartType : 'bubble'
          }
        }
      },
      main : {
        modules : {
          plot : {
            id : 'sap.viz.modules.bubble',
            configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        }
      }
    },
    dependencies : {
      attributes : [  
        undefined, undefined, undefined, undefined, undefined, undefined, undefined,
     {
        targetModule : 'sizeLegend',
        target : 'sizeLegendInfo',
        sourceModule : 'main.plot',
        source : 'sizeLegend'
      } ],
      events : [ {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      } ]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.HeatMap',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var mainLabelAxisFeed = {
      'id' : 'mainLabelAxis',
      'name' : 'Main Category Axis',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
       'acceptMND': -1
    };

    var rectangleColorFeed = {
      'id' : 'rectangleColor',
      'name' : 'Rectangle Color',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    };

    var secondLabelAxisFeed = {
      'id' : 'secondaryLabelAxis',
      'name' : 'Secondary Category Axis',
      'type' : constants.Type.Dimension,
      'min' : 0,
      'max' : 1,
      'aaIndex' : 2,
       'acceptMND': -1
    };
  var feeds = {
    id : "heatMap",
    feeds : [ mainLabelAxisFeed, rectangleColorFeed, secondLabelAxisFeed ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.heatmap',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.modules.dispatch',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.ColorSeriesGenerator',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.util.tooltipDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.EffectManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.NumberUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.TextUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.MeasureBasedColoring',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Repository',
  version : '4.0.0'
}
],
function Setup(dispatch, ColorSeries, tooltipDataHandler, NumberUtils,EffectManager, TypeUtils, NumberUtils, TextRuler, MeasureBasedColoring, langManager, Repository) {
    //heatmap has no MND
    var heatMap = function(manifest) {
    
      var randomSuffix = Repository.newId();              //diff all the id
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };      

        var m_selectionList = [];

        var m_width, m_height;
        var m_props =
        {
            "emptycolor":"#e0e0e0",
            'animation': {
                dataLoading : true,
            },
            'colornumber': 5,
            'discretecolor' : false,
            'guideline' : 
            {
                visible: false,
                color: "#ffff90",
            },
            'drawemptycell': true,
            'colorPalette': [],
            tooltip: {
                enabled: true,
            }
        };
        
        m_props = extendObj(m_props, manifest.props(null));

        var m_styleTooltipFont = "'Open Sans', Arial, Helvetica, sans-serif";

        var m_data;

        var m_HLElement;

        var m_redrawAll = true;

        var m_className = "heatMap";
        var m_classEmptyValue = "heatMap_emptyValue";

        var m_padding = 1;

        var m_xScale = d3.scale.ordinal();
        var m_yScale = d3.scale.ordinal();

        var m_dispatch = new dispatch('selectData', 'deselectData', 'initialized', 'showTooltip', 'hideTooltip');

        var hColor = undefined; //Color Scale

        var m_styleLineColor = "#ffffff";
        
        var m_dataXAxis;
        var m_dataYAxis;
        var m_dataRect;

        var m_heatMapBody;//the root class
        var m_rects;//rects in the heatmap

        var m_selection = null;

        var m_tooltipElement = null;
        var m_guidline = null;

        //we need to draw some recs. So I will build a obj array, each item is a rec.
        var m_heatObjArray = [];

        var m_effectManager = null;
        
        var m_defaultString = langManager.get('IDS_ISNOVALUE');
        
        function chart(selection){
            m_selection = selection;
            //console.log(m_redrawAll);

            //prepare data
            m_heatObjArray = [];
            
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                //build labels
                var labelArray = [];
                var vArray = m_dataRect.values[0].rows[0];
                //add the data to m_heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < vArray.length; i++)
                {
                    m_heatObjArray.push(vArray[i]);
                }

                //build labelArray
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    var label = "";
                    for(var j = 0; j < m_dataXAxis.values.length; j++)
                    {
                        label += m_dataXAxis.values[j].rows[i].val;
                        if(j != (m_dataXAxis.values.length-1))
                        {
                            label += " / ";
                        }
                    }
                    labelArray.push(label);
                }

                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].label = labelArray[i];
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                for(var i = 0; i < numRow; i++)
                {
                    for(var j = 0; j < numCol; j++)
                    {
                        m_heatObjArray.push(hData[i][j]);
                    }
                }
            }

            // //count the max and min value of m_heatObjArray[i].val
            // var maxVal = -Number.MAX_VALUE;
            // var minVal = Number.MAX_VALUE;

            // for(var iObj = 0; iObj < m_heatObjArray.length; iObj++)
            // {
                // if(!NumberUtils.isNoValue(m_heatObjArray[iObj].val))
                // {
                    // if(maxVal < m_heatObjArray[iObj].val)
                    // {
                        // maxVal = m_heatObjArray[iObj].val;
                    // }

                    // if(minVal > m_heatObjArray[iObj].val)
                    // {
                        // minVal = m_heatObjArray[iObj].val;
                    // }
                // }
            // }

            //var numS = m_props.colornumber;

            hColor = buildColorScale();
            var domainArray = hColor.domain();
            for(var i = 0; i < m_heatObjArray.length; i++)
            {
                var domainValue;
                if(NumberUtils.isNoValue(m_heatObjArray[i].val)) {
                    m_heatObjArray[i].color = m_props.emptycolor;
                } else {
                    for (var j=0; j<domainArray.length; j++) {
                        var tdv = domainArray[j];
                        if ((j == domainArray.length-1) || (domainArray[j+1].length == 0)) {
                            domainValue = tdv;
                            break;
                        }
                        if ((m_heatObjArray[i].val >= tdv[0]) && (m_heatObjArray[i].val < tdv[1])) {
                            domainValue = tdv;
                            break;
                        }
                    }
                    m_heatObjArray[i].color = hColor(domainValue);
                }
                
                
                // for(var j = 0; j < numS; j++)
                // {
                     // if(NumberUtils.isNoValue(m_heatObjArray[i].val))
                    // {
                        // m_heatObjArray[i].color = m_props.emptycolor;
                        // break;
                    // }
                     // else if( m_heatObjArray[i].val == maxVal )
                    // {
                        // m_heatObjArray[i].color = hColor([(minVal + (maxVal-minVal)/numS*(numS-1)), maxVal]);
                        // break;
                    // }
                    // else if(m_heatObjArray[i].val >= (minVal + (maxVal-minVal)/numS*j) && m_heatObjArray[i].val < (minVal + (maxVal-minVal)/numS*(j+1)))
                    // {
                        // m_heatObjArray[i].color = hColor( [(minVal + (maxVal-minVal)/numS*j), (minVal + (maxVal-minVal)/numS*(j+1))]  );
                       
                    // }
                    
                // }
            }

            if(isOnlyOneCategroy)
            {
                //build the rect size. The rule is making the rect width and height have similar values
                var score = -Number.MAX_VALUE;//the bigger the better

                var rHeight;
                var rWidth;
                
                var iRow;
                var iCol;

                var emptyCellNum;

                var scoreArray = [];
                var varianceRec;

                if(m_heatObjArray.length == 1)
                {
                    rHeight = m_height;
                    rWidth = m_width;
                    iCol = 1;
                    iRow = 1;
                }
                else
                {

                    for(iRow = 1; iRow <= m_heatObjArray.length; iRow++)
                    {
                        //count the height
                        rHeight = m_height/iRow;

                        //count the num of one row. 
                        var iCol = m_heatObjArray.length;
                        for(; iCol >= 0; iCol--)
                        {
                            if((iCol * iRow) < m_heatObjArray.length)
                            {
                                iCol++;
                                break;
                            }
                        }

                        //count the width
                        rWidth = m_width/iCol;

                        emptyCellNum = (iCol * iRow) - m_heatObjArray.length;
                        varianceRec = (rHeight - rWidth)*(rHeight - rWidth);

                        if(varianceRec < 1)
                        {
                            varianceRec = 1; //to avoid 1/varianceRec huge number
                        }

                        var score;
                        if(emptyCellNum == 0 && varianceRec == 0)
                        {
                            score = 1 + 1;
                        }
                        else if(emptyCellNum == 0 && varianceRec != 0)
                        {
                            score = 1 + 1/varianceRec;
                        }
                        else if(emptyCellNum != 0 && varianceRec == 0)
                        {
                            score = 1/emptyCellNum + 1;
                        }
                        else
                        {
                            score = 1/emptyCellNum + 1/varianceRec;
                        }
                        
                        scoreArray.push(
                        {
                            "iRow":iRow,
                            "iCol":iCol,
                            "rHeight":rHeight,
                            "rWidth":rWidth,
                            "varianceRec":varianceRec,
                            "emptyCellNum":emptyCellNum,
                            "score":score
                        });
                    }
                    //select the best score
                    var maxS = 0;
                    var iChoose = -1;
                    for(var i = 0; i < scoreArray.length; i++)
                    {
                        if(scoreArray[i].score > maxS)
                        {
                            maxS = scoreArray[i].score;
                            iChoose = i;
                        }
                    }

                    rHeight = scoreArray[iChoose].rHeight;
                    rWidth = scoreArray[iChoose].rWidth;
                    iCol = scoreArray[iChoose].iCol;
                    iRow = scoreArray[iChoose].iRow;
                    
                }



                //build the rect height, width, and left, right
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].width = rWidth;
                    m_heatObjArray[i].height = rHeight;

                    m_heatObjArray[i].left = rWidth * (i%iCol);
                    m_heatObjArray[i].top = rHeight * (Math.floor(i/iCol));
                }
            }
            else
            {
                //build the rect height, width, and left, right
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    m_heatObjArray[i].width = m_width/numCol;
                    m_heatObjArray[i].height = m_height/numRow;

                    m_heatObjArray[i].left = (m_width/numCol) * (i%numCol);
                    //the Y is from the bottom
                    m_heatObjArray[i].top = (m_height-m_height/numRow) - ((m_height/numRow) * (Math.floor(i/numCol)));
                }
            }

            if(m_redrawAll)
            {
                selection.select("." + m_className).remove();
            }

            if(isOnlyOneCategroy)
            {
                //draw the rects
                if(m_redrawAll)
                {
                    m_heatMapBody = selection.append("g").attr("class", m_className);
                }
                else
                {
                    m_heatMapBody = selection.select("." + m_className);
                }

                var m_heatObjArrayToDraw = [];
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    if(!m_props.drawemptycell && !m_heatObjArray[i].val)
                    {
                        continue;
                    }
                    else
                    {
                        m_heatObjArray[i].index = i;
                        m_heatObjArrayToDraw.push(m_heatObjArray[i]);
                    }
                }
                //draw rects 
                var item = m_heatMapBody.selectAll("rect")
                     .data(m_heatObjArrayToDraw,function(d){return d.index;});
                    
                     
                var toDrawItems = item.enter();
                var toDeleteItems = item.exit();

                var rects;
                if(m_redrawAll)
                {
                    rects = toDrawItems.append("rect")
                            .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                            .attr('class', 'datapoint')
                            .attr("x", function(d){return d.left+m_padding;})
                            .attr("y", function(d){return d.top+m_padding;})
                            .attr("width", function(d){return d.width-2*m_padding;})
                            .attr("height",function(d){return d.height-2*m_padding;})
                            .attr("fill",function(d){ 
                                var parameter = {
                                    drawingEffect:'normal',
                                    fillColor : d.color};
                                return m_effectManager.register(parameter);
                                })
                            .attr("shape-rendering", "crispEdges");
                }
                else
                {
                    if(m_props.animation.dataUpdating)
                    {
                        rects = item
                                .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                                .attr('class', 'datapoint')
                                .transition()
                                .delay(0)
                                .duration(500)
                                .attr("x", function(d){return d.left+m_padding;})
                                .attr("y", function(d){return d.top+m_padding;})
                                .attr("width", function(d){return d.width-2*m_padding;})
                                .attr("height",function(d){return d.height-2*m_padding;})
                                .attr("fill",function(d){ 
                                    var parameter = {
                                        drawingEffect:'normal',
                                        fillColor : d.color};
                                    return m_effectManager.register(parameter);
                                    })
                                .attr("shape-rendering", "crispEdges");
                    }
                    else
                    {
                        rects = item
                                .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                                .attr('class', 'datapoint')
                                .attr("x", function(d){return d.left+m_padding;})
                                .attr("y", function(d){return d.top+m_padding;})
                                .attr("width", function(d){return d.width-2*m_padding;})
                                .attr("height",function(d){return d.height-2*m_padding;})
                                .attr("fill",function(d){ 
                                    var parameter = {
                                        drawingEffect:'normal',
                                        fillColor : d.color};
                                    return m_effectManager.register(parameter);
                                    })
                                .attr("shape-rendering", "crispEdges");
                    }
                    //unselect all of them
                    rects.attr('opacity', 1);
                }


                if(!m_props.border || (m_props.border && m_props.border.visible))
                {
                    rects.attr("stroke",m_styleLineColor)
                           .attr("stroke-width","1");
                }

                if(m_redrawAll)
                {
                    if(m_props.animation.dataLoading){
                        rects.attr('opacity', 0);

                        rects.transition()
                            .delay(0)
                            .duration(1000).attr('opacity', 1);
                    }
                }

                //labels
                if(m_redrawAll)
                {
                    toDrawItems.append("text")
                                .attr("x", function(d){return d.left+d.width/2;})
                                .attr("y", function(d){return d.top+d.height/2;})
                                .attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                                .attr("text-anchor", "middle") // text-align
                                .text(function(d){return d.label;})
                                .attr("fill", "#ffffff")
                                .style("font-size", "12px")
                                .style("font-family", "'Open Sans', Arial, Helvetica, sans-serif")
                                .attr('pointer-events', 'none')
                                .each(function(d) {
                                    //Jimmy, BITVIZ-384, add padding before text
                                    TextRuler.ellipsis(d.label, this, d.width - 5, "fill:#ffffff;font-family:'Open Sans', Arial, Helvetica, sans-serif;font-size:12px;");
                                });
                }
                else
                {
                     m_heatMapBody.selectAll("text").remove();

                     m_heatMapBody.selectAll("text").data(m_heatObjArrayToDraw,function(d){return d.index;}).enter().append("text")
                    .attr("x", function(d){return d.left+d.width/2;})
                    .attr("y", function(d){return d.top+d.height/2;})
                    .attr("dominant-baseline", "central")//"auto")//"hanging")//"central")
                    .attr("text-anchor", "middle") // text-align
                    .text(function(d){return d.label;})
                    .attr("fill", "#ffffff")
                    .style("font-size", "12px")
                    .style("font-family", "'Open Sans', Arial, Helvetica, sans-serif")
                    .attr('pointer-events', 'none')
                    .each(function(d) {
                        //Jimmy, BITVIZ-384, add padding before text
                        TextRuler.ellipsis(d.label, this, d.width - 5, "fill:#ffffff;font-family:'Open Sans', Arial, Helvetica, sans-serif;font-size:12px;");
                    });
                }

                m_rects = rects;
            }
            else
            {
                //draw the rects
                if(m_redrawAll)
                {
                    m_heatMapBody = selection.append("g").attr("class", m_className);
                }
                else
                {
                    m_heatMapBody = selection.select("." + m_className);
                }

                if(!m_props.drawemptycell)
                {
                    //draw a rect
                    if(m_redrawAll)
                    {
                        m_heatMapBody.append('rect')
                                   .attr("x", 0)
                                   .attr("y", 0)
                                   .attr("width", m_width)
                                   .attr("height",m_height)
                                   .attr("fill",m_props.emptycolor)
                                   .attr("class", m_classEmptyValue)
                                   .attr("shape-rendering", "crispEdges");
                    }
                    else
                    {
                        m_heatMapBody.select("." + m_classEmptyValue)
                                   .attr("x", 0)
                                   .attr("y", 0)
                                   .attr("width", m_width)
                                   .attr("height",m_height)
                                   .attr("fill",m_props.emptycolor)
                                   .attr("class", m_classEmptyValue)
                                   .attr("shape-rendering", "crispEdges");

                    }
                }

                var m_heatObjArrayToDraw = [];
                for(var i = 0; i < m_heatObjArray.length; i++)
                {
                    if(!m_props.drawemptycell && !m_heatObjArray[i].val)
                    {
                        continue;
                    }
                    else
                    {
                        m_heatObjArray[i].index = i;
                        m_heatObjArrayToDraw.push(m_heatObjArray[i]);
                    }
                }
                
                //draw rects 
                var item = m_heatMapBody.selectAll("rect")
                     .data(m_heatObjArrayToDraw,function(d){return d.index;});

                var toDrawItems = item.enter();
                var toDeleteItems = item.exit();

                var rects;
                if(m_redrawAll)
                {     
                    rects = toDrawItems.append("rect")
                        .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                        .attr('class', 'datapoint')
                        .attr("x", function(d){return d.left;})
                        .attr("y", function(d){return d.top;})
                        .attr("width", function(d){return d.width;})
                        .attr("height",function(d){return d.height;})
                        .attr("fill",function(d){ 
                            var parameter = {
                                drawingEffect:'normal',
                                fillColor : d.color};
                            return m_effectManager.register(parameter);
                            })
                        .attr("shape-rendering", "crispEdges");
                }
                else
                {
                    if(m_props.animation.dataUpdating)
                    {
                        rects = item
                            .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                            .attr('class', 'datapoint')
                            .transition()
                            .delay(0)
                            .duration(500)
                            .attr("x", function(d){return d.left;})
                            .attr("y", function(d){return d.top;})
                            .attr("width", function(d){return d.width;})
                            .attr("height",function(d){return d.height;})
                            .attr("fill",function(d){ 
                                var parameter = {
                                    drawingEffect:'normal',
                                    fillColor : d.color};
                                return m_effectManager.register(parameter);
                                })
                            .attr("shape-rendering", "crispEdges");
                    }
                    else
                    {
                        rects = item
                            .attr('id', function(d, i){return ("HM" + d.index + randomSuffix);})
                            .attr('class', 'datapoint')
                            .attr("x", function(d){return d.left;})
                            .attr("y", function(d){return d.top;})
                            .attr("width", function(d){return d.width;})
                            .attr("height",function(d){return d.height;})
                            .attr("fill",function(d){ 
                                var parameter = {
                                    drawingEffect:'normal',
                                    fillColor : d.color};
                                return m_effectManager.register(parameter);
                                })
                            .attr("shape-rendering", "crispEdges");
                    }
                    //unselect all of them
                    rects.attr('opacity', 1);
                }


                if(!m_props.border || (m_props.border && m_props.border.visible))
                {
                    rects.attr("stroke",m_styleLineColor)
                           .attr("stroke-width","1");
                }

                if(m_redrawAll)
                {
                    if(m_props.animation.dataLoading){
                        rects.attr('opacity', 0);

                        rects.transition()
                            .delay(0)
                            .duration(1000).attr('opacity', 1);
                    }
                }
                m_rects = rects;
            }
            //the HLCell Rectange
            if(m_redrawAll)
            {
                m_HLElement = m_heatMapBody.append('g').attr('class', 'HLElement').attr("visibility", "hidden");
                m_HLElement.append('line').attr('class', 'HLLeft').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLRight').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLTop').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
                m_HLElement.append('line').attr('class', 'HLBottom').attr("x1",0).attr("y1",0).attr("x2",0).attr("y2",0).attr("shape-rendering", "crispEdges").attr("stroke","#6c6c6c");
            }

            //tooltip
            if(m_redrawAll)
            {
                m_tooltipElement = m_heatMapBody.append('g').attr('class', 'heatMapTooltip');
                m_tooltipElement.append('rect').attr('ry', 6).attr('rx', 6).attr('opacity', 0.8).attr("stroke-width","1").attr("stroke","#666666");

                var rectText = m_dataRect.values[0].col;
                var xText = m_dataXAxis.values[0].col.val;
                var yText = "";
                if(m_dataYAxis)
                {
                    yText = m_dataYAxis.values[0].col.val;
                }
                
                m_tooltipElement.append('text').attr('text-anchor', 'start').attr('font-size', '12px') 
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr('font-weight', "bold")
                                               .attr("x", 20).attr("y", 18).attr("fill", "#333333").text(rectText);

                m_tooltipElement.append('text').attr('text-anchor', 'start').attr('font-size', '12px').attr("class", "valText")
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr("x", 30).attr("y", 33).attr("fill", "#333333");


                m_tooltipElement.append('line').attr("x1", 0).attr("y1", 40)
                                               .attr("x2", 160).attr("y2", 40).attr("stroke", "#666666");

                m_tooltipElement.append('text').attr('text-anchor', 'end').attr('font-size', '11px') 
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr('font-weight', "bold")
                                               .attr("x", 80).attr("y", 55).attr("fill", "#333333").text(xText);

                m_tooltipElement.append('text').attr('text-anchor', 'start').attr('font-size', '10px').attr("class", "valXValue")
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr("x", 85).attr("y", 55).attr("fill", "#333333");

                m_tooltipElement.append('text').attr('text-anchor', 'end').attr('font-size', '11px') 
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr('font-weight', "bold")
                                               .attr("x", 80).attr("y", 70).attr("fill", "#333333").text(yText);

                m_tooltipElement.append('text').attr('text-anchor', 'start').attr('font-size', '10px').attr("class", "valYValue")
                                               .attr('font-family', m_styleTooltipFont)
                                               .attr("x", 85).attr("y", 70).attr("fill", "#333333");

                m_tooltipElement.attr('visibility', 'hidden');
            }


            //guidline
            if(m_redrawAll)
            {
                m_guidline = m_heatMapBody.append('g').attr('class', 'heatMapGuideline');
                m_guidline.append("line").attr("x1", 0).attr("y1", 0).attr("x2", 0).attr("y2", m_height).attr("stroke", m_props.guideline.color).attr("shape-rendering", "crispEdges").attr('class', 'xGuidline');
                m_guidline.append("line").attr("x1", 0).attr("y1", 0).attr("x2", m_width).attr("y2", 0).attr("stroke", m_props.guideline.color).attr("shape-rendering", "crispEdges").attr('class', 'yGuidline');
                m_guidline.attr('visibility', 'hidden');
            }
            
            //we have to make sure the animation is end.
            if(m_props.animation.dataLoading)
            {
                var lastRectsOpacity = -1;
                var checkEnd = function()
                {
                    var rectsOpacity = m_rects.attr('opacity');
                    //console.log(m_rects.attr('opacity'));
                    if(rectsOpacity == lastRectsOpacity) //no animation
                    {
                          clearInterval(func);
                          m_dispatch.initialized();
                    }
                    else
                    {
                        lastRectsOpacity = rectsOpacity;
                    }
                }

                var func = setInterval(checkEnd, 20);
            }
            else
            { 
                m_dispatch.initialized();
            }                
            

            m_redrawAll = false;
            return chart;
        };
        
        function deregisterEvent(){
            
        };
        
        function registerEvent(){
            
        };

        var showTooltip = function(dataIndex){ 
            var dataItem = m_heatObjArray[dataIndex];
            var valXValue = "";
            var valYValue = "";



           var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                valXValue = m_dataXAxis.values[0].rows[dataIndex].val;
                if(m_dataYAxis)
                {
                    valYValue = m_dataYAxis.values[0].rows[dataIndex].val;
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                valXValue = m_dataXAxis.values[0].rows[dataIndex%numCol].val;
                valYValue = m_dataYAxis.values[0].rows[Math.floor(dataIndex/numCol)].val;
            }

            m_tooltipElement.select("rect").attr("width", 160).attr("height", 78).attr("fill" , "rgb(255,255,255)");
            m_tooltipElement.attr("transform", "translate(" + (dataItem.left + dataItem.width/2 + 5) + "," + (dataItem.top + dataItem.height/2 + 5) + ")");
            if(!NumberUtils.isNoValue(dataItem.val))
            {
                m_tooltipElement.select(".valText").text(dataItem.val);
                m_tooltipElement.select(".valXValue").text(valXValue);
                m_tooltipElement.select(".valYValue").text(valYValue);

                m_tooltipElement.attr('visibility', 'visible');

                //guideline
                if(m_props.guideline.visible)
                {
                    m_guidline.select(".xGuidline").attr("x1", m_heatObjArray[dataIndex].left + m_heatObjArray[dataIndex].width/2).attr("x2", m_heatObjArray[dataIndex].left + m_heatObjArray[dataIndex].width/2);
                    m_guidline.select(".yGuidline").attr("y1", m_heatObjArray[dataIndex].top + m_heatObjArray[dataIndex].height/2).attr("y2", m_heatObjArray[dataIndex].top + m_heatObjArray[dataIndex].height/2);
                    m_guidline.attr('visibility', 'visible');
                }
            }            
        };
        
        var generateTooltipData = function(dataIndex){
            //for heatmap, we only have one measure so that the body's length is always 1
            var tooltipData = {
                body:[],
                footer:[]
            };
            var dataItem = m_heatObjArray[dataIndex];
            var body = {
                    'name': m_dataRect.values[0].col,
                    val:[{
                        color: dataItem.color,
                        value: NumberUtils.isNoValue(dataItem.val)?m_defaultString:dataItem.val
                    }]
            };
            
            tooltipData.body.push(body);
            
            if(TypeUtils.isExist(m_dataXAxis)){
                for(var tval = m_dataXAxis.values, len = tval.length, i = len -1; i  >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col.val;
                    footer.value = tval[i].rows[dataIndex%tval[i].rows.length].val;
                    tooltipData.footer.push(footer);
                }
            }
            
            if(TypeUtils.isExist(m_dataYAxis)){
                var dataIndexInYAxis = Math.floor(dataIndex / m_dataXAxis.values[0].rows.length);
                for(var tval = m_dataYAxis.values, len = tval.length, i = len -1; i >= 0; i--){
                    var footer = {};
                    footer.label = tval[i].col.val;
                    footer.value = tval[i].rows[dataIndexInYAxis%tval[i].rows.length].val;
                    tooltipData.footer.push(footer);
                }
            }
            
            return tooltipData;
        };
        
        var hideTooltip = function(){
            m_tooltipElement.attr('visibility', 'hidden');
            m_guidline.attr('visibility', 'hidden');
        };

        var HLCell = function(item)
        {
            if(!NumberUtils.isNoValue(item.datum().val))
            {
                m_HLElement.attr("visibility", "visible");

                var iLeft = item.datum().left;
                var iRight = item.datum().left + item.datum().width;
                var iTop = item.datum().top;
                var iBottom = item.datum().top + item.datum().height;

                m_HLElement.select(".HLLeft").attr("x1",iLeft).attr("y1",iTop).attr("x2",iLeft).attr("y2",iBottom);
                m_HLElement.select(".HLRight").attr("x1",iRight).attr("y1",iTop).attr("x2",iRight).attr("y2",iBottom);
                m_HLElement.select(".HLTop").attr("x1",iLeft).attr("y1",iTop).attr("x2",iRight).attr("y2",iTop);
                m_HLElement.select(".HLBottom").attr("x1",iLeft).attr("y1",iBottom).attr("x2",iRight).attr("y2",iBottom);
            }
        };

        var unHLCell = function(item)
        {
            m_HLElement.attr("visibility", "hidden");
        };

        chart.mouseover = function(elem){
            var item = d3.select(d3.event.target);
            var clickedItemID = item.attr('id');
            if(clickedItemID && m_props.tooltip.enabled)
            {
              var tmpLength = clickedItemID.toString().length - randomSuffix.toString().length - 2;
                var dataIndex = clickedItemID.toString().substr(2 , tmpLength);
                
                var transform = m_selection.node().getTransformToElement(m_selection.node().ownerSVGElement);
                var svgBoundingBox = m_selection.node().ownerSVGElement.getBoundingClientRect();
                var rectBoundingBox =  elem.getBoundingClientRect();
                //showTooltip(dataIndex);
                var tooltipData = generateTooltipData(dataIndex);
                tooltipData.point = {
                        x : rectBoundingBox.left - svgBoundingBox.left + rectBoundingBox.width/2,
                        y : (rectBoundingBox.height > 16) ? rectBoundingBox.top - svgBoundingBox.top + 8 : rectBoundingBox.top - svgBoundingBox.top + rectBoundingBox.height/2
                };
                tooltipData.plotArea = {
                        x : transform.e,
                        y : transform.f,
                        width : m_width,
                        height : m_height
                };
                m_dispatch.showTooltip(tooltipDataHandler.formatTooltipData(tooltipData));
                HLCell(item);
            }

        };
        
        chart.mouseout = function(){
            if(m_props.tooltip.enabled)
            {
                m_dispatch.hideTooltip();
            }

            if(d3.event)
            {
                var item = d3.select(d3.event.target);
                unHLCell(item);
            }
        };



        /*
         * Add mouse interaction functions.
         */
        chart.parent = function(){
            return m_selection;
        };

        chart.highlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 1);
                }
            }else{
                elems.setAttribute('opacity', 1);
            }
        };
        
        chart.unhighlight = function(elems){
            if(elems instanceof Array){
                for(var i = 0, len = elems.length; i < len; i++){
                    elems[i].setAttribute('opacity', 0.2);
                }
            }else{
                elems.setAttribute('opacity', 0.2);
            }
        };
        
        chart.clear = function(gray){
            if( gray == null){
                m_selection.selectAll('.datapoint').attr('opacity', 1);
            }else{
                m_selection.selectAll('.datapoint').attr('opacity', 0.2);
            }
        };
        
        chart.width = function(_width){
            if (!arguments.length){
              return m_width;
            }
            m_width = _width;

            makeXScale();
            return chart;
        };

        chart.height = function(_height){
            if (!arguments.length){
              return m_height;
            }
            m_height = _height;
            
            makeYScale();
            return chart;       
        };

        chart.data = function(value){
            if (!arguments.length){
                return m_data;
            }

            m_data = value;
            m_redrawAll = true;
            
            m_dataXAxis = m_data.getAnalysisAxisDataByIdx(0);
            m_dataYAxis = m_data.getAnalysisAxisDataByIdx(1);
            m_dataRect = m_data.getMeasureValuesGroupDataByIdx(0);
            
            return chart;
        };

        chart.properties = function(props){
            if (!arguments.length){
                return m_props;
            }           
            m_props = extendObj(m_props, manifest.props(props));
            m_redrawAll = true;
            return chart;           
        };

        /**
         * interfaces for MBC legend selection
         * @param {Object} selectedData 
         * <pre>
         * {
         * ctx: {
         *   ranges: {
         *    endValue:100
         *    isLeftOpen:false
         *    isRightOpen:true
         *    startValue:84
         *   }
         * },
         * val: 84   
         * }
         * @returns {Array} d3 selections in the given range  
         */
        chart.getDatapointsByRange = function(selectedData){
          var datapoints = d3.selectAll('.datapoint')[0], ctxDatapoints = [], ranges = selectedData.ctx.ranges, data;
          for(var i = 0, len = datapoints.length; i < len; i++){
            data = datapoints[i].__data__.val;
            if(NumberUtils.isNoValue(selectedData.val)){
              if(NumberUtils.isNoValue(data)){
                ctxDatapoints.push(datapoints[i]);
              }
            }else{
              if(data < ranges.endValue && data > ranges.startValue){
                ctxDatapoints.push(datapoints[i]);
              }else{
                if(!ranges.isLeftOpen && data === ranges.startValue) {
                  ctxDatapoints.push(datapoints[i]);
                }else if(!ranges.isRightOpen && data === ranges.endValue){
                  ctxDatapoints.push(datapoints[i]);
                }
              }
            }
          }
          return ctxDatapoints;
        };
        
        /**
         * set/get effect manager
         */
        chart.effectManager = function(_){
            if (!arguments.length){
                return m_effectManager;
             }
                
             m_effectManager = _;
             m_redrawAll = true;
            
             return chart;
         };
         
        chart.mbcLegendInfo = function(){
            var hColor = buildColorScale();
            return {
                'colorScale' : hColor,
                'title': m_dataRect.values[0].col
            };
        };

        chart.getPreferredSize = function(){
            
        };

        chart.categoryScaleX = function(){
            return m_xScale;
        };
       
        chart.isDrawXaxisBody = function(){
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            return (!isOnlyOneCategroy);
        };

        chart.categoryScaleY = function(){
            return m_yScale;
        };

        var buildColorScale = function()
        {
            //return a color scale like
            //var domainRg = [ [10,40], [40, 100] ];
            //var rangeRg = ['#ff0000', '#00ff00' ];
            //hColor = d3.scale.ordinal().domain(domainRg).range(rangeRg);

            var hColor = d3.scale.ordinal();

            //we need to draw some recs. So I will build a obj array, each item is a rec.
            var heatObjArray = [];
            
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }

            if(isOnlyOneCategroy)
            {
                var hData = m_dataRect.values[0].rows[0];
                //add the data to heatObjArray. the number of rectanges is the number of rectanglecolor.valuies.
                for(var i = 0; i < hData.length; i++)
                {
                    heatObjArray.push(hData[i]);
                }
            }
            else
            {
                //for the 2 categories, we have to count the numCol and the numRow.
                var hCol = m_dataXAxis.values[0].rows;
                var hRow = m_dataYAxis.values[0].rows;
                var hData = m_dataRect.values[0].rows;

                var numCol = hCol.length;
                var numRow = hRow.length;

                for(var i = 0; i < numRow; i++)
                {
                    for(var j = 0; j < numCol; j++)
                    {
                        heatObjArray.push(hData[i][j]);
                    }
                }
            }

            //count the max and min value of heatObjArray[i].val
            var maxVal = -Number.MAX_VALUE;
            var minVal = Number.MAX_VALUE;

            for(var iObj = 0; iObj < heatObjArray.length; iObj++)
            {
                if(!NumberUtils.isNoValue(heatObjArray[iObj].val))
                {
                    if(maxVal < heatObjArray[iObj].val)
                    {
                        maxVal = heatObjArray[iObj].val;
                    }

                    if(minVal > heatObjArray[iObj].val)
                    {
                        minVal = heatObjArray[iObj].val;
                    }
                }
            }
            //has "novalue" or not
            var hasNullValue = false;
            for(var i = 0; i < heatObjArray.length; i++)
            {
                if( NumberUtils.isNoValue(heatObjArray[i].val))
                {
                    hasNullValue = true;
                }
            }
            
            var numS = m_props.colornumber;

            var fontColorScale;
            if(minVal === Number.MAX_VALUE && maxVal === -Number.MAX_VALUE){
                fontColorScale = d3.scale.ordinal().domain([[]]).range([m_props.emptycolor]);
            } else {
                var fontColorScale = MeasureBasedColoring.getScale(minVal, maxVal, numS, m_props.startColor, m_props.endColor);
                if(hasNullValue){
                    var domains = fontColorScale.domain();
                    var ranges = fontColorScale.range();
                    domains.push([]);
                    ranges.push(m_props.emptycolor);
                }
            }
            return fontColorScale;
            // //build the color
            // var heatColor = d3.scale.linear()
                // .domain([minVal, maxVal])
                // .range([m_props.startcolor, m_props.endcolor]);

            // //build a d3.scale.ordinal() for legend
            // var domainRg = [];
            // var rangeRg = [];
            // for(var j = 0; j < (numS-1); j++)
            // {
                // domainRg.push( [minVal + (maxVal-minVal)/numS*j, (minVal + (maxVal-minVal)/numS*(j+1))] );
                // rangeRg.push( heatColor(minVal + (maxVal-minVal)/(numS-1)*j) );
            // }

            // domainRg.push( [minVal + (maxVal-minVal)/numS*(numS-1), maxVal] );
            // rangeRg.push( heatColor(maxVal) );



            // if(m_props.discretecolor)
            // {
                // var colorArray;
                // if(m_props.colorPalette.length == 0)
                // {
                    // colorArray = ColorSeries.sap32().range();
                // }
                // else
                // {
                    // colorArray = m_props.colorPalette;
                // }

                // var j = 0;
                // for(var i = 0; i < rangeRg.length; i++)
                // {
                    // rangeRg[i] = colorArray[j];
                    // j = (j+1)%(colorArray.length);
                // }
            // }

            // if(hasNULL) //no value
            // {
                // domainRg.push([]);
                // rangeRg.push(m_props.emptycolor);
            // }


            // hColor = d3.scale.ordinal().domain(domainRg).range(rangeRg);

            // return hColor;
        }

        var makeXScale = function()
        {
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            

            var hCol = m_dataXAxis.values[0].rows;
            var dArray = [];
            for(var i = 0; i < hCol.length; i++)
            {
                dArray.push(i);
            }

            m_xScale = m_xScale.domain(dArray)
                                .rangeBands([0, m_width]);
        };

        var makeYScale = function()
        {
            var isOnlyOneCategroy = false;
            if(!m_dataYAxis)
            {
                isOnlyOneCategroy = true;
            }
            
            if(isOnlyOneCategroy)
            {
                //no yAxis
                m_yScale = m_yScale.domain([0,0])
                                .rangeBands([0,0]);
            }
            else
            {
                var hRow = m_dataYAxis.values[0].rows;
                var dArray = [];
                for(var i = 0; i < hRow.length; i++)
                {
                    dArray.push(i);
                }

                //y is from bottom
                m_yScale = m_yScale.domain(dArray)
                                .rangeBands([m_height, 0]);
            }
        };

        /**
         * get/set your event dispatch if you support event
         */
        chart.dispatch = function(_){
            if(!arguments.length)
                return m_dispatch;
            m_dispatch = _;
            return chart;
        };
        
        var extendObj = function(target, source)
        {
            for(var prop in source)
            {
                if(typeof(source[prop]) === "object")
                {
                    if(target[prop])
                    {
                        target[prop] = extendObj(target[prop], source[prop]);
                    }
                    else
                    {
                        target[prop] = source[prop];
                    }
                }
                else
                {
                    target[prop] = source[prop];
                }
            }
            return target;
        };
        m_props = extendObj(m_props, manifest.props(null));
        return chart;
    };

    return heatMap;
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.HeatMap',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.heatmap',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.HeatMap',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {

    var module = {
      'id' : 'sap.viz.modules.heatmap',
      'type' : Constants.Module.Type.Chart,
      'name' : 'heatmap',
      'properties' : {
        'border' : {
          'name' : 'border',
      'description' : 'Settings for border.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'visible' : {
                'name' : 'visible',
                'supportedValueType' : 'Boolean',
                'defaultValue' : true,
                'description' : 'Set visibility of zone edge.'
            },
          },
        },

        'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set heatMap startColor.'
        },
      
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set heatMap endColor.'
        },

        'tooltip' : {
          'name' : 'tooltip',
      'description' : 'Settings for tooltip.',
          'supportedValueType' : 'Object',
          'supportedValues' : {
              'visible': {
                    'name' : 'enabled',
                    'supportedValueType' : 'Bool',
                    'defaultValue' : true,
                    'description' : 'Set enabled/disabled tooltip.'
              },
          }
        }
      },
      'events' : {
        'selectData' : Constants.Module.Event.SelectData.desc,
      'deselectData' : Constants.Module.Event.DeSelectData.desc,
      'showTooltip' : Constants.Module.Event.TooltipShow.desc,
      'hideTooltip' : Constants.Module.Event.TooltipHide.desc

      },
      'feeds' :{
          id:"heatMap"
      },
      'css' : {},
      'configure' : null,
      fn : fn
    };

    Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.HeatMapChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Axis',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.HeatMap',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/heatmap',
    name : 'IDS_HEATMAPCHART',
      base : 'riv/base/single',
    modules : {
        
      legend : {
          id : 'sap.viz.modules.legend',
        configure : {
          'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
          properties : {
              type : 'MeasureBasedColoringLegend'
            },
            propertiesOverride : {
              isHierarchical : {
                isExported : false
              }
            }
        }
      },
    tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'heatmap',
              orientation : 'bottom'
            }
          }
        },

      main : {
        modules : {
          xAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              aa : [ 1 ]
            },
            configure : {
            'description': 'Settings for the x axis of a normal heatmap.',
              propertyCategory : 'xAxis',
              properties : {
                type : 'category',
                position : 'bottom',
                gridline : {
                  visible : false
                }
              },
              propertiesOverride : {
                gridline : {
                  isExported : false
                },
                label : {
                  isExported : false
                },
                axisline : {
                  isExported : false
                }
              }
            }
          },
          
          yAxis : {
            id : 'sap.viz.modules.axis',
            data : {
              aa : [ 2 ]
            },
            configure : {
            'description': 'Settings for the y axis of a normal heatmap.',
              propertyCategory : 'yAxis',
              properties : {
                type : 'category',
                position : 'left',
                gridline : {
                  visible : false
                }
              },
              propertiesOverride : {
                gridline : {
                  isExported : false
                },
                label : {
                  isExported : false
                },
                axisline : {
                  isExported : false
                }
              }
            }
          },          
        
          plot : {
            id : 'sap.viz.modules.heatmap',
            configure : {
              'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          },
        },


        controllers : {
             'interaction' : {
                   id : 'sap.viz.modules.controller.interaction',
                   configure : {
                       propertyCategory : 'interaction',
                        properties : {
                          supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
                        }
                   }
               }
          }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'main.xAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScaleX'
      },{
        targetModule : 'main.xAxis',
        target : 'isDrawBody',
        sourceModule : 'main.plot',
        source : 'isDrawXaxisBody'
      }, {
        targetModule : 'main.yAxis',
        target : 'scale',
        sourceModule : 'main.plot',
        source : 'categoryScaleY'
      },
      {
        targetModule : 'legend',
        target : 'mbcLegendInfo',
        sourceModule : 'main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
      }],
    
          events : [ {
              targetModule : 'main.interaction',
              listener : 'registerEvent',
              sourceModule : 'main.plot',
              type : 'initialized.interaction'
          }, {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }, {
          targetModule : 'tooltip',
          listener : 'showTooltip',
          sourceModule : 'main.plot',
          type : 'showTooltip'
        }, {
          targetModule : 'tooltip',
          listener : 'hideTooltip',
          sourceModule : 'main.plot',
          type : 'hideTooltip'
        }],
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.feeds.TagCloud',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.feeds.Manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.Constants',
  version : '4.0.0'
}
],
function Setup(Manifest, constants) {
  var feeds = {
    id : "tagCloud",
    feeds : [ {
      'id' : 'tagName',
      'name' : 'Tags Name',
      'type' : constants.Type.Dimension,
      'min' : 1,
      'max' : 1,
      'aaIndex' : 1,
      'acceptMND': -1,
      'maxStackedDims' : 1 
      
    }, {
      'id' : 'tagWeight',
      'name' : 'Tags Weight',
      'type' : constants.Type.Measure,
      'min' : 1,
      'max' : 1,
      'mgIndex' : 1
    }, {
      'id' : 'tagFamily',
      'name' : 'Tags Family',
      'type' : constants.Type.Measure,
      'min' : 0,
      'max' : 1,
      'mgIndex' : 2
    } ]
  };
  Manifest.register(feeds);
});sap.riv.module(
{
  qname : 'sap.viz.modules.manifests.TagCloud',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.modules.manifests.Module',
  version : '4.0.0'
},
{  qname : 'sap.viz.Constants',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.tagcloud',
  version : '4.0.0'
},
{  qname : 'sap.viz.feeds.TagCloud',
  version : '4.0.0'
}
],
function Setup(Manifest, Constants, fn) {
  var module = {
    'id' : 'sap.viz.modules.tagcloud',
    'type' : Constants.Module.Type.Chart,
    'name' : 'tagcloud',
    'properties' : {
      'layout' : {
        'name' : 'layout',
        'supportedValueType' : 'List',
        'supportedValues' : [ 'Row', 'Column', 'Wordle' ],
        'defaultValue' : 'Wordle',
        'description' : 'Set layout fo tag cloud.'
      },
      'animation' : {
          'name' : 'animation',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'dataLoading' : {
              'name' : 'dataLoading',
              'supportedValueType' : 'Boolean',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled data loading animation of plot area.'
            },
            'dataUpdating' : {
              'name' : 'dataUpdating',
              'supportedValueType' : 'Boolean',
              'defaultValue' : false,
              'description' : 'Set enabled/disabled data updating animation of plot area.'
            }
          },
          'description' : 'Settings for animation of plot area.'
        },
      'startColor' : {
          'name' : 'startColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#C2E3A9",
          'description' : 'Set tagCloud start color.'
        },
        
        'endColor' : {
          'name' : 'endColor',
          'supportedValueType' : 'String',
          'defaultValue' : "#73C03C",
          'description' : 'Set tagCloud endcolor.'
        },
        'tooltip' : {
          'name' : 'tooltip',
          'supportedValueType' : 'Object',
          'supportedValues' : {
            'enabled' : {
              'name' : 'enabled',
              'supportedValueType' : 'Bool',
              'defaultValue' : true,
              'description' : 'Set enabled/disabled tooltip.'
            }
          },
          'isExported' : false,
          'description' : 'Settings for tooltip related properties.'
        }
    },
    'events' : {
        'selectData' : Constants.Module.Event.SelectData.desc,
        'deselectData' : Constants.Module.Event.DeSelectData.desc,
        'showTooltip' : Constants.Module.Event.TooltipShow.desc,
        'hideTooltip' : Constants.Module.Event.TooltipHide.desc

    },
    'feeds' : {
      id : "tagCloud"
    },
    'css' : {},
    'configure' : null,
    fn : fn
  };
  Manifest.register(module);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.TagCloudChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.TagCloud',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/tagcloud',
    name : 'IDS_TAGCLOUDCHART',
    base : 'riv/base/single',
    modules : {
      legend : {
        feeds : [],
        configure : {
          'description': 'The measure based coloring legend is a bar containing segments with different colors and a value scale on side to indicate the relationship between the values and colors in the chart. ',
          properties : {
            type : 'MeasureBasedColoringLegend'
          },
          propertiesOverride : {
            isHierarchical : {
              isExported : false
            }
          }
        }
      },
    tooltip : {
          id : 'sap.viz.modules.tooltip',
          configure : {
            propertyCategory : 'tooltip',
            properties : {
              chartType : 'tagcloud',
              orientation : 'bottom'
            }
          }
        },
    
      main : {
        modules : {
          plot : {
            id : 'sap.viz.modules.tagcloud',
            configure : {
                'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }
          }
        },
        controllers : {
             'interaction' : {
                   id : 'sap.viz.modules.controller.interaction',
                   configure : {
                       propertyCategory : 'interaction',
                        properties : {
                          supportedEventNames: ['mouseup', 'mouseover', 'mouseout', 'touchstart']
                        }
                   }
               }
          }
      }
    },
    dependencies : {
      attributes : [ {
        targetModule : 'legend',
        target : 'mbcLegendInfo',
        sourceModule : 'main.plot',
        source : 'mbcLegendInfo'
      }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
      } ],
      events : [ {
        targetModule : 'main.interaction',
        listener : 'registerEvent',
        sourceModule : 'main.plot',
        type : 'initialized.interaction'
      },  {
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }, {
        targetModule : 'tooltip',
        listener : 'showTooltip',
        sourceModule : 'main.plot',
        type : 'showTooltip'
      }, {
        targetModule : 'tooltip',
        listener : 'hideTooltip',
        sourceModule : 'main.plot',
        type : 'hideTooltip'
      } ]
    }
  };
  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.manifests.RadarChart',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.Viz',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.BaseSingleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Radar',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Tooltip',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.manifests.Background',
  version : '4.0.0'
}
],
function Setup(Manifest) {
  var chart = {
    id : 'viz/radar',
    name : 'IDS_RADARCHART',
    base : "riv/base/single",
    modules : {
      legend : {
        id : "sap.viz.modules.legend",
        data : {
          aa : [ 2, 3 ]
        }
      },
      tooltip : {
        id : "sap.viz.modules.tooltip",
        configure : {
        propertyCategory : 'tooltip',
          properties : {
            chartType : "radar",
            orientation : "left"
          }
        }
      },
      main : {
        id : 'sap.viz.modules.xycontainer',
        controllers : {
          interaction : {
            id : "sap.viz.modules.controller.interaction",
            configure : {
              propertyCategory : "interaction",
              properties : {
                supportedEventNames : [ "mousemove", "mouseup", "touchstart" ]
              }
            }
          }
        },
        modules : {
          plot: {
            id : 'sap.viz.modules.radar',
            configure : {
            'description': 'Settings regarding the chart area and plot area as well as general chart options.',
              propertyCategory : 'plotArea'
            }    
          }
        }
      }
    },
    dependencies : {
      attributes : [{
        targetModule : "legend",
        target : "colorPalette",
        sourceModule : "main.plot",
        source : "colorPalette"
      },  {
        targetModule : 'legend',
        target : 'shapes',
        sourceModule : 'main.plot',
        source : 'shapes'
      }, {
          targetModule : 'legend',
          target : 'setSelectionMode',
          sourceModule : 'main.interaction',
          source : 'getSelectionMode'
      } ],
      events : [{
        targetModule : "main.interaction",
        listener : "registerEvent",
        sourceModule : "main.plot",
        type : "initialized.interaction"
      },{
          targetModule : 'main.interaction',
          listener : 'highlightedByLegend',
          sourceModule : 'legend',
          type : 'highlightedByLegend'
      }, {
              targetModule : 'legend',
            listener : 'deselectLegend',
            sourceModule : 'main.interaction',
            type : 'deselectLegend'
      }, {
        targetModule : "tooltip",
        listener : "showTooltip",
        sourceModule : "main.plot",
        type : "showTooltip"
      }, {
        targetModule : "tooltip",
        listener : "hideTooltip",
        sourceModule : "main.plot",
        type : "hideTooltip"
      }]
    }
  };

  Manifest.register(chart);
});sap.riv.module(
{
  qname : 'sap.viz.load',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.manifests.RadarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.TagCloudChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.HeatMapChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.scatter.BubbleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.scatter.ScatterChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiScatterChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBubbleChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.ScatterMatrixChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiHorizontalLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualHorizontalLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.DonutChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.pie.PieChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPieChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDonutChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.PercentageStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.PercentageStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.StackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualPercentageStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualPercentageStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseVerticalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.BaseHorizontalChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalWaterfallChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.WaterfallChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualHorizontalLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualLineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.LineChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.CombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualCombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalCombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.DualHorizontalCombinationChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.VerticalBoxplotChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.xy.HorizontalBoxplotChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiRadarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPercentageStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiPercentageStackedVerticalBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualPercentageStackedBarChart',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifests.MultiDualPercentageStackedVerticalBarChart',
  version : '4.0.0'
}
],
function Setup() {
  return;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.VizAppDelegate',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.0'
}
],
function Setup(FuncUtils, ThemeManager) {
	/**
	 * The abstract application delegate class. Application delegate is used to
	 * plug in your specific application logic. The object is created by
	 * VizApplication automatically
	 * 
	 * @name sap.viz.mvc.VizAppDelegate
	 * @constructor
	 */
	var VizAppDelegate = function() {
		this._publicMethodsRegistry = {};
		//this._theme = ThemeManager.defaultTheme();
		this._application;
	};

	var vp = VizAppDelegate.prototype;

	vp._afterLaunched = function(application, launchOption) {
		this._application = application;
		this.appDidFinishLaunching(application, launchOption);
		var rootController = this.rootController();
		rootController._setApplication_(this._application);
		this._application._setRootController(rootController);
	};

	/**
	 * This method will be called after the application fully launched, the
	 * Application will pass launchOption (if any) to this method. Any
	 * application specific initialization should be put here, e.g. initialize
	 * necessary data structure.
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#appDidFinishLaunching
	 * @function
	 * @param {Object}
	 *            launchOption the launchOption which is passed in
	 *            VizApplication constructor
	 */
	vp.appDidFinishLaunching = FuncUtils.noop;

	/**
	 * Subclass <b>MUST</b> implement this method to return the root controller
	 * of the application
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#rootController
	 * @return {sap.viz.mvc.UIController}
	 */
	vp.rootController = FuncUtils.unimplemented;

	/**
	 * This method is used to register any method specific to the current
	 * visualization implementation, and exposed to the consumer. This method is
	 * expected to be called during initialization phase, like in
	 * appDidFinishLaunching. The 'this' object of the function during invoking
	 * will be pointing to delegate object.
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#registerPublicMethod
	 * @param {String}
	 *            methodName the name of the method to be exposed
	 * @param {Function}
	 *            func the function of the method.
	 */
	vp.registerPublicMethod = function(methodName, func) {
		this._publicMethodsRegistry[methodName] = func;
	};

	vp._invokePublicMethod = function(publicMethodName, options) {
		if (this._publicMethodsRegistry.hasOwnProperty(publicMethodName)) {
			this._publicMethodsRegistry[publicMethodName].call(this, options);
		}
	};

	vp._currentTheme = function() {
		return this._theme;
	};

	vp._applyTheme = function(theme) {
		if (this._theme !== theme) {
			this.rootController().doThemeApplied(theme);
		}
	};

	vp._updateThemeSetting = function(theme, key, oldValue, newValue) {
		if (this._theme === theme) {
			this.rootController().doThemeUpdated(key, oldValue, newValue);
		}
	};
	/**
	 * Subclass should implement this method to return plain object contains all
	 * of the modifiable properties and their current value.
	 * 
	 * 
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#getProperties
	 * 
	 * @returns {Object} property bag
	 * 
	 */
	vp.getProperties = function() {
		return {};
	};

	/**
	 * Subclass should implement this method to accept a property bag.
	 * 
	 * 
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#updateProperties
	 * @param {Object}
	 *            propBag
	 * 
	 */
	vp.updateProperties = FuncUtils.noop;

	/**
	 * Subclass should implement this method to accept a dataset.
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#setDataset
	 * @param {Object}
	 */
	vp.setDataset = FuncUtils.noop;
	
	/**
     * Subclass should implement this method to get dataset.
     * 
     * @name sap.viz.mvc.VizAppDelegate#getDataset
     * 
     * @returns {Object} dataset
     */
    vp.getDataset = FuncUtils.noop;

	/**
	 * Subclass should implement this method to return a list of assets(only
	 * image supported) to be preload.
	 * 
	 * 
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#getPreloadAssets
	 * 
	 * @returns {[]} the item in the array should follow below structure
	 * 
	 * <pre>
	 * [ {
	 * 	id : 'IMAGE_ID',
	 * 	url : 'IMAGE_URL'
	 * } ]
	 * </pre>
	 */
	vp.getPreloadAssets = function() {
		return [];
	};
	/**
	 * Subclass should implement this method to return a list of supported
	 * events that could be listened by visualization user.
	 * 
	 * 
	 * 
	 * @name sap.viz.mvc.VizAppDelegate#getSupportedEvents
	 * 
	 * @returns {[]} the list of event names
	 * 
	 */
	vp.getSupportedEvents = function() {
		return [];
	};

	vp.getSupportedMethods = function() {
		var ret = [];
		for ( var p in this._publicMethodsRegistry) {
			ret.push(p);
		}
		return ret;
	};
	return VizAppDelegate;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(Observable, ObjectUtils, LinkedHashMap, FuncUtils) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}

	/**
	 * The mask used to specify the auto resizing behavior
	 * 
	 * @name sap.viz.mvc.UIComponent.Autosizing
	 * @class
	 */
	var ar = {
		/**
		 * Mark width & height is not flexible when its parent component's size
		 * changed
		 * 
		 * @field
		 * 
		 */
		None : 0,
		/**
		 * Mark the left margin is flexible
		 * 
		 * @field
		 */
		FlexibleLeftMargin : 1 << 0,
		/**
		 * Mark the width is flexible
		 * 
		 * @field
		 */
		FlexibleWidth : 1 << 1,
		/**
		 * Mark the right margin is flexible
		 * 
		 * @field
		 */
		FlexibleRightMargin : 1 << 2,
		/**
		 * Mark the top margin is flexible
		 * 
		 * @field
		 */
		FlexibleTopMargin : 1 << 3,
		/**
		 * Mark the height is flexible
		 * 
		 * @field
		 */
		FlexibleHeight : 1 << 4,
		/**
		 * Mark the bottom margin is flexible
		 * 
		 * @field
		 */
		FlexibleBottomMargin : 1 << 5
	};

	var id = 0;
	var nextId = function() {
		return id++;
	};

	/**
	 * This class defines UI component which serves as the super class of every
	 * controls
	 * 
	 * @name sap.viz.mvc.UIComponent
	 * @class
	 * @augments sap.viz.base.utils.Observable
	 */
	var UIComponent = ObjectUtils
			.derive(
					Observable,
					/**
					 * @lends sap.viz.mvc.UIComponent
					 * 
					 */
					{
						events : [ 'widthChanged', 'heightChanged', 'sizeChanged', 'positionChanged', 'anchorChanged',
								'beforeShow', 'afterShow', 'beforeHide', 'afterHide', 'focusin', 'focusout', 'focus',
								'blur', 'mousedown', 'mouseup', 'mouseenter', 'mouseleave', 'mousemove', 'click',
								'dblclick', 'touchstart', 'touchmove', 'touchend', 'touchcancel' ],
						/**
						 * @constructs
						 * @param {Object}
						 *            options the options to initialize the UI
						 *            component
						 * @param {Boolean}
						 *            [options.hidden] whether the UI component
						 *            is hidden
						 * @param {Integer}
						 *            [options.autoresizingMask] the bitwise
						 *            combination of the autoresizing mask,
						 *            default is
						 *            {@link  sap.viz.mvc.UIComponent.Autosizing#None}
						 * @param {Object}
						 *            [options.anchor] the anchor point of the
						 *            UI component, default is
						 * 
						 * <pre>
						 * {
						 * 	x : 0.5,
						 * 	y : 0.5
						 * }
						 * </pre>
						 * 
						 * @param {Object}
						 *            [options.position] the position of the UI
						 *            component, default is
						 * 
						 * <pre>
						 * {
						 * 	x : 0,
						 * 	y : 0
						 * }
						 * </pre>
						 * 
						 * @param {Object}
						 *            [options.size] the size of the UI
						 *            component, default is
						 * 
						 * <pre>
						 * {
						 * 	w : 0,
						 * 	h : 0
						 * }
						 * </pre>
						 */
						constructor : function(options) {
							options = options || {};

							var _nextId = nextId();

							this._id = options.id ? options.id + '_' + _nextId : _nextId;

							this._attached = false;// a internal flag indicates
							// if the underlying div is
							// attached to DOM tree

							this._container = undefined;// DOM div container for
							// this ui component

							this._superComp = undefined;

							this._subComps = new LinkedHashMap();

							this._hidden = false;

							this._clipToBound = true;

							this._parentVisible = false;

							this._printable = true;

							this._autoresizeSubComponents = true;

							this._autoresizingMask = ar.None;

							this._gestureDetectors = [];

							this._bounds = {
								x : 0,
								y : 0,
								width : 1,
								height : 1
							};
							this._position = {
								x : 0,
								y : 0
							};
							this._anchorPoint = {
								x : 0.5,
								y : 0.5
							};
							this._init_(options);
						},

						_init_ : function(options) {
							this._container = $(document.createElement('div')).attr('id', this._id).css('position',
									'absolute').css({
								'font-size' : '10px',
								'box-sizing' : 'border-box',
								'-moz-box-sizing' : 'border-box',
								'-ms-box-sizing' : 'border-box',
								'-webkit-box-sizing' : 'border-box'
							}).data('selfComp', this);
							if (options.clipToBound === false) {
								this._container.css('overflow', 'visible');
								this._clipToBound = false;
							} else {
								this._container.css('overflow', 'hidden');
							}
							if (options.hidden === true) {
								this._container.css('display', 'none');
								this._hidden = true;
							}
							if (options.autoSizingMask != undefined) {
								this._autoresizingMask = options.autoSizingMask;
							}
							if (options.anchor) {
								this._anchorPoint.x = options.anchor.x;
								this._anchorPoint.y = options.anchor.y;
								delete options.anchor;
							}
							if (options.position) {
								this._position.x = options.position.x;
								this._position.y = options.position.y;

								this._container
										.css('left', this._position.x - this._anchorPoint.x * this._bounds.width);
								this._container
										.css('top', this._position.y - this._anchorPoint.y * this._bounds.height);
								delete options.position;
							}

							if (options.size) {
								this._bounds.width = options.size.w;
								this._bounds.height = options.size.h;
								this._container.width(this._bounds.width);
								this._container.height(this._bounds.height);
								delete options.size;
							}

							this._registerMandatoryHandler();

						},

						_registerMandatoryHandler : function() {
							this.on([ {
								eventName : 'sizeChanged',
								listener : this._updateContainerSize,
								scope : this
							}, {
								eventName : 'heightChanged',
								listener : this._updateContainerHeight,
								scope : this
							}, {
								eventName : 'widthChanged',
								listener : this._updateContainerWidth,
								scope : this
							}, {
								eventName : 'positionChanged',
								listener : this._updateContainerPos,
								scope : this
							}, {
								eventName : 'anchorChanged',
								listener : this._updateContainerAnchor,
								scope : this
							} ]);
						},

						_updateContainerSize : function(os, ns) {
							this._container.width(ns.width);
							this._container.height(ns.height);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('left', this._position.x - this._anchorPoint.x * ns.width);
								this._container.css('top', this._position.y - this._anchorPoint.y * ns.height);
							}
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerWidth : function(ow, nw) {
							this._container.width(nw);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('left', this._position.x - this._anchorPoint.x * nw);
							}
							var os = {
								height : this._bounds.height,
								width : ow
							}, ns = {
								height : this._bounds.height,
								width : nw
							};
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerHeight : function(oh, nh) {
							this._container.height(nh);
							if (this._anchorPoint.x !== 0 || this._anchorPoint.y !== 0) {
								this._container.css('top', this._position.y - this._anchorPoint.y * nh);
							}
							var os = {
								height : oh,
								width : this._bounds.width
							}, ns = {
								height : nh,
								width : this._bounds.width
							};
							this.doContentResize(os, ns);
							this._layout(os, ns);
						},

						_updateContainerPos : function(op, np) {
							this._container.css('left', np.x - this._anchorPoint.x * this._bounds.width);
							this._container.css('top', np.y - this._anchorPoint.y * this._bounds.height);
						},

						_updateContainerAnchor : function(oap, nap) {
							this._container.css('left', this._position.x - nap.x * this._bounds.width);
							this._container.css('top', this._position.y - nap.y * this._bounds.height);
						},

						_markAttached_ : function() {
							this._attached = true;
							var subCompItr = this._subComps.getIterator();
							while (subCompItr.hasMore()) {
								subCompItr.next().value._markAttached_();
							}
							this._handleSubCompShow(this);
						},

						_markDetached_ : function() {
							this._attached = false;
							var subCompItr = this._subComps.getIterator();
							while (subCompItr.hasMore()) {
								subCompItr.next().value._markDetached_();
							}
						},

						/**
						 * Get the id of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#id
						 * @function
						 * @returns {String} the unique id of the component
						 */
						id : function() {
							return this._id;
						},
						/**
						 * Mark the component as hidden, if the component is
						 * already marked as hidden, nothing will happen;
						 * Whether the component will be shown and whether the
						 * events <b>beforeHide</b>, <b>afterHide</b> and the
						 * call-back methods <b>doBeforeHide</b>,
						 * <b>doAfterHide</b> will get triggered depend on
						 * whether two more conditions are true: 1, all of its
						 * ancestors are marked as shown. 2, the component is
						 * currently attached to DOM.
						 * 
						 * @name sap.viz.mvc.UIComponent#markHide
						 * @function
						 * @returns {this}
						 */
						markHide : function() {
							if (this._hidden === false) {
								if (this._attached && this._parentVisible) {
									this.doBeforeHide();
									this.fireEvent('beforeHide');
								}
								this._hidden = true;
								this._container.css('display', 'none');
								if (this._attached && this._parentVisible) {
									this.doAfterHide();
									this.fireEvent('afterHide');
									var subCompItr = this._subComps.getIterator();
									while (subCompItr.hasMore()) {
										this._handleSubCompHide(subCompItr.next().value);
									}
								}
							}
							return this;
						},

						_handleSubCompHide : function(comp) {
							if (comp._parentVisible && !comp._hidden) {
								comp.doBeforeHide();
								comp.fireEvent('beforeHide');
								comp.doAfterHide();
								comp.fireEvent('afterHide');
							}
							// mark all the descendant components's
							// parentVisible as false.
							comp._parentVisible = false;
							var subCompItr = comp._subComps.getIterator();
							while (subCompItr.hasMore()) {
								comp._handleSubCompHide(subCompItr.next().value);
							}
						},

						/**
						 * Mark the component as shown, if the component is
						 * already marked as shown, nothing will happen; Whether
						 * the component will be shown and whether the events
						 * <b>beforeShow</b>, <b>afterShow</b> and the
						 * call-back methods <b>doBeforeShow</b>,
						 * <b>doAfterShow</b> will get triggered depend on
						 * whether two more conditions are true: 1, all of its
						 * ancestors are marked as shown. 2, the component is
						 * currently attached to DOM.
						 * 
						 * @name sap.viz.mvc.UIComponent#markShow
						 * @function
						 * @returns {this}
						 */
						markShow : function() {
							if (this._hidden === true) {
								if (this._attached && this._parentVisible) {
									this.doBeforeShow();
									this.fireEvent('beforeShow');
								}
								this._hidden = false;
								this._container.css('display', 'block');
								if (this._attached && this._parentVisible) {
									this.doAfterShow();
									this.fireEvent('afterShow');
									var subCompItr = this._subComps.getIterator();
									while (subCompItr.hasMore()) {
										this._handleSubCompShow(subCompItr.next().value);
									}
								}
							}
							return this;
						},

						_handleSubCompShow : function(comp) {
							// whether parent is visible
							var superComp = comp.superComponent();
							comp._parentVisible = !superComp._hidden && superComp._parentVisible;
							if (comp._parentVisible && !comp._hidden) {
								// whether needs to show
								comp.doBeforeShow();
								comp.fireEvent('beforeShow');
								comp.doAfterShow();
								comp.fireEvent('afterShow');
							}
							var subCompItr = comp._subComps.getIterator();
							while (subCompItr.hasMore()) {
								comp._handleSubCompShow(subCompItr.next().value);
							}
						},

						clipToBound : function(clipToBound) {
							if (clipToBound !== undefined) {
								if (this._clipToBound !== clipToBound) {
									this._clipToBound = clipToBound;
									if (this._clipToBound) {
										this._container.css('overflow', 'hidden');
									} else {
										this._container.css('overflow', 'visible');
									}
								}
								return this;
							} else {
								return this._clipToBound;
							}
						},

						/**
						 * Get the current visibility of the component, the
						 * visibility is affected by the component's
						 * hidden/shown status, whether it's attached to DOM,
						 * whether it's ancestor components are shown.
						 * 
						 * 
						 * @name sap.viz.mvc.UIComponent#visibility
						 * @function
						 * @returns {Boolean}
						 */
						visibility : function() {
							return !this._hidden && this._attached && this._parentVisible;
						},

						/**
						 * Get and set the printable property of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#printable
						 * @function
						 * @param {undefined|Boolean}
						 *            printable
						 * @returns {this|Boolean}
						 */
						printable : function(printable) {
							if (printable !== undefined) {
								if (this._printable !== printable) {
									this._printable = printable;
								}
								return this;
							} else {
								return this._printable;
							}
						},

						/**
						 * Get and set whether the component should resize
						 * automatically when its parent's size changed
						 * 
						 * @name sap.viz.mvc.UIComponent#printable
						 * @function
						 * @param {undefined|Boolean}
						 *            autoresize
						 * @returns {this|Boolean}
						 */
						autoresizeSubComponents : function(autoresize) {
							if (autoresize !== undefined) {
								if (this._autoresizeSubComponents !== autoresize) {
									this._autoresizeSubComponents = autoresize;
								}
								return this;
							} else {
								return this._autoresizeSubComponents;
							}
						},

						/**
						 * Get and set the autoresizing mask of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#autoresizingMask
						 * @function
						 * @param {undefined|Integer}
						 *            mask
						 * @returns {this|Integer}
						 */
						autoresizingMask : function(mask) {
							if (mask !== undefined) {
								if (this._autoresizingMask !== mask) {
									this._autoresizingMask = mask;
								}
								return this;
							} else {
								return this._autoresizingMask;
							}
						},
						/**
						 * Get and set the bounds of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#bounds
						 * @function
						 * @param {undefined|Object}
						 *            bounds the new bounds of the component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 *      width : ##,
						 *      height : ##
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						bounds : function(bounds) {
							if (bounds) {
								var ob = this._bounds, nb = bounds;
								this._bounds.x = nb.x;
								this._bounds.y = nb.y;
								if (ob.width !== nb.width || ob.height !== nb.height) {
									var os = {
										width : ob.width,
										height : ob.height
									};
									var ns = {
										width : nb.width,
										height : nb.height
									};
									this._bounds.width = nb.width;
									this._bounds.height = nb.height;
									this.fireEvent('sizeChanged', os, ns);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._bounds);
							}
						},
						/**
						 * Get the position of the component, the position is in
						 * Page coordinate system
						 * 
						 * @name sap.viz.mvc.UIComponent#pagePosition
						 * @function
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {Object}
						 */
						pagePosition : function() {
							var offset = this._container.offset();
							return {
								x : offset.left,
								y : offset.top
							};
						},
						/**
						 * Get and set the position of the component, the
						 * position is in it's direct super component's
						 * coordinate system
						 * 
						 * @name sap.viz.mvc.UIComponent#position
						 * @function
						 * @param {undefined|Object}
						 *            position the new position of the
						 *            component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						position : function(position) {
							if (position) {
								var op = this._position, np = position;
								if (op.x !== np.x || op.y !== np.y) {
									var o = {
										x : op.x,
										y : op.y
									};
									var n = {
										x : np.x,
										y : np.y
									};
									op.x = np.x;
									op.y = np.y;
									this.fireEvent('positionChanged', o, n);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._position);
							}
						},
						/**
						 * Get and set the size of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#size
						 * @function
						 * @param {undefined|Object}
						 *            size the new size of the component:
						 * 
						 * <pre>
						 * {
						 *      width : ##,
						 *      height : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object}
						 */
						size : function(size) {
							if (size) {
								var os = {
									width : this._bounds.width,
									height : this._bounds.height
								};
								if (os.width !== size.width || os.height !== size.height) {
									this._bounds.width = size.width;
									this._bounds.height = size.height;
									this.fireEvent('sizeChanged', os, size);
								}
								return this;
							} else {
								return {
									width : this._bounds.width,
									height : this._bounds.height
								};
							}
						},
						/**
						 * Get and set the width of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#width
						 * @function
						 * @param {undefined|Number}
						 *            width the new width of the component:
						 * 
						 * 
						 * @returns {this|Number}
						 */
						width : function(width) {
							if (width) {
								var ow = this._bounds.width;
								if (ow !== width) {
									this._bounds.width = width;
									this.fireEvent('widthChanged', ow, width);
								}
								return this;
							} else {
								return this._bounds.width;
							}
						},
						/**
						 * Get and set the height of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#height
						 * @function
						 * @param {undefined|Number}
						 *            height the new height of the component:
						 * 
						 * 
						 * @returns {this|Number}
						 */
						height : function(height) {
							if (height) {
								var oh = this._bounds.height;
								if (oh !== height) {
									this._bounds.height = height;
									this.fireEvent('heightChanged', oh, height);
								}
								return this;
							} else {
								return this._bounds.height;
							}
						},
						/**
						 * Get and set the anchor of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#anchorPoint
						 * @function
						 * @param {undefined|Object}
						 *            anchorPoint the new anchor of the
						 *            component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						anchorPoint : function(anchorPoint) {
							if (anchorPoint) {
								var oap = this._anchorPoint, nap = anchorPoint;
								if (oap.x !== nap.x || oap.y !== nap.y) {
									var o = {
										x : oap.x,
										y : oap.y
									};
									var n = {
										x : nap.x,
										y : nap.y
									};
									oap.x = nap.x;
									oap.y = nap.y;
									this.fireEvent('anchorChanged', o, n);
								}
								return this;
							} else {
								return ObjectUtils.extend({}, this._anchorPoint);

							}
						},
						/**
						 * Get and set the frame of the component
						 * 
						 * @name sap.viz.mvc.UIComponent#frame
						 * @function
						 * @param {undefined|Object}
						 *            rect the new frame of the component:
						 * 
						 * <pre>
						 * {
						 *      x : ##,
						 *      y : ##,
						 *      width : ##,
						 *      height : ##
						 * }
						 * </pre>
						 * 
						 * @returns {this|Object }
						 */
						frame : function(rect) {
							if (rect) {
								var ob = this._bounds, op = this._position;
								var npx = rect.x + rect.width * this._anchorPoint.x;
								var npy = rect.y + rect.height * this._anchorPoint.y;
								var posChanged = false, o = undefined, n = undefined, sizeChanged = false,os = {
										width : ob.width,
										height : ob.height
									};
									ns = {
										width : rect.width,
										height : rect.height
									};
								if (ob.width !== rect.width || ob.height !== rect.height) {
									ob.width = rect.width;
									ob.height = rect.height;
									sizeChanged = true;
								}
								if (op.x !== npx || op.y !== npy) {
									o = {
										x : op.x,
										y : op.y
									};
									n = {
										x : npx,
										y : npy
									};
									op.x = npx;
									op.y = npy;
									posChanged = true;
								}
								if (posChanged) {
									this.fireEvent('positionChanged', o, n);
								}
								if (sizeChanged || (os.width===5 && os.height===5)) {
									this.fireEvent('sizeChanged', os, ns);
								}
								return this;
							} else {
								return {
									x : this._position.x - this._anchorPoint.x * this._bounds.width,
									y : this._position.y - this._anchorPoint.y * this._bounds.height,
									width : this._bounds.width,
									height : this._bounds.height
								};
							}
						},
						/**
						 * Get the parent component
						 * 
						 * @name sap.viz.mvc.UIComponent#superComponent
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 * 
						 */
						superComponent : function() {
							return this._superComp;
						},
						/**
						 * Get the parent component
						 * 
						 * @name sap.viz.mvc.UIComponent#subComponents
						 * @function
						 * @param {sap.viz.base.utils.LinkedHashMap}
						 * 
						 */
						subComponents : function() {
							return this._subComps;
						},
						/**
						 * Add a component as a child component, the visibility
						 * related events and call-back methods will get
						 * triggered on the component tree rooted at the
						 * detached component, if the component in the tree is
						 * visible.
						 * 
						 * @name sap.viz.mvc.UIComponent#addSubComponent
						 * @function
						 * @param {this}
						 *            return this component
						 * @throws {ExistedParent}
						 */
						addSubComponent : function(subComp) {
							if (subComp) {
								if (subComp._superComp === undefined) {
									subComp._superComp = this;
									this._subComps.add(subComp.id(), subComp);
									this._container.append(subComp._container);
									if (this._attached) {
										subComp._markAttached_();
									}
									return this;
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Detach this component from its parent, the detached
						 * component is not destroyed and could be reattached
						 * later. the visibility related events and call-back
						 * methods will get triggered on the component tree
						 * rooted at the detached component, if the component in
						 * the tree is visible.
						 * 
						 * @name sap.viz.mvc.UIComponent#detachFromSuperComponent
						 * @function
						 */
						detachFromSuperComponent : function() {
							if (this._superComp) {
								if (this._superComp._attached) {
									this._superComp._handleSubCompHide(this);
									this._markDetached_();
								}
								this._superComp._subComps.remove(this.id());
								this._container.detach();
								this._superComp = undefined;
							}
						},
						/**
						 * Remove this component from its parent, the remove
						 * component is destroyed including its subcomponent,
						 * and should not intend for reuse.
						 * 
						 * @name sap.viz.mvc.UIComponent#detachFromSuperComponent
						 * @function
						 */
						removeFromSuperComponent : function() {
							if (this._superComp) {
								this._superComp._subComps.remove(this.id());
								this._container.remove();
								if (this._superComp._attached)
									this._markDetached_();
								this._superComp = undefined;

							}
						},
						/**
						 * Insert a component as a child component before other
						 * component, the visibility related events and
						 * call-back methods will get triggered on the component
						 * tree rooted at the detached component, if the
						 * component in the tree is visible.
						 * 
						 * @name sap.viz.mvc.UIComponent#insertBeforeSubComponent
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 *            subComp the component to insert
						 * @param {sap.viz.mvc.UIComponent}
						 *            beforeComp the component to be inserted
						 *            before
						 */
						insertBeforeSubComponent : function(subComp, beforeComp) {
							if (subComp && beforeComp) {
								if (subComp._superComp === undefined) {
									var newKey = subComp.id();
									var beforeKey = beforeComp.id();
									if (this._subComps.has(beforeKey) && newKey !== beforeKey) {
										subComp._superComp = this;
										this._subComps.insertBefore(newKey, subComp, beforeKey);
										subComp._container.before(beforeComp._container);
										if (this._attached) {
											subComp._markAttached_();
										}
									}
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Insert a component as a child component after other
						 * component, the visibility related events and
						 * call-back methods will get triggered on the component
						 * tree rooted at the detached component, if the
						 * component in the tree is visible.
						 * 
						 * @name sap.viz.mvc.UIComponent#insertAfterSubComponent
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 *            subComp the component to insert
						 * @param {sap.viz.mvc.UIComponent}
						 *            afterComp the component to be inserted
						 *            before
						 */
						insertAfterSubComponent : function(subComp, afterComp) {
							if (subComp && afterComp) {
								if (subComp._superComp === undefined) {
									var newKey = subComp.id();
									var afterKey = afterComp.id();
									if (this._subComps.has(afterKey) && newKey !== afterKey) {
										subComp._superComp = this;
										this._subComps.insertAfter(newKey, subComp, afterKey);
										subComp._container.after(afterComp._container);
										if (this._attached) {
											subComp._markAttached_();
										}
									}
								} else {
									throw new Error('The component already has a parent component');
								}
							}
						},
						/**
						 * Bring the sub component to the front of other sub
						 * components
						 * 
						 * @name sap.viz.mvc.UIComponent#bringToFront
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 *            subComp the sub component to move
						 */
						bringToFront : function(subComp) {
							if (subComp && this._subComps.has(subComp.id())
									&& this._subComps.getLastInsert().id() !== subComp.id()) {
								this._subComps.moveToLast(subComp.id());
								subComp._container.detach();
								this._container.append(subComp._container);
							}
						},
						/**
						 * Send the sub component to the back of other sub
						 * component
						 * 
						 * @name sap.viz.mvc.UIComponent#sendToBack
						 * @function
						 * @param {sap.viz.mvc.UIComponent}
						 *            subComp the sub component to move
						 */
						sendToBack : function(subComp) {
							if (subComp && this._subComps.has(subComp.id())
									&& this._subComps.getFirstInsert().id() !== subComp.id()) {
								this._subComps.moveToFirst(subComp.id());
								subComp._container.detach();
								this._container.prepend(subComp._container);
							}
						},

						/**
						 * Convert the point in parent's coordinate system to
						 * local point
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointFromSuper
						 * @function
						 * @param {Object}
						 *            pointInSuper
						 * @returns {Object}
						 */
						convertPointFromSuper : function(pointInSuper) {
							var frame = this.frame();
							return {
								x : pointInSuper.x - frame.x,
								y : pointInSuper.y - frame.y
							};
						},
						/**
						 * Convert the point to point in parent's coordinate
						 * system
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointToSuper
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @returns {Object}
						 */
						convertPointToSuper : function(pointInLocal) {
							var frame = this.frame();
							return {
								x : pointInLocal.x + frame.x,
								y : pointInLocal.y + frame.y
							};
						},
						/**
						 * Convert the point in global coordinate system to
						 * local point
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointFromGlobal
						 * @function
						 * @param {Object}
						 *            globalPoint
						 * @returns {Object}
						 */
						convertPointFromGlobal : function(globalPoint) {
							var path = [ this ];
							var currentLevel = this;
							var pointInProgress = globalPoint;
							while (currentLevel._superComp) {
								path.push(currentLevel._superComp);
								currentLevel = currentLevel._superComp;
							}
							while (path.length) {
								currentLevel = path.pop();
								pointInProgress = currentLevel.convertPointFromSuper(pointInProgress);
							}
							return pointInProgress;
						},

						/**
						 * Convert the point to point in global coordinate
						 * system
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointToGlobal
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @returns {Object}
						 */
						convertPointToGlobal : function(pointInLocal) {
							var currentLevel = this;
							var pointInProgress = pointInLocal;
							while (currentLevel) {
								pointInProgress = currentLevel.convertPointToSuper(pointInProgress);
								currentLevel = currentLevel._superComp;
							}
							return pointInProgress;
						},

						/**
						 * Convert the point in source component's coordinate
						 * system to local coordinate system. Two components
						 * should rooted at same component.
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointFromComp
						 * @function
						 * @param {Object}
						 *            pointInSourceComp
						 * @param {sap.viz.mvc.UIComponent}
						 *            sourceComp
						 * @returns {Object}
						 */
						convertPointFromComp : function(pointInSourceComp, sourceComp) {
							return this.convertPointFromGlobal(sourceComp.convertPointToGlobal(pointInSourceComp));
						},

						/**
						 * Convert the point in local coordinate system to
						 * target Component's coordinate system. Two components
						 * should rooted at same component.
						 * 
						 * @name sap.viz.mvc.UIComponent#convertPointToComp
						 * @function
						 * @param {Object}
						 *            pointInLocal
						 * @param {sap.viz.mvc.UIComponent}
						 *            targetComp
						 * @returns {Object}
						 */
						convertPointToComp : function(pointInLocal, targetComp) {
							return targetComp.convertPointFromGlobal(this.convertPointToGlobal(pointInLocal));
						},

						_resizeSubComp : function(subComp, oldsize, newsize) {
							var origFrame = subComp.frame();
							var x = origFrame.x, y = origFrame.y, width = origFrame.width, height = origFrame.height;
							var ml = x, mr = oldsize.width - x - width, mt = y, mb = oldsize.height - y - height;
							var wdiff = newsize.width - oldsize.width, hdiff = newsize.height - oldsize.height;
							var arMask = subComp._autoresizingMask;
							var horizontalMask = ar.FlexibleLeftMargin | ar.FlexibleWidth | ar.FlexibleRightMargin;
							var verticalMask = ar.FlexibleTopMargin | ar.FlexibleHeight | ar.FlexibleBottomMargin;
							switch (arMask & horizontalMask) {
							case ar.None:
								if (ml !== 0) {
									x += wdiff * ml / (ml + mr);
								}
								break;
							case ar.FlexibleLeftMargin:
								x += wdiff;
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleRightMargin:
							case ar.FlexibleRightMargin:
								break;
							case ar.FlexibleWidth:
								width += wdiff;
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleWidth:
								if (width !== 0) {
									x += wdiff * ml / (ml + width);
									width += wdiff * width / (ml + width);
								}
								break;
							case ar.FlexibleRightMargin | ar.FlexibleWidth:
								if (width !== 0) {
									width += wdiff * width / (mr + width);
								}
								break;
							case ar.FlexibleLeftMargin | ar.FlexibleWidth | ar.FlexibleRightMargin:
								if (oldsize.width !== 0) {
									var r = wdiff / oldsize.width;
									x += x * r;
									width += width * r;
								}
								break;
							}
							switch (arMask & verticalMask) {
							case ar.None:
								if (mt !== 0) {
									y += hdiff * mt / (mt + mb);
								}
								break;
							case ar.FlexibleTopMargin:
								y += hdiff;
								break;
							case ar.FlexibleTopMargin | ar.FlexibleBottomMargin:
							case ar.FlexibleBottomMargin:
								break;
							case ar.FlexibleHeight:
								height += hdiff;
								break;
							case ar.FlexibleTopMargin | ar.FlexibleHeight:
								if (height !== 0) {
									y += hdiff * mt / (mt + height);
									height += hdiff * height / (mt + height);
								}
								break;
							case ar.FlexibleBottomMargin | ar.FlexibleHeight:
								if (height != 0) {
									height += hdiff * height / (mb + height);
								}
								break;
							case ar.FlexibleTopMargin | ar.FlexibleHeight | ar.FlexibleBottomMargin:
								if (oldsize.height) {
									var r = hdiff / oldsize.height;
									y += y * r;
									height += height * r;
								}
								break;
							}
							return {
								x : x,
								y : y,
								height : height,
								width : width
							};
						},

						_layout : function(oldsize, newsize) {
							if (this._autoresizeSubComponents) {
								var subCompItr = this._subComps.getIterator();
								var subComp, newFrame;
								while (subCompItr.hasMore()) {
									subComp = subCompItr.next().value;
									newFrame = this._resizeSubComp(subComp, oldsize, newsize);
									subComp.frame(newFrame);
								}
							} else if (this.doLayout != FuncUtils.noop && this.doLayout !== undefined) {
								this.doLayout();
							}
						},

						_fireEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								this._superComp._fireEvent_(event);
							}
						},

						_fireMouseEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								event._setCurrentLocalXY_({
									x : event.currentLocalXY().x + this._position.x - this._anchorPoint.x
											* this._bounds.width,
									y : event.currentLocalXY().y + this._position.y - this._anchorPoint.y
											* this._bounds.height
								});
								this._superComp._fireMouseEvent_(event);
							}
						},

						_fireTouchEvent_ : function(event) {
							this.fireEvent(event.type(), event);
							if (this._superComp && event.shouldBubble()) {
								event._setCurrentTarget_(this._superComp);
								this._superComp._fireTouchEvent_(event);
							}
						},

						/**
						 * Remove all listeners currently attached to the
						 * component
						 * 
						 * @name sap.viz.mvc.UIComponent#purgeListeners
						 * @function
						 */
						purgeListeners : function() {
							this.callParent('purgeListeners');
							this._registerMandatoryHandler();
						},
						/**
						 * Remove all listeners currently listening on the given
						 * event
						 * 
						 * @name sap.viz.mvc.UIComponent#removeAllListeners
						 * @function
						 * @param {String}
						 *            eventName
						 */
						removeAllListeners : function(eventName) {
							this.callParent('removeAllListeners', eventName);
							switch (eventName) {
							case 'sizeChanged':
								this.on({
									eventName : 'sizeChanged',
									listener : this._updateContainerSize,
									scope : this
								});
								break;
							case 'heightChanged':
								this.on({
									eventName : 'heightChanged',
									listener : this._updateContainerHeight,
									scope : this
								});
								break;
							case 'widthChanged':
								this.on({
									eventName : 'widthChanged',
									listener : this._updateContainerWidth,
									scope : this
								});
								break;
							case 'positionChanged':
								this.on({
									eventName : 'positionChanged',
									listener : this._updateContainerPos,
									scope : this
								});
								break;
							case 'anchorChanged':
								this.on({
									eventName : 'anchorChanged',
									listener : this._updateContainerAnchor,
									scope : this
								});
								break;
							}
						},
						/**
						 * Add a gesture detector to this component
						 * 
						 * @name sap.viz.mvc.UIComponent#addGestureDetector
						 * @function
						 * @param {sap.viz.mvc.GestureDetector}
						 *            detector
						 */
						addGestureDetector : function(detector) {
							if (detector !== undefined) {
								detector._setOwnerComp_(this);
								this._gestureDetectors.push(detector);
							}
						},
						/**
						 * remove a previously added gesture detector to this
						 * component
						 * 
						 * @name sap.viz.mvc.UIComponent#addGestureDetector
						 * @function
						 * @param {sap.viz.mvc.GestureDetector}
						 *            detector
						 */
						removeGestureDetector : function(detector) {
							for ( var i = 0, len = this._gestureDetectors.length; i < len; i++) {
								if (this._gestureDetectors[i] === detector) {
									this._gestureDetectors.splice(i, 1);
									detector._setOwnerComp_(undefined);
									len--;
								}
							}
						},

						/**
						 * Returns the farthest descendant uicomponent in the
						 * hierarchy rooted at this component, that contains the
						 * specified point.
						 * 
						 * @name sap.viz.mvc.UIComponent#hitTest
						 * @param {POINT}
						 *            localXY
						 * @returns {sap.viz.mvc.UIComponent#}
						 */
						hitTest : function(localXY) {
							var pStack = [ {
								comp : this,
								pointInLocal : localXY,
								subCompsItr : this._subComps.getIterator(true)
							} ];
							var levelInTest, localPoint, comp, subCompsItr;
							while (pStack.length) {
								levelInTest = pStack[pStack.length - 1];
								comp = levelInTest.comp;
								localPoint = levelInTest.pointInLocal;
								subCompsItr = levelInTest.subCompsItr;
								if (comp.visibility()) {
									if (subCompsItr.hasMore()) {
										var subComp = subCompsItr.next().value;
										pStack.push({
											comp : subComp,
											pointInLocal : subComp.convertPointFromSuper(localPoint),
											subCompsItr : subComp._subComps.getIterator(true)
										});
										continue;
									} else if (comp.containsPoint(localPoint)) {
										// find the top layer which contains the
										// point and can
										// respond to event
										return comp;
									}
									pStack.pop();
								} else {
									pStack.pop();
								}
							}
						},

						/**
						 * Test whether the given local point(point in local
						 * coordinate system) is contained in the component's
						 * boundary
						 * 
						 * @name sap.viz.mvc.UIComponent#containsPoint
						 * @function
						 * @param {Object}
						 *            localPoint the point to test
						 * @returns {Boolean}
						 */
						containsPoint : function(localPoint) {
							var bounds = this.bounds();
							return localPoint.x >= bounds.x && localPoint.x <= (bounds.x + bounds.width)
									&& localPoint.y >= bounds.y && localPoint.y <= (bounds.y + bounds.height);
						},

						printTo : function(drawingCtx) {
							drawingCtx.clearRect(0, 0, this._bounds.width, this._bounds.height);
							this.doPrint(drawingCtx);
						},

						/**
						 * Implement this method to do adhoc sub-components
						 * layout, this method will be called on super component
						 * when its size changed.
						 * 
						 * @name sap.viz.mvc.UIComponent#doLayout
						 * @function
						 */
						doLayout : FuncUtils.noop,

						/**
						 * Resize component's visual content, when the
						 * component's size changed, this method will be invoked
						 * before layout sub components
						 * 
						 * @name sap.viz.mvc.UIComponent#doContentResize
						 * @function
						 * @param {Object}
						 *            os the old size of the component
						 * @param {Object}
						 *            ns the new size of the component
						 */
						doContentResize : FuncUtils.noop,

						/**
						 * Print the component visual content into the passed-in
						 * drawing context
						 * 
						 * @name sap.viz.mvc.UIComponent#doPrint
						 * @function
						 * @param {sap.viz.graphic.DrawingContext}
						 */
						doPrint : FuncUtils.noop,

						/**
						 * This method will get called before the component
						 * becoming hidden
						 * 
						 * @name sap.viz.mvc.UIComponent#doBeforeHide
						 * @function
						 */
						doBeforeHide : FuncUtils.noop,
						/**
						 * This method will get called after the component is
						 * hided
						 * 
						 * @name sap.viz.mvc.UIComponent#doAfterHide
						 * @function
						 */
						doAfterHide : FuncUtils.noop,
						/**
						 * This method will get called before the component
						 * becoming visible
						 * 
						 * @name sap.viz.mvc.UIComponent#doBeforeShow
						 * @function
						 */
						doBeforeShow : FuncUtils.noop,
						/**
						 * This method will get called after the component is
						 * visible
						 * 
						 * @name sap.viz.mvc.UIComponent#doAfterShow
						 * @function
						 */
						doAfterShow : FuncUtils.noop
					});
	UIComponent.Autosizing = ar;
	return UIComponent;
});sap.riv.module(
{
  qname : 'sap.viz.base.Math',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
}
],
function Setup(UADetector) {
    var OptMath = {
        PI : Math.PI,
        E : Math.E,
        LN10 : Math.LN10,
        LN2 : Math.LN2,
        LOG2E : Math.LOG2E,
        LOG10E : Math.LOG10E,
        SQRT1_2 : Math.SQRT1_2,
        SQRT2 : Math.SQRT2,

        abs : (function() {
            if(UADetector.isSafari() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)) {
                return function(n) {
                    return n < 0 ? -n : n;
                };
            } else {
                return Math.abs;
            }
        })(),

        acos : (function() {
            return Math.acos;
        })(),

        asin : (function() {
            return Math.asin;
        })(),

        atan : (function() {
            return Math.atan;
        })(),

        atan2 : (function() {
            return Math.atan2;
        })(),

        /**
         * Get the ceil of a number.
         *
         * @name sap.viz.base.Math#ceil
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the ceil of number
         */
        ceil : (function() {
            // if (UADetector.isFirefox()) {
            // return function(n) {
            // var i = n | 0;
            // return n <= 0 ? i : (i == n ? i : i + 1);
            // };
            // }
            // else if (UADetector.isChrome()) {
            // return function(n) {
            // return n <= 0 ? n | 0 : Math.ceil(n);
            // };
            // }
            // else {
            return Math.ceil;
            // }
        })(),

        cos : (function() {
            return Math.cos;
        })(),

        exp : (function() {
            return Math.exp;
        })(),

        /**
         * Get the floor of a number.
         *
         * @name sap.viz.base.Math#floor
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the floor of number
         */
        floor : (function() {
            // if(UADetector.isFirefox()) {
            // return function(n) {
            // var a = n | 0;
            // return n < 0 ? (a == n ? a : a - 1) : a;
            // };
            // } else
            return Math.floor;
        })(),

        log : (function() {
            return Math.log;
        })(),

        /**
         * Get the maximum number in an array.
         *
         * @name sap.viz.base.Math#max
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the maximum number in array
         */
        max : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.max;
            // } else
                // return function() {
                    // var max = arguments[0];
                    // var length = arguments.length;
                    // for(var i = 1; i < length; i++) {
                        // max = arguments[i] > max ? arguments[i] : max;
                    // }
                    // return max;
                // };
        })(),

        /**
         * Get the minimum number in an array.
         *
         * @name sap.viz.base.Math#min
         * @function
         * @param {array}
         *            array must be an array of Number
         * @returns {Number} the minimum number in array
         */
        min : (function() {
            // if(UADetector.isIE() && parseFloat(UADetector.version()) < 9) {
                return Math.min;
			// }
			// else return function(){
		        // var min = arguments[0];
		        // var length = arguments.length;
				// for (var i=1; i<length; i++){
					// min = arguments[i] > min ? min : arguments[i];
				// }
				// return min;
            // };
        })(),

        pow : (function() {
            return Math.pow;
        })(),

        random : (function() {
            return Math.random;
        })(),

        /**
         * Get the round of a number.
         *
         * @name sap.viz.base.Math#round
         * @function
         * @param {n}
         *            n must not be NaN
         * @returns {Number} the round of number
         */
        round : (function() {
            return Math.round;
            //			if(UADetector.isFirefox() || (UADetector.isIE() && parseFloat(UADetector.version()) < 9)){
            //				return function(n) {
            //					return (n >= 0) ? (n + 0.5) | 0 : (n - 0.4999999999999999) | 0;
            //				};
            //			}
            //			else if(UADetector.isChrome()){
            //				return function(n) {
            //					return Math.floor(n + 0.5);
            //				};
            //			}
            //			else return Math.round;
        })(),

        sin : (function() {
            return Math.sin;
        })(),

        sqrt : (function() {
            return Math.sqrt;
        })(),

        tan : (function() {
            return Math.tan;
        })()
    };
    return OptMath;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.Event',
  version : '4.0.0'},
[

],
function Setup() {
	/**
	 * Event class
	 * 
	 * @name sap.viz.mvc.Event
	 * @constructor
	 */
	var Event = function(type, target, canBubbling) {
		this._type = type;
		this._target = this._currentTarget = target;
		this._canBubbling = canBubbling !== undefined ? canBubbling : true;
		this._timestamp = +new Date;
	};

	var Ep = Event.prototype;

	Ep._setCurrentTarget_ = function(currentTarget) {
		this._currentTarget = currentTarget;
	};

	/**
	 * Get the type of the event
	 * 
	 * @name sap.viz.mvc.Event#type
	 * @function
	 * @returns {String}
	 */
	Ep.type = function() {
		return this._type;
	};

	/**
	 * Get the timestamp of the event
	 * 
	 * @name sap.viz.mvc.Event#timestamp
	 * @function
	 * @returns {Integer}
	 */
	Ep.timestamp = function() {
		return this._timestamp;
	};

	/**
	 * Get the target component the event is originated from
	 * 
	 * @name sap.viz.mvc.Event#target
	 * @function
	 * @returns {sap.viz.mvc.UIComponent}
	 */
	Ep.target = function() {
		return this._target;
	};

	/**
	 * Get the current target component the event is currently going through it
	 * can be different with the target component
	 * 
	 * @name sap.viz.mvc.Event#currentTarget
	 * @function
	 * @returns {sap.viz.mvc.UIComponent}
	 */
	Ep.currentTarget = function() {
		return this._currentTarget;
	};

	/**
	 * Whether the event is in the bubbling phase
	 * 
	 * @name sap.viz.mvc.Event#isInBubbling
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.isInBubbling = function() {
		return this._target.id() != this._currentTarget.id();
	};
	/**
	 * Whether the event should be bubbled
	 * 
	 * @name sap.viz.mvc.Event#shouldBubble
	 * @function
	 * @returns {Boolean}
	 * 
	 */
	Ep.shouldBubble = function() {
		return this._canBubbling;
	};
	/**
	 * Stop the event propagation in the bubbling phase
	 * 
	 * @name sap.viz.mvc.Event#stopPropagation
	 * @function
	 * 
	 */
	Ep.stopPropagation = function() {
		this._canBubbling = false;
	};
	return Event;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.TouchEvent',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.Event',
  version : '4.0.0'
}
],
function Setup(FuncUtils, ObjectUtils, Event) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * Touch class
	 * 
	 * @name sap.viz.mvc.Touch
	 * @constructor
	 */
	var Touch = function(identifier, target, localXY, pageXY) {
		this._id = identifier;
		this._target = target;
		this._localXY = localXY;
		this._pageXY = pageXY;
	};
	var tp = Touch.prototype;
	/**
	 * Get the identifier of the touch
	 * 
	 * @name sap.viz.mvc.Touch#identifier
	 * @function
	 * @returns {Number}
	 */
	tp.identifier = function() {
		return this._id;
	};

	/**
	 * Get the target component of the touch
	 * 
	 * @name sap.viz.mvc.Touch#target
	 * @function
	 * @returns {sap.viz.mvc.UIComponent}
	 */
	tp.target = function() {
		return this._target;
	};

	/**
	 * Get the local XY of the touch in touch's target component's coordinate
	 * system
	 * 
	 * @name sap.viz.mvc.Touch#localXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	tp.localXY = function() {
		return {
			x : this._localXY.x,
			y : this._localXY.y
		};
	};

	/**
	 * Get the page XY of the touch in document's coordinate system
	 * 
	 * @name sap.viz.mvc.Touch#pageXY
	 * @function
	 * @returns {Object}
	 * 
	 * <pre>
	 * { x: ##, y: ##}
	 * </pre>
	 */
	tp.pageXY = function() {
		return {
			x : this._pageXY.x,
			y : this._pageXY.y
		};
	};
	/**
	 * Touch List class
	 * 
	 * @name sap.viz.mvc.TouchList
	 * @constructor
	 */
	var TouchList = function(tArray, tMap) {
		this.tA = tArray, this.tM = tMap;
	};

	var tlp = TouchList.prototype;
	/**
	 * Return the length of the list
	 * 
	 * @name sap.viz.mvc.TouchList#length
	 * @function
	 * @returns {Number}
	 * 
	 */
	tlp.length = function() {
		return this.tA.length;
	};
	/**
	 * Get the touch at specified index
	 * 
	 * @name sap.viz.mvc.TouchList#item
	 * @function
	 * @param {Number}
	 *            index
	 * @returns {sap.viz.mvc.Touch}
	 */
	tlp.item = function(index) {
		if (index >= 0 && (index < this.tA.length)) {
			return this.tA[index];
		}
	};
	/**
	 * Get the touch with specified identifier
	 * 
	 * @name sap.viz.mvc.TouchList#identifiedTouch
	 * @function
	 * @param {Number}
	 *            identifier
	 * @returns {sap.viz.mvc.Touch}
	 */
	tlp.identifiedTouch = function(identifier) {
		if (identifier) {
			return this.tM[identifier];
		}
	};
	/**
	 * This class defines Touch Event
	 * 
	 * @name sap.viz.mvc.TouchEvent
	 * @class
	 * @augments sap.viz.mvc.Event
	 */
	var TouchEvent = ObjectUtils.derive(Event,
	/**
	 * @lends sap.viz.mvc.TouchEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, touches, targetTouches, changedTouches) {
			this._relatedTarget = undefined;
			this._touches = touches;
			this._targetTouches = targetTouches;
			this._changedTouches = changedTouches;
		},

		/**
		 * Get the all touches on the screen.
		 * 
		 * @name sap.viz.mvc.TouchEvent#touches
		 * @function
		 * @returns {sap.viz.mvc.TouchList}
		 */
		touches : function() {
			return this._touches;
		},
		/**
		 * Get the touches initiated from the same target
		 * 
		 * @name sap.viz.mvc.TouchEvent#targetTouches
		 * @function
		 * @returns {sap.viz.mvc.TouchList}
		 */
		targetTouches : function() {
			return this._targetTouches;
		},
		/**
		 * Get the touches lead to the event
		 * 
		 * @name sap.viz.mvc.TouchEvent#changedTouches
		 * @function
		 * @returns {sap.viz.mvc.TouchList}
		 */
		changedTouches : function() {
			return this._changedTouches;
		}
	});
	var _buildTouchListFromTouchList = function(touchlist) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchlist.length; i < len; i++) {
			targetComp = _findTargetComp(touchlist.item(i));
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchlist.item(i), targetComp);
				tArray.push(touch);
				tMap[touch.identifier()] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _buildTouchListFromTouchArray = function(touchArray) {
		var tArray = [], tMap = {};
		for ( var i = 0, targetComp, touch, len = touchArray.length; i < len; i++) {
			targetComp = _findTargetComp(touchArray[i]);
			if (targetComp) {
				// We only consider the touches originated from RIV component
				touch = _buildTouch(touchArray[i], targetComp);
				tArray.push(touch);
				tMap[touch.identifier()] = touch;
			}
		}
		return new TouchList(tArray, tMap);
	};

	var _findTargetComp = function(touch) {
		var cnode = $(touch.target);
		while (cnode.length && !cnode.data('selfComp')) {
			cnode = cnode.parent();
		}
		return cnode.data('selfComp');
	};

	var _buildTouch = function(touch, targetComp) {
		var targetCompPagePosition = targetComp.pagePosition();
		var localXY = {
			x : touch.pageX - targetCompPagePosition.x,
			y : touch.pageY - targetCompPagePosition.y
		};
		// binding to UIComponent instead of Element
		return new Touch(touch.identifier, targetComp, localXY, {
			x : touch.pageX,
			y : touch.pageY
		});
	};
	TouchEvent.buildFrom3TouchArray = function(type, target, touches, changedTouches, targetTouches, canBubbling) {
		var _touches = _buildTouchListFromTouchArray(touches);
		var _targetTouches = _buildTouchListFromTouchArray(targetTouches);
		var _changedTouches = _buildTouchListFromTouchArray(changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	TouchEvent.buildFromDomTouchEvent = function(type, target, domTouchEvent, canBubbling) {
		var _touches = _buildTouchListFromTouchList(domTouchEvent.touches);
		var _targetTouches = _buildTouchListFromTouchList(domTouchEvent.targetTouches);
		var _changedTouches = _buildTouchListFromTouchList(domTouchEvent.changedTouches);
		return new TouchEvent(type, target, canBubbling, _touches, _targetTouches, _changedTouches);
	};
	return TouchEvent;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.MouseEvent',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.Event',
  version : '4.0.0'
}
],
function Setup(ObjectUtils, Event) {
	/**
	 * This class defines Mouse Event
	 * 
	 * @name sap.viz.mvc.MouseEvent
	 * @class
	 * @augments sap.viz.mvc.Event
	 */
	var MouseEvent = ObjectUtils.derive(Event,
	/**
	 * @lends sap.viz.mvc.MouseEvent
	 * 
	 */
	{
		constructor : function(type, target, canBubbling, localXY, pageXY) {
			this._relatedTarget = undefined;
			this._currentLocalXY = this._targetLocalXY = localXY;
			this._pageXY = pageXY;
		},

		_setCurrentLocalXY_ : function(currentLocalXY) {
			this._currentLocalXY = currentLocalXY;
		},

		_setRelatedTarget_ : function(relatedTarget) {
			this._relatedTarget = relatedTarget;
		},

		/**
		 * Get the XY according to target component's coordinates system
		 * 
		 * @name sap.viz.mvc.MouseEvent#targetLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		targetLocalXY : function() {
			return {
				x : this._targetLocalXY.x,
				y : this._targetLocalXY.y
			};
		},

		/**
		 * Get the XY according to current component's coordinates system
		 * 
		 * @name sap.viz.mvc.MouseEvent#currentLocalXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		currentLocalXY : function() {
			return {
				x : this._currentLocalXY.x,
				y : this._currentLocalXY.y
			};
		},
		/**
		 * Get the page XY of the event
		 * 
		 * @name sap.viz.mvc.MouseEvent#pageXY
		 * @function
		 * @returns {Object}
		 * 
		 * <pre>
		 * { x: ##, y: ##}
		 * </pre>
		 */
		pageXY : function() {
			return {
				x : this._pageXY.x,
				y : this._pageXY.y
			};
		}
	});
	return MouseEvent;
});sap.riv.module(
{
  qname : 'sap.viz.base.utils.DomWatcher',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.UADetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'
}
],
function Setup(UADetector, LinkedHashMap) {
    var watcherId = 0;
    var domId = 1;
    var nextWatcherId = function() {
        return watcherId++;
    };
    var nextDomId = function() {
        return domId++;
    };
    var isEmpty = function(obj) {
        for(var prop in obj) {
            if(obj.hasOwnProperty(prop))
                return false;
        }
        return true;
    };
    var css = function(dom, prop) {
        var val = null;
        if(window.getComputedStyle) {
            val = window.getComputedStyle(dom, null)[prop];
        } else if(dom.currentStyle) {
            val = dom.currentStyle[prop];
        }
        return val;
    };
    var domDataAccessor = function(key, value) {
        if(!this._data)
            this._data = {};
        if(arguments.length === 2) {
            this._data[key] = value;
        } else
            return this._data[key];
    };
    var domTasks = new LinkedHashMap();

    var eventHandler = function(e) {
    	var task;
        var dom = e.srcElement || e.target;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId)
            return;
        var domTaskIt = domTasks.get(domId).getIterator();
        while(domTaskIt.hasMore()) {
            task = domTaskIt.nextValue();
            task.checkChange();
        }
    };
    var addEventHandler = function(id) {
        var task = taskQueue.get(id);
        var dom = task.domElem;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId) {
            domId = nextDomId();
            domDataAccessor.call(dom, 'domId', domId);
            domTasks.add(domId, new LinkedHashMap());
        }
        domTasks.get(domId).add(task.id, task);
        if(!domDataAccessor.call(dom, 'eventHandler')) {
            if( typeof (dom.onpropertychange) == "object") {
                dom.attachEvent("onpropertychange", eventHandler);
            } else if(UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
                dom.addEventListener("DOMAttrModified", eventHandler);
            }
            domDataAccessor.call(dom, 'eventHandler', eventHandler);
        }
    };
    var removeFromEventHandler = function(task) {
        var dom = task.domElem;
        var domId = domDataAccessor.call(dom, 'domId');
        if(!domId)
            return;

        if(domTasks.get(domId).has(task.id))
            domTasks.get(domId).remove(task.id);

        if(domTasks.get(domId).isEmpty()) {
            var eventHandler = domDataAccessor.call(dom, 'eventHandler');
            if( typeof (dom.onpropertychange) == "object") {
                dom.detachEvent("onpropertychange", eventHandler);
            } else if(UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6) {
                dom.removeEventListener("DOMAttrModified", eventHandler);
            }
            domDataAccessor.call(dom, 'eventHandler', null);
        }
    };
    var scannerInstance = undefined;
    var taskQueue = new LinkedHashMap();
    var scanner = function() {
        var taskItr = taskQueue.getIterator();
        var task;
        while(taskItr.hasMore()) {
            task = taskItr.nextValue();
            task.checkChange();
        }
    };
    var addIntervalTask = function(task) {
        if(!scannerInstance)
            scannerInstance = setInterval(scanner, 100);
        if(!taskQueue.has(task.id))
            taskQueue.add(task.id, task);
    };
    var removeIntervalTask = function(id) {
        if(taskQueue.has(id)) {
            taskQueue.remove(id);
        }
        if(taskQueue.isEmpty()) {
            clearInterval(scannerInstance);
            scannerInstance = undefined;
        }
    };
    var hookChange = function(task) {
        var dom = task.domElem;
        if( typeof (dom.onpropertychange) == "object" || (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
            addEventHandler(task.id);
        } else {
            //for browsers not support dom attributes change event, add a iterval task to check properties changes.
            addIntervalTask(task);
        }
    };
    var __watcher = function(id) {
        var task = taskQueue.get(id);
        if(!task)
            return;
        var dom = task.domElem;
        if(!task.callback)
            return;

        var changed = false;
        var i = 0;
        var changedProps = [];
        for(var l = task.cssProps.length; i < l; i++) {
            var newVal = css(dom, task.cssProps[i]);
            if(task.lastestVals[i] != newVal) {
                task.lastestVals[i] = newVal;
                changed = true;
                changedProps.push(task.cssProps[i]);
            }
        }
        if(changed)
            //task.callback.call(caller, changedProps);
            task.callback(changedProps);
    };
    //var caller;
    var DomWatcher = {
        /**
         * watch a dom element on specific css properties, if change, excute callback func,
         * callback parameter is an array of changed properties
         *
         * @param dom element to watch
         * @param props css properties on element to watch, input as a string, properties should be seperated by comma ','
         * @param func function to execute on properties change, when calling DomWatcher.watch,
         *     ObjectUtils.proxy(func, this) is recommend for the callback function. i.e. DomWatcher.watch(dom,props, ObjectUtils.proxy(func, this));
         * @return generated watcher id
         */
        watch : function(dom, props, func) {
            //caller = this.watch.caller;
            var id = nextWatcherId();
            var checkChange = function() {
                __watcher(id);
            };
            var task = {
                id : id,
                domElem : dom,
                cssProps : props.split(","),
                lastestVals : [props.split(",").length],
                callback : func,
                checkChange : checkChange
            };

            for(var i = 0, len = task.cssProps.length; i < len; i++) {
                task.lastestVals[i] = css(dom, task.cssProps[i]);
            }
            if(!taskQueue.has(task.id))
                taskQueue.add(task.id, task);
            hookChange(task);
            return id;
        },
        unwatch : function(id) {
            var task = taskQueue.get(id);
            var dom = task.domElem;
            try {
                if( typeof (dom.onpropertychange) == "object" || (UADetector.isFirefox() && parseFloat(UADetector.version()) > 3.6)) {
                    removeFromEventHandler(task);
                } else
                    removeIntervalTask(task.id);
            }
            // ignore if element was already unbound
            catch (e) {
            }
        }
    };
    return (DomWatcher);
});sap.riv.module(
{
  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(FuncUtils) {
	/**
	 * The mask used to specify gesture detector's state
	 * 
	 * @name sap.viz.mvc.GestureDetector.TransitionState
	 * @class
	 */
	var ts = {
		/**
		 * Possible State. Gesture Detector is ready to detect gesture
		 * 
		 * @field
		 * 
		 */
		Possible : 0,
		/**
		 * Began State. Gesture Detector is ready to detect continuous gesture
		 * 
		 * @field
		 * 
		 */
		Began : 1,
		/**
		 * Began State. Gesture Detector is continuous to detect continuous
		 * gesture
		 * 
		 * @field
		 * 
		 */
		Changed : 2,
		/**
		 * Recognized State. Discrete Gesture is detected
		 * 
		 * @field
		 * 
		 */
		Recognized : 3,// Recognized == Ended
		/**
		 * Ended State. Continuous Gesture is detected
		 * 
		 * @field
		 * 
		 */
		Ended : 3,
		/**
		 * Ended State. Continuous Gesture is stop to detected
		 * 
		 * @field
		 * 
		 */
		Cancelled : 4,
		/**
		 * Ended State. Detector fails to detect in current touch sequence
		 * 
		 * @field
		 * 
		 */
		Failed : 5
	};

	/**
	 * The base abstract gesture detector class
	 * 
	 * @name sap.viz.mvc.GestureDetector
	 * @constructor
	 */
	var GestureDetector = function() {
		this._grOwnerComp;
		this._grEnabled = true;
		this._grTouchTotal = 0;
		this._grTouchTracker = {};
		this._grState = ts.Possible;
		this._grActions = [];
		this._grCancelTouches = true;
	};
	var grp = GestureDetector.prototype;

	grp._setOwnerComp_ = function(ownerComp) {
		this._grOwnerComp = ownerComp;
	};
	/**
	 * Get the attached UI component
	 * 
	 * @name sap.viz.mvc.GestureDetector#attachedComponent
	 * @function
	 * @returns {sap,riv.vizkit.UIComponent}
	 */
	grp.attachedComponent = function() {
		return this._grOwnerComp;
	};

	/**
	 * Add a gesture action function which will get triggered when gesture
	 * detected.
	 * 
	 * @name sap.viz.mvc.GestureDetector#addGestureAction
	 * @function
	 * @param {Function}
	 *            actionFn, function to be called when gesture detected.
	 * @returns {Boolean}
	 */
	grp.addGestureAction = function(actionFn) {
		var added = false;
		for ( var i = 0, len = this._grActions.length; i < len; i++) {
			if (this._grActions[i] === actionFn) {
				added = true;
				break;
			}
		}
		if (!added) {
			this._grActions.push(actionFn);
		}
		return !added;
	};

	/**
	 * Remove a previously added gesture action
	 * 
	 * @name sap.viz.mvc.GestureDetector#removeGestureAction
	 * @function
	 * @param {Function}
	 *            actionFn, the function to be removed.
	 * @returns {Boolean}
	 */
	grp.removeGestureAction = function(actionFn) {
		var found = false;
		for ( var i = 0, len = this._grActions.length; i < len; i++) {
			if (this._grActions[i] === actionFn) {
				found = true;
				this._grActions.splice(i, 1);
				break;
			}
		}
		return found;
	};

	/**
	 * Return the current global location of the gesture, the location is
	 * calculated as the center of the current touches. Caution: This function
	 * only return meaningful point value IF and ONLY IF the current state of
	 * this gesture detector is in Recognizing state, a.k.a Began, Changed,
	 * Cancelled, Ended, Recognized, otherwise undefined will return.
	 * 
	 * @function
	 * @returns {Object}
	 */
	grp.globalLocOfGesture = function() {
		var state = this.state();
		if (this._grEnabled
				&& (state === ts.Began || state === ts.Changed || state === ts.Cancelled || state === ts.Ended || state === ts.Recognized)) {
			var count = 0;
			var ttracker = this._grTouchTracker, xy;
			var x = y = 0;
			for ( var tId in ttracker) {
				xy = ttracker[tId].globalXY;
				x += xy.x;
				y += xy.y;
				count++;
			}
			if (count) {
				return {
					x : x / count,
					y : y / count
				};
			}
		} else {
			return;
		}
	};

	/**
	 * Return a list of identifier of touches currently involved in the gesture
	 * detection, Caution: This function only return meaningful array of touches
	 * IF and ONLY IF the current state of this gesture detector is in
	 * Recognizing state, a.k.a Began, Cancelled, Ended, Recognized, otherwise
	 * empty array will return.
	 * 
	 * @function
	 * @returns {Array}
	 */
	grp.involvedTouchePoints = function() {
		var ret = [];
		var state = this.state();
		if (this._grEnabled
				&& (state === ts.Began || state === ts.Cancelled || state === ts.Ended || state === ts.Recognized)) {
			var ttracker = this._grTouchTracker;
			for ( var tId in ttracker) {
				ret.push(tId);
			}
		}
		return ret;
	};

	/**
	 * Return the current global location of all the current touches, the
	 * location is calculated as the center of the touches currently contacting
	 * with the screen.
	 * 
	 * @function
	 * @returns {Object}
	 */
	grp.globalLocOfTouchPoints = function() {
		var count = 0;
		var ttracker = this._grTouchTracker, xy;
		var x = y = 0;
		for ( var tId in ttracker) {
			xy = ttracker[tId].globalXY;
			x += xy.x;
			y += xy.y;
			count++;
		}
		if (count) {
			return {
				x : x / count,
				y : y / count
			};
		}
	};

	/**
	 * Return the number of touches currently contacting with the screen
	 * 
	 * @function
	 * @returns {Number}
	 */
	grp.totalTouches = function() {
		return this._grTouchTotal;
	};

	/**
	 * Get or set whether canceling previous touches when a gesture detected.
	 * Default is yes.
	 * 
	 * @function
	 * @returns {Boolean|this}
	 */
	grp.cancelTouches = function(cancel) {
		if (cancel !== undefined) {
			this._grCancelTouches = cancel;
			return this;
		} else {
			return this._grCancelTouches;
		}
	};
	/**
	 * Get or set the enable status of the gesture detector. If the gesture
	 * detector is in detecting some continuous gesture it will immediately
	 * transit to cancelled state. Default is yes.
	 * 
	 * @function
	 * @returns {Boolean|this}
	 */
	grp.enable = function(enable) {
		if (enable !== undefined) {
			this._grEnabled = enable;
			if (!enable) {
				if (this._grState === ts.Began || this._grState === ts.Cancelled) {
					this.state(ts.Cancelled);
				} else {
					this.state(ts.Failed);
				}
			}
		} else {
			return this._grEnabled;
		}
	};

	grp.touchBegin = function(touchStartEvent) {
		var newTouches = touchStartEvent.changedTouches;
		var ttracker = this._grTouchTracker;
		var ownerComp = this._grOwnerComp;
		var pagePosition = ownerComp.pagePosition();
		for ( var i = 0, t, len = newTouches.length; i < len; i++) {
			t = newTouches.item(i);
			ttracker[t.identifier] = {
				globalXY : ownerComp.convertPointToGlobal({
					x : t.pageX - pagePosition.x,
					y : t.pageY - pagePosition.y
				})
			};
			this._grTouchTotal++;
		}
		if (this._grEnabled
				&& (this._grState === ts.Possible || this._grState === ts.Began || this._grState === ts.Changed)) {
			this.doTouchBegin(touchStartEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in moving phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#touchMove
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchMoveEvent
	 */
	grp.touchMove = function(touchMoveEvent) {
		if (this._grEnabled
				&& (this._grState === ts.Possible || this._grState === ts.Began || this._grState === ts.Changed)) {
			var movedTouches = touchMoveEvent.changedTouches;
			var ownerComp = this._grOwnerComp;
			var pagePosition = ownerComp.pagePosition();
			var ttracker = this._grTouchTracker;
			for ( var i = 0, t, len = movedTouches.length; i < len; i++) {
				t = movedTouches.item(i);
				if (ttracker[t.identifier]) {
					ttracker[t.identifier].globalXY = ownerComp.convertPointToGlobal({
						x : t.pageX - pagePosition.x,
						y : t.pageY - pagePosition.y
					});
				}
			}
			this.doTouchMove(touchMoveEvent);
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in ending phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#touchEnd
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchEndEvent
	 */
	grp.touchEnd = function(touchEndEvent) {
		var endedTouches = touchEndEvent.changedTouches;
		var ttracker = this._grTouchTracker;
		var ownerComp = this._grOwnerComp;
		var pagePosition = ownerComp.pagePosition();
		for ( var i = 0, t, tId, track, len = endedTouches.length; i < len; i++) {
			t = endedTouches.item(i);
			tId = t.identifier;
			track = ttracker[tId];
			if (track) {
				track.globalXY = ownerComp.convertPointToGlobal({
					x : t.pageX - pagePosition.x,
					y : t.pageY - pagePosition.y
				});
				this._grTouchTotal--;
			}
		}
		if (this._grEnabled
				&& (this._grState === ts.Possible || this._grState === ts.Began || this._grState === ts.Changed)) {
			this.doTouchEnd(touchEndEvent);
		}
		// Reset the detector only when all fingers lifted and in 'ending' state
		if (!this._grTouchTotal
				&& (this._grState === ts.Recognized || this._grState === ts.Failed || this._grState === ts.Cancelled)) {
			this.reset();
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in cancellation
	 * phase of a touch sequence. This method should be overridden in subclass.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#touchCancel
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchCancelEvent
	 */
	grp.touchCancel = function(touchCancelEvent) {
		var cancelledTouches = touchCancelEvent.changedTouches;
		var ttracker = this._grTouchTracker;
		var ownerComp = this._grOwnerComp;
		var pagePosition = ownerComp.pagePosition();
		for ( var i = 0, t, tId, track, len = cancelledTouches.length; i < len; i++) {
			t = cancelledTouches.item(i);
			tId = t.identifier;
			track = ttracker[tId];
			if (track) {
				track.globalXY = ownerComp.convertPointToGlobal({
					x : t.pageX - pagePosition.x,
					y : t.pageY - pagePosition.y
				});
				this._grTouchTotal--;
			}
		}
		if (this._grEnabled
				&& (this._grState === ts.Possible || this._grState === ts.Began || this._grState === ts.Changed)) {
			this.doTouchCancel(touchCancelEvent);
		}
		// Reset the detector only when all fingers lifted and in 'ending' state
		if (!this._grTouchTotal
				&& (this._grState === ts.Recognized || this._grState === ts.Failed || this._grState === ts.Cancelled)) {
			this.reset();
		}
	};
	/**
	 * Gesture Detector uses this method to receive touches in start phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#doTouchBegin
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchStartEvent
	 */
	grp.doTouchBegin = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in moving phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#doTouchMove
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchMoveEvent
	 */
	grp.doTouchMove = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in ending phase of a
	 * touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#doTouchEnd
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchEndEvent
	 */
	grp.doTouchEnd = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to receive touches in cancellation
	 * phase of a touch sequence. This method should be overridden in subclass.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#doTouchCancel
	 * @function
	 * @param {DOMTouchEvent}
	 *            touchCancelEvent
	 */
	grp.doTouchCancel = FuncUtils.noop;
	/**
	 * Gesture Detector uses this method to reset the internal state, before
	 * start to do next around recognition.
	 * <P>
	 * <b>Method of superclass must be called in first place when overriding</b>
	 * </p>
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#reset
	 * @function
	 */
	grp.reset = function() {
		this._grState = ts.Possible;
		// this._grTouchTotal = 0;
		this._grTouchTracker = {};
	};
	/**
	 * Get the current state of gesture detector
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#state
	 * @function
	 * @param {sap.viz.mvc.GestureDetector.TransitionState}
	 *            transState
	 */
	grp.state = function(transState) {
		return this._grState;
	};

	/**
	 * Gesture Detector uses this method to set it's state. Subclass should set
	 * correct state at right time, usually in
	 * doTouchBegin/doTouchMove/doTouchEnd/doTouchCancel method.
	 * 
	 * 
	 * @name sap.viz.mvc.GestureDetector#_state_
	 * @function
	 * @param {sap.viz.mvc.GestureDetector.TransitionState}
	 *            transState
	 */
	grp._setState_ = function(transState) {
		switch (transState) {
		case ts.Possible:
			break;
		case ts.Began:
			this._grState = ts.Began;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			break;
		case ts.Changed:
			if (this._grState === ts.Began) {
				this._grState = ts.Changed;
			}
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			break;
		case ts.Cancelled:
			this._grState = ts.Cancelled;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			// this.reset();
			break;
		case ts.Failed:
			this._grState = ts.Failed;
			// this.reset();
			break;
		case ts.Ended:
		case ts.Recognized:
			this._grState = transState;
			for ( var i = 0, grActions = this._grActions, len = grActions.length; i < len; i++) {
				grActions[i](this);
			}
			// this.reset();
			break;
		}
	};

	GestureDetector.TransitionState = ts;
	return GestureDetector;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.VizFrame',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.GestureDetector',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.DomWatcher',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.Event',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.MouseEvent',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.TouchEvent',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Math',
  version : '4.0.0'
}
],
function Setup(FunctionUtils, ObjectUtils, UIComponent, GestureDetector, DomWatcher, Event, MouseEvent, TouchEvent,
		Math) {
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	var isInDomtree = function(node) {
		var bodyNode = undefined;
		do {
			if (node.nodeName == 'BODY') {
				bodyNode = node;
				break;
			} else {
				node = node.parentNode;
			}
		} while (node)
		return bodyNode;
	};

	var setFrame = function(vframe) {
		// set offset according to parent postion property
		var holder = vframe._holder;
		if (holder.css('position') == "static" || holder.css('position') == "fix") {
			var position = holder.position();
			vframe.frame({
				x : position.left,
				y : position.top,
				width : holder.width(),
				height : holder.height()
			});
		} else {
			vframe.frame({
				x : 0,
				y : 0,
				width : holder.width(),
				height : holder.height()
			});
		}
	};
	// callback on css change
	var func = function(changedProps) {
		for ( var i = 0, len = changedProps.length; i < len; i++) {
			if (changedProps[i] === "position") {
				setFrame(this);
				break;
			}
		}
	};

	var getHittedComponent = function(event) {
		var domEntity = $(event.target);
		while (!domEntity.data('selfComp')) {
		  if (!domEntity.length)
		    break;
			domEntity = domEntity.parent();
		}
		return domEntity.data('selfComp');
	};

	var ts = GestureDetector.TransitionState;
	var VizFrame = ObjectUtils
			.derive(
					UIComponent,
					{
						constructor : function(options) {
							if (options.container) {
								this._holder = $(options.container);
								if (!isInDomtree(this._holder.get(0))) {
									FunctionUtils.error('The holder DIV must be a child of Body element.');
								}
								// VizFrame's logical parent is always visible
								if (this._holder.css('display') === 'none') {
									this.markHide();
								}
								this.clipToBound(false);
								this._regDOMEventHandlers();
								this._holder.append(this._container);
								this.anchorPoint({
									x : 0,
									y : 0
								});
								setFrame(this);
								// watch position changes
								DomWatcher.watch(this._holder.get(0), "position", ObjectUtils.proxy(func, this));
								this._parentVisible = true;
								this._attached = true;
								// structure for event dispatching
								this._msTracking = [];
								this._touchSeqTracking = {};

							} else {
								throw new Error('you have to provide a container for viz frame');
							}
						},

						_regDOMEventHandlers : function() {
							this._container.bind('click', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('dblclick', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focusin', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focusout', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('focus', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('blur', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mousedown', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseup', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseenter', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mouseleave', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('mousemove', ObjectUtils.proxy(this._handleDomEvent, this));
							// Below events are supposed to be fired when the
							// element is attached/detached to/from document,
							// it's used to register touch listener correctly in
							// iOS Mobile Safari.
							this._container.bind('DOMNodeInsertedIntoDocument', ObjectUtils.proxy(
									this._registerDOMTouchHandler, this));
							this._container.bind('DOMNodeRemovedFromDocument', ObjectUtils.proxy(
									this._unregisterDOMTouchHandler, this));
						},

						_registerDOMTouchHandler : function() {
							this._container.bind('touchstart', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchmove', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchend', ObjectUtils.proxy(this._handleDomEvent, this));
							this._container.bind('touchcancel', ObjectUtils.proxy(this._handleDomEvent, this));
						},

						_unregisterDOMTouchHandler : function() {
							this._container.unbind('touchstart');
							this._container.unbind('touchmove');
							this._container.unbind('touchend');
							this._container.unbind('touchcancel');
						},

						_handleDomEvent : function(event) {
							event.preventDefault();
							var hittedComp = getHittedComponent(event);
							switch (event.type) {
							case 'mousemove':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									var localPoint = {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									};
									if (this._msTracking.length) {
										if (this._msTracking[this._msTracking.length - 1] !== hittedComp) {
											var enteredComps = [];
											var entered = hittedComp;
											while (entered) {
												enteredComps.push(entered);
												entered = entered.superComponent();
											}
											var inCompCount = 0, checkFinished = false, minLen = Math.min(
													this._msTracking.length, enteredComps.length);
											while (true) {
												var left = undefined;
												if (!checkFinished
														&& this._msTracking[inCompCount] === enteredComps[enteredComps.length
																- 1 - inCompCount]) {
													inCompCount++;
													checkFinished = inCompCount === minLen;
												} else {
													while (this._msTracking.length > inCompCount) {
														left = this._msTracking.pop();
														var mlEvt = new MouseEvent('mouseleave', left, false, left
																.convertPointFromComp(localPoint, hittedComp), {
															x : event.pageX,
															y : event.pageY
														});
														mlEvt._setRelatedTarget_(hittedComp);
														left._fireMouseEvent_(mlEvt);
													}
													while (inCompCount < enteredComps.length) {
														var entered = enteredComps.shift();
														left = this._msTracking[enteredComps.length - 1];
														this._msTracking[enteredComps.length] = entered;
														var mlEvt = new MouseEvent('mouseenter', entered, false,
																entered.convertPointFromComp(localPoint, hittedComp), {
																	x : event.pageX,
																	y : event.pageY
																});
														mlEvt._setRelatedTarget_(left);
														entered._fireMouseEvent_(mlEvt);
													}
													break;
												}
											}
										}
									} else {
										var entered = hittedComp;
										do {
											this._msTracking.push(entered);
											entered._fireMouseEvent_(new MouseEvent('mouseenter', entered, false,
													localPoint, {
														x : event.pageX,
														y : event.pageY
													}));
											entered = entered.superComponent();
										} while (entered)
										this._msTracking.reverse();
									}
									hittedComp._fireMouseEvent_(new MouseEvent('mousemove', hittedComp, true,
											localPoint, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									while (this._msTracking.length) {
										var left = this._msTracking.pop();
										var framePagePosition = this.pagePosition();
										left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, {
											x : event.pageX - framePagePosition.x,
											y : event.pageY - framePagePosition.y
										}, {
											x : event.pageX,
											y : event.pageY
										}));
									}
								}
								break;
							case 'mouseleave':
								while (this._msTracking.length) {
									var left = this._msTracking.pop();
									var leftCompPageXY = left.pagePosition();
									left._fireMouseEvent_(new MouseEvent('mouseleave', left, false, {
										x : event.pageX - leftCompPageXY.x,
										y : event.pageY - leftCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'mouseup':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									hittedComp._fireMouseEvent_(new MouseEvent('mouseup', hittedComp, true, {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'mousedown':
								if (hittedComp) {
									var hittedCompPageXY = hittedComp.pagePosition();
									hittedComp._fireMouseEvent_(new MouseEvent('mousedown', hittedComp, true, {
										x : event.pageX - hittedCompPageXY.x,
										y : event.pageY - hittedCompPageXY.y
									}, {
										x : event.pageX,
										y : event.pageY
									}));
								}
								break;
							case 'dblclick':
								if (hittedComp) {
									if (this._focusedComp) {
										if (this._focusedComp.id() !== hittedComp.id()) {
											this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
											this._focusedComp._fireEvent_(new Event('focusout', this._focusedLayer,
													true));
											this._focusedComp = hittedComp;
											this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusin', this._focusedComp, true));
										}
									} else {
										this._focusedComp = hittedComp;
										this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusin', this._focusedComp, true));
									}
									var hittedCompPageXY = hittedComp.pagePosition();
									this._focusedComp._fireMouseEvent_(new MouseEvent('dblclick', this._focusedComp,
											true, {
												x : event.pageX - hittedCompPageXY.x,
												y : event.pageY - hittedCompPageXY.y
											}, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									if (this._focusedComp) {
										this._focusedComp._fireEvent_(new Event('blur', this._focusedLayer, false));
										this._focusedComp._fireEvent_(new Event('focusout', this._focusedLayer, true));
										this._focusedComp = undefined;
									}
								}
								break;
							case 'click':
								if (hittedComp) {
									if (this._focusedComp) {
										if (this._focusedComp.id() !== hittedComp.id()) {
											this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusout', this._focusedComp, true));
											this._focusedComp = hittedComp;
											this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
											this._focusedComp
													._fireEvent_(new Event('focusin', this._focusedComp, true));
										}
									} else {
										this._focusedComp = hittedComp;
										this._focusedComp._fireEvent_(new Event('focus', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusin', this._focusedComp, true));
									}
									var hittedCompPageXY = hittedComp.pagePosition();
									this._focusedComp._fireMouseEvent_(new MouseEvent('click', this._focusedComp, true,
											{
												x : event.pageX - hittedCompPageXY.x,
												y : event.pageY - hittedCompPageXY.y
											}, {
												x : event.pageX,
												y : event.pageY
											}));
								} else {
									if (this._focusedComp) {
										this._focusedComp._fireEvent_(new Event('blur', this._focusedComp, false));
										this._focusedComp._fireEvent_(new Event('focusout', this._focusedComp, true));
										this._focusedComp = undefined;
									}
								}
								break;
							case 'touchstart':
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									// 'false' means the touch hasn't been
									// marked
									// cancelled
									this._touchSeqTracking[touch.identifier] = false;
								}

								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								var touchEvent = TouchEvent.buildFromDomTouchEvent('touchstart', hittedComp,
										event.originalEvent);
								hittedComp._fireTouchEvent_(touchEvent);
								break;
							case 'touchmove':
								// Handle gesture Detection and fire touchmove
								// event when no gesture currently detected
								if (!this._handleGestureDetect(hittedComp, event.originalEvent)) {
									var touchEvent = TouchEvent.buildFromDomTouchEvent('touchmove', hittedComp,
											event.originalEvent);
									hittedComp._fireTouchEvent_(touchEvent);
								}
								break;
							case 'touchend':
								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								var uncancelledTouchesArray = [], cancelledTouchesArray = [], touchesArray = [], targetTouchesArray = [];
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									this._touchSeqTracking[touch.identifier] === true ? cancelledTouchesArray
											.push(touch) : uncancelledTouchesArray.push(touch);
									delete this._touchSeqTracking[touch.identifier];
								}

								if (uncancelledTouchesArray.length) {
									// Some touches are not cancelled, so we
									// have to split the event into two events,
									// one for cancelled touches, one for
									// uncancelled touches
									for ( var i = 0, touch, targetTouches = event.originalEvent.targetTouches, len = targetTouches.length; i < len; i++) {
										touch = targetTouches.item(i);
										targetTouchesArray.push(touch);
									}
									for ( var i = 0, touch, touches = event.originalEvent.touches, len = touches.length; i < len; i++) {
										touch = touches.item(i);
										touchesArray.push(touch);
									}
									var touchCancelEvent = TouchEvent.buildFrom3TouchArray('touchcancel', hittedComp,
											touchesArray, cancelledTouchesArray, targetTouchesArray);
									hittedComp._fireTouchEvent_(touchCancelEvent);
									var touchEndEvent = TouchEvent.buildFrom3TouchArray('touchend', hittedComp,
											touchesArray, uncancelledTouchesArray, targetTouchesArray);
									hittedComp._fireTouchEvent_(touchEndEvent);
								} else {
									// All ended touches are marked as cancelled
									var touchEvent = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
											event.originalEvent);
									hittedComp._fireTouchEvent_(touchEvent);
								}
								// Fire touch event
								break;

							case 'touchcancel':
								// Handle gesture Detection
								this._handleGestureDetect(hittedComp, event.originalEvent);
								for ( var i = 0, touch, changedTouches = event.originalEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									delete this._touchSeqTracking[touch.identifier];
								}
								var touchEvent = TouchEvent.buildFromDomTouchEvent('touchcancel', hittedComp,
										event.originalEvent);
								hittedComp._fireTouchEvent_(touchEvent);
								break;
							}
						},

						_handleGestureDetect : function(hittedComponent, origTouchEvent) {
							var grs = [];
							var thisLevel = hittedComponent;
							// find the gesture recognizers responsible for the
							// gesture detection of the component hierarchy
							while (!thisLevel._gestureDetectors.length && thisLevel._superComp) {
								thisLevel = thisLevel._superComp;
							}
							grs = thisLevel._gestureDetectors;
							var someGestureDetected = false, gestureDetected, needToCancelTouches = false;
							for ( var i = 0, state, gd, len = grs.length; i < len; i++) {
								gd = grs[i];
								switch (origTouchEvent.type) {
								case 'touchstart':
									gd.touchBegin(origTouchEvent);
									break;
								case 'touchmove':
									gd.touchMove(origTouchEvent);
									break;
								case 'touchend':
									gd.touchEnd(origTouchEvent);
									break;
								case 'touchcancel':
									gd.touchCancel(origTouchEvent);
									break;
								}
								state = gd.state();
								gestureDetected = (state === ts.Began) || (state === ts.Changed)
										|| (state === ts.Recognized);
								someGestureDetected = someGestureDetected || gestureDetected;
								needToCancelTouches = needToCancelTouches || (gestureDetected && gd.cancelTouches());
							}
							if (needToCancelTouches) {
								for ( var i = 0, touch, changedTouches = origTouchEvent.changedTouches, len = changedTouches.length; i < len; i++) {
									touch = changedTouches.item(i);
									// Mark all changed touch as cancelled
									this._touchSeqTracking[touch.identifier] = true;
								}
							}
							return someGestureDetected;
						},

						hidden : function(hidden) {
							hidden ? this._holder.hide() : this._holder.show();
							if (hidden) {
								this.markHide();
							} else {
								this.markShow();
							}
						}
					});
	return VizFrame;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.ImageManager',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.LinkedHashMap',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
function Setup(ObjUtils, LinkedHashMap, FuncUtils) {
	/**
	 * The image object
	 * 
	 * @name sap.viz.mvc.Image
	 * @constructor
	 */
	var img = function(htmlImageElement) {
		this._imgEl = htmlImageElement;
	};

	/**
	 * Return the underlying htmlImageElement
	 * 
	 * @name sap.viz.mvc.Image#getBitmap
	 * @function
	 * @returns {HtmlImageElement}
	 */
	img.prototype.getBitmap = function() {
		return this._imgEl;
	};

	/**
	 * Get or set the visual width of the image
	 * 
	 * @name sap.viz.mvc.Image#width
	 * @param {undefined|Number}
	 *            width the new width of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the width
	 */
	img.prototype.width = function(width) {
		if (width !== undefined) {
			this._imgEl.width = width;
			return this;
		}
		return this._imgEl.width;
	};

	/**
	 * Get or set the visual height of the image
	 * 
	 * @name sap.viz.mvc.Image#height
	 * @param {undefined|Number}
	 *            height the new height of the image
	 * @returns {this|Number} when in set mode the return will be the image
	 *          object itself; in get mode the return will be the height
	 */
	img.prototype.height = function(height) {
		if (height !== undefined) {
			this._imgEl.height = height;
			return this;
		}
		return this._imgEl.height;
	};

	/**
	 * Get the intrinsic height of the image
	 * 
	 * @name sap.viz.mvc.Image#intrinsicHeight
	 * @returns {Number}
	 */
	img.prototype.intrinsicHeight = function() {
		return this._imgEl.naturalHeight;
	};

	/**
	 * Get the intrinsic width of the image
	 * 
	 * @name sap.viz.mvc.Image#intrinsicWidth
	 * @returns {Number}
	 */
	img.prototype.intrinsicWidth = function() {
		return this._imgEl.naturalWidth;
	};

	/**
	 * Get the url of the image
	 * 
	 * @name sap.viz.mvc.Image#url
	 * @returns {String} the url of the image
	 */
	img.prototype.url = function() {
		return this._imgEl.src;
	};

	var _imageCache = new LinkedHashMap();
	var _id2src = new LinkedHashMap();
	var _src2ids = {};

	/**
	 * This class defines global shared image manager used for loading external
	 * image. The loading process is asynchronously. The loaded images are
	 * indentified by src urls internally, and can shared within the all viz
	 * application. You must assign an id when loading an image. You can
	 * retrieve the loaded image by id only. the same image can be assigned
	 * multiple ids.
	 * 
	 * @name sap.viz.mvc.ImageManager
	 * @class
	 */
	var ImageManager = {
		/**
		 * Load an image designated by URL. The loading is asynchronized, the
		 * image will be available when the onComplete is called
		 * 
		 * @param {String}
		 *            id the caller-provided Id of the image to be loaded and
		 *            retrieved later.
		 * @param {String}
		 *            url the url of the image to be loaded
		 * @param {Function}
		 *            [onComplete], the on complete callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImage : function(id, url, onComplete) {
			if (id && url) {
				onComplete = onComplete || FuncUtils.noop;
				if (_id2src.has(id)) {
					if (_imageCache.get(_id2src.get(url))) {
						onComplete(true);
					}
				}
				var imgEl = new Image();
				imgEl.onabort = imgEl.onerror = function() {
					onComplete(false, {
						id : id,
						url : url
					});
				};
				imgEl.onload = ObjUtils.proxy(function() {
					var src = imgEl.src;
					if (!_imageCache.has(src)) {
						var imgObj = new img(imgEl);
						_id2src.add(id, src);
						_src2ids[src] = {
							ids : {
								id : id
							},
							length : 1
						};
						_imageCache.add(src, imgObj);
					} else {
						_id2src.add(id, imgEl.src);
						_src2ids[src].ids[id] = id;
						_src2ids[src].length++;
					}
					onComplete(true, {
						id : id,
						url : url
					});
				}, this);
				imgEl.src = url;
			}
		},
		/**
		 * Load an array of images concurrently. The loading is asynchronized,
		 * the images will be available when the onComplete is called
		 * 
		 * @param {Object[]}
		 *            urls the array of the image url to be loaded. The urls
		 *            should follow the format:
		 * 
		 * <pre>
		 * [ {
		 * 	id : 'IMAGE_ID',
		 * 	url : 'IMAGE_URL'
		 * } ]
		 * </pre>
		 * 
		 * @param {Function}
		 *            [onComplete] the on-complete function callback. the single
		 *            argument is of type boolean indicating the if loaded
		 *            successful
		 */
		loadImages : function(urls, onProgress, onComplete) {
			onProgress = onProgress || FuncUtils.noop;
			onComplete = onComplete || FuncUtils.noop;
			var total = urls.length;
			if (total == 0) {
				onComplete(true);
			} else {
				var count = 0;
				var _stepFunction = function(isSuccessful, imgInfo) {
					count++;
					if (count < total) {
						onProgress(count / total, isSuccessful, imgInfo);
					} else {
						onComplete(true, imgInfo);
					}
				};
				for ( var i = 0, len = urls.length; i < len; i++) {
					ImageManager.loadImage(urls[i].id, urls[i].url, _stepFunction);
				}
			}
		},

		/**
		 * Check if the image has been loaded
		 * 
		 * @param {String}
		 *            id the id of the image to be checked
		 * @returns {Boolean}
		 */
		hasImage : function(id) {
			return _id2src.has(id);
		},

		/**
		 * Get the loaded image by its id, the caller has to ensure the image is
		 * loaded
		 * 
		 * @param {String}
		 *            id the id of the image to get
		 * @returns {sap.viz.mvc.Image}
		 */
		getImage : function(id) {
			if (_id2src.has(id)) {
				return _imageCache.get(_id2src.get(id));
			}
		},

		/**
		 * Remove the loaded image from internal cache
		 * 
		 * @param {String}
		 *            id the id of the image
		 */
		disposeImage : function(id) {
			if (_id2src.has(id)) {
				var src = _id2src.remove(id);
				delete _src2ids[src].ids[id];
				_src2ids[src].length--;
				if (_src2ids[src].length === 0) {
					delete _src2ids[src];
					_imageCache.remove(src);
				}
			}
		}
	};
	return ImageManager;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.VizApplication',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.Observable',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.ImageManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.VizFrame',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.Logger',
  version : '4.0.0'
}
],
function Setup(Observable, FuncUtils, ObjectUtils, ThemeManager, ImageManager, VizFrame, UIComponent, LOG) {

	var id = 0;
	function nextId() {
		return id++;
	}
	var Autosizing = UIComponent.Autosizing;
	var $ = jQuery;
	if (!$) {
		FuncUtils.error('Cannot find jQuery');
	}
	/**
	 * The main entry of a given visualization application. It implements most
	 * of the things that need to start a viz application, e.g. bootstrapping,
	 * preload images
	 * 
	 * @name sap.viz.mvc.VizApplication
	 * @constructor
	 * @param {Object}
	 *            options the options that needs to start the application
	 * @param {String}
	 *            options.wrapperDivEl the wrapper DIV element
	 * @param {Constructor}
	 *            options.delegateClass the constructor of your custom viz app
	 *            delegate
	 * @param {Object}
	 *            [launchOption] the additional option that will pass to the
	 *            {@link sap.viz.mvc.VizAppDelegate#appDidFinishLaunching}
	 */
	var VizApplication = function(options) {
		var _nextId = nextId();
		this._id = options.id ? options.id + '_' + _nextId : _nextId;
		LOG.debug("Chart Application[" + this._id + "] initializing.", "perf");
		if (!options.delegateClass) {
			FuncUtils.error('You have to specify a delegate for visualization custom behavior.');
		}
		if (!options.wrapperDivEl) {
			FuncUtils.error('You have to specify a div element for holding the visualization.');
		}
		this._vizFrame = new VizFrame({
			container : options.wrapperDivEl
		});
		//this._canvasForPrinting = CanvasHelper.createCanvasElement(1, 1);
		this._delegate = new options.delegateClass();
		var assets = this._delegate.getPreloadAssets();
		ImageManager.loadImages(assets, undefined, ObjectUtils.proxy(function() {
			this._delegate._afterLaunched(this, options.launchOption);
		}, this));
		var comsItr = this._vizFrame.subComponents().getIterator();
		while (comsItr.hasMore()) {
			LOG.debug("application[" + this._id + "]" + "component[" + comsItr.nextValue().id() + "] initialized.",
					"perf");
		}
		this._eventBridge = new Observable();
		this._addEvents(this._delegate.getSupportedEvents());

	};

	var ap = VizApplication.prototype;

	ap.id = function() {
		return this._id;
	};

	/**
	 * Get and set the size of the application
	 * 
	 * @name sap.viz.mvc.VizApplication#size
	 * @param {undefined|Object}
	 *            size undefined or new size of the application
	 * @returns {this|Object} when set the size the return is this object, when
	 *          get the size the return will be the size
	 * 
	 */
	ap.size = function(size) {
		if (size !== undefined) {
			this._vizFrame.size(size);
			return this;
		} else {
			return this._vizFrame.size();
		}
	};

	/**
	 * Get and set the visibility of the application
	 * 
	 * @name sap.viz.mvc.VizApplication#hidden
	 * @param {undefined|Boolean}
	 *            hidden undefined or boolean value indicating whether the
	 *            application should be hided.
	 * @returns {this|Object} when set the hidden status the return is this
	 *          object, when get the hidden status the return will be the
	 *          current hidden status.
	 * 
	 */
	ap.hidden = function(hidden) {
		if (hidden !== undefined) {
			if (this._vizFrame.hidden() !== hidden) {
				this._vizFrame.hidden(hidden);
			}
			return this;
		} else {
			return this._vizFrame.hidden();
		}
	};
	/**
	 * Get a list of event names the current visualization instance supports
	 * 
	 * @name sap.viz.mvc.VizApplication#getSupportedEvent
	 * @returns {Array} an array of event names supported
	 * 
	 */
	ap.getSupportedEvent = function() {
		return this._eventBridge.getSupportedEvents();
	};
	/**
	 * Add a listener to the supported event
	 * 
	 * @name sap.viz.mvc.VizApplication#addListener
	 * @param {String}
	 *            event the event to listen
	 * @param {Function}
	 *            listener the function to be called back when event occurs
	 * 
	 */
	ap.addListener = function(event, listener) {
		this._eventBridge.addListeners({
			eventName : event,
			listener : listener
		});
	};
	/**
	 * Remove an existing listener
	 * 
	 * @name sap.viz.mvc.VizApplication#removeListener
	 * @param {String}
	 *            event the event to listen
	 * @param {Function}
	 *            listener the existing function to be removed
	 * 
	 */
	ap.removeListener = function(event, listener) {
		this._eventBridge.removeListener(event, listener);
	};

	ap._addEvents = function(events) {
		for ( var i = 0, len = events.length; i < len; i++) {
			this._eventBridge.addEvents(events[i]);
		}
	};

	ap._fireEvent = function() {
		this._eventBridge.fireEvent.apply(this._eventBridge, arguments);
	};

	/**
	 * Get a list of public method names the current visualization instance
	 * supports
	 * 
	 * @name sap.viz.mvc.VizApplication#getPublicMethods
	 * @returns {Array} an array of public method names supported
	 * 
	 */
	ap.getPublicMethods = function() {
		return this._delegate.getSupportedMethods();
	};
	/**
	 * Invoke the public method of the current visualization with options
	 * 
	 * @name sap.viz.mvc.VizApplication#invokePublicMethod
	 * @param {String}
	 *            publicMethodName, the name of the public method.
	 * @param {Object}
	 *            [options] the options object is passed as argument.
	 */
	ap.invokePublicMethod = function(publicMethodName, options) {
		this._delegate._invokePublicMethod(publicMethodName, options);
	};
	/**
	 * Apply a new theme to the visualization instance
	 * 
	 * @name sap.viz.mvc.VizApplication#applyTheme
	 * @deprecated
	 * @param {String}
	 *            theme, the name of the theme.
	 */
	ap.applyTheme = function(theme) {
		this._delegate._applyTheme(theme);
	};

	/**
	 * Get or set the properties of the current visualization instance.
	 * 
	 * @name sap.viz.mvc.VizApplication#properties
	 * @param {Object}
	 *            [propBag]
	 * @returns {Object}
	 */
	ap.properties = function(propBag) {
		if (propBag !== undefined) {
			this._delegate.updateProperties(propBag);
		}
		return this._delegate.getProperties();
	};

	/**
	 * Update dataset after chart created
	 * 
	 * @name sap.viz.mvc.VizApplication#setDataset
	 * @param {Object}
	 */
	ap.setDataset = function(dataset) {
		if (dataset) {
			this._delegate.setDataset(dataset);
		}
	};
	
	ap.getDataset = function() {
        return this._delegate.getDataset();
    };

	ap._setRootController = function(rootController) {
		if (rootController) {
			var rootUIComp = rootController.rootUIComponent();
			rootUIComp.frame(this._vizFrame.bounds());
			rootUIComp.autoresizingMask(Autosizing.FlexibleWidth | Autosizing.FlexibleHeight);
			this._vizFrame.addSubComponent(rootUIComp);
		}
	};

	return VizApplication;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.D3BasedComponent',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'
}
],
function Setup(ObjUtils, FuncUtils, UIComponent) {
	if (!d3) {
		FuncUtils.error('D3 cannot be found');
	}
	var initD3Root = function() {
		var width = this.width();
		var height = this.height();
		this._d3Root = d3.select(this._container[0]).append('svg').attr('width', width).attr('height', height);
	};
	/**
	 * This component initializes a SVG element acting as the root element for
	 * d3 based development.
	 * 
	 * @name sap.viz.mvc.D3BasedComponent
	 * @class
	 * @augments sap.viz.mvc.UIComponent
	 */
	var D3BasedComponent = ObjUtils.derive(UIComponent,
	/**
	 * @lends sap.viz.mvc.D3BasedComponent
	 */
	{
		constructor : function(options) {
			initD3Root.call(this);
		},

		doContentResize : function(oldSize, newSize) {
			if (oldSize.width !== newSize.width) {
				this._d3Root.attr('width', newSize.width);
			}
			if (oldSize.height !== newSize.height) {
				this._d3Root.attr('height', newSize.height);
			}
		},

		/**
		 * Returns the d3 container of the component, subclass should use this
		 * as the root container in d3 development
		 * 
		 * @final
		 * @name sap.viz.mvc.D3BasedComponent#getD3Root
		 * @function
		 * @returns {sap.viz.graphics.Canvas2DSurface}
		 */
		getD3Root : function() {
			return this._d3Root;
		}
	});
	return D3BasedComponent;
});sap.riv.module(
{
  qname : 'sap.viz.mvc.UIController',
  version : '4.0.0'},
[
{
  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIComponent',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.0'
}
],
function Setup(FuncUtils, UIComponent, ThemeManager) {
	/**
	 * The base class of Controller in VizKit MVC framework
	 * 
	 * @name sap.viz.mvc.UIController
	 * @constructor
	 * @param {Object}
	 *            options any arguments you want to pass in when initialize your
	 *            concrete subclass of controller
	 */
	var controller = function(options) {
		this._defaultWidth = 5;
		this._defaultHeight = 5;
		this._app;
		this._uiComp;
		ThemeManager.on({
			eventName : 'themechanged',
			listener : this.doThemeChanged,
			scope : this
		});
	};

	var cp = controller.prototype;

	/**
	 * Return the root component of the hierarchy that this controller manages
	 * 
	 * @name sap.viz.mvc.UIController#rootUIComponent
	 * @function
	 * @returns {sap.viz.mvc.UIComponent}
	 */
	cp.rootUIComponent = function() {
		if (!this._uiComp) {
			this._uiComp = this.initUIComponent(this._defaultWidth, this._defaultHeight);
			this._uiComp.on({
				eventName : 'beforeShow',
				listener : this._handleBeforeShow,
				scope : this
			});
			this._uiComp.on({
				eventName : 'beforeHide',
				listener : this._handleBeforeHide,
				scope : this
			});
			this._uiComp.on({
				eventName : 'afterShow',
				listener : this._handleAfterShow,
				scope : this
			});
			this._uiComp.on({
				eventName : 'afterHide',
				listener : this._handleAfterHide,
				scope : this
			});
			this.afterUIComponentLoaded();
		}
		return this._uiComp;
	};

	cp._handleBeforeHide = function(hide) {
		this.beforeUIComponentDisappear();
	};

	cp._handleBeforeShow = function(hide) {
		this.beforeUIComponentAppear();
	};

	cp._handleAfterHide = function(hide) {
		this.afterUIComponentDisappear();
	};

	cp._handleAfterShow = function(hide) {
		this.afterUIComponentAppear();
	};

	cp._setApplication_ = function(application) {
		this._app = application;
	};

	/**
	 * Get the application instance
	 * 
	 * @name sap.viz.mvc.UIController#getApplication
	 * @function
	 * @returns {sap.viz.mvc.VizApplication}
	 */
	cp.getApplication = function() {
		return this._app;
	};
	/**
	 * Fire the event supported by application which is declared in
	 * {@link sap.viz.mvc.VizAppDelegate#getSupportedEvents}
	 * 
	 * @name sap.viz.mvc.UIController#fireAppEvent
	 * @function
	 */
	cp.fireAppEvent = function(event, arguments) {
		this._app._fireEvent(event, arguments);
	};

	/**
	 * Subclass should override this method to initialize its own UIComponent
	 * hierarchy and return the root UIComponent. The default implementation
	 * creates an empty UIComponent
	 * 
	 * @name sap.viz.mvc.UIController#initUIComponent
	 * @function
	 * @param {Number}
	 *            initWidth the initial width of the root component
	 * @param {Number}
	 *            initHeight the initial height of the root component
	 * 
	 */
	cp.initUIComponent = function(initWidth, initHeight) {
		return new UIComponent({
			size : {
				w : initWidth,
				h : initHeight
			}
		});
	};

	/**
	 * This method will be called after the root UIComponent initialized
	 * 
	 * @name sap.viz.mvc.UIController#afterUIComponentLoaded
	 * @function
	 */
	cp.afterUIComponentLoaded = FuncUtils.noop;

	/**
	 * This method will be called when the managed UIComponent will become
	 * visible via set the hidden property
	 * 
	 * @name sap.viz.mvc.UIController#beforeUIComponentAppear
	 * @function
	 */
	cp.beforeUIComponentAppear = FuncUtils.noop;

	/**
	 * This method will be called after the managed UIComponent became visible
	 * via set the hidden property
	 * 
	 * @name sap.viz.mvc.UIController#afterUIComponentAppear
	 * @function
	 */
	cp.afterUIComponentAppear = FuncUtils.noop;
	/**
	 * This method will be called when the managed UIComponent will become
	 * visible via set the hidden property
	 * 
	 * @name sap.viz.mvc.UIController#beforeUIComponentDisappear
	 * @function
	 */
	cp.beforeUIComponentDisappear = FuncUtils.noop;
	/**
	 * This method will be called after the managed UIComponent became visible
	 * via set the hidden property
	 * 
	 * @name sap.viz.mvc.UIController#afterUIComponentDisappear
	 * @function
	 */
	cp.afterUIComponentDisappear = FuncUtils.noop;

	/**
	 * This method will be called when user apply a new theme, and if and only
	 * if the controller is the root controller.
	 * 
	 * @name sap.viz.mvc.UIController#doThemeApplied
	 * @function
	 * @deprecated
	 * @param {String}
	 *            old the name of the old theme
	 * @param {String}
	 *            new the name of the new theme
	 */
	cp.doThemeApplied = FuncUtils.noop;

	/**
	 * This method will be called when user update the theme setting and if and
	 * only if the controller is the root controller.
	 * 
	 * @name sap.viz.mvc.UIController#doThemeUpdated
	 * @function
	 * @deprecated
	 * @param {String}
	 *            key the key of the updated property
	 * @param {Object}
	 *            oldValue the old value
	 * @param {Object}
	 *            newValue the new value
	 */
	cp.doThemeUpdated = FuncUtils.noop;
	/**
	 * This method will be called when user changes to another theme through 
	 * ThemeManager
	 * @name sap.viz.mvc.UIController#doThemeChanged
	 * @function
	 */
	cp.doThemeChanged = FuncUtils.noop;
	return controller;
});sap.riv.module(
{
  qname : 'sap.viz.core',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.Objects',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.UIController',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.D3BasedComponent',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.VizApplication',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.VizAppDelegate',
  version : '4.0.0'
},
{  qname : 'sap.viz.manifest',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.layout',
  version : '4.0.0'
},
{  qname : 'sap.viz.load',
  version : '4.0.0'
},
{  qname : 'sap.viz.modules.xycontainer',
  version : '4.0.0'
},
{  qname : 'sap.viz.mvc.ThemeManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.handler.BaseDataHandler',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.MultiAxesDataAdapter',
  version : '4.0.0'
},
{  qname : 'sap.viz.util.EffectManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.TemplateManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.lang.langManager',
  version : '4.0.0'
},
{  qname : 'sap.viz.config',
  version : '4.0.0'
}
],
function Setup( TypeUtils, ObjectUtils, Objects, Functions, UIController, D3Component, VizApplication, VizAppDelegate, manifest, layout, loader, container, ThemeManger, Feeder,BaseDataHandler, MultiAxesDataAdapter, EffectManager, TemplateManager, langManager, CanvgConfig ) {

  function load(moduleId) {
    return manifest.module.get(moduleId).execute();
  }
  

  function dispatchData(moduleConfig, data) {
    var result;
    if (moduleConfig) {
      var dataConfig = moduleConfig.data;
      if (dataConfig) {
        result = data.createDataAdapterForModule(dataConfig);
      }
    }
    return result;
  }
  
  /* Represents the root component. */
  var ChartComponent = ObjectUtils.derive(D3Component, {
    constructor : function ( options ) {
      this._config = options.config;      // Chart configuration
      this._data = options.data;          // Transformed data set
      this._inputProperties = options.options; // Chart properties
      this._canvas_rootThreshold = d3.select(document.createElement('div')), this._canvas_rootThreshold.append('svg');
    this._canvas_root = d3.select(document.createElement('canvas')).style('width', 0).style('height', 0);
    this._container.prepend(this._canvas_root.node());
      m_canvg_config = CanvgConfig.get(this._config.id)? CanvgConfig.get(this._config.id): {}, this._max_svg =  CanvgConfig.enableCanvg() && m_canvg_config.max_svg? m_canvg_config.max_svg : Number.POSITIVE_INFINITY ;
      if(this._data.dataPointCount() > this._max_svg){
        this._root =  this._canvas_rootThreshold.select('svg');
        this._compoennt_status = 'canvg';
      }else{
        this._root = this.getD3Root();      // D3 selection
        this._compoennt_status = 'svg';
      }
      this._modules = {};                 // Chart sub components
      this._subModuleNames = [];    // used to update sub modules when data update
      this._subControllers = [];  //used to update controllers when data update
      this._effectManager = null;
      this._initialize();

      this._templateManagerListener = {
        fn : this._templateChanged,
        scope : this
      };
      
      TemplateManager.addListener(this._templateManagerListener);
      
      this._langManagerListener = {
        fn : this._localeChanged,
        scope : this
      };
      
      langManager.addListener(this._langManagerListener);
    },
    
    _updateSubModules : function(parentModule) {
      //clean all current submodules
      for(var i = 0, len = this._subModuleNames.length; i < len; i++){
        delete this._modules[this._subModuleNames[i]];
      }
      this._subModuleNames.length = 0;
      if(parentModule.modules){
        var subModules = parentModule.modules();
        var sname;                              
        for ( var m in subModules ) {
          if ( subModules.hasOwnProperty(m) ) {
            sname = 'main.' + m;
            this._subModuleNames.push(sname);
            this._modules[sname] = subModules[m];
          }
        }
      }
    },
    
    _updateSubControllers : function(parentModule) {
      for(var i = 0, len = this._subControllers.length; i < len; i++){
        this._modules[this._subControllers[i]].module(parentModule);
      }
    },
    
    //////////////////////Can be moved to base container///////////////////
    _resolveProperties : function(nodeConfig, isContainer){
      var props = {}, // Empty properties basket
          propsCat,   // Property category node
          usrProps,   // User set properties
          sysProps;   // Predefined properties in configure node
      if(isContainer){
        //Jimmy/8/15/2012 pay attention to the property structure, for container we will pass
        //all properties instead of properties under propsCat only.
        if ( nodeConfig ) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = this._properties;
          sysProps = {};
          sysProps[propsCat] = nodeConfig.properties;
          Objects.extend( true, props, sysProps, usrProps );
        }else{
          props = this._properties;
        }
      }else{
        if ( nodeConfig ) {
          propsCat = nodeConfig.propertyCategory;
          usrProps = this._properties[ propsCat ];
          sysProps = nodeConfig.properties;
          // User properties will override predefined properties 
          // upon a merge. FIXME handle array values (Raised by Jimmy)
          Objects.extend( true, props, sysProps, usrProps );
        }
      }
      return props;
    },
    
    _updateProperties : function (id, isContainer){
      var moduleManifest = this._config.modules; // Module configurations
      var props, nodeConfig;
      if ( moduleManifest[id] && this._modules[id] ) {
        nodeConfig = moduleManifest[id].configure;
        props = this._resolveProperties (nodeConfig, isContainer);
        this._modules[id].properties(props);
      }
    },
    
    //////////////////////Can be moved to base container///////////////////
    
    _initialize : function () {
      this._mergeTemplateProperties();
   
      //initial effect manager first
      this._effectManager = new EffectManager(this._root.append("svg:defs"), this._data.fakeData());
      
      var moduleManifest = this._config.modules; // Module configurations
      var props, nodeController; // The 'controller' node of modules 
      // Feed data to components for size calculation.
      var legend, legendData = {};
      if ( moduleManifest.legend ) {
         legendData = dispatchData(moduleManifest.legend, this._data);
        legend = load( moduleManifest.legend.id );
        nodeConfig = moduleManifest.legend.configure;
        props = this._resolveProperties(nodeConfig);
        this._modules.legend = legend.data(legendData).properties(props).effectManager(this._effectManager);
        this._root.append('g').attr('class', 'legend');
      }
      
      if ( moduleManifest.sizeLegend ) {
         legendData = dispatchData(moduleManifest.sizeLegend, this._data);
        legend = load( moduleManifest.sizeLegend.id );
        nodeConfig = moduleManifest.sizeLegend.configure;
        props = this._resolveProperties(nodeConfig);
        this._modules.sizeLegend = legend.data(legendData).properties(props).effectManager(this._effectManager);
        this._root.append('g').attr('class', 'sizeLegend');
      }
      
      if ( moduleManifest.title ) {
        var title = load( moduleManifest.title.id );
        nodeConfig = moduleManifest.title.configure;
        props = this._resolveProperties(nodeConfig);
        this._modules.title = title.properties(props).effectManager(this._effectManager);
        this._root.append('g').attr('class', 'title');
      }
      
      if ( moduleManifest.main ) {
        var container = load( moduleManifest.main.id );
        nodeConfig = moduleManifest.main.configure;
        
        //FIXME currently it's hard coded here we assume the plot is container, actually we should
          //check the plot type
        props = this._resolveProperties(nodeConfig, true);
        this._modules.main = container.data(this._data)
                            .config(moduleManifest.main)
                            .properties(props)
                            .effectManager(this._effectManager);
        
        // Merge Ian Li's fix to make canvg waiting for chart modules' initialized event
        if(this._modules.main.dispatch && this._modules.main.dispatch()['initialized']){
            var _self = this;
            this._modules.main.dispatch().on('initialized.sap.core', function(){
              _self._exportToCanvas.apply(_self);
            });
          }
          
        this._root.append('g').attr('class', 'main');
        var containerModules = this._modules.main
                              .parent(this._root.select('.main'));
        
        this._updateSubModules(containerModules);
                
        //Jimmy/8/22/2012 we introduce controller module which can be configured to any module (except controller module of course)
        //as for now, we only add the support to container. TODO
        
        nodeController = moduleManifest.main.controllers;
        if(nodeController){
          for(var nc in nodeController){
            if(nodeController.hasOwnProperty(nc)){
              var controller = load(nodeController[nc].id);
              var controllerConfig =  nodeController[nc].configure;
              controller().module(this._modules['main']);
              props = {};
              propsCat = controllerConfig.propertyCategory;
              usrProps = this._properties[ propsCat ];
              sysProps = controllerConfig.properties;
              Objects.extend( true, props, sysProps, usrProps );
              controller.properties(props);
              this._subControllers.push('main.' + nc);
              this._modules['main.' + nc] = controller;
            }
          }
        }   
      }
      
      if ( moduleManifest.tooltip ) {
        var tooltip = load( moduleManifest.tooltip.id );
        nodeConfig = moduleManifest.tooltip.configure;
        props = this._resolveProperties(nodeConfig);
        this._modules.tooltip = tooltip(this._container[0]).properties(props).effectManager(this._effectManager);
      }
     
    },

    // Current layout policy doesn't pass component references
    // to the layout functions, hence only component size and
    // layout preferences are passed and only layout solution
    // is expected to be returned.
    _doLayout : function ( newSize, actualLayout ) {
      var vgap = 8, padding = 20; //2em . 1em = 10px in sdk
      // reduce padding when chart size is small
      if (newSize.width < padding * 10) {
          padding = newSize.width / 10;
      }
      if (newSize.height < padding * 10) {
          padding = newSize.height / 10;
      }
      var preferences = {};
      
      if ( this._modules.title ) {
        preferences.north = { size : this._modules.title.getPreferredSize() };
      }
      //FIXME Elliott/8/20/2012, need support different legend position
      var preferenceEast = { width : 0, height: 0, minWidth: 0, maxSizeConstant: 1 }, 
        sizeLegendPS = { 
            width : 0, 
            height: 0,
            titleSize : {
                width : 0,
                height : 0
            }
        },
        legendPS = { 
            width : 0, 
            height: 0,
            titleSize : {
                width : 0,
                height : 0
            }
        };
      if ( this._modules.legend ) {
        legendPS = this._modules.legend.getPreferredSize(newSize);
        preferenceEast.width = Math.max ( preferenceEast.width, legendPS.width );
        preferenceEast.height = Math.max ( preferenceEast.height, legendPS.height );
        preferenceEast.minWidth = Math.max ( preferenceEast.minWidth, legendPS.minWidth );
        preferenceEast.minHeight = legendPS.minHeight;
        preferenceEast.maxSizeConstant = Math.min ( preferenceEast.maxSizeConstant, legendPS.maxSizeConstant );
      }
      
      preferences.east = { size : preferenceEast };
      if ( this._modules.main ) {
        preferences.center = {};
      }

      function layoutSolution() {
        return layout({
          type : 'border',
          hgap : 8,
          vgap : vgap,
          bias : 'north', // default bias is north
          size : {
            width : newSize.width,
            height : newSize.height
          },
          padding : [ padding, padding, padding, padding ],
          prefs : preferences
        });
      }

      var solution = layoutSolution();

      // by Jia Liu
      // only for size legend.
      if (actualLayout && this._modules.sizeLegend && this._modules.sizeLegend.isVisible()) {
        if (solution.center) {
          // only update size for container to force container layout
          // internally
          this._modules.main.width(solution.center.bounds.width)
              .height(solution.center.bounds.height);
  
          // call container's API infoForSizeLegend to calculate correct
          // max bubble size and size legend size
          sizeLegendPS = this._modules.sizeLegend.getPreferredSize(
              newSize, vgap + 2 * padding, this._modules.main
                  .infoForSizeLegend());
          var legendWidth = Math.max(sizeLegendPS.width, legendPS.width);
          preferenceEast.width = legendWidth < newSize.width * 1/3 ? legendWidth : newSize.width * 1/3;
          preferenceEast.height = sizeLegendPS.height;
          preferenceEast.minWidth = sizeLegendPS.minWidth;
          preferenceEast.minHeight = sizeLegendPS.minHeight;
  
          // use size legend size as preferred size to layout again
          solution = layoutSolution();
        }
      }      
      
      if ( solution.north ) {
        this._root.select('.title').attr('visibility', 'visible').attr('transform', 
          'translate(' + solution.north.bounds.x + 
          ', ' + solution.north.bounds.y + ')');
        this._modules.title
          .width(solution.north.bounds.width)
          .height(solution.north.bounds.height);
      } else {
          this._root.select('.title').attr('visibility', 'hidden');
      }

      if ( solution.east ) {
        var eastHeight = solution.east.bounds.height; 
        var eastY = solution.east.bounds.y;
        var sizeLegendHeight = 0;
        var showSizeLegendTitle = true;
        if (sizeLegendPS.height + 8 + legendPS.height > solution.east.bounds.height) {
            showSizeLegendTitle = sizeLegendPS.titleSize.height < sizeLegendPS.height * 1/3 && sizeLegendPS.titleSize.height < solution.east.bounds.height * 1/3;
            
        }
        
        if ( this._modules.sizeLegend ) {
            this._modules.sizeLegend.hide(false);
          this._root.select('.sizeLegend').attr('transform', 
          'translate(' + solution.east.bounds.x + 
          ', '+ eastY +')');
          
          sizeLegendHeight = sizeLegendPS.height;
          if (!showSizeLegendTitle) {
              this._modules.sizeLegend.hideTitle();
              sizeLegendHeight -= sizeLegendPS.titleSize.height;
          }
          
          this._modules.sizeLegend
            .width(solution.east.bounds.width)
            .height(sizeLegendHeight);
          //FIXME Elliott/8/20/2012, hard code padding here
          eastY = eastY + sizeLegendHeight + 8;
      }
      
      var showLegendTitle = true;
      if ((sizeLegendHeight > 0 ? sizeLegendHeight + 8 : 0) + legendPS.height > solution.east.bounds.height) {
          showLegendTitle = legendPS.titleSize.height < (eastHeight - sizeLegendPS.height) * 0.3;
      }
        
        if ( this._modules.legend ) {
          this._modules.legend.hide(false);
          this._root.select('.legend').attr('transform', 
          'translate(' + solution.east.bounds.x + 
          ', '+ eastY +')');
          
          if (!showLegendTitle) {
              this._modules.legend.hideTitle();
          }
          
          this._modules.legend
            .width(solution.east.bounds.width)
            .height(eastHeight - sizeLegendPS.height);
        }
      } else {
          if (this._modules.legend) {
              this._modules.legend.hide(true);
          }
          if (this._modules.sizeLegend) {
              this._modules.sizeLegend.hide(true);
          }
      }
      
      if ( solution.center ) {
        this._root.select('.main').attr('transform', 
          'translate(' + solution.center.bounds.x + 
          ', ' + solution.center.bounds.y + ')');
        this._modules.main
          .width(solution.center.bounds.width)
          .height(solution.center.bounds.height);
          
        if ( this._modules.tooltip ) {
          this._modules.tooltip.plotArea(solution.center.bounds).zone(newSize);
        }
      }
    },
    
    _updateAllProperties : function(){
      this._mergeTemplateProperties();
      this._updateProperties('legend');
        this._updateProperties('title');
        this._updateProperties('sizeLegend');
        this._updateProperties('tooltip');
        this._updateProperties('main', true);
        
    },
    
    _mergeTemplateProperties : function(){      
      var templateProperties = TemplateManager.current().props(
          this._config.id);  
      this._properties = Objects.extend(true, null, templateProperties,
          this._inputProperties);
      
      if(CanvgConfig.enableCanvg() && this._data.dataPointCount() >= this._max_svg){
        var temp = {};
        //TODO: currently, can not get property cateogry in geo chart by this._config.getChartPropCate(),
        //we use plotArea instead of this function 
        temp['plotArea'] = {
            animation: {
              dataLoading: false,
              dataUpdating: false
            }
        };
        this._properties = Objects.extend(true, null, this._properties, temp);
      }
    },
    
    _templateChanged : function(){      
      this._updateAllProperties();
      this._relayout(this.size());
      this._paint();
    },
    
    _localeChanged : function(){
      //update the data of modules to let the module have change to make up locale string again.
       var moduleManifest = this._config.modules;
         var ddata = dispatchData(moduleManifest.legend, this._data);
         if(ddata) this._modules.legend.data(ddata);
         ddata = dispatchData(moduleManifest.sizeLegend, this._data);
         if(ddata) this._modules.sizeLegend.data(ddata);
         ddata = dispatchData(moduleManifest.title, this._data);
         if(ddata) this._modules.title.data(ddata);
          this._modules.main.data(this._data); 
         
      this._updateAllProperties();
      this._relayout(this.size());
      this._paint();
    },
    
    properties : function (_) {
      if ( !arguments.length ) return this._inputProperties;
      this._inputProperties = _;
      
      //update properties
      this._updateAllProperties();
      
      this._relayout(this.size());
      this._paint();
    },
    
    data : function (_) {
      if ( !arguments.length ) return this._data;
     
      this._data = _;
      
      this._effectManager.ghostEffect(this._data.fakeData());
      
      //currenty, we should update properties when reset dataset. As when change the component mode from svg to canvg, we should disable all animation
      this._updateAllProperties();
      
      //switch canvg mode to svg mode when change the size of dataset
      if(CanvgConfig.enableCanvg() && this._data.dataPointCount() >= this._max_svg && this._compoennt_status == 'canvg'){
        
      }else if(CanvgConfig.enableCanvg() &&this._data.dataPointCount() >= this._max_svg &&  this._compoennt_status == 'svg'){ //svg => canvg
        //turn to canvg mode, switch  svg node and fake svg node
        //1. 
        this._root = this._d3Root;
        $(this._d3Root.node()).remove();
        this._d3Root = this._canvas_rootThreshold.select('svg');
        $(this._d3Root.node()).remove();
       // $(this._canvas_rootThreshold.node()).append(this._root.node());
        if(this._canvas_rootThreshold.select('svg').node() == null){
          this._canvas_rootThreshold.node().appendChild(this._root.node());
        }else{
          $(this._root.node()).insertBefore(this._canvas_rootThreshold.select('svg').node());
        }
        if(d3.select(this._container.get(0)).select('svg').node() == null){
          this._container.get(0).appendChild(this._d3Root.node());
        }else{
          $(this._d3Root.node()).insertBefore( d3.select(this._container.get(0)).select('svg').node());
        }
        
        this._compoennt_status = 'canvg';
      }else if(CanvgConfig.enableCanvg() && this._data.dataPointCount() < this._max_svg && this._compoennt_status == 'canvg'){// canvg => svg
        //clear the canvas and reset the size of canvas
        this._canvas_root.node().getContext('2d').clearRect(0, 0, this._canvas_root.node().width, this._canvas_root.node().height);
        this._canvas_root.style('width', 0), this._canvas_root.style('height', 0);
        this._canvas_root.attr('width', 0), this._canvas_root.attr('height', 0);
        
        this._d3Root = d3.select(this._container.get(0)).select('svg');
        this._root =  this._canvas_rootThreshold.select('svg');
        this._root.remove();
        $(this._root.node()).insertBefore(this._d3Root.node());
        this._canvas_rootThreshold.insert("svg", "svg").attr('width', this.size().width).attr('height', this.size().height);
        
        this._d3Root.remove();
        this._d3Root = this._root;
        this._compoennt_status = 'svg';
      }
      
      //redispatch data
      var moduleManifest = this._config.modules;
      var ddata = dispatchData(moduleManifest.legend, this._data);
      if(ddata) this._modules.legend.data(ddata);
      ddata = dispatchData(moduleManifest.sizeLegend, this._data);
      if(ddata) this._modules.sizeLegend.data(ddata);
      ddata = dispatchData(moduleManifest.title, this._data);
      if(ddata) this._modules.title.data(ddata);
      
      this._modules.main.data(this._data);
      
      //after we reset data, we need update submodules as they may
      //have changed during data update
      //TODO a potential optimization here: if we split data update and schema data updata
      //we can skip module update when only data has been updated 
      this._updateSubModules(this._modules.main);
      this._updateSubControllers(this._modules.main);
      
      this._relayout(this.size());
      this._paint();
    },
    
    modules : function () {
      return this._modules;
    },
    
    _relayout : function(newSize){
      this._doLayout(newSize);
      this._loadDependencies();
      //Jimmy/8/20/2012, scales may be different after dependencies have been resolved,
      //so we layout again to use the latest scales
      //see tablecontainer#158(//JIMMY/8/8/2012) for axis case. we also have the case for
      //bubble size legend. it should be able to be optimized in the future 
      this._doLayout(newSize, true);
    },
    
    // Callback invoked by platform upon the occurrence of a resizing event.
    doContentResize : function ( oldSize, newSize ) {
      this.callParent('doContentResize', oldSize, newSize);
      this._relayout(newSize);
      this._paint();
    },   

    themeChanged : function () {
      this._relayout(this.size());
      this._paint();
    },
    
    _expandDependencyDefs : function(item){
      var defs = [];
      var sourceModule = item['sourceModule'];
      var targetModule = item['targetModule'];
      var expandedSourceModules = this._expandModulePath(sourceModule);
      var expandedTargetModules = this._expandModulePath(targetModule);
      if(expandedSourceModules.length > 1 && expandedTargetModules.length > 1){
        if(expandedSourceModules.length !== expandedTargetModules.length){
          Functions.error('Error on resolving dependency:' + sourceModule + ',' + targetModule);
        }else{
          for(var i = 0, len = expandedSourceModules.length; i < len; i++){
            defs.push({
              'sourceModule' : expandedSourceModules[i],
              'targetModule' : expandedTargetModules[i],
              'source' : item['source'],
              'target' : item['target'],
              'type' : item['type'],
              'listener' : item['listener']
            });
          }
        }
      }else{
        //we are sure that one of the loop will execute only once, and we don't care which one
        for(var i = 0, len = expandedSourceModules.length; i < len; i++){
          for(var j = 0, jlen = expandedTargetModules.length; j < jlen; j++){
            defs.push({
              'sourceModule' : expandedSourceModules[i],
              'targetModule' : expandedTargetModules[j],
              'source' : item['source'],
              'target' : item['target'],
              'type' : item['type'],
              'listener' : item['listener']
            });
          }
        }
      }
      
      //FIXME jimmy/8/8/2012 if both sourceModule and targetModule have
      //been expanded, and they have different number of items, what should
      //we do? do cartesian product? currently we simply throw exception
      return defs;
    },
    
    //nodeN.nodeN-1.nodeN-2...node1, for each nodeN,
    //if we have several entities for it, we should expand it
    _expandModulePath : function(path){
      var pathArray = path.split('.');
      var currentPrefix = [];
      var currentExpand = [];
      for(var i = 0, len = pathArray.length; i < len; i++){
        var j = 0, jlen = currentPrefix.length;
        do
          {
            var pathI = jlen > 0 ? [currentPrefix[j], pathArray[i]].join('.') : pathArray[i];
            if(TypeUtils.isArray(this._modules[pathI])){
              //we have to expand this, and we may have undefined items in the array
              for(var k = 0, klen = this._modules[pathI].length; k < klen; k++){
                if(this._modules[pathI][k]){
                  var newPrefix = jlen > 0 ? [currentPrefix[j], pathArray[i] + '[' + k + ']'].join('.') : pathArray[i] + '[' + k + ']';
                  currentExpand.push(newPrefix);
                }
              }
            }else{
              //put it in directly
              currentExpand.push(pathI);
            }
            j++;
          }
        while(j < jlen);
        var refTemp = currentPrefix;
        currentPrefix = [].concat(currentExpand);
        currentExpand.length = 0;
        refTemp.length = 0;
      }
      return currentPrefix;  
    },

    _expandModules : function(){
      var modules = this._modules;
      var result = [];
      for(var p in modules){
        if (modules.hasOwnProperty(p)) { 
          var m = modules[p];
          if(TypeUtils.isArray(m)) {
            for (var i = 0; i < m.length; i++) {
              result[p + '[' + i + ']'] = m[i];
            }
          } else {
            result[p] = m; 
          }
        }
      }
        
      return result;
    },
    
    // Configures various kinds of module dependencies.
    _loadDependencies : function () {
      var dependencies = this._config.dependencies, item, i;
      var attrs = dependencies.attributes || [],
          events = dependencies.events || [];
      
      var expandedDefs, expandedDef;
      
      // Resolve attributes.
      /*
     * [jimmy/8/8/2012]each node in the path may have several entities
     * like main.plot, we may create several main.plots
     * (here the xycontainer), by using 'main.plot.xAxis'
     * here we actually means for xAxis in each main.plot
     * 
     * in the future, we may need support more complicated dependency resolving
     * like 'the 3rd xycontainer's xAxis', can be described
     * as main.plot[2].xAxis
     */
      var modules = this._expandModules();
      
      for ( i = 0; i < attrs.length; i++ ) {
        item = attrs[i];
        if( item == null ){
          continue;
        }
        expandedDefs = this._expandDependencyDefs(item);
        for(var j = 0, jlen = expandedDefs.length; j < jlen; j++) {
          expandedDef = expandedDefs[j];
          if ( modules[ expandedDef['sourceModule'] ] && modules[ expandedDef['targetModule'] ] ) {
            if ( typeof modules[ expandedDef['sourceModule'] ][ expandedDef['source'] ] === 'function' &&
                 typeof modules[ expandedDef['targetModule'] ][ expandedDef['target'] ] === 'function' ) {
              modules[ expandedDef['targetModule'] ][ expandedDef['target'] ]( 
                modules[ expandedDef['sourceModule']][ expandedDef['source']]() );
            } else {
              Functions.error('dependency configuration error');
            }
          } else {
            Functions.error('dependency configuration error');
          }
        }
      }
      
      // Resolve events.
      for ( i = 0; i < events.length; i++ ) {
        item = events[i];
        expandedDefs = this._expandDependencyDefs(item);
        for(var j = 0, jlen = expandedDefs.length; j < jlen; j++) {
          expandedDef = expandedDefs[j];
          if ( modules[ expandedDef['targetModule'] ] && modules[ expandedDef['sourceModule'] ] ) {
            if ( typeof modules[ expandedDef['targetModule'] ][ expandedDef['listener'] ] === 'function' &&
                 typeof modules[ expandedDef['sourceModule'] ] === 'function' ) {
                   if(typeof modules[ expandedDef['sourceModule'] ].dispatch === 'function'){
                      modules[ expandedDef['sourceModule'] ].dispatch().on(expandedDef['type'] + '.' + expandedDef['targetModule'] + '.' + j, 
                        modules[ expandedDef['targetModule'] ][ expandedDef['listener'] ]);
                   } else {
                     Functions.error('dependency configuration error:' + expandedDef['sourceModule'] + ' does not support event!');
                   }
            } else {
              Functions.error('dependency configuration error');
            }
          } else {
            Functions.error('dependency configuration error: source or target does not exist!');
          }
        }
      }
    },
        
    _paint : function () {
      if ( this._modules.title ) {
        this._root.select('.title').call(this._modules.title);
      } 
      if ( this._modules.legend ) {
        this._root.select('.legend')
          .datum(this._modules.legend.data())
          .call(this._modules.legend);
      }
      if ( this._modules.sizeLegend ) {
        this._root.select('.sizeLegend')
          .datum(this._modules.sizeLegend.data())
          .call(this._modules.sizeLegend);
      }
      if ( this._modules.main ) {
        this._root.select('.main')
          .datum(this._modules.main.data())
          .call(this._modules.main);
      }
      
    },
    
    // Merge Ian Li's fix to make canvg waiting for chart modules' initialized event
    _exportToCanvas: function(){
      if(CanvgConfig.enableCanvg() && this._compoennt_status == 'canvg'){
        this._root.attr( 'height', this.size().height);
        this._root.attr('width', this.size().width);
        //set the d3root svg size to 0
        this._d3Root.attr( 'height', 0);
        this._d3Root.attr('width', 0);
        this._canvas_rootThreshold.selectAll('title').remove();
        if(canvg) {
          canvg(this._canvas_root.node(), this._canvas_rootThreshold.html(), { ignoreMouse: true, ignoreAnimation: true });
        }
      }
    },
    
    /**
     * Loops over events configuration of each module
     * and return the events types.
     * 
     * @function
     * @returns {Array} Array of supported event types
     */
    getSupportedEvents : function () {
      var events = [];
      var modules = this._config.modules;
      
      function getEventDefs( modules ) {
        for ( var m in modules ) {
          if ( modules.hasOwnProperty(m) ) {
            if(!modules[m])
              continue;
            var module = manifest.module.get(modules[m].id);
            if ( module && module.events ) {
              events.push({
                sourceId : modules[m].id,
                source : {},
                evtTypes : module.events
              });
            }
            // Continue searching for composite module like a container
            if ( modules[m].modules ) getEventDefs(modules[m].modules); 
          }
        }
      }
      getEventDefs(modules);
      return events;
    },
    
    destroy : function(){
      TemplateManager.removeListener(this._templateManagerListener);
      langManager.removeListener(this._langManagerListener);
      this.removeFromSuperComponent();
    }
  });
  
  /* Represents the chart controller. */
  var ChartController = ObjectUtils.derive(UIController, {
    constructor : function ( options ) {
      this._parseOptions(options);
    },
    
    _parseOptions : function ( options ) {
      if ( !manifest.viz.get(options.vizType) ) Functions.error('Invalid vizType');
      this._dataset = options.dataset ? options.dataset : {};
      this._options = options.option;
      this._vizType = options.vizType;
      this._dataFeeding = options.feeding;
    },
    
    initUIComponent : function ( width, height ) {
      var config = manifest.viz.get(this._vizType);
    this._cc_component = new ChartComponent({
        id : 'rootComponent',
        data : this._dataset,
        dataFeeding : this._dataFeeding,
        config : config,
        options : this._options,
        clipToBound : false,
        size : { w : width, h : height }
      });
        
      
      return this._cc_component;
    },
    
    getSupportedEvents : function () {
      return this._cc_component.getSupportedEvents();
    },
    
    setDataset : function ( dataset ) {
      this._cc_component.data(dataset);
    },
    
    doThemeChanged : function(){
      this._cc_component.themeChanged();
    },
    
    updateProperties : function (props) {
      this._cc_component.properties(props);
    },
    
    getProperties : function() {
      return this._cc_component.properties();
    },
    
    destroy : function(){
      this._cc_component.destroy();
    }
  });
  
  /* Represents the application delegate class. */
  var AppDelegate = ObjectUtils.derive(VizAppDelegate, {
    appDidFinishLaunching : function ( app, launchOptions ) {
      // Format data set from data feeds.
      this._vc_vizType = launchOptions.vizType;
      this._vc_dataset = launchOptions.data.rawData;
      this._vc_feeding = launchOptions.feeding;
      this._vc_properties = launchOptions.options;
      var datapointCount =  this._vc_dataset.getDataPointCount();
      var vc_config = CanvgConfig.get(this._vc_vizType) ?CanvgConfig.get(this._vc_vizType) : {} ;
      this.max_canvas = CanvgConfig.enableCanvg() && vc_config.max_canvas ? vc_config.max_canvas : Number.POSITIVE_INFINITY;
      var dataAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding, this.max_canvas);
    this._controller = new ChartController({
          vizType : this._vc_vizType,
          dataset : dataAdapter,
          option : launchOptions.options // Chart properties
    });  
      
      this.registerPublicMethod('update', this._vc_update);
      this.registerPublicMethod('destroy', this._vc_destroy);
    },
    
    _vc_createAdapter : function(vizType, rawData, feeding, upperLimit) {
      var feeder = Feeder(manifest.viz.get(vizType).allFeeds(), rawData, feeding);
      var dataHandler = new BaseDataHandler(feeder, rawData, upperLimit);
      var feeds = feeder.getFeeds();
      var dataAdapter = new MultiAxesDataAdapter(feeder.getBindingInfo());
      dataAdapter.fakeData(rawData.hasFakeData());
      dataAdapter.dataPointCount(rawData.getDataPointCount());
      var id, dataItems;
      for ( var i = 0, len = feeds.length; i < len; i++ ) {
      id = feeds[i].feedId();
        dataItems = dataHandler.getFeedValues(id);
        if(dataItems != null){
          if(feeds[i].type() == "Dimension"){
            dataAdapter.addAnalysisAxis({values:dataItems, index: feeds[i].getIndex() - 1});
          }else{
            dataAdapter.addMeasureValuesGroup({values:dataItems, index: feeds[i].getIndex() - 1});
          }
        }     
      }
      return dataAdapter;
    },
    
    _vc_update : function(updates) {
      if(updates){
        //TODO Jimmy/9/19/2012 finish update property workflow
        //especially properties like 'numberOfDimensionsInColumn' which will
        //affect the structure, and ideally, we need merge all updates into one
        //function in each module, currently we still call them separately  
        if(updates.properties) {
          if(this._controller){
            this._vc_properties = updates.properties;
            this._controller.updateProperties(this._vc_properties);
          }
        }
        if(updates.data || updates.feeding) {
          if(updates.data) this._vc_dataset = updates.data;
          if(updates.feeding) this._vc_feeding = updates.feeding;
          var newAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding, this.max_canvas);
          this._controller.setDataset(newAdapter);
        }
      }
    },
    
    rootController : function () {
      return this._controller;
    },
    
    getSupportedEvents : function () {
      return this._controller.getSupportedEvents();
    },
    
    setDataset : function ( dataset ) {
      this._vc_dataset = dataset;
      var newAdapter = this._vc_createAdapter(this._vc_vizType, this._vc_dataset, this._vc_feeding);
      this._controller.setDataset(newAdapter);
    },
    
    getDataset : function (){
      return this._vc_dataset;
    },
    
    updateProperties : function (props) {
      if(this._controller){
        this._vc_properties = props;
        this._controller.updateProperties(this._vc_properties);
      }
    },
    
    getProperties : function() {
      return this._controller.getProperties();
    },
    
    _vc_destroy : function(){
      this._controller.destroy();
    }    
  });
  
  var riv = 
  /**
     * @lends sap.viz.core
     */
  {
        /**
         * @constructs
         */
        constructor : function() {

        },
        
        /**
         * @ignore 
         */
        instances : [], // Stores references to chart applications for easy processing of global events.
        
        /**
         * The main entry point of creating a chart.
         * @param {Object} usrOptions
         * <pre>
         * {
         *   type: 'viz/bar', //see propDoc.html for all supported viz chart types
         *   options: {}, //see propDoc.html for all supported options for each viz type
         *   container: HTMLDivElement, // HTMLDivElement is the container of viz chart in html
         *   data: {@link sap.viz.data.CrosstableDataset},
         *   feeding: {@link sap.viz.VizInstance#feeding}
         * }
         * </pre>
         * @returns {Object} vizApplication instance {@link sap.viz.VizInstance}
         */
        createViz : function ( usrOptions ) {
          var _eventsListeners = {}; //holder event lister
          var _feeding = usrOptions.feeding;
          
          var viz = 
          /**
           * @lends sap.viz.VizInstance.prototype
           */
          {
            /**
             * it can only be created by {@link sap.viz.core}
             * @constructs
             */
            constructor : function() {
    
            },
            
            /**
             * add event listener. one eventType can only have one listener, to register multiple listeners to a certain eventType you
             * have to add additional namespace after the eventType, such as 'selectData.foo' or 'selectData.bar'
             * @param {String} evtType see propDoc.html for supported events for each kind of chart
             * @param {Function} callback listener function
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            on : function ( evtType, callback/*, context*/ ) {
              //event register strategy
              //1. when modules A, B, C in the same level has this event type dispatch, register this event type on all modules.
              //2. If the module A contain other modules B, C and A, B, C all has this event type dispatch, only register event on this module.
              var modules = viz.app.getDelegate().rootController().rootUIComponent().modules(), dispatch, hittedModules = {};
              
              _eventsListeners[evtType] = callback;
              
              //we support optional namespace in evtType
              var i = evtType.indexOf(".");
              var typeToCheck = i > 0 ? evtType.substring(0, i) : evtType;
              
              for(var m in modules){
                if(modules.hasOwnProperty(m)){
                  var slist = m.split('.'),  index = slist.length - 1;
                  if(modules[m].dispatch && modules[m].dispatch()[typeToCheck]){
                    
                    for(var t = 0; t <= index; t++){
                      if(hittedModules[t] && hittedModules[t][slist.slice(0, t).toString()]){
                        break;
                      }
                    }
                    //if t is larger than index, it means do not exist the parent modules has this event type dispath.
                    if(t > index){
                      if(!hittedModules[slist.length]){
                        hittedModules[slist.length] = {};
                      }
                    hittedModules[slist.length][slist.toString()] = modules[m];
                    modules[m].dispatch().on(evtType, callback);
                    }
                  }
                }
              }
              
              return viz;
            },
            
            /**
             * Get/set chart size.
             * @param {Object} size {width:xx, height:xx}
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            size : function (size) {
              if ( !arguments.length ) return viz.app.size();
              viz.app.size(size);
              
              return viz;
            },
            
            /**
             * Get/set chart data.
             * @param {Object} data {@link sap.viz.data.CrosstableDataset} 
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            data : function (data) {
              if ( !arguments.length ) return viz.app.getDataset();
              viz.update({
                data : data
              });
              
              //rebind event listener as upon data update, sub plots may be recreated
              for(var evt in _eventsListeners){
               if(_eventsListeners.hasOwnProperty(evt)){
                 viz.on(evt, _eventsListeners[evt]);
               }
              }
              
              return viz;
            },
            
            /**
             * Get/set chart properties.
             * @ignore
             * @param {Object} props see propDoc.html
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            properties : function (props) {
              if ( !arguments.length ) return viz.app.properties();
              viz.update({
                properties : props
              });
              
              return viz;
            },
            
            /**
             * Get/set data feeding info
             * @param {Object} feedingObj in the following structure: 
             *  <pre>
             *  {
                  'feedid'   : feedid  // feed id for example 'RegionColor', see propDoc.html
                  'binding'   :[ {
                      'type' : 'analysisAxis' | 'measureValueGroup' | 'measureNamesDimension',
                      'index':  Number 
                  }]
                }
                </pre>
               @returns {Object} {@link sap.viz.VizInstance} 
             */
            feeding : function(feedingObj) {
              if( !arguments.length ) return _feeding;
              
              _feeding = feedingObj;
              viz.update({
                feeding : feedingObj
              });
              
              return viz;
            },
            
            /**
             * Update various items in one go.
             * @param {Object} updates {data: {@link sap.viz.data.CrosstableDataset}, feeding: feedingObj}
             * @returns {Object} {@link sap.viz.VizInstance}
             */
            update : function ( updates ) {
              if(updates){
                //we actually support use a null value to clear current feeding and switch to use
                //auto feed
                if(TypeUtils.isDefined(updates.feeding)){
                  _feeding = updates.feeding;
                }
                viz.app.invokePublicMethod('update', updates);
              }
              return viz;
            },
            

            /**
             * Destroy this chart instance. This will remove all dom
             * nodes of chart and its listeners.
             */
            destroy : function() {
              riv.instances.splice(riv.instances.indexOf(this), 1);
              viz.app.invokePublicMethod('destroy');
            }
          };
          
          viz.app = new VizApplication({
            wrapperDivEl : usrOptions.container,
            delegateClass : AppDelegate,
            launchOption : {
              vizType : usrOptions.type,
              options : usrOptions.options || {},
              data : { rawData : usrOptions.data },
              feeding : usrOptions.feeding || usrOptions.dataFeeding /* dataFeeding for backward compatibility*/ 
            }
          });
          
          viz.app.getDelegate = function () {
            return this._delegate;
          };
          riv.instances.push(viz);
          return viz;
        },
        
        /**
         * Destroy chart.
         * @param {Object...} viz instances to be destroyed
         */
        destroyViz : function(){
          for(var i=-1, j = arguments.length;++i<j;)
            arguments[i].destroy();
        }
  }; 
  
  return riv;
});sap.riv.module(
{
  qname : 'sap.viz.data.description.MeasureValues',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.base.utils.ObjectUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.DataContainer',
  version : '4.0.0'
}
],
 function Setup(ObjUtils, DataContainer){
   
   /**
    * @private
    * @name sap.viz.data.description.MeasureValues
    */
     var MeasureValues = ObjUtils.derive(DataContainer, {
      
       /** 
        * @constructor
        * @param uid    identifier of measure values, usually name
        * @param values 
        */
       constructor : function ( uid, values ) {
           this._values = values;
       },
       
         getValues : function(){
           return this._values;
         }
    
    });
     
     
     
     return MeasureValues;
});sap.riv.module(
{
  qname : 'sap.viz.data.description.MeasureValuesGroup',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.data.description.MeasureValues',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
}
],
 function Setup(MeasureValues, FunctionUtils){
   
   var MeasureValuesGroup = function(data){
     this._measureValues = new Array();
     this.init(data);
   };
   
   MeasureValuesGroup.prototype.init = function(data){
     
       for(var i = 0; i < data.length; i++){
         this._measureValues[i] = new MeasureValues(data[i]["name"], data[i]["values"]);
         this._measureValues[i].fake(data[i]["isFake"] ? data[i]["isFake"] : false);
         this._measureValues[i].infos(data[i]["infos"] ? data[i]["infos"] : null);
       }
   };
   
     MeasureValuesGroup.prototype.getMeasureValues = function(){
     return this._measureValues;
   };
   
   MeasureValuesGroup.prototype.getType = function(){
     return "measureValuesGroup";
   };
   
   MeasureValuesGroup.prototype.validate  = function(labels){
       
      if (!arguments.length){
        var label = [1,1];
        var measures = this.getMeasureValues();
        for(var i = 0; i < measures.length;i++){
          value = measures[i].getValues();
          if(i == 0){
           if(value.length != label[1])
            FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + label[1]);
           
           label[0] = value[0].length;
           
          }else{
            if(value.length != label[1])
              FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + label[1]);
            
            for(var j = 0; j < value.length; j++){
              if(value[j].length != label[0] )
                FunctionUtils.error(measures[i].getId() + " wrong values count in aa1. should be " + label[0]);
            }  
          }
          
        }
        
        return label;
        
      }else{
        var measures = this.getMeasureValues();
        for(var i = 0; i < measures.length;i++){
          value = measures[i].getValues();
          if(value.length != labels[1])
            FunctionUtils.error(measures[i].getId() + " wrong values count in aa2. should be " + labels[1]);
          
          for(var j = 0; j < value.length; j++){
            if(value[j].length != labels[0] )
              FunctionUtils.error(measures[i].getId() + " wrong values count in aa1. should be " + labels[0]);
          }
        }
      }
     
   };
   
   MeasureValuesGroup.prototype.hasFakeData = function(){
      var measures = this.getMeasureValues();
      for(var i = 0; i < measures.length;i++){
        if(measures[i].fake())
         return true;
      }
      
      return false;
   };
   
   return MeasureValuesGroup;
 });sap.riv.module(
{
  qname : 'sap.viz.data.CrosstableDataset',
  version : '4.0.0',
  exported : true
},
[
{
  qname : 'sap.viz.data.feed.feeder',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.TypeUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.base.utils.FunctionUtils',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.AnalysisAxis',
  version : '4.0.0'
},
{  qname : 'sap.viz.data.description.MeasureValuesGroup',
  version : '4.0.0'
}
],
 function Setup(Feeder, TypeUtils, FunctionUtils, AnalysisAxis, MeasureValuesGroup){
 
   var TYPE   =    'type';
   var NAME   =    'name';
   var VALUES =    'values';
   
   var FEEDID =  'feedId';
   var MND    =  'MeasureNamesDimension';
   
   var ANALYSISAXIS = "analysisAxis";
   var MEASUREVALUESGROUP = "measureValuesGroup";
      
   function getMeasureValueDataPointCount(measureValue){
         var values = measureValue.getValues();
     
         return values.length > 0 ? values.length * values[0].length : 0;
   }
   
   /**
    * @name sap.viz.data.CrosstableDataset
    * @constructor
     */
   function crossTableDataSet(){
        this._analysisAxis = [];
        this._measureValuesGroup = [];
        this._dataSet = {};
   }
   
   /**
    * Get/Set data
    * @name sap.viz.data.CrosstableDataset#data
    * @param data
    *        data with metaData and rawData
    * @returns {Object} {@link sap.viz.data.CrosstableDataset}
    */
   crossTableDataSet.prototype.data = function(data){
     if(!arguments.length){
       return this._dataSet;
     }
     this._analysisAxis = [];
     this._measureValuesGroup = [];
     this._dataSet = data;
     this.init(this._dataSet);
     return this;
   };
   
   //@deprecated
   crossTableDataSet.prototype.setData = function(in_data){
     this.data(in_data);
   };
   
   crossTableDataSet.prototype.init = function(data){
      if(!data || !data[MEASUREVALUESGROUP] || (data[ANALYSISAXIS] && !data[MEASUREVALUESGROUP])){
       //FIX ME Remove when multihandler is available
       return;// FunctionUtils.error("dataset is empty or invalid");
      }
      var aaLabels = [1,1];

      
      var axes = data[ANALYSISAXIS];
      var i = 0;
      var mvgs, mvg, mv;
      if(axes){
        if(axes.length > 2){
         FunctionUtils.error("could not accept more than 2 axes");
        }
        
        for(;i < axes.length; i++){
          var axis = axes[i];
          var axisIndex = axis["index"];
          if(axisIndex !== 1 && axisIndex !== 2){
           FunctionUtils.error("Axis index should be 1 or 2");
          }
          
          if(this._analysisAxis[axisIndex - 1]){
           FunctionUtils.error("Axis " + axisIndex + " already exists");
          }
          
          var aa = new AnalysisAxis(axis["data"]);
          aaLabels[axisIndex - 1] = aa.validate();
          this._analysisAxis[axisIndex - 1] = aa;
          
        }
        
        mvgs = data[MEASUREVALUESGROUP];
        for(i = 0;i < mvgs.length; i++){
          mvg = mvgs[i];
          var mvgIndex = mvg["index"];
          if(this._measureValuesGroup[mvgIndex - 1]){
            FunctionUtils.error("MeausreValuesGroup " + mvgIndex + " already exists");
          }
          
          mv =  new MeasureValuesGroup(mvg["data"]);
          mv.validate(aaLabels);
          this._measureValuesGroup[mvgIndex - 1] = mv;
        }
      }else{ // no axes case
        
        mvgs = data[MEASUREVALUESGROUP];
        for(i = 0;i < mvgs.length; i++){
          mvg = mvgs[i];
          mv =  new MeasureValuesGroup(mvg["data"]);
          if(i === 0){
            aaLabels = mv.validate();
          }  
          else{
            mv.validate(aaLabels);
          }
          
          this._measureValuesGroup[mvg["index"] - 1] = mv;
        }
      }
      
      
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getAnalysisAxisCount
    * @ignore 
    */
   crossTableDataSet.prototype.getAnalysisAxisCount = function(){
      return this._analysisAxis.length;    
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getAnalysisAxisByIdx
    * @ignore
    * @param index 
    */
   crossTableDataSet.prototype.getAnalysisAxisByIdx = function(index){
     return this._analysisAxis[index];
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getMeasureValuesGroupCount
    * @ignore 
    */
   crossTableDataSet.prototype.getMeasureValuesGroupCount = function(){
      return this._measureValuesGroup.length;    
   };
   
   /**
    * @name sap.viz.data.CrosstableDataset#getMeasureValuesGroupByIdx
    * @ignore
    * @param index 
    */
   crossTableDataSet.prototype.getMeasureValuesGroupByIdx = function(index){
     return this._measureValuesGroup[index];
   };
   
   /**
      * @name sap.viz.data.CrosstableDataset#hasFakeData
      * @ignore
      */
   crossTableDataSet.prototype.hasFakeData = function(){
     for(var i = 0; i < this._measureValuesGroup.length; i++){
       if(this._measureValuesGroup[i].hasFakeData()){
        return true;
       }
     }
     
     for(i = 0; i < this._analysisAxis.length; i++){
       if(this._analysisAxis[i].hasFakeData()){
        return true;
       }
     }
     
     return false;
   };
   
   /**
      * @name sap.viz.data.CrosstableDataset#getDataPointCount
      * @ignore
      */
   crossTableDataSet.prototype.getDataPointCount = function(){
     
     var dpCount = 0;
     var mvDPCount = getMeasureValueDataPointCount(this._measureValuesGroup[0].getMeasureValues()[0]);
     for(var i = 0; i < this._measureValuesGroup.length; i++){
       dpCount +=  mvDPCount * this._measureValuesGroup[i].getMeasureValues().length;
     }
     
     return dpCount;
   };
   
    return crossTableDataSet;
 });sap.viz.lang.langManager.register({id:'dev',value: {IDS_DEFAULTMND:'All Measures',IDS_DEFAULTCHARTTITLE:'Title of Chart',IDS_ISNOVALUE:'No value',IDS_BARCHART:'Bar Chart',IDS_COMBINATIONCHART:'Combined Column Line Chart',IDS_DUALBARCHART:'Bar Chart with 2 X-Axes',IDS_DUALCOMBINATIONCHART:'Combined Column Line Chart with 2 Y-Axes',IDS_DUALHORIZONTALCOMBINATIONCHART:'Combined Bar Line Chart with 2 X-Axes',IDS_DUALHORIZONTALLINECHART:'Horizontal Line Chart with 2 X-Axes',IDS_DIUALLINECHART:'Line Chart with 2 Y-Axes',IDS_DUALPERCENTAGESTACKEDBARCHART:'100% Stacked Bar Chart with 2 X-Axes',IDS_DUALSTACKEDVERTICALBARCHART:'Stacked Column Chart with 2 Y-Axes',IDS_DUALPERCENTAGESTACKEDVERTICALBARCHART:'100% Stacked Column Chart with 2 Y-Axes',IDS_DUALSTACKEDBARCHART:'Stacked Bar Chart with 2 X-Axes',IDS_DUALVERTICALBARCHART:'Column Chart with 2 Y-Axes',IDS_HORIZONTALBOXPLOTCHART:'Horizontal Box Plot',IDS_HORIZONTALCOMBINATIONCHART:'Combined Bar Line Chart',IDS_HORIZONTALLINECHART:'Horizontal Line Chart',IDS_HORIZONTALWATERFALLCHART:'Horizontal Waterfall Chart',IDS_LINECHART:'Line Chart',IDS_PERCENTAGESTACKEDBARCHART:'100% Stacked Bar Chart',IDS_PERCENTAGESTACKEDVERTICALBARCHART:'100% Stacked Column Chart',IDS_SPARKLINECHART:'Spark Line Chart (POC)',IDS_STACKEDBARCHART:'Stacked Bar Chart',IDS_STACKEDVERTICALBARCHART:'Stacked Column Chart',IDS_VARIANTBARCHART:'Variant Bar Chart (POC)',IDS_VERTICALBARCHART:'Column Chart',IDS_VERTICALBOXPLOTCHART:'Box Plot',IDS_WATERFALLCHART:'Waterfall Chart',IDS_DONUTCHART:'Donut Chart',IDS_PIECHART:'Pie Chart',IDS_BASEBUBBLECHART:'Base Scatter Chart',IDS_BUBBLECHART:'Bubble Chart',IDS_SCATTERCHART:'Scatter Plot',IDS_BASECHART:'Base Chart',IDS_BASEHORIZONTALCHART:'Base horizontal XY Chart',IDS_BASEVERTICALCHART:'Base Vertical XY Chart',IDS_BASEMULTIPLECHART:'Base Multiple Chart',IDS_BASEMULTIPLEXYCHART:'Base Multiple XY Chart',IDS_BASESINGLECHART:'Base Single Chart',IDS_HEATMAPCHART:'Heat Map',IDS_MULTIBARCHART:'Multiple Bar Chart',IDS_MULTIBUBBLECHART:'Multiple Bubble Chart',IDS_MULTIDONUTCHART:'Multiple Donut Chart',IDS_MULTIDUALBARCHART:'Multiple Bar Chart with 2 X-Axes',IDS_MULTIDUALHORIZONTALLINECHART:'Multiple Horizontal Line Chart with 2 X-Axes',IDS_MULTIDUALLINECHART:'Multiple Line Chart with 2 Y-Axes',IDS_MULTIDUALPERCENTAGESTACKEDBARCHART:'Multiple 100% Stacked Bar Chart with 2 X-Axes',IDS_MULTIDUALPERCENTAGESTACKEDVERTICALBARCHART:'Multiple 100% Stacked Column Chart with 2 Y-Axes',IDS_MULTIDUALSTACKEDBARCHART:'Multiple Stacked Bar Chart with 2 X-Axes',IDS_MULTIDUALSTACKEDVERTICALBARCHART:'Multiple Stacked Column Chart with 2 Y-Axes',IDS_MULTIDUALVERTICALBARCHART:'Multiple Column Chart with 2 Y-Axes',IDS_MULTIHORIZONTALLINECHART:'Multiple Horizontal Line Chart',IDS_MULTILINECHART:'Multiple Line Chart',IDS_MULTIPERCENTAGESTACKEDBARCHART:'Multiple 100% Stacked Bar Chart',IDS_MULTIPERCENTAGESTACKEDVERTICALBARCHART:'Multiple 100% Stacked Column Chart',IDS_MULTIPIECHART:'Multiple Pie Chart',IDS_MULTISCATTERCHART:'Multiple Scatter Plot',IDS_MULTISTACKEDBARCHART:'Multiple Stacked Bar Chart',IDS_MULTISTACKEDVERTICALBARCHART:'Multiple Stacked Column Chart',IDS_MULTIVERTICALBARCHART:'Multiple Column Chart',IDS_MULTIRADARCHART:'Multiple Radar Chart',IDS_RADARCHART:'Radar Chart',IDS_SCATTERMATRIXCHART:'Scatter Matrix Chart',IDS_TAGCLOUDCHART:'Tag Cloud',IDS_TREEMAPCHART:'Tree Map (POC)',IDS_REGIONCOLOR:'Region Color',IDS_PRIMARYVALUES:'Primary Values',IDS_SECONDARYVALUES:'Secondary Values',IDS_AXISLABELS:'Axis Labels',IDS_RECTANGLETITLE:'Rectangle Title',IDS_RECTANGLEWEIGHT:'Rectangle Weight',IDS_RECTANGLECOLOR:'Rectangle Color',IDS_TAGNAME:'Tag Name',IDS_TAGWEIGHT:'Tags Weight',IDS_TAGFAMILY:'Tags Family',IDS_CATEGORYAXIS:'Axis Labels Category',IDS_REGIONSHAPE:'Region Shape',IDS_BUBBLEWIDTH:'Bubble Width',IDS_BUBBLEHEIGHT:'Bubble Height',IDS_RADARAXES:'Radar Axes',IDS_RADARAXESVALUE:'Radar Axes Values',IDS_PIESECTORCOLORNAME:'Sector Color',IDS_PIESECTORSIZE:'Sector Size',IDS_MAINLABELAXISNAME:'Main Category Axis',IDS_SECONDARYAXISLABELNAME:'Secondary Category Axis',IDS_SELECTABILITY:'selectability',IDS_PRIMARYVALUECOLORPALETTE:'primaryValuesColorPalette',IDS_SECONDARYVALUESCOLORPALETTE:'secondaryValuesColorPalette',IDS_DRAWINGEFFECT:'drawingEffect',IDS_TOOLTIPVISIBLE:'tooltipVisible',IDS_ENABLEROUNDCORNER:'enableRoundCorner',IDS_ANIMATION:'animation',IDS_DATALOADING:'dataLoading',IDS_DATAUPDATING:'dataUpdating',IDS_BAR:'bar',IDS_LINE:'line',IDS_WIDTH:'width',IDS_HOVERLINEVISIBLE:'hoverlineVisible',IDS_MARKER:'marker',IDS_VISIBLE:'visible',IDS_SHAPE:'shape',IDS_SIZE:'size',IDS_HEADERVISIBLE:'headerVisible',IDS_AXISVISIBLE:'axisVisible',IDS_GRIDVISIBLE:'gridVisible',IDS_COLUMNSEQUENCE:'columnSequence',IDS_COLUMNCONFIG:'columnConfig',IDS_STARTCOLUMN:'startColumn',IDS_LABEL:'label',IDS_VALUEFORMAT:'valueFormat',IDS_ENDCOLUMN:'endColumn',IDS_HIGHCOLUMN:'highColumn',IDS_LOWCOLUMN:'lowColumn',IDS_LINECONFIG:'lineConfig',IDS_MARKERS:'markers',IDS_FILLVISIBLE:'fillVisible',IDS_REFINEVISIBLE:'reflineVisible',IDS_MODE:'mode',IDS_TITLE:'title',IDS_TEXT:'text',IDS_GRIDLINE:'gridline',IDS_SHOWFIRSTLINE:'showFirstLine',IDS_TYPE:'type',IDS_FORMAT:'format',IDS_POSITION:'position',IDS_BORDER:'border',IDS_STARTCOLOR:'startcolor',IDS_ENDCOLOR:'endcolor',}});